<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>PPMY RSS</title>
    <link>https://www.ppmy.cn/news</link>
    <description>PPMY 网站文章 RSS</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 31 Oct 2025 12:38:00 +0000</lastBuildDate>
    <item>
      <title>OceanBase 的写盘与传统数据库有什么不同？</title>
      <link>https://www.ppmy.cn/news/1540632.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维OceanBase 的写盘与传统数据库有什么不同？news/2025/10/31 20:55:45/背景在数据库开发过程中，“写盘”是一项核心操作，即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中，写盘主要有以下几步：首先将数据写入缓存池；其次，为了确保数据的完整性，系统会将数据写到"二进制日志文件"中，这一步骤对于在系统崩溃时恢复数据至关重要；最后将数据写入磁盘。为了提升这一过程的性能，可以使用SSD盘、延迟写或增加缓存池大小等多种策略。而在OceanBase 数据库中，写盘与传统数据库大不相同。由于OceanBase 存储引擎是基于LSM-Tree架构实现的，数据被分为了静态基线数据（放在 SSTable 中，存储于磁盘）和动态增量数据（放在 MemTable 中，存储于内存）两部分。当内存的增量数据达到一定规模的时候，会触发冻结转储操作，保证将要被转储的MemTable不再进行新的数据写入，同时生成新的活动MemTable（冻结，Freeze），以及将被冻结MemTable的数据存储到磁盘上以释放内存空间（转储，Mini Merge）。此时，一些小伙伴会存在疑问：到底如何读取那些所谓的"row"结构，才能将MemTable的数据存储到磁盘上？本文从MemTable的结构、读行过程讲起，逐步带大家解开疑问，并对OceanBase 的MemTable产生新的认识。MemTable的结构OceanBase中的MemTable是由BTree和Hash Table两个数据结构结合而成，二者各司其职，BTree发挥其范围查询的能力，Hash Table发挥其点查的能力。什么意思呢？我们来看下面这张图。图中是BTree和Hash Table的一个结合结构，BTree的每个叶节点和Hash Table的节点都指向着某一个row节点，而row节点指向着一个链表（实现上是双向链表）。我们只需要知道，每个rowkey在MemTable中最终是对应着一个row节点（即一行数据），这行数据可能经过了insert、update、delete、insert的一系列操作，在OceanBase中，每个这样的操作都会通过一个MvccNode存储起来，并按照操作的先后顺序从尾到头组成一个MvccNode list，链表尾部是最新的操作。好，到这里我们已经掌握了OceanBase中MemTable的"核心科技"了，也没那么复杂是不是？接下来，我们一起经历一遍冻结后的MemTable在将要存储到磁盘时，逐行读取数据的过程，尽可能简单地加深我们对"核心科技"的理解。Memtable迭代读行过程为了方便大家自主阅读代码，后续介绍过程会贴出部分源码，所有源码都基于GitHub master分支。容易理解的是，逐行读取数据是一个scan的过程，因此我们会通过遍历BTree而不是HashTable来完成读取。整个迭代过程可以分为两个部分：一部分是对BTree的遍历，每次我们将得到一个rowkey对应的行，换句话说就是得到一个行的MvccNode list；另一部分则是对MvccNode list的遍历，过程中得到一个行的多版本数据。那么，什么叫“行的多版本数据”呢？既然说到这，就不得不插入一段对MvccNode的解释。我们刚才提到，每个MvccNode代表着一个操作，这个操作放到事务中来说的话，其事务的状态可能是已提交的，也可能是未提交的，就是图中的status（commit/uncommit）。MvccNode会记录事务的提交版本号，即图中的trans_version，对于未提交的操作来说，trans_version是MAX。由于每个rowkey不允许多写，容易理解MvccNode list中的uncommit node一定是属于同一个事务的（即事务id相同），并且一定处在MvccNode list的最新位置，即链尾。MvccNode的具体实现结构如下所示：struct ObMvccTransNode {transaction::ObTransID tx_id_;  // 事务idshare::SCN trans_version_; // 事务提交版本share::SCN scn_; // 数据所在日志的 scnint64_t seq_no_;  // 在事务中的sql numble // 可能一个存储过程有多个相同sql no的mvcc nodeshare::SCN tx_end_scn_; // 数据所在事务的 commit/abort 日志的 scn // 未提交为max...uint8_t type_;  // 标记是否是COMPACTuint8_t flag_;   // 事务状态 （F_COMMITTED/F_ABORTED 等等
};需要注意的是，每个操作实际上是被包含在一个事务中的，因此该操作存在一个sql_no_，标记着其在整个事务中的序号，同时操作本身对应着一条日志，scn_记录了该日志的scn（简单理解为时间戳即可），而整个事务的提交对应着另一条日志，tx_end_scn_记录了该日志的scn。trans_version_记录着事务的提交版本，我们只需要知道这是和日志时间戳不同的两个维度的概念。我们已经知道了uncommit和commit的概念，那么图中被标记为compact的node是什么呢？简单来说，compact node是将后续所有已提交MvccNode中数据进行整合后得到的一个特殊的包含完整行的node。如下图所示，三个MvccNode从尾到头分别是update/update/insert操作，其中insert node是包含全部列数据的完整行，update node只包含更新列的数据的部分行。对于一个想要全部列的查询来说（这里我们忽略版本的问题），每次都需要读取这三个node并整合成一个新的完整行。因此，compact node产生了。我们会将整合三个node所得到的完整行保留下来，最终形成一个包含当前最新完整行的compact node。再回到最开始的问题："什么叫行的多版本数据？"在逐行读取的过程中，对于每个rowkey，我们最终会读取出多个sql numble不一样的未提交行（如果有的话）、一个compact行以及多个多版本行，这就是所谓的“行的多版本数据”。这里就涉及一个版本范围的限制，即(base_version, snapshot_version, multi_version_start) 三元组。我们的读取实际上附带着这样一个版本范围。我们所读取出的compact行是在遍历MvccNode list过程中，将多个提交版本在(base_version, snapshot_version)之间的compact node或者commit node再次整合所得。而读取出的多个多版本行分为两部分，一部分是将事务提交版本在(multi_version_start，snapshot_version)之间的node进行整合所得，可能会有多个结果，每个结果是由相同事务提交版本的node整合所得；另一部分是将事务提交版本在(base_version，multi_version_start)之间所有node整合所得，只有一个结果。看完以上解释，大家其实已经掌握了七八了，整个逐行读取的过程就是根据所谓的版本范围，遍历BTree上的每个rowkey，再将每个rowkey所拥有的MvccNode通过一系列的整合操作，得到一条条提交或者未提交的行记录，最后将这些行依次写入微块、微块写入宏块、多个宏块形成SSTable。如果对源码细节不感兴趣的同学，看到这已经可以转身离开了。但是剩下的同学别着急，让我们继续向细节探寻。整个逐行读取过程通过ObMemtableMultiVersionScanIterator实现，参见ObMemtableMultiVersionScanIterator::inner_get_next_row。其中包含两个子迭代器ObMultiVersionRowIterator和ObMultiVersionValueIterator，两者分别用于迭代BTree和迭代MvccNode list：class ObMultiVersionRowIterator {...common::ObVersionRange version_range_; // (base_version,snapshot_version,multi_version_start)三元组ObMultiVersionValueIterator value_iter_;...ObIQueryEngineIterator *query_engine_iter_;  // BTree迭代器
};class ObMultiVersionValueIterator {...common::ObVersionRange version_range_;ObMvccRow *value_;  // 装载着ObMvccTransNode *list_head_ObMvccTransNode *version_iter_; // value-&gt;list_head_ObMvccTransNode *multi_version_iter_; // 用于迭代多版本行，来自某一次的version_iter_int64_t max_committed_trans_version_; // 这一行的最大已提交版本share::SCN cur_trans_version_;bool is_node_compacted_;bool has_multi_commit_trans_;share::SCN merge_scn_; // 来自merge_param.scn_range_.end_scn_
};迭代过程被实现为一个简易的状态机，每个状态以及每个状态的行为如下：状态行为输出行结果SCAN_END通过ObMultiVersionRowIterator row_iter_迭代每个rowkey，得到下一个rowkey的MvccNode list，存放到ObMultiVersionValueIterator value_iter_.version_iter_。SCAN_UNCOMMITTED_ROW通过value_iter_的version_iter_迭代MvccNode list，每次先拿出一个uncommit node，然后向后迭代将所有相同sql_no_的uncommit node compact成一行，将该行输出。该状态会重复进入直到迭代到commit node。多个uncommit行，每行由多个sql_no_相同的node compact而成SCAN_COMPACT_ROW通过value_iter_的version_iter_继续迭代MvccNode list，将所有访问到的commit或者compact node compact成一行，将该行输出。在遇到compact node或者事务提交版本小于等于base_version的node时结束遍历，并将value_iter_置为空。一个事务提交版本在（base_version, snapshot_version)范围内所有commit node的compact行SCAN_MULTI_VERSION_ROW通过value_iter_的multi_version_iter_迭代MvccNode list，将所有访问到的具有相同trans_version并且trans_version大于multi_version_start的node compact成一行，将该行输出。所有trans_version介于(base_version,multi_version_start)之间的node将compact成一行输出。特别地，当遇到事务提交版本大于multi_version_start的compact node时，后续相同事务提交版本的node可以直接跳过，因为已经通过compact node进行过compact了。多个多版本行，在(snapshot_version,multi_version_start)范围内每个相同事务提交版本的node compact为一个多版本行，在(multi_version_start,base_version)范围内，所有事务提交版本的node compact为一个多版本行状态之间的转换过程如下：需要注意的是，在SCAN_UNCOMMITTED_ROW向SCAN_COMPACT_ROW进行状态转换时会对multi_version_iter_进行初始化：当前version_iter_是commit node，其trans_version为所有commit node中的最大已提交版本，如果该版本比multi_version_start_小，或者后续node没有比最大已提交版本小的trans_version，multi_version_iter_被初始化为null，否则初始化为当前version_iter_以上迭代读行细节的描述，可能会有一定的门槛，如果现在没有理解也没有关系。如果大家真的对源码本身感兴趣并且做了一定的研究之后，回过头来看这些内容，相信会有更深入的思考。后记这篇博客依然省略了很多细节，旨在分享一个以存储视角对MemTable最基本的解读，希望能够让大家对OceanBase相关源码产生兴趣（可以在Github上找到），只有真正的去探究了源码，才能领略到其中的艰涩与风光。当然，笔者文中难免有不少纰漏，也欢迎大家指正和讨论，错误的订正也是加深理解的一个过程。http://www.ppmy.cn/news/1540632.html相关文章飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...vLLM 大模型推理引擎调研文档文章目录 介绍vLLM 速度很快vLLM 灵活且易于使用 使用和部署离线批量推理在线推理服务 分布式推理服务如何确定分布式推理策略?多节点推理和服务-Ray集群 量化支持模型量化KV Cache 量化 性能调优PagedAttentionAutomatic prefix cachingBatching 策略PreemptionChunked Prefi…阅读更多...SpringBoot构建的智能健康生活助手4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...极速体验：实用的前端性能优化技巧本文将深入探讨一系列实用的前端性能优化方案&amp;#xff0c;从基础知识到高级技巧&amp;#xff0c;我们将揭示如何让你的网站在瞬息万变的互联网中脱颖而出&amp;#xff0c;无论你是经验丰富的开发者还是刚入行的新手&amp;#xff0c;这篇文章都将为你提供宝贵的见解和实践建议。 目录 
&amp;…阅读更多...CTF(七)导言&amp;#xff1a; 
本文主要讲述在CTF竞赛中&amp;#xff0c;Misc&amp;#xff08;杂项&amp;#xff09;题目中的CatchCat。 
靶场链接&amp;#xff1a;攻防世界 (xctf.org.cn) 
一&amp;#xff0c;分析题目。 下载并解压附件&amp;#xff1a; CatchCat.txt文件内容为&amp;#xff1a; 发现是坐标。 
另一个…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api创建文字注释mysql 查询今天、昨天、本周、上周、本月、上月、本季度、上季度、本年、上一年、的数据P10674 [MX-S1-T3] 电动力学 题解【UE引擎解构】- GamePlay篇 : 移动读后感一：《代码大全 2》—— 从 “写代码” 到 “做工程” 的思维跃迁 - AAi元人文：对“局限性”的反驳Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 12:55:48 +0000</pubDate>
    </item>
    <item>
      <title>飞腾X100适配Ubuntu说明</title>
      <link>https://www.ppmy.cn/news/1540631.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维飞腾X100适配Ubuntu说明news/2025/10/31 20:55:41/【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力，聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域，包含了应用使能套件、软件仓库、软件支持、软件适配认证四大板块，旨在共享尖端技术，为开发者提供一个涵盖多领域的开发平台和工具套件。 点击这里开始你的技术升级之旅吧​​​​​​本文分享至飞腾开发者平台《飞腾X100适配Ubuntu说明文档》1 简介本文档介绍飞腾X100芯片图形软件栈如何适配Ubuntu系统，后续介绍主要基于Ubuntu20.04系统。注意：文档中提到的deb安装包，可联系飞腾提供，实际名称会根据版本有所不同。linux-image-phytium-4.19.deb： 飞腾linux内核安装包(集成了X100显示驱动)phytium-x100-drivers_1.1.2_ubuntu20.04_aarch64.deb：Ubuntu 20.04飞腾X100 GPU驱动安装包2 KDE适配步骤飞腾X100芯片图形软件栈适配KDE桌面的Ubuntu系统步骤如下：1）安装原版arm64 ubuntu系统，如ubuntu arm64 server 20.04.2版，该版本默认没有图形界面。可制作安装U盘（rufus工具等），使用U盘安装。注：安装系统时，硬盘分区请选择ext4文件格式，不要选择默认的LVM格式。2）更新系统：sudo apt updatesudo apt upgrade3）联网安装kde桌面：sudo apt install kubuntu-desktop4）替换phytium的4.19内核：sudo dpkg -i linux-image-phytium-4.19.deb注意：a）为了使phytium 4.19内核为默认启动项，可将/boot下的5.4内核移走，然后更新grub。这样就只剩下4.19一个启动选项了。命令如下：cd/bootmkdirbakmvvmlinux-5.4.0-xxx bakupdate-grubb）替换phytium 4.19内核后，可能出现启动时间过长问题，解决办法如下；i. 关闭init-cloud.service服务：systemctldisablecloud-init-local cloud-init cloud-config cloud-finalsystemctl stop cloud-init-local cloud-init cloud-config cloud-finalii. 修复固态硬盘启动等待10分钟问题：修改/lib/systemd/system/systemd-random-seed.service文件内容，将其中的TimeoutSec改为3s或更短时间iii. 对于长时间等待“a start job is running for wait for network.. to be configued”问题，可通过禁用相关服务解决：sudo systemctl mask systemd-networkd-wait-online.service5）安装X100 GPU驱动安装包：sudo dpkg -i phytium-x100-drivers_1.1.2_ubuntu20.04_aarch64.deb6）重启。3 GNOME适配步骤1）安装原版arm64 ubuntu系统，如ubuntu arm64 server 20.04.2版，该版本默认没有图形界面。可制作安装U盘（rufus工具等），使用U盘安装。注：安装系统时，硬盘分区请选择ext4文件格式，不要选择默认的LVM格式。2）更新系统：apt update
apt upgrade3）联网安装gnome桌面：sudo apt install ubuntu-gnome-desktop ubuntu-desktop4）替换phytium的4.19内核：sudo dpkg -i linux-image-phytium-4.19.deb注意：a）为了使phytium 4.19内核为默认启动项，可将/boot下的5.4内核移走，然后更新grub。这样就只剩下4.19一个启动选项了。命令如下：cd/bootmkdirbakmvvmlinux-5.4.0-xxx bakupdate-grubb）替换phytium 4.19内核后，可能出现启动时间过长问题，解决办法如下；i. 关闭init-cloud.service服务：systemctldisablecloud-init-local cloud-init cloud-config cloud-finalsystemctl stop cloud-init-local cloud-init cloud-config cloud-finalii. 修复固态硬盘启动等待10分钟问题：修改/lib/systemd/system/systemd-random-seed.service文件内容，将其中的TimeoutSec改为3s或更短时间iii. 对于长时间等待“a start job is running for wait for network.. to beconfigued”问题，可通过禁用相关服务解决：sudo systemctl mask systemd-networkd-wait-online.service5）安装X100 GPU驱动安装包：sudo dpkg -i phytium-x100-drivers_1.1.2_ubuntu20.04_aarch64.deb6）其它定制修改：a）修改gdm配置，禁用xwayland: 编辑/etc/gdm3/custom.conf:[daemon]# Uncomment the line below to force the login screen to use XorgWaylandEnable=falseb）修改/etc/X11/Xwrapper.config# If you have edited this file but would like it to be automatically updated# again, run the following command as root:#  dpkg-reconfigure xserver-xorg-legacy#allowed_users=consoleallowed_users = anybody
needs_root_rights =yesc）此时，可正常进入gdm登录界面，但用户登录后，还是会回到登录界面。需要将用户加入到render和video组，才能正常进入桌面。gpasswd -atestrendergpasswd -atestvideo7）重启。4 常见问题1）使用lightdm，在登录界面输入密码后，出现failed to startsession错误，无法登录进入桌面？这是因为/usr/share/lightdm/lightdm.conf.d/40-kde-plasma-kf5.conf文件内容:[SetDefaults]user-session=kde-plasma-kf5其中kde-plasma-kf5与/usr/share/xsessions/目录下的plasma.desktop项不一致导致。可将其中的kde-plasma-kf5修改为plasma，或plasma.desktop重命名为kde-plasma-kf5.desktop即可解决该问题。2）如何设置系统默认显示管理器？例如系统同时安装了sddm和lightdm时，需要默认显示管理器为sddm，可运行下列命令：dpkg-reconfigure sddm3）如何设置ubuntu系统默认进入字符界面/图形界面？为调试问题，有时需要让Ubuntu不自动进入图形界面。此时，可输入下列命令：systemctl set-default multi-user.target如果要恢复默认进入图形界面，输入：systemctl set-default multi-user.target graphical.target4）常用内核启动参数配置UEFI启动时，选择引导盘后，进入grub菜单选项时，按“e”进入编辑界面，修改其中包含linux /boot/vmlinuz-4.19.0.ft+的行，可修改启动内核、增加多种内核启动参数，例如：设置OS使用的cpu数目为1，添加maxcpus=1进行S3睡眠时不关闭串口输出，添加no_console_suspend设置内核打印信息级别，添加loglevel=7禁止自动加载驱动，如禁用phytium_mci_pci驱动，添加modprobe.blacklist=phytium_mci_pci强制PCI设备使用INT中断方式，添加pci=nomsiinitcall_debug更详细的参数配置，可参考linux内核相关文档。为让这些配置永久生效，需要修改grub配置文件，更新grub。例如为永久增加no_console_suspend，可输入下列命令：sudo suvi /etc/default/grub# 修改其中的GRUB_CMDLINE_LINUX_DEFAULT=””行,在引号中添加no_console_suspendupdate-grub#更新grub配置5）进入KDE桌面后没有声音？进入KDE桌面后，没有声音，打开声音图标没有声卡设备。可能原因：当前用户没有权限访问声音设备，将当前用户加入audio组后，重启。sudo gpasswd -atestaudio
sudo reboot如果还是没有找到声音设备，可通过下列命令查看声音设备：aplay -l检查是否存在声音设备，例如对于飞腾hda声音设备，会输出：card 0: fthda [ft-hda] ...如果存在声音设备，可运行alsamixer配置声音设备：alsamixer如果没有找到任何声音设备，则可能声音驱动出现问题，请联系飞腾进一步分析。推荐阅读飞腾平台perf工具PMU事件集成指南基于飞腾平台的OpenCV的编译与安装欢迎广大开发者来飞腾开发者平台获取更多前沿技术文档及资料如开发者在使用飞腾产品有任何问题可通过在线工单联系我们版权所有。飞腾信息技术有限公司 2023。保留所有权利。未经本公司同意，任何单位、公司或个人不得擅自复制，翻译，摘抄本文档内容的部分或全部，不得以任何方式或途径进行传播和宣传。商标声明Phytium和其他飞腾商标均为飞腾信息技术有限公司的商标。本文档提及的其他所有商标或注册商标，由各自的所有人拥有。注意本文档的内容视为飞腾的保密信息，您应当严格遵守保密任务；未经飞腾事先书面同意，您不得向任何第三方披露本文档内容或提供给任何第三方使用。由于产品版本升级或其他原因，本文档内容会不定期进行更新。除非另有约定，本文档仅作为使用指导，飞腾在现有技术的基础上尽最大努力提供相应的介绍及操作指引，但飞腾在此明确声明对本文档内容的准确性、完整性、适用性、可靠性的等不作任何明示或暗示的保证。本文档中所有内容，包括但不限于图片、架构设计、页面布局、文字描述，均由飞腾和/或其关联公司依法拥有其知识产权，包括但不限于商标权、专利权、著作权等。非经飞腾和/或其关联公司书面同意，任何人不得擅自使用、修改，复制上述内容。http://www.ppmy.cn/news/1540631.html相关文章mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...vLLM 大模型推理引擎调研文档文章目录 介绍vLLM 速度很快vLLM 灵活且易于使用 使用和部署离线批量推理在线推理服务 分布式推理服务如何确定分布式推理策略?多节点推理和服务-Ray集群 量化支持模型量化KV Cache 量化 性能调优PagedAttentionAutomatic prefix cachingBatching 策略PreemptionChunked Prefi…阅读更多...SpringBoot构建的智能健康生活助手4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...极速体验：实用的前端性能优化技巧本文将深入探讨一系列实用的前端性能优化方案&amp;#xff0c;从基础知识到高级技巧&amp;#xff0c;我们将揭示如何让你的网站在瞬息万变的互联网中脱颖而出&amp;#xff0c;无论你是经验丰富的开发者还是刚入行的新手&amp;#xff0c;这篇文章都将为你提供宝贵的见解和实践建议。 目录 
&amp;…阅读更多...CTF(七)导言&amp;#xff1a; 
本文主要讲述在CTF竞赛中&amp;#xff0c;Misc&amp;#xff08;杂项&amp;#xff09;题目中的CatchCat。 
靶场链接&amp;#xff1a;攻防世界 (xctf.org.cn) 
一&amp;#xff0c;分析题目。 下载并解压附件&amp;#xff1a; CatchCat.txt文件内容为&amp;#xff1a; 发现是坐标。 
另一个…阅读更多...◇【论文_20151120_20160405v3】Dueling Network 决斗〔Google DeepMind〕整理代码&amp;#xff1a;Dueling_DQN__Pendulum_v1.ipynb 
https://arxiv.org/abs/1511.06581 
Dueling Network Architectures for Deep Reinforcement Learning 文章目录 摘要1. 引言1.1. 相关工作 2. 背景2.1. Deep Q-networks 【DQN】2.2. Double Deep Q-networks 【DDQN】2.3…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api创建文字注释mysql 查询今天、昨天、本周、上周、本月、上月、本季度、上季度、本年、上一年、的数据P10674 [MX-S1-T3] 电动力学 题解【UE引擎解构】- GamePlay篇 : 移动读后感一：《代码大全 2》—— 从 “写代码” 到 “做工程” 的思维跃迁 - AAi元人文：对“局限性”的反驳Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 12:55:44 +0000</pubDate>
    </item>
  </channel>
</rss>
