<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>PPMY RSS</title>
    <link>https://www.ppmy.cn/news</link>
    <description>PPMY 网站文章 RSS</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 31 Oct 2025 13:28:47 +0000</lastBuildDate>
    <item>
      <title>【C语言】数据输出格式控制</title>
      <link>https://www.ppmy.cn/news/1540732.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【C语言】数据输出格式控制news/2025/10/31 21:30:56/数据的输出格式修饰常用两种：整型中，输出数据左对齐、右对齐、占m位、不足m位前补0。浮点型中，默认通过四舍五入保留小数点后6位，通过参数设置保留小数点后n位。#include&lt;stdio.h&gt;#definePI3.14159/*	功能：不同数据类型的输出格式修饰符 时间：2024年9月 地点：贤者楼129 作者：LChen
*/intmain(){inta,b;doublec,d;scanf("%d%d",&amp;a,&amp;b);scanf("%lf%lf",&amp;c,&amp;d);printf("a=%d,b=%d.\n",a,b);//输出结果printf("a=%5d,b=%5d.\n",a,b);//输出5位，右对齐printf("a=%-5d,b=%-5d.\n",a,b);//输出5位，左对齐printf("a=%05d,b=%05d.\n",a,b);//输出5位，不足时前补0printf("c=%lf,d=%lf.\n",c,d);//默认输出小数点后6位，四舍五入printf("c=%10lf,d=%10lf.\n",c,d);//输出10位printf("c=%.10lf,d=%.10lf.\n",c,d);//输出小数点后10位，不足后补0return0;}前两行为输入a,b为整型变量c,d为浮点型变量，四舍五入截取数据，不足补0.http://www.ppmy.cn/news/1540732.html相关文章前端项目中遇到的技术问题1.性能问题 
页面加载过长、图像加载慢。解决方案&amp;#xff1a;代码分割&amp;#xff0c;按照需求加载模块&amp;#xff0c;减少初始的加载量或者使用懒加载、资源压缩、cdn加速 
2.响应式设计&amp;#xff08;移动设备适配&amp;#xff09; 
不同的屏幕尺寸&amp;#xff0c;布局和样式不统一。解决方…阅读更多...依赖标签分类任务Smin值计算（蛋白质功能预测，GO标签）前言 
Smin是在蛋白质功能预测中比较流行的一个指标&amp;#xff0c;具体由来我也不甚清楚&amp;#xff0c;只是在最近复现的几篇论文中反复出现了&amp;#xff0c;所以记录一下。 
计算方法 
&amp;#xff08;图来自于PSPGO论文&amp;#xff09; 其中&amp;#x1d70f;表示阈值&amp;#xff0c;t表示GO标签…阅读更多...【动态规划】【路径问题】下降路经最小和、最小路径和、地下城游戏4. 下降路径最小和 931. 下降路径最小和  算法原理 确定状态表示 dp[i][j] 表示&amp;#xff1a;到达 [i, j] 位置&amp;#xff0c;最小的下降路径  状态转移方程  dp[i][j] 从 [i-1, j-1] 到达 [i, j] &gt; dp[i-1][j-1]  m[i][j]从 [i-1, j] 到达 [i, j] &gt; dp[i-1][j]  m[i][j]从 …阅读更多...RabbitMQ service is already present - only updating service parametersWindows下卸载RabbitMQ之后，然后重新注册RabbitMQ服务的时候，报错以下信息： D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin&gt;D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin\rabbitmq-service.bat install RabbitMQ service is already …阅读更多...csp普及组算法集训--DfsDFS是一种经典的搜索算法&amp;#xff0c;也是检测有没有编程天赋的试金石。 
DFS&amp;#xff1a;搜索与回溯 
题1&amp;#xff1a;自然数的拆分 
//自然数的拆分 
#include&lt;bits/stdc.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可…阅读更多...初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:56 +0000</pubDate>
    </item>
    <item>
      <title>前端项目中遇到的技术问题</title>
      <link>https://www.ppmy.cn/news/1540731.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维前端项目中遇到的技术问题news/2025/10/31 21:30:55/1.性能问题页面加载过长、图像加载慢。解决方案：代码分割，按照需求加载模块，减少初始的加载量或者使用懒加载、资源压缩、cdn加速2.响应式设计（移动设备适配）不同的屏幕尺寸，布局和样式不统一。解决方案：使用css的媒体查询（media queries）针对不同屏幕下应用特定的样式、采用弹性盒布局flexbox布局实现更灵活的响应式布局。采用bootstrap之类的前端框架提供的响应式工具类。3.网络请求的跨域问题协议、域名、端口任意一个任意一个不同的时候，就会产生跨域问题。解决方案：两种cors、jsonp；cors是后台解决方案，proxy是我常用的，get请求target输入服务器地址，changeOrigin设置为true。http://www.ppmy.cn/news/1540731.html相关文章依赖标签分类任务Smin值计算（蛋白质功能预测，GO标签）前言 
Smin是在蛋白质功能预测中比较流行的一个指标&amp;#xff0c;具体由来我也不甚清楚&amp;#xff0c;只是在最近复现的几篇论文中反复出现了&amp;#xff0c;所以记录一下。 
计算方法 
&amp;#xff08;图来自于PSPGO论文&amp;#xff09; 其中&amp;#x1d70f;表示阈值&amp;#xff0c;t表示GO标签…阅读更多...【动态规划】【路径问题】下降路经最小和、最小路径和、地下城游戏4. 下降路径最小和 931. 下降路径最小和  算法原理 确定状态表示 dp[i][j] 表示&amp;#xff1a;到达 [i, j] 位置&amp;#xff0c;最小的下降路径  状态转移方程  dp[i][j] 从 [i-1, j-1] 到达 [i, j] &gt; dp[i-1][j-1]  m[i][j]从 [i-1, j] 到达 [i, j] &gt; dp[i-1][j]  m[i][j]从 …阅读更多...RabbitMQ service is already present - only updating service parametersWindows下卸载RabbitMQ之后，然后重新注册RabbitMQ服务的时候，报错以下信息： D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin&gt;D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin\rabbitmq-service.bat install RabbitMQ service is already …阅读更多...csp普及组算法集训--DfsDFS是一种经典的搜索算法&amp;#xff0c;也是检测有没有编程天赋的试金石。 
DFS&amp;#xff1a;搜索与回溯 
题1&amp;#xff1a;自然数的拆分 
//自然数的拆分 
#include&lt;bits/stdc.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可…阅读更多...初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:55 +0000</pubDate>
    </item>
    <item>
      <title>依赖标签分类任务Smin值计算（蛋白质功能预测，GO标签）</title>
      <link>https://www.ppmy.cn/news/1540730.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维依赖标签分类任务Smin值计算（蛋白质功能预测，GO标签）news/2025/10/31 21:30:54/前言Smin是在蛋白质功能预测中比较流行的一个指标，具体由来我也不甚清楚，只是在最近复现的几篇论文中反复出现了，所以记录一下。计算方法（图来自于PSPGO论文）其中𝜏表示阈值，t表示GO标签，Pa(t)表示该GO标签依赖父亲。Prob(t|Pa(t))使用频率估算，是描述整个Protein-GO数据集的统计值。Pi(𝜏)表示在阈值𝜏下的第i个蛋白质的预测GO集合，Ti表示第i个蛋白质实际GO标签集合。这个计算流程比较复杂，得先用频率估计概率求出ic（相信大部分GO预测论文里面都有对应代码）然后枚举Threshold值，对每个蛋白质计算 当前预测GO标签传递闭包 与 真实标签的传递闭包 的差集（Ti-Pi的差集和Pi-Ti的差集），统计这两部分的ic值各自的平均数，然后求这两个平均数的评分平均数作为S值。最后找到最小的S值就是Smin了。一些疑问的解答1、为什么求传递闭包？（什么是传递闭包？请看《离散数学》图论部分）首先GO标签依赖关系是一个DAG（这里只考虑is_a和part_of关系，加入regulates之后就可能存在环了！）然而一般数据库给出go.gaf文件都只是给出最具体的标签部分，更上层的GO标签未必有记录，但是有子标签必然是有父标签的，所以我们需要读取go.obo文件建立DAG图，然后求每个子标签的传递闭包的并，这才能得到一个蛋白质完整的GO标注数据。2、ic值的计算首先ic值也必须建立在所有蛋白质的GO标注都求过传递闭包的基础上。在一个点有两个父亲的情况应该怎么办，例如：在一些论文中，我们选取的是Prob(t|Pa(t))更大的作为这里标签的ic值（也就是选取父亲出现次数更少的进行计算）。另一些论文中可能会有不同的处理。3、计算Smin的时候能否先对预测结果做一遍传递闭包？复现论文是发现的细节，有些论文在计算Smin的时候巨慢无比，原来是每次都会把预测结果传递一遍再来求ru和mi值。这样按照理论，得到的Smin值会更优一些，因为可以避免掉一些预测误差导致的中间某个GO标签缺失的情况。实战来说，确实可以这么做，毕竟预测结果肯定是可以先传递一遍，再给别人拿去用的。但有些老实的论文并没有做传递，得到的Smin值可能就会略有偏高。4、关于Smin计算的优化在复现PO2Vec论文时发现的问题，算一个thresh得花我十多分钟，实在受不了了，就给他优化了一把。优化思路：提前保存每个GO标签的传递闭包结果，更改计算顺序，利用two-pointers计算每个蛋白质对各个阈值下的ru与mi的贡献。在优化前，在swissprot数据集下，计算一次mf的Smin需要约10个小时，在优化后，只需要不到一个半小时。主要优化的evaluate_cafa3.py中的evaluate_model_predicion函数。def evaluate_model_prediction(labels, terms, model_preds, go_rels, ont):ru_list = []mi_list = list()# go setgo_set = go_rels.get_namespace_terms(NAMESPACES[ont])go_set.remove(FUNC_DICT[ont])# labelslabels = list(map(lambda x: set(filter(lambda y: y in go_set and y in terms, x)), labels))ancs = {}for go_id in tqdm(go_rels.ont,desc="calc ancs..."):ancs[go_id] = go_rels.get_ancestors(go_id)lim_set = go_set.intersection(terms)ru_list = [0]*101mi_list = [0]*101total = 0for x in labels:if len(x) &gt; 0:total+=1assert len(labels) == len(model_preds)for label,pred_score in tqdm(zip(labels,model_preds)):tmp_lis = list(zip(pred_score,terms))tmp_lis.sort(reverse=True)j=0new_annots = set()for t in reversed(range(101)):threshold = t/100.0while j&lt;len(tmp_lis) and tmp_lis[j][0]&gt;threshold:new_annots |= ancs[tmp_lis[j][1]]j+=1new_annots = new_annots.intersection(lim_set)tp = new_annots.intersection(set(label))fp = new_annots - tpfn = label - tpfor go_id in fp:mi_list[t] += go_rels.get_ic(go_id)for go_id in fn:ru_list[t] += go_rels.get_ic(go_id)ru = np.array(ru_list)/totalmi = np.array(mi_list)/totalsmin = np.min(np.sqrt(ru * ru + mi * mi))return sminhttp://www.ppmy.cn/news/1540730.html相关文章【动态规划】【路径问题】下降路经最小和、最小路径和、地下城游戏4. 下降路径最小和 931. 下降路径最小和  算法原理 确定状态表示 dp[i][j] 表示&amp;#xff1a;到达 [i, j] 位置&amp;#xff0c;最小的下降路径  状态转移方程  dp[i][j] 从 [i-1, j-1] 到达 [i, j] &gt; dp[i-1][j-1]  m[i][j]从 [i-1, j] 到达 [i, j] &gt; dp[i-1][j]  m[i][j]从 …阅读更多...RabbitMQ service is already present - only updating service parametersWindows下卸载RabbitMQ之后，然后重新注册RabbitMQ服务的时候，报错以下信息： D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin&gt;D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin\rabbitmq-service.bat install RabbitMQ service is already …阅读更多...csp普及组算法集训--DfsDFS是一种经典的搜索算法&amp;#xff0c;也是检测有没有编程天赋的试金石。 
DFS&amp;#xff1a;搜索与回溯 
题1&amp;#xff1a;自然数的拆分 
//自然数的拆分 
#include&lt;bits/stdc.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可…阅读更多...初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:54 +0000</pubDate>
    </item>
    <item>
      <title>【动态规划】【路径问题】下降路经最小和、最小路径和、地下城游戏</title>
      <link>https://www.ppmy.cn/news/1540729.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【动态规划】【路径问题】下降路经最小和、最小路径和、地下城游戏news/2025/10/31 21:30:52/4. 下降路径最小和931. 下降路径最小和算法原理确定状态表示dp[i][j]表示：到达[i, j]位置，最小的下降路径状态转移方程dp[i][j]从[i-1, j-1]到达[i, j]==&gt;dp[i-1][j-1] + m[i][j]从[i-1, j]到达[i, j]==&gt;dp[i-1][j] + m[i][j]从[i-1, i+1]到达[i, j]==&gt;dp[i-1][j+1] + m[i][j]dp[i][j] = min(上面三个) + m[i][j]初始化目的是为了让我们再填表的过程中不会出现越界的情况里面的值，要保证后面的填表是正确的绿星的地方都可能会越界进行绿框范围的虚拟节点构造虚拟出的第一行全部填 0，就可以保证原表的第一行都是 0但从原表的第二行开始，每个格子都是取前三者之间的最小值，所以下面虚拟的节点就不能填最小的值 0 了，不然每个格子都是 0。所以都取正无穷大下标的映射整个表向右下移动了一个单位长度(0, 0)——&gt;(1, 1)在初始化的时候，可以把所有虚拟出的节点都设为+∞，然后将第一行改为0就可以了填表顺序从上往下返回值这里不是返回dp[m][n]的值返回dp表中最行一行的最小值代码编写publicintminFallingPathSum(int[][]matrix){//1. 创建 dp 表intn=matrix.length;int[][]dp=newint[n+1][n+2];//2. 初始化for(inti=1;i&lt;=n;i++){//第一列和最后一列dp[i][0]=dp[i][n+1]=Integer.MAX_VALUE;}//3. 填表for(inti=1;i&lt;=n;i++){for(intj=1;j&lt;=n;j++){dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i-1][j],dp[i-1][j+1]))+matrix[i-1][j-1];}}intret=Integer.MAX_VALUE;for(inti=1;i&lt;=n;i++){ret=Math.min(ret,dp[n][i]);}returnret;}取最值只能两个进行比较注意无穷值的写法时间复杂度：n*n（两个for循环）空间复杂度：n*n（弄了个二维dp表）5. 最小路径和64. 最小路径和算法原理确定状态表示dp[i][j]表示：到达[i, j]位置时，最小路径和状态转移方程dp[i][j]从[i-1, j]走过来==&gt;dp[i-1][j] + g[i][j]从[i, j-1]走过来==&gt;dp[i][j-1] + g[i][j]`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + g[i][j]初始化因为是取最小值，所以虚拟的节点要小，以免被误取但起点需要是 0，所以它左边和上面的虚拟节点dp[0][1]和dp[1][0]需要是 0填表顺序从上往下从左往右返回值返回dp[m][n]代码编写publicintminPathSum(int[][]grid){//1. 创建 dp 表intm=grid.length;intn=grid[0].length;int[][]dp=newint[m+1][n+1];//2. 初始化for(inti=0;i&lt;=n;i++)dp[0][i]=Integer.MAX_VALUE;for(inti=0;i&lt;=m;i++)dp[i][0]=Integer.MAX_VALUE;dp[0][1]=dp[1][0]=0;//3. 填表for(inti=1;i&lt;=m;i++){for(intj=1;j&lt;=n;j++){dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];}}returndp[m][n];}6. 地下城游戏174. 地下城游戏算法原理确定状态表示dp[i][j]表示：从[i, j]位置出发，到达终点，所需的最低初始健康点数这里不能以[i, j]为终点构建状态表示，状态转移方程dp[i][j]，此时的点数必须要&gt;=下一个要到的地方 dp 值从此处往右走，x+d[i][j] &gt;= dp[i][j+1]，所以x &gt;= dp[i][j+1] - d[i][j]即可从此处往下走，同理x &gt;= d[i+1][j] - d[i][j]即可如果d[i][j]太大，就是说在那一格有个很大的血包。减完之后就变成一个负值了（你是一个负血的状态，通过这个格子之后也能顺利通过），这是不符合逻辑的。所以我们要把dp[i][j]和1放在一起取一下max如果算出来是负数，就更新为 1如果是大于等于 1 的数，就保持初始化我们关注的是格子的下面和右边的状态，所以可能会越界的是最下面一行和最右边一行我们在最下面和最右边添加辅助节点此时就不用考虑下标映射关系里面的值，需要保证后续的填表是正确的我们看原表终点格，要走出去，终点最少需要1点血量所以只需要把终点下面和右边的格子置为1就可以了其余的位置是两格之间求min，我们只需要保证辅助的节点不被选上就可以，所以我们将其他的节点设为+∞填表顺序从下往上从右往左返回值返回dp[0][0]代码编写publicintcalculateMinimumHP(int[][]dungeon){//1. 创建 dp 表intm=dungeon.length;intn=dungeon[0].length;int[][]dp=newint[m+1][n+1];//2. 初始化for(intj=0;j&lt;=n;j++)dp[m][j]=Integer.MAX_VALUE;for(inti=0;i&lt;=m;i++)dp[i][n]=Integer.MAX_VALUE;dp[m][n-1]=dp[m-1][n]=1;//3. 填表for(inti=m-1;i&gt;=0;i--){for(intj=n-1;j&gt;=0;j--){dp[i][j]=Math.min(dp[i][j+1],dp[i+1][j])-dungeon[i][j];dp[i][j]=Math.max(dp[i][j],1);}}returndp[0][0];}http://www.ppmy.cn/news/1540729.html相关文章RabbitMQ service is already present - only updating service parametersWindows下卸载RabbitMQ之后，然后重新注册RabbitMQ服务的时候，报错以下信息： D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin&gt;D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin\rabbitmq-service.bat install RabbitMQ service is already …阅读更多...csp普及组算法集训--DfsDFS是一种经典的搜索算法&amp;#xff0c;也是检测有没有编程天赋的试金石。 
DFS&amp;#xff1a;搜索与回溯 
题1&amp;#xff1a;自然数的拆分 
//自然数的拆分 
#include&lt;bits/stdc.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可…阅读更多...初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:53 +0000</pubDate>
    </item>
    <item>
      <title>RabbitMQ service is already present - only updating service parameters</title>
      <link>https://www.ppmy.cn/news/1540728.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维RabbitMQ service is already present - only updating service parametersnews/2025/10/31 21:30:51/Windows下卸载RabbitMQ之后，然后重新注册RabbitMQ服务的时候，报错以下信息：D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin&gt;D:\software\rabbitmq-server-4.0.2\rabbitmq_server-4.0.2\sbin\rabbitmq-service.bat installRabbitMQ service is already present - only updating service parametersC:\Program Files\Erlang OTP\erts-14.0\bin\erlsrv: Warning, could not set correct interactive mode. RabbitMQError: Ö¸¶¨µÄ·þÎñÒÑ±ê¼ÇÎªÉ¾³ý¡£C:\Program Files\Erlang OTP\erts-14.0\bin\erlsrv: Warning, could not set correct service description (comment) RabbitMQError: Ö¸¶¨µÄ·þÎñÒÑ±ê¼ÇÎªÉ¾³ý¡£解决办法http://www.ppmy.cn/news/1540728.html相关文章csp普及组算法集训--DfsDFS是一种经典的搜索算法&amp;#xff0c;也是检测有没有编程天赋的试金石。 
DFS&amp;#xff1a;搜索与回溯 
题1&amp;#xff1a;自然数的拆分 
//自然数的拆分 
#include&lt;bits/stdc.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可…阅读更多...初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:51 +0000</pubDate>
    </item>
    <item>
      <title>csp普及组算法集训--Dfs</title>
      <link>https://www.ppmy.cn/news/1540727.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维csp普及组算法集训--Dfsnews/2025/10/31 21:30:50/DFS是一种经典的搜索算法，也是检测有没有编程天赋的试金石。DFS：搜索与回溯题1：自然数的拆分//自然数的拆分 
#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,ans[101];
void dfs(int sum,int dp){if(sum&gt;n){return;//不可以让若干个数的和大于n }if(sum==n){for(int i=1;i&lt;=dp-2;i++){printf("%d+",ans[i]);}printf("%d\n",ans[dp-1]);}for(int i=ans[dp-1];i&lt;n;i++){//是组合而不是全排列 ans[dp]=i;dfs(sum+i,dp+1);}
}
int main(){scanf("%d",&amp;n);ans[0]=1;//从1开始 dfs(0,1);	
}迷宫问题：（洛谷）# 迷宫## 题目描述给定一个 $N *M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。## 输入格式第一行为三个正整数 $N,M,T$，分别表示迷宫的长宽和障碍总数。第二行为四个正整数 $SX,SY,FX,FY$，$SX,SY$ 代表起点坐标，$FX,FY$ 代表终点坐标。接下来 $T$ 行，每行两个正整数，表示障碍点的坐标。## 输出格式输出从起点坐标到终点坐标的方案总数。## 样例 #1### 样例输入 #1```2 2 11 1 2 21 2```### 样例输出 #1```1```## 提示对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。code:#include&lt;bits/stdc++.h&gt;
using namespace std;
int q[101][101];
int sum=0;
int i,j,n,m,t,sx,sy,x,y,ex,ey;
void dfs(int a,int b)
{if (a==ex&amp;&amp;b==ey){//终止条件sum++;return;}else{q[a][b]=0;if(q[a-1][b]!=0) {dfs(a-1,b);q[a-1][b]=1;}if(q[a][b-1]!=0) {dfs(a,b-1);q[a][b-1]=1;}if(q[a][b+1]!=0) {dfs(a,b+1);q[a][b+1]=1;}if(q[a+1][b]!=0) {dfs(a+1,b);q[a+1][b]=1;}}
}
int main()
{memset(q,0,sizeof(q));//边界当作障碍。cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++)q[i][j]=1;//可以走for(i=1;i&lt;=t;i++){cin&gt;&gt;x&gt;&gt;y;q[x][y]=0;//障碍物初始化}dfs(sx,sy);cout&lt;&lt;sum&lt;&lt;endl;return 0;
}总结：dfs模板：int search(int t)
{if(满足输出条件){输出解;}else{for(int i=1;i&lt;=尝试方法数;i++)if(满足进一步搜索条件){为进一步搜索所需要的状态打上标记;search(t+1);恢复到打标记前的状态;//也就是说的{回溯一步}}}
}http://www.ppmy.cn/news/1540727.html相关文章初识git · 远程操作目录 
前言&amp;#xff1a; 
理解分布式版本控制系统 
远程仓库 
仓库操作 
克隆仓库 
推送和抓取 
特殊文件 
取别名 
标签管理 前言&amp;#xff1a; 
在基本操作&amp;#xff0c;分支管理这几个部分&amp;#xff0c;我们都会在本地仓库操作了&amp;#xff0c;但是目前还没有办法将自己的代码远程…阅读更多...深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:50 +0000</pubDate>
    </item>
    <item>
      <title>初识git · 远程操作</title>
      <link>https://www.ppmy.cn/news/1540726.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维初识git · 远程操作news/2025/10/31 21:30:49/目录前言：理解分布式版本控制系统远程仓库仓库操作克隆仓库推送和抓取特殊文件取别名标签管理前言：在基本操作，分支管理这几个部分，我们都会在本地仓库操作了，但是目前还没有办法将自己的代码远程推送到仓库里面，所以本文，我们学习远程操作，操作完之后，我们就可以将自己的代码远程推送到我们自己的gitee或者是github账户啦。那么废话不多说，进入今日主题——远程操作。理解分布式版本控制系统git的本质是分布式的版本控制系统，版本控制我们已经知道了，git中通过改变HEAD指针的朝向，从而快速的实现版本回退等操作。那么分布式，我们其实在分支管理章节有已经有所体会，对于master分支，作为最稳定的分支，一般不会在上面进行开发，对于其他分支，开发分支，以及bug分支，共同维护某个项目，这是分布式，一个项目交给多个分支完成，每个分支完成对应的操作。最初，分布式可以理解为两个人的电脑互传对应的修改，所以两个人之间可以看到所有的文件，如果一个人的数据丢失了也不用担心，直接从另一个人的电脑上cv就可以了。那么，实际上分布式操作的时候很少有两个人互相传数据的，一般都是一台机器作为中央服务器，也就是所有的代码，数据都会放在上面，谁的数据丢失了，谁的代码丢失了，都可以从上面cv代码回来。所以，对于我们来说，中央服务器实际上是我们平常生活中使用的gitee的仓库，我们将该仓库作为中央服务器，代码也都是传在上面的，那么，我们如何新建一个远程仓库呢？远程仓库我们在gitee右上角有个加号，点击选择新建仓库，我们就进入到了该界面，那么名称是要有的，路径会默认生成，仓库的介绍也是一定要有的。然后，是是否开源，我们可以先选择为私有，后面有开源的需求就可以直接开源即可。在新建仓库的时候，我们要注意的点是三个部分。语言，肯定就是自己经常用什么语言就选择什么语言，.gitnore我们后面介绍。开源不用管。那么对于模板来说，ReadMe文件是仓库的一般说明，也就是别人进入你仓库之后，第一眼看到的就是ReadMe文件，所以该文件的作用是用来具体介绍仓库是用来干什么的。第二个是Issue模板文件，这个文件与之后的Bug之类的有关，我们一会儿看看。第三个是Pull Request文件，是什么我们一会儿介绍。最后就是分支模型，因为目前来说不是写项目的话，我们选择的一般是单分支模型，也就是只有一条分支，开发啊调试什么的都在上面进行。此时，我们点击创建。出现了如下的文件，对于README文件我们已经清楚，其中后缀有en的README文件是英文，非en的就是中文版的：具体的内容我们都是可以自己编辑的。那么我们看看Issue文件：该文件所在的目录是.gitee里面，我们根据该文件的一个模板，大概也能猜出大体功能是什么，也就是发现Bug的一个报告模板，在Issue一栏我们可以看到：这就是Issue的具体图形化，新建Issue试试：在Issue一栏，我们可以设置对应的负责人，标签(里面不止有bug)，还有该问题是在哪个分支上出现的，日期也有，并且可以选择置顶等级和优先级，这是非常符合企业级的管理的。此时创建之后，Issue里面就有了对应的报告，那么当问题解决了，我们可以在对应的状态里面点击已解决，此时一个bug就被我们解决了。当然了，这个仓库如果是开源的，任何人都是可以提交Issue的，我们作为管理者，可以对Issue进行任何的处理，如拒绝等。对于Pull Request来说呢，是一个分支合并请求，因为开发中的时候，不是能直接合并的，如果能随便合并，那么项目基本上就报废了，所以存在着合并请求的东西，我们作为管理者，自然是有权处理对应的请求的。对于远程仓库的Pull Request和Issue就暂时讲解到这里。仓库操作克隆仓库我们创建了仓库，自然是需要提交代码上去的，那么第一个点，我们如何克隆远程仓库到我们的本地呢？此时，存在两种常用的克隆方法，一种是使用SSH协议，一种是使用https协议，对于SSH来说，安全性更高，更有保障，因为它是使用了公钥加密的。对于https协议呢，就没有那么多要注意的了，简简单单的克隆就可以了，我们先使用https协议作为例子：使用https我们需要的是该字符串，然后使用git clone命令，注意，克隆远程仓库是不能在.git所在的目录创建的，所以我们还需要将原来的本地仓库删除：此时，仓库就创建好了，创建好了之后，在基本操作那里我们提及最重要的两个信息是名字和邮箱，所以我们也应该配置上：此时都是没有配置的。此时，基本配置就做好了。这是使用https协议克隆的仓库，那么我们将此仓库删除，使用SSH克隆一个。如果我们直接使用git clone进行克隆的话，那么往往是会报错的：不能克隆仓库往往是因为我们没有添加对应公钥：在这里是我们添加公钥的地方，添加公钥之前，我们需要创建文件。第一步是我们要查看用户的家目录下面是否存在.ssh文件：这里是有的，那么我们进入：里面只有这么多东西，而我们需要创建的是id_rsa，id_rsa.pub两个文件，pub是public，公钥的意思，对于id_rsa是私钥的意思，肯定是不能透露给其他人的，公钥就无所谓了。ssh-keygen -t rsa -C "email"然后我们退出来，在家目录下执行该命令，注意，邮箱是要输入我们自己的：此时我们一路回车就可以了。此时进入到ssh目录下：我们打开对应的公钥文件：此时这个一长串的，我们就需要全部复制下来。然后到gitee添加即可：添加好了之后，我们此时再次使用ssh协议就可以了：此时就创建成功了，但是该公钥是只读的，我们应该到设置部分添加公钥，操作一样的，这里就不演示了。那么我们的仓库克隆操作就完成了。此时我们可以git remote查看远程仓库的信息：我们仓库的原始名称就叫做origin。-v显示了抓取和推送的地址，如果我们没有对应的权限也就看不到了。那么现在演示推送和抓取。推送和抓取对于推送push，我们常用的操作如上，我们目前本地的分支和远程的分支都叫做master，所以我们可以直接git push master即可，此时我们不妨创建文件,push一下试试：此时push成功了，那么我们看看gitee的提交记录：此时push成功。如果我们是使用的https协议，每次推送需要输入口令相对来说就麻烦一点。此时，我们实现一下抓取操作，这种情况是发生在远端仓库代码进度快于本地的，此时需要抓取，那么我们在gitee直接修改一下刚才提交的文件就可以了，但是注意，平时的代码修改是最好不要在gitee上修改的，这是个很不好的坏习惯：此时修改成功。pull来说就是远程在前，从远程pull到本地，push是本地push到远程，顺序还是很好理解的：此时就成功了。我们平常使用图形化界面的时候，如果没有.git文件，常常就会push出一大推无关的文件，此时，特殊文件.gitignore就出场了。特殊文件我们现在克隆仓库里面看看.gitignore里面有没有东西：是有的，因为我们当时创建的时候，勾选了该文件，所以gitee自动帮我们初始化好了，由Linux的学习我们知道*的意思是通配符，所以*.d的意思就是所有以d为后缀结束的文件都不要追踪它，#的意思是注释，那么文件里面那么多，都是代表不要追踪的意思。我们创建一个.so结尾的文件，看git的状态是否发生改变：此时就没有，但是有的时候啊，我们有一个文件是.so结尾，但是是要传输的，那么怎么办呢？此时只需要! + filename就可以了：此时我们就可以传了。那么有的时候，文件传不过去，,gitignore又不好找，我们可以使用check检查一下是为什么：git check-ignore -v a.so就是说检查一下，为什么传不了。对于传隐藏文件，如果我们不希望改变.gitignore，我们就可以git add -f filename即可。取别名对于有些命令实在是太长了，我们就可以对某些命令取别名：git config --global alias.st status--global代表的是这台电脑的所有仓库都可以使用该命令，如果没有了就只有当前仓库能够使用，alias.newname dir即可。此时我们就可以将status简写为st了。标签管理本文呢简单介绍一下标签管理，因为涉及的内容就只有创建标签，操作标签，就没了。如果要创建标签，我们应该切换到我们需要创建标签的分支上。使用git tag [tagname]即可。使用命令git tag可以查看所有标签。而标签创建好了之后，默认是打在最新一次的commit上的。那么我们如何修改标签到指定的commit上呢？git tag tagname + commit id就可以了，commit id也可以使用短的，使用pretty=oneline就可以了。注意，标签是按照字母排序的，不是按照创建时间排序的。-a指定标签名，-m文字说明。此时我们tree .git一下：refs下面就有了一个标签咯。删除就很简单了，-d即可。因为创建的标签都是在本地，只有push到远端才有，所以我们可以git push origin [tagname]：此时我们上Gitee看看：标签部分也有了。git push origin --tags如果有很多标签，可以使用如上的指令一次性推送。但是删除就相对麻烦一点了：本地删除之后，远程也需要删除，就像这样。有关git的远程操作和标签管理就介绍完咯~感谢阅读！http://www.ppmy.cn/news/1540726.html相关文章深入了解Spring重试组件spring-retry在我们的项目中&amp;#xff0c;为了提高程序的健壮性&amp;#xff0c;很多时候都需要有重试机制进行兜底&amp;#xff0c;最多就场景就比如调用远程的服务&amp;#xff0c;调用中间件服务等&amp;#xff0c;因为网络是不稳定的&amp;#xff0c;所以在进行远程调用的时候偶尔会产生超时的异常&amp;#xff0…阅读更多...Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:49 +0000</pubDate>
    </item>
    <item>
      <title>深入了解Spring重试组件spring-retry</title>
      <link>https://www.ppmy.cn/news/1540725.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深入了解Spring重试组件spring-retrynews/2025/10/31 21:30:48/在我们的项目中，为了提高程序的健壮性，很多时候都需要有重试机制进行兜底，最多就场景就比如调用远程的服务，调用中间件服务等，因为网络是不稳定的，所以在进行远程调用的时候偶尔会产生超时的异常，所以一般来说我们都会通过手动去写一些重试的代码去进行兜底，而这些重试的代码其实都是模板化的，因此Spring实现了自己的重试机制组件spring-retry，下面我们就一起来学习一下spring-retry这个组件吧使用方式1.编程式// 创建一个RetryTemplate
RetryTemplate retryTemplate = RetryTemplate.builder().customPolicy(new SimpleRetryPolicy()) // 指定重试策略，默认重试3次.exponentialBackoff(1000L, 2, 10000L) // 指定重试的退避时间策略.withListener(new RetryListenerDemo())// 重试监听器.build();// 通过RetryTemplate的execute方法执行业务逻辑
retryTemplate.execute(retryContext -&gt; {log.info("开始执行");throw new RuntimeException("抛出异常");
}, context -&gt; recoverMethod());// 当重试结束还是失败之后最后兜底执行的方法
public String recoverMethod() {log.info("执行恢复");return "执行了Recover方法";
}public class RetryListenerDemo implements RetryListener {@Overridepublic &lt;T, E extends Throwable&gt; boolean open(RetryContext context, RetryCallback&lt;T, E&gt; callback) {log.info("{}", context.getRetryCount());log.info("listener&gt;&gt;&gt;开始监听");//        return false; // 否决整个重试return true; // 继续重试}@Overridepublic &lt;T, E extends Throwable&gt; void close(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {log.info("listener&gt;&gt;&gt;关闭");}@Overridepublic &lt;T, E extends Throwable&gt; void onError(RetryContext context, RetryCallback&lt;T, E&gt; callback, Throwable throwable) {log.info("listener&gt;&gt;&gt;报错了");}
}这里说一下重试监听器，自定义的重试监听器需要实现RetryListener接口，该接口主要包括三个方法：open：在执行我们的业务逻辑之前会执行一次open方法，如果该方法返回false，则会直接抛出一个TerminatedRetryException异常，从而不会往下执行业务逻辑，返回true则正常往下执行close：当重试结束之后，或者open方法返回false的时候就会触发close方法onError：在每一次业务逻辑抛出异常的时候都会执行onError方法2.声明式@Retryable(value = Exception.class, maxAttempts = 3, listeners = {"retryListenerDemo"})
public String test() {log.info("开始执行");throw new RuntimeException("抛出异常");
}@Recover
public String recoverMethod() {log.info("执行恢复");return "执行了Recover方法";
}声明式只需要在需要重试的方法上加上Retryable注解，并且在注解上指定一些重试的属性，比如重试次数，触发重试的异常，重试监听器等等，这些属性对应在编程式中都能进行设置。而对于重试兜底方法则需要Recover注解进行标识重试策略RetryPolicy在对重试属性进行配置的时候我们可以去配置不同的重试策略，所谓的重试策略，其实就是去判断是否能够进行重试，也就是RetryPolicy，它是一个接口public interface RetryPolicy extends Serializable {/*** 是否能够重试** @param context 重试上下文* @return true=&gt;允许重试，false=&gt;不允许重试*/boolean canRetry(RetryContext context);/*** 获取一个重试上下文，不同的重试策略有自己的重试上下文** @param parent 父级重试上下文* @return a {@link RetryContext} object specific to this policy.**/RetryContext open(RetryContext parent);/*** 关闭这个重试上下文*/void close(RetryContext context);/*** 每一次重试失败后会回调该方法，然后通过重试上下文记录下重试的异常，方便在下一次canRetry方法中从重试上下文中去判断是否还能进行重试* @param context 重试上下文* @param throwable 重试时抛出的异常*/void registerThrowable(RetryContext context, Throwable throwable);}该接口在spring-retry中提供多种不同的重试策略的实现SimpleRetryPolicy：这是一种简单的重试策略，允许根据最大重试次数和特定的异常列表来控制重试行为NeverRetryPolicy：不进行重试的重试策略，也就是说我们的业务逻辑代码在第一次执行如果抛出异常了，不会进行重试AlwaysRetryPolicy：允许一直重试的重试策略TimeoutRetryPolicy：通过设置重试的时间段，仅允许在未超过该时间段的时候才进行重试CompositeRetryPolicy：组合重试策略，可以组合多种重试策略，这对于需要复杂条件的情况非常有用ExpressionRetryPolicy：该策略继承了SimpleRetryPolicy，在SimpleRetryPolicy的基础上加上了基于spel表达式去判断是否需要进行重试的功能在RetryPolicy接口中关键的方法就是canRetry，canRetry方法会在重试之前进行调用，用来判断是否还能够继续进行重试，而判断所需的一些上下文属性（例如已经重试的次数，重试的超时时间）就在重试上下文RetryContext中，对于每一种重试策略来说，都会有自己的RetryContext，因为不同的重试策略它们用来判断重试机会的时候所需的上下文属性是不一样的以TimeoutRetryPolicy为例，它具有限制重试时间的功能，那自然就需要记录下重试的起始时间和重试的超时时间了，而这两个信息就会放在TimeoutRetryContext中private static class TimeoutRetryContext extends RetryContextSupport {/*** 允许重试的时间段*/private long timeout;/*** 重试开始时间*/private long start;public TimeoutRetryContext(RetryContext parent, long timeout) {super(parent);this.start = System.currentTimeMillis();this.timeout = timeout;}/*** 判断当前是否超过了重试时间* @return true=&gt;允许重试，false=&gt;已经超过了重试时间了，不允许重试*/public boolean isAlive() {return (System.currentTimeMillis() - start) &lt;= timeout;}}这样就可以在下一次判断是否能够重试的时候，也就是调用canRetry方法的时候通过传入TimeoutRetryContext去判断重试是否超时了退避策略BackOffPolicy上面说的RetryPolicy主要是在每一次要重试之前用来判断是否能够进行重试的，而BackOffPolicy则是提供了重试之间的间隔时间多久的功能，也就是说会先去执行RetryPolicy判断是否允许重试，如果允许重试，则才会去执行BackOffPolicy去等待重试的执行public interface BackOffPolicy {/*** 创建一个退避上下文** @param context the {@link RetryContext} context, which might contain information* that we can use to decide how to proceed.* @return the implementation-specific {@link BackOffContext} or '&lt;code&gt;null&lt;/code&gt;'.*/BackOffContext start(RetryContext context);/*** 执行退避操作* @param backOffContext the {@link BackOffContext}* @throws BackOffInterruptedException if the attempt at back off is interrupted.*/void backOff(BackOffContext backOffContext) throws BackOffInterruptedException;}spring-retry也提供了不同的BackOffPolicy实现NoBackOffPolicy：一个不执行任何操作的 BackOffPolicy，即不会增加等待时间。适用于不需要等待时间间隔的情况FixedBackOffPolicy：以固定时间去进行重试退避ExponentialBackOffPolicy：退避时间以指数形式增长执行流程protected &lt;T, E extends Throwable&gt; T doExecute(RetryCallback&lt;T, E&gt; retryCallback,RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state) throws E, ExhaustedRetryException {RetryPolicy retryPolicy = this.retryPolicy;BackOffPolicy backOffPolicy = this.backOffPolicy;// 获取当前的重试上下文RetryContext context = open(retryPolicy, state);if (this.logger.isTraceEnabled()) {this.logger.trace("RetryContext retrieved: " + context);}// 把当前的重试上下文设置到ThreadLocal中RetrySynchronizationManager.register(context);Throwable lastException = null;boolean exhausted = false;try {// 遍历所有的重试监听器，执行其open方法boolean running = doOpenInterceptors(retryCallback, context);// 条件成立：有其中一个重试监听器的open方法返回了falseif (!running) {// 抛出异常throw new TerminatedRetryException("Retry terminated abnormally by interceptor before first attempt");}// Get or Start the backoff context...BackOffContext backOffContext = null;// 尝试从当前的重试上下文中获取退避上下文Object resource = context.getAttribute("backOffContext");if (resource instanceof BackOffContext) {backOffContext = (BackOffContext) resource;}// 条件成立：说明当前的重试上下文中没有设置退避上下文if (backOffContext == null) {// 这时候通过退避策略创建出对应的退避上下文backOffContext = backOffPolicy.start(context);// 再把这个退避上下文放到重试上下文中if (backOffContext != null) {context.setAttribute("backOffContext", backOffContext);}}// 条件成立：当前配置的重试策略允许重试，并且当前的重试上下文中没有设置中断重试的标志while (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) {try {if (this.logger.isDebugEnabled()) {this.logger.debug("Retry: count=" + context.getRetryCount());}// Reset the last exception, so if we are successful// the close interceptors will not think we failed...lastException = null;// 执行retryCallback，也就是执行目标重试方法return retryCallback.doWithRetry(context);}// 执行目标重试方法时抛异常了catch (Throwable e) {lastException = e;try {// 此时在重试上下文中记录下重试异常registerThrowable(retryPolicy, state, context, e);}catch (Exception ex) {throw new TerminatedRetryException("Could not register throwable", ex);}finally {// 遍历所有的重试监听器，执行其onError方法doOnErrorInterceptors(retryCallback, context, e);}// 在执行退避策略之前再判断一下是否还能重试if (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) {try {// 执行退避策略backOffPolicy.backOff(backOffContext);}catch (BackOffInterruptedException ex) {lastException = e;// back off was prevented by another thread - fail the retryif (this.logger.isDebugEnabled()) {this.logger.debug("Abort retry because interrupted: count=" + context.getRetryCount());}throw ex;}}if (this.logger.isDebugEnabled()) {this.logger.debug("Checking for rethrow: count=" + context.getRetryCount());}if (shouldRethrow(retryPolicy, context, state)) {if (this.logger.isDebugEnabled()) {this.logger.debug("Rethrow in retry for policy: count=" + context.getRetryCount());}throw RetryTemplate.&lt;E&gt;wrapIfNecessary(e);}}/** A stateful attempt that can retry may rethrow the exception before now,* but if we get this far in a stateful retry there's a reason for it,* like a circuit breaker or a rollback classifier.*/if (state != null &amp;&amp; context.hasAttribute(GLOBAL_STATE)) {break;}}// 代码执行到这里说明重试结束了if (state == null &amp;&amp; this.logger.isDebugEnabled()) {this.logger.debug("Retry failed last attempt: count=" + context.getRetryCount());}exhausted = true;// 重试结束之后，最后执行recover方法，并返回recover方法的执行结果return handleRetryExhausted(recoveryCallback, context, state);}// 上面try中抛出异常之后catchcatch (Throwable e) {throw RetryTemplate.&lt;E&gt;wrapIfNecessary(e);}finally {close(retryPolicy, context, state, lastException == null || exhausted);// 执行所有重试监听器的close方法doCloseInterceptors(retryCallback, context, lastException);// 在ThreadLocal中清除当前的重试上下文，如有必要，还需把父级上下文设置回ThreadLocal中RetrySynchronizationManager.clear();}}上面就是执行重试的核心流程代码，注释都详细写上去了，就不多说了。这里有个说一下的就是如果存在嵌套重试的话，我们需要去保存父层级的RetryContext，什么叫嵌套重试？就是在一个重试方法中调用了另一个重试方法，这两个重试方法的重试规则可能都不一样，这时候在执行第二个重试方法的时候就需要把第一个重试方法的RetryContext进行保存，那spring-retry是怎么保存的呢？在RetryContext中会有一个parent，这个parent记录的就是当前上一层的RetryContext，而当第二层重试执行完之后，这时候就会返回上一层的重试，所以就需要把上一层的RetryContext复原，这个复原的动作会在上面最后的finally代码块中执行。关联父子RetryContext的操作会在RetryPolicy的open方法中去执行，传入的参数就是父级的RetryContext/*** 获取一个重试上下文，不同的重试策略有自己的重试上下文** @param parent 父级重试上下文* @return a {@link RetryContext} object specific to this policy.**/RetryContext open(RetryContext parent);http://www.ppmy.cn/news/1540725.html相关文章Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。第一步&amp;#xff0c;重启蓝牙服务 
sudo systemctl restart bluetooth第二步&amp;#xff0c;蓝牙重新连接蓝牙音响。如果已经有声音&amp;#xff0c;那说明需要连接蓝牙的重新加载一下设备。 
第三步&amp;#xff0c;如果第二部成功了之后&amp;#xff0c;继续下面操作&amp;#xff0c;如果不成功&amp;a…阅读更多...已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:48 +0000</pubDate>
    </item>
    <item>
      <title>Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。</title>
      <link>https://www.ppmy.cn/news/1540724.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Ubuntu20.04TLS 连接JBL蓝牙音响连接上却没有播放声音。news/2025/10/31 21:30:47/第一步，重启蓝牙服务sudosystemctl restart bluetooth第二步，蓝牙重新连接蓝牙音响。如果已经有声音，那说明需要连接蓝牙的重新加载一下设备。第三步，如果第二部成功了之后，继续下面操作，如果不成功，可能说明出现问题的原因不一样。可能下面对你没有帮助了sudoaptinstallpulseaudio pulseaudio-module-bluetooth pavucontrol第四步，修改配置文件,在配置文件最下面加上一句load-module module-switch-on-connectcp/etc/pulse/default.pa ~/.config/pulse/default.panano~/.config/pulse/default.pa第五步，重置pulseaudio -k
pulseaudio --start第六步，重新连接蓝牙看是否成功http://www.ppmy.cn/news/1540724.html相关文章已解决：ModuleNotFoundError: No module named ‘pip‘[已解决] ModuleNotFoundError: No module named ‘pip‘ 文章目录 写在前面问题描述报错原因分析 解决思路解决办法1. 手动安装或升级 pip2. 使用 get-pip.py 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 pip6. 使用 conda 安装 pip&amp;…阅读更多...STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:47 +0000</pubDate>
    </item>
    <item>
      <title>已解决：ModuleNotFoundError: No module named ‘pip‘</title>
      <link>https://www.ppmy.cn/news/1540723.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维已解决：ModuleNotFoundError: No module named ‘pip‘news/2025/10/31 21:30:45/[已解决] ModuleNotFoundError: No module named ‘pip‘文章目录写在前面问题描述报错原因分析解决思路解决办法1. 手动安装或升级 `pip`2. 使用 `get-pip.py` 脚本3. 检查环境变量配置4. 重新安装 Python 并确保添加到 PATH5. 在虚拟环境中安装 `pip`6. 使用 `conda` 安装 `pip`（如果使用 Anaconda）总结写在前面在使用 Python 环境时，ModuleNotFoundError: No module named 'pip'是常见的错误，特别是在初次配置 Python 或重新安装 Python 后出现。此错误意味着系统未能找到pip模块，可能由于环境变量配置问题、pip未正确安装或 Python 安装不完整等原因。问题描述报错代码行：ModuleNotFoundError: No module named'pip'报错原因分析pip未安装：在某些情况下，Python 安装过程中未附带pip，导致无法使用pip命令。环境变量配置错误：即使pip已安装，但系统未正确配置 Python 或pip的路径，导致系统无法识别pip。Python 安装不完整或损坏：如果 Python 安装包不完整，可能导致pip相关文件缺失。多个 Python 版本共存：系统中存在多个 Python 版本时，可能会导致pip和python版本不匹配，找不到对应的pip模块。虚拟环境中缺少pip：在创建虚拟环境时，pip可能未自动安装，导致在虚拟环境中使用pip时出现错误。解决思路检查 Python 安装路径：确认系统是否正确安装了 Python，并检查是否包含pip。手动安装或升级pip：通过 Python 自带的脚本手动安装或升级pip。检查并配置环境变量：确保python和pip的路径已经添加到系统环境变量中。重新安装 Python：如果 Python 安装包不完整，建议重新安装，确保安装过程中选中Add Python to PATH选项。在虚拟环境中安装pip：若在虚拟环境中使用pip，则需要单独安装。解决办法1. 手动安装或升级pip如果 Python 已正确安装，可以通过ensurepip模块来安装pip：python -m ensurepip --upgrade此命令会自动安装或升级 Python 中的pip。2. 使用get-pip.py脚本如果ensurepip无法解决问题，可以从官方获取get-pip.py文件，并手动安装pip：下载get-pip.py：打开浏览器，访问 get-pip.py 官方链接。将文件下载到本地（如C:\get-pip.py）。运行以下命令安装pip：python C:\get-pip.py这将自动下载并安装pip。3. 检查环境变量配置确保python和pip的路径已添加到系统的环境变量中：Windows:右键点击“此电脑” -&gt; “属性” -&gt; “高级系统设置” -&gt; “环境变量”。在“系统变量”中找到Path，并添加 Python 和pip的安装路径（如C:\Python39\Scripts\和C:\Python39\）。macOS/Linux:编辑~/.bashrc或~/.zshrc文件，添加 Python 路径：exportPATH="$PATH:/usr/local/bin/python3"保存并运行：source~/.bashrc4. 重新安装 Python 并确保添加到 PATH如果问题依然存在，可以尝试重新安装 Python，并确保在安装过程中选择了“Add Python to PATH”选项：下载最新版 Python 安装程序：Python 官方下载运行安装程序，并勾选“Add Python to PATH”选项。安装完成后，检查 Python 和pip是否正常：python --version
pip --version5. 在虚拟环境中安装pip如果是在虚拟环境中遇到此错误，可以在虚拟环境中手动安装pip：python -m ensurepip或者在虚拟环境中运行：python -m pipinstall--upgrade pip6. 使用conda安装pip（如果使用 Anaconda）如果使用的是 Anaconda 管理 Python 环境，可以通过conda安装pip：condainstallpip确保pip已成功安装在对应的 Anaconda 环境中。总结ModuleNotFoundError: No module named 'pip'错误通常是由于pip模块未安装或路径配置错误引起的。通过手动安装pip、调整环境变量、检查 Python 安装完整性等方式可以有效解决问题。在使用虚拟环境时，确保在虚拟环境内也有pip的正确配置。通过上述方法可以快速解决pip模块找不到的问题。http://www.ppmy.cn/news/1540723.html相关文章STM32G4系列MCU的低功耗模式介绍目录 
概述 
1 认识低功耗模式 
1.1 低功耗模式的应用 
1.2 低功耗模式介绍 
2 低功耗模式的状态关系 
2.1 低功耗模式可能的转换状态图 
2.2 低功耗模式总结 
3 运行模式 
3.1 减慢系统时钟 
3.2 外围时钟门控 
3.3 低功耗运行模式&amp;#xff08;LP运行&amp;#xff09; 概述 
本文主…阅读更多...在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:46 +0000</pubDate>
    </item>
    <item>
      <title>STM32G4系列MCU的低功耗模式介绍</title>
      <link>https://www.ppmy.cn/news/1540722.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维STM32G4系列MCU的低功耗模式介绍news/2025/10/31 21:30:44/目录概述1 认识低功耗模式1.1 低功耗模式的应用1.2 低功耗模式介绍2 低功耗模式的状态关系2.1 低功耗模式可能的转换状态图2.2 低功耗模式总结3 运行模式3.1 减慢系统时钟3.2 外围时钟门控3.3 低功耗运行模式（LP运行）概述本文主要介绍STM32G4系列MCU的低功耗模式的相关内容，包括低功耗的运行状态机，时钟关系，运行模块等内容。1 认识低功耗模式1.1 低功耗模式的应用默认情况下，微控制器在系统复位或电源复位后处于运行模式。当CPU不需要保持运行时，例如等待外部事件时，可以使用几种 低功耗模式来节省电源。这是由用户选择 模式，给出了低功耗，短启动时间 和可用的唤醒源之间的最佳折衷。1.2 低功耗模式介绍该设备具有7种低功耗模式：1）休眠模式：CPU时钟关闭，所有外设包括Cortex®-M4与FPU核心外设，如NVIC， SysTick等可以运行，并在中断或事件发生时唤醒CPU。2）低功耗运行模式：当CPU时钟频率降低到2mhz以下时，支持该模式。代码从SRAM或闪存执行。稳压器处于低功率模式，以最小化稳压器的工作电流。3）低功耗睡眠模式：从低功耗运行模式进入：Cortex®-M4 带FPU关机4）停止0和停止1模式：SRAM和所有寄存器内容保留。所有的时钟都在停止VCORE域，禁用PLL、HSI16和HSE。LSI和LSE可以保持运行。RTC和stamp可以保持活动状态（有RTC的停止模式，没有RTC的停止模式）。一些具有唤醒能力的外设可以在Stop 模式期间启用HSI16 RC来检测它们的唤醒状态。在停止0模式下：主调节器保持ON，这允许最快的唤醒时间 但消耗更高。活动外设和唤醒源与停止1模式下的 相同。当从停止0或停止1模式退出时：系统时钟为HSI16时钟。如果将设备配置为在低功耗运行模式下唤醒，则必须在进入停止模式之前配置RCC_CFGR 寄存器中的HPRE位，以提供不大于2Hz 的频率。5）Standby模式：表示VCORE域处于下电状态。然而，它是有可能保存的 SRAM内容:1) 当位RRS在PWR_CR3寄存器中设置时，具有SRAM2保留的备用模式。在这种情况下，SRAM2由低功耗稳压器提供。2) 当PWR_CR3寄存器中的位RRS被清除时，进入待机模式。在这种情况下，主稳压器和低功率稳压器断电。VCORE域中的所有时钟都停止，锁相环、HSI16和HSE振荡器 被禁用。LSI和LSE可以保持运行。 RTC可以保持激活状态（有RTC的备用模式，没有RTC的备用模式）。当退出Standby模式时，系统时钟为HSI16振荡时钟。6）关机模式：表示VCORE域下电。VCORE域中所有时钟停止，PLL、HSI16、LSI和HSE关闭。伦敦证交所可以继续运转。退出Shutdown模式时，系统时钟为HSI16振荡时钟。 在这种模式下，电源电压监测功能被关闭，当电源电压下降时，产品的行为不能得到保证。另外，运行模式下的功耗可以通过以下 方式降低：1) 减慢系统时钟2) 当APB和AHB外设未使用时，对时钟进行门控。2 低功耗模式的状态关系2.1 低功耗模式可能的转换状态图2.2 低功耗模式总结3 运行模式3.1 减慢系统时钟在运行模式下，系统时钟（SYSCLK， HCLK， PCLK）的速度可以通过 编程预分频寄存器来降低。这些预缩放器也可用于在进入睡眠模式之前减慢 外设的速度。3.2 外围时钟门控在运行模式下，单个外设和存储器的HCLK和PCLK可以随时停止 以降低功耗。 为了进一步降低睡眠模式下的功耗，可以在执行WFI或WFE指令之前 禁用外围时钟。 外围时钟门控由RCC_AHBxENR和RCC_APBxENR 寄存器控制。 通过重置 RCC_AHBxSMENR和RCC_APBxSMENR寄存器中的相应位，可以自动执行休眠模式下禁用外设时钟。3.3 低功耗运行模式（LP运行）为了进一步降低系统在运行模式下的功耗，可以将稳压器配置为 低功耗模式。在此模式下，CPU主频不能超过2M Hz。 有关稳压器和外设的详细信息请参阅产品数据表 工作条件。http://www.ppmy.cn/news/1540722.html相关文章在掌控板上搭建http服务器在掌控板上搭建http服务器 
打开Arduino IDE&amp;#xff0c;并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤&amp;#xff1a; 包含必要的库&amp;#xff1a; #include &lt;WiFi.h&gt;
#include &lt;WebServer.h&gt;配置WiFi&amp;#xff1a; 替换ssid和password为你的WiFi网…阅读更多...【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:44 +0000</pubDate>
    </item>
    <item>
      <title>在掌控板上搭建http服务器</title>
      <link>https://www.ppmy.cn/news/1540721.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维在掌控板上搭建http服务器news/2025/10/31 21:30:43/在掌控板上搭建http服务器打开Arduino IDE，并且已经添加了ESP32的支持库。以下是创建一个基本HTTP服务器的步骤：包含必要的库：#include&lt;WiFi.h&gt;#include&lt;WebServer.h&gt;配置WiFi：替换ssid和password为你的WiFi网络名称和密码。constchar*ssid="your_SSID";constchar*password="your_PASSWORD";初始化Web服务器：创建一个监听80端口的Web服务器实例。WebServerserver(80);定义处理函数：为不同的URL路径定义处理函数。例如，当用户访问根目录时的处理函数。voidhandleRoot(){server.send(200,"text/html","&lt;h1&gt;Welcome to32 Web Server&lt;/h1&gt;");}设置路由：在setup()函数中，设置路由和启动服务器。voidsetup(){Serial.begin(115200);WiFi.begin(ssid,password);// 等待WiFi连接while(WiFi.status()!=WL_CONNECTED){delay(500);Serial.print(".");}// 打印ESP32的IP地址Serial.println("");Serial.println("WiFi connected.");Serial.println("IP address: ");Serial.println(WiFi.localIP());// 定义根目录的处理函数server.on("/",handleRoot);// 启动服务器server.begin();Serial.println("HTTP server started.");}处理客户端请求：在loop()函数中，不断处理客户端的请求。voidloop(){server.handleClient();}上传代码到ESP32：使用Arduino IDE上传代码到你的ESP32开发板。访问HTTP服务器：打开浏览器，输入ESP32的IP地址（你可以通过串口监视器查看），你将看到由你的HTTP服务器返回的欢迎信息。完整的代码如下#include&lt;WiFi.h&gt;#include&lt;WebServer.h&gt;constchar*ssid="your_SSID";#将your_SSID替换成使用的wifi的SSIDconstchar*password="your_PASSWORD";#将your_PASSWORD替换成使用的wifi的密码
WebServerserver(80);voidhandleRoot(){server.send(200,"text/html","&lt;h1&gt;Welcome to ESP32 Web Server&lt;/h1&gt;");}voidsetup(){Serial.begin(115200);WiFi.begin(ssid,password);// 等待WiFi连接while(WiFi.status()!=WL_CONNECTED){delay(500);Serial.print(".");}// 打印ESP32的IP地址Serial.println("");Serial.println("WiFi connected.");Serial.println("IP address: ");Serial.println(WiFi.localIP());// 定义根目录的处理函数server.on("/",handleRoot);// 启动服务器server.begin();Serial.println("HTTP server started.");}voidloop(){server.handleClient();}运行结果将代码编译上传后，打开Arduino IDE的串口监视器，可以看到连接WiFi的过程，并打印出esp32 http服务器所在的IP地址，如图1所示。图1 连接wifi的过程使用浏览器连接esp32 http服务器，运行结果如下：图2 使用浏览器登陆esp32 http服务器http://www.ppmy.cn/news/1540721.html相关文章【02】RabbitMQ客户端应用开发实战1、RabbitMQ基础编程模型 
RabbitMQ提供了很多种主流编程语言的客户端支持&amp;#xff0c;这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现&amp;#xff0c;下面就以此为基础&amp;#xff0c;了解RabbitMQ客户端开发的基础流程。 
1.1 Maven依赖 amqp是一种…阅读更多...设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:43 +0000</pubDate>
    </item>
    <item>
      <title>【02】RabbitMQ客户端应用开发实战</title>
      <link>https://www.ppmy.cn/news/1540720.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【02】RabbitMQ客户端应用开发实战news/2025/10/31 21:30:42/1、RabbitMQ基础编程模型RabbitMQ提供了很多种主流编程语言的客户端支持，这里只分析Java语言的客户端。在上一章节提供了一个简单的RabbitMQ的客户端的实现，下面就以此为基础，了解RabbitMQ客户端开发的基础流程。1.1 Maven依赖amqp是一种标准的消息驱动实现协议，RabbitMQ是对这一协议的具体实现。由于协议具有稳定性，所以，通常RabbitMQ的客户端不一定要求与服务端版本一致。&lt;dependency&gt;&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;&lt;version&gt;5.21.0&lt;/version&gt;&lt;/dependency&gt;1.2 基础编程模型结合上个案例，详细拆解每个核心概念的具体实现方式以及功能扩展。1.2.1 step1：首先创建连接，获取Channel通常情况下，我们在客户端中都只是创建一个Channel就可以了。因为一个Channel只要不关闭，是可以一直复用的。但是，如果你想要创建多个Channel，就要注意Channel冲突的问题。在创建Channel时，可以在createChannel()方法中传入一个分配Int类型的参数channelNumber。这个参数就会作为Channel的唯一标识，而RabbitMQ为了防止ChannelNumber重复的方式是：如果对应的Channel没有创建过，就会创建一个新的Channel。如果已经创建过了，这时机会返回一个null。ConnectionFactoryfactory=newConnectionFactory();factory.setHost("192.168.121.134");factory.setPort(5672);factory.setUsername("admin");factory.setPassword("admin");factory.setVirtualHost("/master");//建立连接Connectionconnection=factory.newConnection();//创建信道Channelchannel=connection.createChannel();1.2.2 step2：声明Exchange交换机关键代码：channel.exchangeDeclare(Stringexchange,Stringtype,booleandurable,booleanautoDelete,Map&lt;String,Object&gt;arguments)throwsIOException;api说明：exchange：设置交换机的名称；type：交换机的类型；durable：是否持久化（交换机在服务重启后仍然有效）；autoDelete：是否自动删除（如果服务器不再使用是否自动删除该交换机）；arguments：交换机的其他属性（构造参数）；在声明Exchange时需要注意，如果Broker（消息队列服务器实体）上没有对应的Exchange，那么RabbitMQ会自动创建一个新的交换机。如果Broker上已经存在这个Exchange，那么你声明这个交换机的参数时必须要与Broker上的Exchange参数保持一致，如果不一致就会报错；声明时的大部分参数在管理平台是可以看到的：重点需要关注的是Exchange的类型，它共有四种类型，分别对应了四种不同的消息分发逻辑。1.2.3 step3：声明Queue关键代码：channel.queueDeclare(Stringqueue,booleandurable,booleanexclusive,booleanautoDelete,Map&lt;String,Object&gt;arguments);api说明：queue：设置队列的名称；durable：是否持久化（服务器重启后队列仍然有效）；exclusive：是否独占（仅限于此连接）；autoDelete：是否自动删除（服务器不再使用时自动删除）；arguments：队列的其他属性（构造参数）；与Exchange一样，如果你声明的Queue在Broker上不存在，RabbitMQ会创建一个新的队列。但是如果Broker上已经有了这个队列，那么声明的属性必须和Broker上的队列保持一致，否则也会报错。声明Queue时，同样大部分的参数是可以从管理平台看到的：Durablility表示是否持久化。Durable选项表示会将队列的消息写入硬盘，这样服务重启后这些消息就不会丢失。而另外一个选项Transient表示不持久化，消息只在内存中流转。这样服务重启后这些消息就会丢失。当然这也意味着消息读写的效率会比较高。但是与Exchange不同的是，在管理控制台上，队列有个Type参数，这个参数并没有在API中体现。这里是有历史版本的原因的，也有不同类型的队列实现方式不同的原因。例如：对于Quorum和Stream类型，根本没有Durability参数，因为它们的消息默认就是必须要持久化的。客户端API中默认只能声明Classic类型的队列。如果需要声明其他类型的队列，只能通过后面的arguments参数来区分。如果要声明一个Quorum队列，则只需要在后面的arguments中传入一个参数，x-queue-type，参数值设定为quorum。Map&lt;String,Object&gt;params=newHashMap&lt;&gt;();params.put("x-queue-type","quorum");//声明Quorum队列的方式就是添加一个x-queue-type参数，指定为quorum。默认是classicchannel.queueDeclare(QUEUE_NAME,true,false,false,params);//需要注意的是：对于Quorum类型，durable参数必须是true，设置成false的话，会报错。同样，exclusive参数必须设置为false如果要声明一个Stream队列，则x-queue-type参数要设置为streamMap&lt;String,Object&gt;params=newHashMap&lt;&gt;();params.put("x-queue-type","stream");params.put("x-max-length-bytes",20_000_000_000L);// maximum stream size: 20 GBparams.put("x-stream-max-segment-size-bytes",100_000_000);// size of segment files: 100 MBchannel.queueDeclare(QUEUE_NAME,true,false,false,params);//需要注意的是：1、同样，durable参数必须是true，exclusive必须是false。 对于这两种队列，这两个参数是不可以选择的。2、x-max-length-bytes 表示日志文件的最大字节数。x-stream-max-segment-size-bytes 每一个日志文件的最大大小。这两个是可选参数，通常为了防止stream日志无限制累计，都会配合stream队列一起声明。3、stream类型的对列，并不能像之前两种对列一样使用。例如前两种对列类型，声明消费者后，可以从控制台直接发消息，消费者端就能接受到。 但是Stream类型是接收不到的实际项目中用得最多的是RabbitMQ的Classic经典队列，但是从RabbitMQ官网就能看到， 目前RabbitMQ更推荐的是使用Quorum队列。至于Stream队列目前企业用得还比较少。1.2.4 step4：声明Exchange与Queue的绑定关系关键代码：channel.queueBind(Stringqueue,Stringexchange,StringroutingKey)throwsIOException;api说明：queue：需要绑定的队列的名称；exchange：需要绑定的交换机的名称；routingKey：用于绑定的路由key；如果我们声明了Exchange和Queue，那么就还需要声明它们之间的绑定关系Binding。有了Binding绑定关系，Exchange才可以知道Producer发送过来的消息将要分发到哪些Queue上。这些Binding涉及到消息的不同分发逻辑，与Exchange和Queue一样，如果Broker上没有建立绑定关系，那么RabbitMQ会按照客户端的声明，创建这些绑定关系。但是如果声明的Binding存在了，那么就需要与Broker上的保持一致。另外，在声明Binding时，还可以传入两个参数，routingKey和props。这两个参数都是跟Exchange的消息分发逻辑有关。1.2.5 step5：Producer根据应用场景发送消息到queue关键代码：channel.basicPublish(Stringexchange,StringroutingKey,BasicPropertiesprops,message.getBytes("UTF-8"));api说明：exchange：要发送到某个交换机的名称；routingKey：路由key；props：支持消息的其他属性；message：消息正文；这其中Exchange如果不需要，传个空字符串就行。routingKey跟Exchange的消息分发逻辑有关。关于props参数，可以传入一些消息相关的属性。管理控制台上有明确的说明:props的这些配置项，可以用RabbitMQ中提供的一个Builder对象来构建:AMQP.BasicProperties.Builderbuilder=newAMQP.BasicProperties.Builder();//对应页面上的Properties部分，传入一些预定的参数值。builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());//builder.headers(headers);对应页面上的Headers部分。传入自定义的参数值builder.build()AMQP.BasicPropertiesprop=builder.build();在发送消息时要注意一下消息的持久化问题。MessageProperties.PERSISTENT_TEXT_PLAIN是RabbitMQ提供的持久化消息的默认配置。而RabbitMQ中消息是否持久化不光取决于消息，还取决于Queue。通常为了保证消息安全，会将Queue和消息同时声明为持久化。1.2.6 step6：Consumer消费消息定义消费者，对消息进行处理，并向RabbitMQ进行消息确认。确认了之后就表明这个消息已经消费完了，否则RabbitMQ还会继续发起重试。Consumer主要有两种消费方式：&lt;1&gt;Push 推模式Consumer等待rabbitMQ 服务器将message推送过来再消费。一般是启一个一直挂起的线程来等待。关键代码：channel.basicConsume(Stringqueue,booleanautoAck,Consumercallback);api说明：使用服务器生成的consumerTag启动一个非本地的、非独占的消费者。queue：队列名称;autoAck：是否自动确认消息已被消费（如果服务器认为消息一经发送就被确认则为true；如果服务器期望显式确认，则为false）;callback：回调函数（封装了消费者对消息处理的业务逻辑）；&lt;2&gt;Pull 拉模式Comsumer主动到rabbitMQ服务器上去拉取messge进行消费。关键代码：GetResponseresponse=channel.basicGet(QUEUE_NAME,booleanautoAck);api说明：queue：队列名称；autoAck：是否自动应答；其中需要注意点的是autoAck，自动应答。Consumer处理完一条消息后，需要给Broker一个Ack应答，Broker就不会重复投递消息。如果Broker没有收到应答，就会重复投递消息。实际开发中，更建议使用Push推模式，这样消息处理能够比较及时，并且也不会给服务端带来重复查询的压力。1.2.7 step7：完成之后关闭连接，释放资源用完之后主动释放资源。如果不主动释放的话，大部分情况下，过一段时间RabbitMQ也会将这些资源释放掉，但是这就需要额外消耗系统资源。channel.close();conection.clouse();最后给出完整生产者发送消息的代码处理过程：publicclassCallbackProducer{privatestaticfinalStringEXCHANGE_NAME="testExchange1";privatestaticfinalStringALTER_EXCHANGE_NAME="testAlterExchange1";privatestaticfinalStringQUEUE_NAME="testQueue1";publicstaticvoidmain(String[]args)throwsException{Connectionconnection=RabbitMQUtil.getConnection();Channelchannel=connection.createChannel();//给交换机添加一个备用交换机，如果发往EXCHANGE_NAME的消息无法路由，就会转发到ALTER_EXCHANGE_NAME上。Map&lt;String,Object&gt;params=newHashMap&lt;&gt;();params.put("alternate-exchange",ALTER_EXCHANGE_NAME);channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,params);channel.exchangeDeclare(ALTER_EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,null);channel.queueDeclare(QUEUE_NAME,true,false,false,null);channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"key1");channel.confirmSelect();//如果发往Exchange的消息无法路由，就会给Producer一个通知，触发ReturnListener。channel.addConfirmListener(newConfirmListener(){@OverridepublicvoidhandleAck(longdeliveryTag,booleanmultiple)throwsIOException{System.out.println("message acked; deliveryTag = "+deliveryTag);}@OverridepublicvoidhandleNack(longdeliveryTag,booleanmultiple)throwsIOException{System.out.println("message Nacked; deliveryTag = "+deliveryTag);}});channel.addReturnListener(newReturnListener(){@OverridepublicvoidhandleReturn(intreplyCode,StringreplyText,Stringexchange,StringroutingKey,AMQP.BasicPropertiesproperties,byte[]body)throwsIOException{System.out.println("message returned replayCode = "+replyCode+";replyText:"+replyText+"; message = "+newString(body)+";props = "+properties);}});AMQP.BasicProperties.Builderbuilder=newAMQP.BasicProperties.Builder();builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());builder.correlationId("111");Stringmessage="correlationId=1,asdfasdfas";//发送两条消息， routingkey为key2的消息没有队列接收，就会触发return callbackchannel.basicPublish(EXCHANGE_NAME,"key1",true,builder.build(),message.getBytes(StandardCharsets.UTF_8));channel.basicPublish(EXCHANGE_NAME,"key2",true,builder.build(),message.getBytes(StandardCharsets.UTF_8));System.out.println("message sended");//不要立即结束，这样才能接收到服务端的回调。Thread.sleep(10000);channel.close();connection.close();}}1.3 关于消息监听与回溯前面只是列出了用得最多的几个常用的方法。但是，RabbitMQ的客户端还提供了很多重载方法和扩展方法，这些需要自行掌握。例如，在消费消息时，channel还提供了一个重载的方法：StringbasicConsume(Stringqueue,DeliverCallbackdeliverCallback,//消息传递时的回调CancelCallbackcancelCallback,//消费者被取消时的回调ConsumerShutdownSignalCallbackshutdownSignalCallback//通道/连接关闭时的回调)throwsIOException;另外，自己再做一个小案例：ConnectionFactoryfactory=newConnectionFactory();factory.setHost(HOST_NAME);factory.setPort(HOST_PORT);factory.setUsername(USER_NAME);factory.setPassword(PASSWORD);factory.setVirtualHost(VIRTUAL_HOST);//建立连接Connectionconnection=factory.newConnection();Channelchannel=connection.createChannel();Map&lt;String,Object&gt;params=newHashMap&lt;&gt;();params.put("alternate-exchange",ALTER_EXCHANGE_NAME);channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,params);channel.exchangeDeclare(ALTER_EXCHANGE_NAME,BuiltinExchangeType.DIRECT,true,false,null);channel.queueDeclare(QUEUE_NAME,true,false,false,null);channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,"key1");channel.basicConsume(QUEUE_NAME,newDeliverCallback(){//正常消息传递的处理逻辑@Overridepublicvoidhandle(StringconsumerTag,Deliverymessage)throwsIOException{longdeliveryTag=message.getEnvelope().getDeliveryTag();StringcorrelationId=message.getProperties().getCorrelationId();System.out.println("收到消息的consumerTag: "+consumerTag+"\n 收到的消息message: "+newString(message.getBody())+";deliveryTag: "+deliveryTag+";correlationId: "+correlationId);channel.basicAck(deliveryTag,false);}}//消费者被取消的处理逻辑，例如：去控制台把队列删掉就会触发cancel,newCancelCallback(){@Overridepublicvoidhandle(StringconsumerTag){System.out.println("取消消息的consumerTag: "+consumerTag+"; ");}}//通道或者连接被断开的时候的处理逻辑，例如：突然关闭连接、关闭通道,newConsumerShutdownSignalCallback(){@OverridepublicvoidhandleShutdownSignal(StringconsumerTag,ShutdownSignalExceptionsig){System.out.println("消费者宕机的consumerTag: "+consumerTag+"\n Exception: "+sig);}});上述过程中的consumerTag代表的是与客户端的一个会话，deliveryTag代表的是这个Channel处理的一条消息。这都是RabbitMQ服务器分配的一些内部参数。日后，如果你希望对Consumer处理的每一条消息增加溯源功能时，把consumerTag+deliveryTag作为消息编号，保存下来，这就是一个不错的设计。2、RabbitMQ常用的消息场景这一部分是学习以及使用RabbitMQ的重中之重。RabbitMQ的客户端API使用是比较简单的，但是如果面临复杂业务时，要用好RabbitMQ还是需要一些功力的。对这一部分的学习，理解业务场景是最为重要的。RabbitMQ官方提供了总共七种典型的使用场景：2.1 hello world 体验最直接的方式，P端发送一个消息到一个指定的队列，中间不需要任何exchange规则。C端按队列方式进行消费。关键代码：生产者：channel.queueDeclare(QUEUE_NAME,false,false,false,null);channel.basicPublish("",QUEUE_NAME,null,message.getBytes("UTF-8"));消费者：channel.queueDeclare(QUEUE_NAME,false,false,false,null);channel.basicConsume(QUEUE_NAME,true,Consumercallback);2.2 Work Queues 工作序列这是RabbitMQ最基础也是最常用的一种工作机制。工作任务模式，领导部署一个任务，由下面的一个员工来处理。只关心任务被正确处理，不关心给谁处理。Producer消息发送给queue，多个Consumer同时往队列上消费消息。关键代码：producer: 将消息直接发送到Queue上//任务一般是不能因为消息中间件的服务而被耽误的，所以durable设置成了true，这样，即使rabbitMQ服务断了，这个消息也不会消失channel.queueDeclare(TASK_QUEUE_NAME,true,false,false,null);channel.basicPublish("",TASK_QUEUE_NAME,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes("UTF-8"));consumer: 每次拉取一条消息channel.queueDeclare(TASK_QUEUE_NAME,true,false,false,null);channel.basicQos(1);channel.basicConsume(TASK_QUEUE_NAME,false,consumer);这个模式应该是最常用的模式，有几个问题需要注意：&lt;1&gt;：Consumer对每个消息必须应答消费端每消费完一个消息就需要给服务端一个ACK应答，这个应答可以自动应答也可以手动应答。如果消费者对某个消息消费完后一直没有给服务端应答，那么服务端会不断地将这条消息重复进行投递，这就会不断地消耗系统资源。这也就是 Poison Message (毒消息)。这是使用RabbitMQ时易犯的一个错误。&lt;2&gt;：RabbitMQ并不能完全保证消息安全非常关键的message消息不能因为服务器出现问题而就被忽略了。如果想要保证消息不被丢失，在RabbitMQ中需要同时将队列和消息的durable属性都设置成true。但是，官方也明确说了，就算把队列和消息都持久化，RabbitMQ也并不能保证消息完全不丢失。因为，RabbitMQ对于持久化的消息，会写入到文件当中。但此时，只是写入到了PageCache缓存中，而不是磁盘。缓存中的数据断电就丢失。消息从缓存写入磁盘，需要进行一次刷盘。RabbitMQ并不会对每个消息都执行刷盘操作，而且执行该操作也是有一定的时间间隔的，因此，如果服务器异常断电，RabbitMQ在这个层面是可能面临消息丢失的问题的。&lt;3&gt;：消息如何在多个Consumer之间分发这里，RabbitMQ默认是采用的fair dispatch，也叫round-robin模式，就是把消息轮询，在所有consumer中轮流发送。这种方式，没有考虑消息处理的复杂度以及consumer的处理能力。而他们改进后的方案，是consumer可以向服务器声明一个prefetchCount，我把他叫做预处理能力值。channel.basicQos(prefetchCount);表示当前这个consumer可以同时处理几个message。这样服务器在进行消息发送前，会检查这个consumer当前正在处理中的message(message已经发送，但是未收到consumer的basicAck)有几个，如果超过了这个consumer节点的能力值，就不再往这个consumer发布。 这种模式，官方也指出还是有问题的，消息有可能全部阻塞，所有consumer节点都超过了能力值，那消息就阻塞在服务器上，这时需要自己及时发现这个问题，采取措施，比如增加consumer节点或者其他策略;2.3 Publish/Subscribe 发布/订阅 机制type为 ‘fanout’ 的交换机：这个机制是对上面的一种补充。也就是把Producer与Consumer进行进一步的解耦。producer只负责发送消息，至于消息进入哪个queue，由exchange来分配。如上图，就是把producer发送的消息，交由exchange同时发送到两个queue里，然后由不同的Consumer去进行消费。关键代码：binding：将消费的目标队列绑定到Exchange交换机上。channel.exchangeDeclare(EXCHANGE_NAME,"fanout");StringqueueName=channel.queueDeclare().getQueue();channel.queueBind(queueName,EXCHANGE_NAME,"");producer: 只负责往exchange里发消息，后面的事情不管。channel.exchangeDeclare(EXCHANGE_NAME,"fanout");channel.basicPublish(EXCHANGE_NAME,"",null,message.getBytes("UTF-8"));关键所在：就是type为”fanout” 的exchange，这种类型的exchange只负责往所有已绑定的队列上发送消息。2.4 Routing 基于内容的路由type为 ‘direct’ 的交换机：在上一章 exchange 往所有队列发送消息的基础上，增加一个路由配置，指定exchange如何将不同类别的消息分发到不同的queue上。关键代码：Producer 同样是往Exchange发送消息，但是需要指定一个routingKeychannel.exchangeDeclare(EXCHANGE_NAME,"direct");channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes("UTF-8"));Bindings 在建立Exchange和Queue的绑定关系时，需要指定routingKey。channel.exchangeDeclare(EXCHANGE_NAME,"direct");channel.queueBind(queueName,EXCHANGE_NAME,routingKey1);channel.queueBind(queueName,EXCHANGE_NAME,routingKey2);channel.basicConsume(queueName,true,consumer);消息就会根据routingkey转发到对应的Queue上，然后给消费者处理。2.5 Topics 基于话题的路由type为 ‘topic’ 的exchange：这个模式也就在Routing模式的基础上，对routingKey进行了模糊匹配。单词之间用 ‘,’ 隔开，‘*’ 代表一个具体的单词，‘#’ 代表0个或多个单词。关键代码：Producer，依然是往Exchange发送消息，并且需要带上routingKey。channel.exchangeDeclare(EXCHANGE_NAME,"topic");channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes("UTF-8"));Bindings: 绑定routingKey。channel.exchangeDeclare(EXCHANGE_NAME,"topic");channel.queueBind(queueName,EXCHANGE_NAME,routingKey1);channel.queueBind(queueName,EXCHANGE_NAME,routingKey2);channel.basicConsume(queueName,true,consumer);消息根据routingKey进行转发时，会进行模糊匹配。2.6 Publisher Confirms 发送者消息确认RabbitMQ的消息可靠性是非常高的，但是他以往的机制都是保证消息发送到了MQ之后，可以推送到消费者消费，不会丢失消息。但是发送者发送消息是否成功是没有保证的。我们可以回顾下，发送者发送消息的基础API：channel.basicPublish方法是没有返回值的，也就是说，一次发送消息是否成功，应用是不知道的，这在业务上就容易造成消息丢失。而这个模块就是通过给发送者提供一些确认机制，来保证这个消息发送的过程是成功的。发送者确认模式默认是不开启的，所以如果需要开启发送者确认模式，需要手动在channel中进行声明。channel.confirmSelect();在官网的示例中，重点解释了三种策略：&lt;1&gt;发布单条消息即：每当发布一条消息就确认一次。核心代码如下：channel.confirmSelect();for(inti=0;i&lt;MESSAGE_COUNT;i++){Stringbody=String.valueOf(i);channel.basicPublish("",queue,null,body.getBytes());channel.waitForConfirmsOrDie(5_000);}channel.waitForConfirmsOrDie(5_000); 这个方法就会在channel端等待RabbitMQ给出一个响应，用来表明这个消息已经正确发送到了RabbitMQ服务端。但是要注意，这个方法会同步阻塞channel，在等待确认期间，channel将不能再继续发送消息，也就是说会明显降低集群的发送速度即吞吐量。官方说明了，其实channel底层是异步工作的，会将channel阻塞住，然后异步等待服务端发送一个确认消息，才解除阻塞。但是我们在使用时，可以把他当作一个同步工具来看待。然后如果到了超时时间，还没有收到服务端的确认机制，那就会抛出异常。然后通常处理这个异常的方式是记录错误日志或者尝试重发消息，但是尝试重发时一定要注意不要使程序陷入死循环。&lt;2&gt;发送批量消息之前单条确认的机制会对系统的吞吐量造成很大的影响，所以稍微中和一点的方式就是发送一批消息后，再一起确认。核心代码如下：intbatchSize=100;intoutstandingMessageCount=0;for(inti=0;i&lt;MESSAGE_COUNT;i++){Stringbody=String.valueOf(i);ch.basicPublish("",queue,null,body.getBytes());outstandingMessageCount++;if(outstandingMessageCount==batchSize){ch.waitForConfirmsOrDie(5_000);outstandingMessageCount=0;}}if(outstandingMessageCount&gt;0){ch.waitForConfirmsOrDie(5_000);}这种方式可以稍微缓解下发送者确认模式对吞吐量的影响。但是也有个固有的问题就是，当确认出现异常时，发送者只能知道是这一批消息出问题了， 而无法确认具体是哪一条消息出了问题。所以接下来就需要增加一个机制能够具体对每一条发送出错的消息进行处理。&lt;3&gt;异步确认消息实现的方式也比较简单，Producer在channel中注册监听器来对消息进行确认。ch.confirmSelect();ConcurrentNavigableMap&lt;Long,String&gt;outstandingConfirms=newConcurrentSkipListMap&lt;&gt;();ConfirmCallbackcleanOutstandingConfirms=(sequenceNumber,multiple)-&gt;{if(multiple){ConcurrentNavigableMap&lt;Long,String&gt;confirmed=outstandingConfirms.headMap(sequenceNumber,true);confirmed.clear();}else{outstandingConfirms.remove(sequenceNumber);}};ch.addConfirmListener(cleanOutstandingConfirms,(sequenceNumber,multiple)-&gt;{Stringbody=outstandingConfirms.get(sequenceNumber);System.err.format("Message with body %s has been nack-ed. Sequence number: %d, multiple: %b%n",body,sequenceNumber,multiple);cleanOutstandingConfirms.handle(sequenceNumber,multiple);});这里注册了两个监听器，是因为：执行成功一个，执行失败一个；然后关于这个ConfirmCallback，这是个监听器接口，里面只有一个方法：void handle(long sequenceNumber, boolean multiple) throws IOException; 这方法中的两个参数:sequenceNumer：这个是一个唯一的序列号，代表一个唯一的消息。在RabbitMQ中，他的消息体只是一个二进制数组，默认消息是没有序列号的。那么在回调的时候，Producer怎么知道是哪一条消息成功或者失败呢？RabbitMQ提供了一个方法int sequenceNumber = channel.getNextPublishSeqNo(); 来生成一个全局递增的序列号，这个序列号将会分配给新发送的那一条消息。然后应用程序需要自己来将这个序列号与消息对应起来。multiple：这个是一个Boolean型的参数。如果是false，就表示这一次只确认了当前一条消息。如果是true，就表示RabbitMQ这一次确认了一批消息，在sequenceNumber之前的所有消息都已经确认完成了。&lt;4&gt;三种确认机制的区别这三种确认机制都能够提升Producer发送消息的安全性。通常情况下，第三种异步确认机制的性能是最好的。实际上，在当前版本中，Publisher不光可以确认消息是否到了Exchange，还可以确认消息是否从Exchange成功路由到了Queue。在Channel中可以添加一个ReturnListener。这个ReturnListener就会监控到这一部分发送成功了，但是无法被Consumer消费到的消息。那接下来，更进一步，这部分消息要如何处理呢？还记得在Web控制台声明Exchange交换机的时候，还可以添加一个属性吗？是的。当前版本在Exchange交换机中可以添加一个属性alternate-exchange。这个属性可以指向另一个Exchange。其作用，就是将这些无法正常路由的消息转到另外的Exchange进行兜底处理。2.7 Headers 头部路由机制这种策略在实际中用得比较少，但是在某些比较特殊的业务场景，还是挺好用的。官网示例中的集中路由策略， direct,fanout,topic等这些Exchange，都是以routingkey为关键字来进行消息路由的，但是这些Exchange有一个普遍的局限就是都是只支持一个字符串的形式，而不支持其他形式。Headers类型的Exchange就是一种忽略routingKey的路由方式。他通过Headers来进行消息路由。这个headers是一个键值对，发送者可以在发送的时候定义一些键值对，接受者也可以在绑定时定义自己的键值对。当键值对匹配时，对应的消费者就能接收到消息。匹配的方式有两种，一种是all，表示需要所有的键值对都满足才行。另一种是any，表示只要满足其中一个键值就可以。在Consumer端，声明Queue与Exchange绑定关系时，可以增加声明headers，表明自己对哪些信息感兴趣。Map&lt;String,Object&gt;headers=newHashMap&lt;String,Object&gt;();headers.put("x-match","any");//x-match:特定的参数。all表示必须全部匹配才算成功。any表示只要匹配一个就算成功。headers.put("loglevel","info");headers.put("buslevel","product");headers.put("syslevel","admin");​Connectionconnection=RabbitMQUtil.getConnection();Channelchannel=connection.createChannel();channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.HEADERS);StringqueueName=channel.queueDeclare("ReceiverHeader",true,false,false,null).getQueue();channel.queueBind(queueName,EXCHANGE_NAME,routingKey,headers);在Producer端，发送消息时，带上消息的headers相关属性。publicclassEmitLogHeader{​privatestaticfinalStringEXCHANGE_NAME="logs";/*** exchange有四种类型， fanout topic headers direct* headers用得比较少，他是根据头信息来判断转发路由规则。头信息可以理解为一个Map* @param args* @throws Exception*/publicstaticvoidmain(String[]args)throwsException{// header模式不需要routingKey来转发，他是根据header里的信息来转发的。比如消费者可以只订阅logLevel=info的消息。// 然而，消息发送的API还是需要一个routingKey。// 如果使用header模式来转发消息，routingKey可以用来存放其他的业务消息，客户端接收时依然能接收到这个routingKey消息。StringroutingKey="ourTestRoutingKey";// The map for the headers.Map&lt;String,Object&gt;headers=newHashMap&lt;&gt;();headers.put("loglevel","error");headers.put("buslevel","product");headers.put("syslevel","admin");Stringmessage="LOG INFO asdfasdf";Connectionconnection=RabbitMQUtil.getConnection();Channelchannel=connection.createChannel();//发送者只管往exchange里发消息，而不用关心具体发到哪些queue里。channel.exchangeDeclare(EXCHANGE_NAME,BuiltinExchangeType.HEADERS);AMQP.BasicProperties.Builderbuilder=newAMQP.BasicProperties.Builder();builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());builder.headers(headers);​channel.basicPublish(EXCHANGE_NAME,routingKey,builder.build(),message.getBytes("UTF-8"));​channel.close();connection.close();}}Headers交换机的性能相对比较低，因此官方并不建议大规模使用这种交换机，也没有把他列入基础的示例当中。3、SpringBoot集成RabbitMQ3.1 引入依赖SpringBoot官方集成了RabbitMQ，只需要快速引入依赖包即可使用。RabbitMQ与SpringBoot集成的核心maven依赖就下面一个：&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;3.2 配置关键参数基础的运行环境参数以及生产者的一些默认属性配置都集中到了application.yml配置文件中。所有配置项都以spring.rabbitmq开头。spring:rabbitmq:host:192.168.137.120port:5672username:adminpassword:123456virtual-host:/connection-timeout:6000003.3 声明Exchange、Queue和Binding所有的exchange, queue, binding的配置，都需要以对象的方式声明。默认情况下，这些业务对象一经声明，应用就会自动到RabbitMQ上常见对应的业务对象。但是也是可以配置成绑定已有业务对象的。3.4 使用RabbitmqTemplate对象发送消息生产者的所有属性都已经在application.properties配置文件中进行配置。项目启动时，就会在Spring容器中初始化一个RabbitmqTemplate对象，然后所有的发送消息操作都通过这个对象来进行。3.5 使用@RabbitListener注解声明消费者消费者都是通过@RabbitListener注解来声明。在@RabbitMQListener注解中包含了非常多对Queue进行定制的属性，大部分的属性都是有默认值的。例如ackMode默认是null，就表示自动应答。在日常开发过程中，通常都会简化业务模型，让消费者只要绑定队列消费即可。使用SpringBoot框架集成RabbitMQ后，开发过程可以得到很大的简化，所以使用过程并不难，对照一下示例就能很快上手。但是，需要理解一下的是，SpringBoot集成后的RabbitMQ中的很多概念，虽然都能跟原生API对应上，但是这些模型中间都是做了转换的，比如Message，就不是原生RabbitMQ中的消息了。使用SpringBoot框架，尤其需要加深对RabbitMQ原生API的理解，这样才能以不变应万变，深入理解各种看起来简单，但是其实坑很多的各种对象声明方式。http://www.ppmy.cn/news/1540720.html相关文章设备ESD防静电监控仪助力自动化产线设备稳定运行在现代自动化生产线中&amp;#xff0c;设备的稳定运行至关重要。而静电放电&amp;#xff08;ESD&amp;#xff09;常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率&amp;#xff0c;更可能造成潜在的…阅读更多...华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:42 +0000</pubDate>
    </item>
    <item>
      <title>设备ESD防静电监控仪助力自动化产线设备稳定运行</title>
      <link>https://www.ppmy.cn/news/1540719.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维设备ESD防静电监控仪助力自动化产线设备稳定运行news/2025/10/31 21:30:41/在现代自动化生产线中，设备的稳定运行至关重要。而静电放电（ESD）常常是导致这些问题的隐患之一。许多企业在生产管理中面临着设备接地状况不明、漏电检测困难、人工点检耗时巨大的难题。这些问题不仅影响生产效率，更可能造成潜在的安全风险和经济损失。传统的设备接地和漏电检测方法往往依赖于人工巡检，这种方式费时费力，效率低下，且难以保证检测的全面性和准确性。工作人员需要花费大量时间进行人工点检，这不仅增加了人力成本，而且容易出现人为疏漏，导致潜在的静电危害被忽视。  更重要的是，人工检测难以及时发现隐蔽的接地不良或漏电问题，直到出现严重故障才被察觉，这时造成的损失往往是巨大的。针对这些痛点，我们推出了这款先进的设备ESD防静电监控仪。它采用电流式阻值监控原理，能够准确、可靠地检测设备接地情况，并实时监测接地回路的电阻值。不同于传统方法的被动检测，该监控仪主动监控，能够及时发现并预警潜在的静电危害。  其提供的多通道选择（双路、四路、八路），满足不同规模生产线的监控需求，灵活部署，覆盖范围广。该监控仪的核心优势在于其一站式解决方案：硬件和软件的完美结合。硬件部分负责精准采集数据，而配套的软件则提供直观的数据显示和分析，并支持远程监控和数据管理。 通过软件，用户可以实时查看所有设备的接地状态和电阻值，及时掌握生产线的整体运行状况。  这使得问题排查更加高效，大大缩短了停机时间，提高了生产效率。为了满足不同场景下的应用需求，该监控仪提供了多种通信模式：RS485有线通信和RF433/LoRa无线通信。  RS485有线通信适用于对通信稳定性要求较高的场合，而RF433/LoRa无线通信则能够解决有线布线困难的问题，尤其适合空间布局复杂的自动化生产线。 用户可以根据实际情况选择合适的通信模式，灵活安装和部署。为了及时提醒用户注意潜在的危险，该监控仪还具备完善的告警机制。 它既可以通过输出接口驱动外接提示装置（如警灯），也可以依靠内置蜂鸣器发出声光报警。 当静电仪监测到异常情况，例如接地不良或漏电，它会立即发出警报，提醒工作人员及时处理，防止事故发生。  这种主动预警机制，有效降低了静电危害带来的风险。设备ESD防静电监控仪为自动化产线提供了全面的静电防护解决方案。 它通过精准的检测、灵活的通信方式和及时的告警机制，有效解决了设备接地不稳定、漏电难以检测和人工点检耗时等难题，保障了自动化产线设备的稳定运行，提升了生产效率，降低了安全风险，为企业创造更大的经济效益。【XF】http://www.ppmy.cn/news/1540719.html相关文章华为OD机试2024年真题（基站维修工程师）基站维修工程师&amp;#xff08;200分&amp;#xff09; 
小王是一名基站维护工程师&amp;#xff0c;负责某区域的基站维护。 某地方有n个基站(1&lt;n&lt;10)&amp;#xff0c;已知各基站之间的距离s(0&lt;s&lt;500)&amp;#xff0c;并且基站x到基站y的距离&amp;#xff0c;与基站y到基站x的距离并不一定会…阅读更多...Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:41 +0000</pubDate>
    </item>
    <item>
      <title>华为OD机试2024年真题（基站维修工程师）</title>
      <link>https://www.ppmy.cn/news/1540718.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维华为OD机试2024年真题（基站维修工程师）news/2025/10/31 21:30:39/基站维修工程师（200分）小王是一名基站维护工程师，负责某区域的基站维护。某地方有n个基站(1&lt;n&lt;10)，已知各基站之间的距离s(0&lt;s&lt;500)，并且基站x到基站y的距离，与基站y到基站x的距离并不一定会相同。小王从基站1出发，途径每个基站1次，然后返回基站1，需要请你为他选择一条距离最短的路线。&gt;&gt;输入描述站点数n和各站点之间的距离(均为整数)。如:3 {站点数}
0 2 1 {站点1到各站点的路程)
1 0 2 (站点2到各站点的路程}
2 1 0 {站点3到各站点的路程}&gt;&gt;输出描述最短路程的数值&gt;&gt;示例1输入3
0 2 1
1 0 2
2 1 0输出3思路：目标是解决典型的旅行商问题（TSP, Travelling Salesman Problem），即在一个给定的城市网络中，找到一条从起点城市出发，经过每个城市一次并最终返回起点的路径，使得路径的总距离最短。算法使用了递归（深度优先搜索）结合状态标记来遍历所有可能的路径，并通过回溯法不断比较最短路径。输入：给定一个 size x size 的二维数组 arr，其中 arr[i][j] 表示城市 i 到城市 j 的距离。输出：求解从城市0出发，经过每个城市一次并返回的最短路径长度。步骤:数据输入：读取城市数 size 和城市之间的距离矩阵 arr。递归函数 recur：递归尝试从一个城市访问未访问过的下一个城市，记录当前路径长度，并使用状态数组 st 标记某个城市是否已经访问过。状态回溯：递归探索完某条路径后，返回上一步，尝试其他未访问过的城市，最终比较得到最短路径。结果输出：输出所有路径中的最小总距离。代码段如下：package com.rich.huawei.od_test;import java.util.Scanner;/*** @description* @Title Test01* @Author tang rui qi* @Date 2024/10/14 5:17*/
public class Test03 {static int res; // 用于保存最短路径的总距离// 递归函数// u: 当前访问的第几个城市// pre: 上一个访问的城市编号// temRes: 当前路径的总距离// size: 城市的总数// arr: 城市之间的距离矩阵// st: 访问状态数组，标记某个城市是否被访问过static void recur(int u, int pre, int temRes, int size, int[][] arr, boolean[] st) {// 如果已经访问完所有城市并回到起点城市if (u == size - 1) {// 将当前路径的总距离与最小距离进行比较，更新最小距离res = Math.min(res, temRes + arr[pre][0]);return;}// 遍历每个城市，寻找下一个未访问过的城市for (int i = 1; i &lt; size; ++i) {if (st[i]) { // 如果该城市已被访问，则跳过continue;}st[i] = true; // 标记该城市为已访问// 递归访问下一个城市，并累加当前路径的距离recur(u + 1, i, temRes + arr[pre][i], size, arr, st);st[i] = false; // 回溯时将该城市重置为未访问状态}}public static void main(String[] args) {Scanner cin = new Scanner(System.in);int size = cin.nextInt(); // 读取城市的总数res = 0x3f3f3f3f; // 初始化最短路径为一个很大的值int[][] arr = new int[size][size]; // 城市之间的距离矩阵boolean[] st = new boolean[size]; // 访问状态数组// 读取距离矩阵的值for (int x = 0; x &lt; size; ++x)for (int y = 0; y &lt; size; ++y) arr[x][y] = cin.nextInt();// 从城市0开始递归搜索recur(0, 0, 0, size, arr, st);// 输出最短路径的总距离System.out.println(res);}}http://www.ppmy.cn/news/1540718.html相关文章Git推送被拒今天开发完成一个新的需求&amp;#xff0c;将自己的分支合并到test分支后&amp;#xff0c;推送到远程仓库&amp;#xff0c;结果显示推送被拒&amp;#xff1a;  
原因是因为有人更新了test分支的代码&amp;#xff0c;我在合并之前没有拉取最新的test分支代码&amp;#xff0c;所以他提示我“推送前需要合并…阅读更多...java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:39 +0000</pubDate>
    </item>
    <item>
      <title>Git推送被拒</title>
      <link>https://www.ppmy.cn/news/1540717.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Git推送被拒news/2025/10/31 21:30:38/今天开发完成一个新的需求，将自己的分支合并到test分支后，推送到远程仓库，结果显示推送被拒：原因是因为有人更新了test分支的代码，我在合并之前没有拉取最新的test分支代码，所以他提示我“推送前需要合并远程更改”，我们点击合并后，就相当于帮我们合并了最新更新的代码到我们要推送的test分支中，这样test分支中除了我们自己更新的代码之外的其他代码才与远程仓库中的代码一致，才能推送成功。所以我们要养成一个好习惯，合并之前拉取一下最新的代码，确保除了我们自己修改的部分以外的其他代码都和远程仓库保持一致再合并，合并过程中如果发现冲突，那就解决完冲突后再合并。http://www.ppmy.cn/news/1540717.html相关文章java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)这是什么系统&amp;#xff1f; 
资源获取方式再最下方 
java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频) 
基于Java的飞机大战游戏是一款经典的射击类游戏&amp;#xff0c;主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方…阅读更多...LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:38 +0000</pubDate>
    </item>
    <item>
      <title>java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)</title>
      <link>https://www.ppmy.cn/news/1540716.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)news/2025/10/31 21:30:37/这是什么系统？资源获取方式再最下方java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)基于Java的飞机大战游戏是一款经典的射击类游戏，主要包含我方飞机、敌方飞机、子弹、特殊NPC、开始背景、结束背景以及背景音乐等元素。我方飞机可以随意移动，敌方飞机无规律出现。游戏玩家通过鼠标移动控制飞机移动，我方飞机在游戏开始时就一直能发射子弹，当我方子弹碰到敌方飞机时，敌方飞机消失。当玩家飞机碰到敌方子弹时，生命值减一，直到玩家飞机生命值为一时，游戏结束。基本模块包括：游戏状态控制功能模块、游戏难度的调整模块、游戏界面绘画功能模块、玩家游戏控制功能模块等。功能模块：1.游戏状态控制功能模块：负责游戏的运行和结束状态的控制。在游戏进行中，玩家需要躲避或击落敌方飞机，当玩家飞机的生命值降为零时，弹出游戏结束界面。2.游戏难度调整模块：随着玩家游戏时间的增加，游戏难度逐渐提高。敌方飞机的数量和出现频率会增加，使得玩家保证飞机存活的难度加大，操作难度相应提高。3.游戏界面绘画功能模块：左上角显示玩家飞机当前生命值、游戏时间和当前分数，其他区域用于展示玩家对我方飞机的控制和敌方飞机的动作。4.玩家游戏控制功能模块：玩家可以通过鼠标或键盘来控制我方飞机（Hero Airplane）的移动。设计需要考虑的几个细节方面：在游戏中，绘图美化是一个重要的难点，需要参考原始的游戏画面，使敌我飞机的形象更加美丽。此外，多线程技术的实现也是关键，它能够实现游戏的控制和资源的加载，以实现整个游戏的自动控制。防碰撞问题的解决也是一个重要的考虑因素，需要根据不同情况采用不同的防碰撞检测方法。最后，动画的实现也是游戏中不可或缺的一部分，通过图片阵列和动画切片变换形成图像阵列，达到爆炸效果。以下是部分功能的界面截图（详细的请看最下面的全部功能截图）：我们提供什么？1.软件对应的安装包；2.项目导入视频+功能介绍视频；3.课设-论设的基础参考文章；4.源代码（数据库+项目）。我们系统到底有哪些功能？功能模块：1.游戏状态控制功能模块：负责游戏的运行和结束状态的控制。在游戏进行中，玩家需要躲避或击落敌方飞机，当玩家飞机的生命值降为零时，弹出游戏结束界面。2.游戏难度调整模块：随着玩家游戏时间的增加，游戏难度逐渐提高。敌方飞机的数量和出现频率会增加，使得玩家保证飞机存活的难度加大，操作难度相应提高。3.游戏界面绘画功能模块：左上角显示玩家飞机当前生命值、游戏时间和当前分数，其他区域用于展示玩家对我方飞机的控制和敌方飞机的动作。4.玩家游戏控制功能模块：玩家可以通过鼠标或键盘来控制我方飞机（Hero Airplane）的移动。设计需要考虑的几个细节方面：在游戏中，绘图美化是一个重要的难点，需要参考原始的游戏画面，使敌我飞机的形象更加美丽。此外，多线程技术的实现也是关键，它能够实现游戏的控制和资源的加载，以实现整个游戏的自动控制。防碰撞问题的解决也是一个重要的考虑因素，需要根据不同情况采用不同的防碰撞检测方法。最后，动画的实现也是游戏中不可或缺的一部分，通过图片阵列和动画切片变换形成图像阵列，达到爆炸效果。各个模块的功能实现截图：如何获取资源呢？方式1：java计算机毕设课设-飞机大战游戏(附源码、文章、相关截图、部署视频)资源-CSDN文库方式2：java计算机毕设课设—飞机大战游戏(附源码、文章、相关截图、部署视频)项目视频辅助讲解链接：java计算机毕设课设-飞机大战游戏(附源码、文章、相关截图、部署视频)_哔哩哔哩_bilibili​http://www.ppmy.cn/news/1540716.html相关文章LabVIEW提高开发效率技巧----VI继承与重载在LabVIEW开发中&amp;#xff0c;继承和重载是面向对象编程&amp;#xff08;OOP&amp;#xff09;中的重要概念。通过合理运用继承与重载&amp;#xff0c;不仅能提高代码的复用性和灵活性&amp;#xff0c;还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载&amp;#xff0c;并…阅读更多...analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:37 +0000</pubDate>
    </item>
    <item>
      <title>LabVIEW提高开发效率技巧----VI继承与重载</title>
      <link>https://www.ppmy.cn/news/1540715.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维LabVIEW提高开发效率技巧----VI继承与重载news/2025/10/31 21:30:36/在LabVIEW开发中，继承和重载是面向对象编程（OOP）中的重要概念。通过合理运用继承与重载，不仅能提高代码的复用性和灵活性，还能减少开发时间和维护成本。下面从多个角度介绍如何在LabVIEW中使用继承和重载，并结合实际例子说明其在项目中的应用。一、LabVIEW面向对象编程（OOP）简介LabVIEW自从引入面向对象编程后，允许开发者使用**类、继承、动态分发（Dynamic Dispatch）**等特性。OOP使得代码模块化、灵活性增强，适合大型项目开发。主要概念包括：类（Class）：封装数据和功能的模板。继承（Inheritance）：子类可以继承父类的属性和方法，增强代码重用性。重载（Overriding）：子类可以根据具体需求重写父类的方法，实现更灵活的功能。​二、继承与重载的意义与优势1.提高代码复用性继承允许我们在子类中复用父类的代码，避免重复编写相同功能。例如，如果你开发了一套测试系统，父类可以包含一些通用功能，如数据采集、信号处理等，子类可以继承这些功能并在需要时进行拓展。2.增强代码灵活性通过重载，子类可以根据具体需求修改或扩展父类的方法，而无需改变父类本身的代码。这种动态分发机制（Dynamic Dispatch）允许在运行时根据对象的类型选择不同的实现。三、具体应用示例1.继承与重载的基础应用假设你有一个通用的设备控制类DeviceControl.lvclass，其中包含一个通用的启动设备方法StartDevice.vi，实现设备启动功能。如果你要控制不同类型的设备，可以创建多个子类，例如MotorControl.lvclass和PumpControl.lvclass，并在这些子类中重载StartDevice.vi。每个子类根据不同设备的特性，实现设备启动的具体逻辑。在调用时，可以使用动态分发技术，通过父类指针调用不同设备的启动功能，灵活应对多种设备。2.利用继承和重载实现模块化开发继承与重载也可以用于模块化开发，特别是在复杂的测试或自动化系统中。以下是一个基于继承的温度控制系统的设计：父类：TemperatureController.lvclass包含通用的温度读取、设定值调整等功能。子类1：WaterHeaterController.lvclass重载父类的温度控制逻辑，适用于加热水的设备。子类2：RoomHeaterController.lvclass重载父类的方法，实现房间取暖设备的特殊控制逻辑。通过这种设计，无论控制水加热还是房间取暖，均可通过继承复用通用功能，而具体控制逻辑则由各个子类实现。四、继承与重载的实战技巧1.合理规划类的层次结构设计时应避免类层次结构过深，通常建议不超过三层，以免增加系统复杂性。父类应该只包含通用功能，子类才负责具体实现。这样既能保持代码清晰，也方便后期维护和扩展。2.重载方法时确保一致性在重载父类方法时，应确保子类的方法参数和返回值与父类保持一致，以避免接口不匹配的问题。这在LabVIEW的类继承中非常重要。3.使用动态分发LabVIEW的动态分发允许我们根据实际对象的类型调用相应的子类方法。这不仅提高了系统的灵活性，还减少了手动切换代码路径的繁琐操作。例如，控制系统中可以通过父类对象调用不同子类的控制方法，而无需手动判断设备类型，大幅提高了代码的灵活性和扩展性。五、实际案例分享假设你在开发一个多传感器数据采集系统，要求支持不同传感器（温度、压力、流量）的数据读取和处理。通过创建一个通用的Sensor.lvclass父类，定义ReadData.vi和ProcessData.vi两个通用方法，子类可以分别为不同的传感器重载这两个方法。父类：Sensor.lvclass方法1：ReadData.vi(读取传感器数据)方法2：ProcessData.vi(处理传感器数据)子类1：TemperatureSensor.lvclass重载方法：ReadData.vi(读取温度数据)重载方法：ProcessData.vi(温度数据处理)子类2：PressureSensor.lvclass重载方法：ReadData.vi(读取压力数据)重载方法：ProcessData.vi(压力数据处理)这种继承与重载的方式，极大提高了开发效率，方便后期添加新传感器时不影响已有代码。六、总结继承与重载是LabVIEW面向对象编程中的核心技术。通过合理使用继承和重载，可以有效提高代码复用性、增强系统灵活性、减少开发与维护成本。在实际开发中，设计良好的类层次结构、合理使用动态分发，将会显著提升系统的扩展性与稳定性。http://www.ppmy.cn/news/1540715.html相关文章analysis-ik分词器analysis-ik分词器 1、安装离线在线 2、使用配置拓展词典 3、测试ik_smartik_max_word 1、安装 
离线 
使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效 
…阅读更多...使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:36 +0000</pubDate>
    </item>
    <item>
      <title>analysis-ik分词器</title>
      <link>https://www.ppmy.cn/news/1540714.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维analysis-ik分词器news/2025/10/31 21:30:35/analysis-ik分词器1、安装离线在线2、使用配置拓展词典3、测试ik_smartik_max_word1、安装离线使用离线安装下载地址https://release.infinilabs.com/analysis-ik/stable/找到对应es版本的ik分词器、下载zip后放到/elasticsearch/plugins/ik文件夹下。重启es即可生效在线bin目录下执行脚本/elasticsearch/bin/elasticsearch-plugin install https://get.infini.cloud/elasticsearch/analysis-ik/es版本号（服务器能连通外网）2、使用参考官方地址：https://github.com/infinilabs/analysis-ik/blob/master/README.md配置ik_smart：最少切分模式。该模式会尽可能少地切分文本ik_max_word：最细粒度划分模式。该模式会尽可能多地切分文本，将文本中的每个可能的词语都切分curl-XPOST"http://localhost:9200/test/_mapping"-H'Content-Type: application/json'-d'{        "properties": {            "content": {                "type": "text",                "analyzer": "ik_max_word",                "search_analyzer": "ik_smart"            }        }}'参数说明将索引test的content字段类型为text设置为创建时使用ik_max_word创建相关索引、搜索时用ik_smart拓展词典elasticsearch/plugins/ik/config/IKAnalyzer.cfg.xml配置文件进行相关修改参考链接:扩展字典官网3、测试注意：已经建好索引ik_smartcurl-XPOST"http://localhost:9200/_analyze"-H'Content-Type: application/json'-d'{    "analyzer": "ik_smart",    "text": "中华人民共和国"  }'分词结果{"tokens":[{"token":"中华人民共和国","start_offset":0,"end_offset":7,"type":"CN_WORD","position":0}]}ik_max_wordcurl-XPOST"http://localhost:9200/_analyze"-H'Content-Type: application/json'-d'{    "analyzer": "ik_max_word",    "text": "中华人民共和国"  }'分词结果{"tokens":[{"token":"中华人民共和国","start_offset":0,"end_offset":7,"type":"CN_WORD","position":0},{"token":"中华人民","start_offset":0,"end_offset":4,"type":"CN_WORD","position":1},{"token":"中华","start_offset":0,"end_offset":2,"type":"CN_WORD","position":2},{"token":"华人","start_offset":1,"end_offset":3,"type":"CN_WORD","position":3},{"token":"人民共和国","start_offset":2,"end_offset":7,"type":"CN_WORD","position":4},{"token":"人民","start_offset":2,"end_offset":4,"type":"CN_WORD","position":5},{"token":"共和国","start_offset":4,"end_offset":7,"type":"CN_WORD","position":6},{"token":"共和","start_offset":4,"end_offset":6,"type":"CN_WORD","position":7},{"token":"国","start_offset":6,"end_offset":7,"type":"CN_CHAR","position":8}]}http://www.ppmy.cn/news/1540714.html相关文章使用Python-pptx轻松批量添加水印哈喽，大家好，我是木头左！ 本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。 
安装Python-pptx库 
确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装： 
pip install python-pptx创建一个简单的PPT文件 
在开始之前，需要创建…阅读更多...leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:35 +0000</pubDate>
    </item>
    <item>
      <title>使用Python-pptx轻松批量添加水印</title>
      <link>https://www.ppmy.cn/news/1540713.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维使用Python-pptx轻松批量添加水印news/2025/10/31 21:30:34/哈喽，大家好，我是木头左！本文将详细介绍如何使用Python-pptx库批量添加文字或图片水印到每张幻灯片上。安装Python-pptx库确保你已经安装了Python-pptx库。如果没有，可以使用以下命令进行安装：pipinstallpython-pptx创建一个简单的PPT文件在开始之前，需要创建一个包含一些幻灯片的PPT文件。这里使用Python-pptx库来创建一个简单的PPT文件：frompptximportPresentation# 创建一个PPT对象presentation=Presentation()http://www.ppmy.cn/news/1540713.html相关文章leetcode day1最小差值 
给你一个整数数组 nums&amp;#xff0c;和一个整数 k 。 
在一个操作中&amp;#xff0c;您可以选择 0 &lt; i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i]  x &amp;#xff0c;其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i &amp;#xff0c;最多 只能 应用…阅读更多...Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:34 +0000</pubDate>
    </item>
    <item>
      <title>leetcode day1</title>
      <link>https://www.ppmy.cn/news/1540712.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维leetcode day1news/2025/10/31 21:30:32/最小差值给你一个整数数组 nums，和一个整数 k 。在一个操作中，您可以选择 0 &lt;= i &lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的任意整数。对于每个索引 i ，最多 只能 应用 一次 此操作。nums 的 分数 是 nums 中最大和最小元素的差值。在对  nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。示例 1：输入：nums = [1], k = 0输出：0解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。示例 2：输入：nums = [0,10], k = 2输出：6解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。示例 3：输入：nums = [1,3,6], k = 3输出：0解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。提示：1 &lt;= nums.length &lt;= 1040 &lt;= nums[i] &lt;= 1040 &lt;= k &lt;= 104解题思路：先对数组排序1、考虑数组可变为相等数的情况，x为数组任意元素，x-min&lt;=k,max-x&lt;=k,这种情况满足即max-min&lt;=2*k，此时最低 分数=02、max-min&gt;2*k时，最低分数=max-k-(min+k)=max-min-2*k当x&lt;min+k时，x可以加一个比k小的数达到min+k当x&gt;max-k时，x可以减一个比k小的数达到max-kint cmp(const void *a,const void *b){return *(int*)a-*(int*)b;
}
int smallestRangeI(int* nums, int numsSize, int k) {qsort(nums,numsSize,sizeof(int),cmp);if(nums[numsSize-1]-nums[0]&lt;=2*k)return 0;else return nums[numsSize-1]-nums[0]-2*k;
}最接近的三数之和给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。示例 1：输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2)。示例 2：输入：nums = [0,0,0], target = 1输出：0解释：与 target 最接近的和是 0（0 + 0 + 0 = 0）。提示：3 &lt;= nums.length &lt;= 1000-1000 &lt;= nums[i] &lt;= 1000-104 &lt;= target &lt;= 104解题思路：利用三层循环会超时先枚举第一个元素，从[i+1,numsSize)的范围枚举j,k对应数如果 a+b+c≥target，那么就将 c指针左移一位；注意考虑指针的范围j&lt;k如果 a+b+c&lt;target，那么就将 b指针右移一位。int cmp(const void *a,const void *b){return *(int *)a-*(int *)b;
}
int threeSumClosest(int* nums, int numsSize, int target) {qsort(nums,numsSize,sizeof(int),cmp);int sum,close=1e7;for(int i=0;i&lt;numsSize;i++){int j=i+1,k=numsSize-1;if(i&gt;0&amp;&amp;nums[i]==nums[i-1])continue;while(j&lt;k){sum=nums[i]+nums[j]+nums[k];if(sum==target)return target;if(abs(sum-target)&lt;abs(close-target))close=sum;if(sum&gt;target){int k0=k-1;while(j&lt;k0&amp;&amp;nums[k0]==nums[k])k0--;k=k0;}else{int j0=j+1;while(j0&lt;k&amp;&amp;nums[j0]==nums[j])j0++;j=j0;}}}return close;
}http://www.ppmy.cn/news/1540712.html相关文章Python爬虫：获取数据的入门详解在互联网时代&amp;#xff0c;数据已成为最宝贵的资源之一。Python&amp;#xff0c;作为一种功能强大且易于学习的编程语言&amp;#xff0c;成为了数据获取和处理的理想工具。Python爬虫&amp;#xff0c;特别是&amp;#xff0c;允许我们从网页中自动提取大量数据&amp;#xff0c;为数据分析、机器学习、…阅读更多...基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:33 +0000</pubDate>
    </item>
    <item>
      <title>Python爬虫：获取数据的入门详解</title>
      <link>https://www.ppmy.cn/news/1540711.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python爬虫：获取数据的入门详解news/2025/10/31 21:30:31/在互联网时代，数据已成为最宝贵的资源之一。Python，作为一种功能强大且易于学习的编程语言，成为了数据获取和处理的理想工具。Python爬虫，特别是，允许我们从网页中自动提取大量数据，为数据分析、机器学习、研究和开发等多种应用提供了原材料。本文将为您提供一个Python爬虫的入门详解，包括关键技术和示例代码。为什么选择Python进行爬虫开发简洁的语法：Python的简洁语法使得编写爬虫变得容易，即使是初学者也能快速上手。强大的库支持：Python拥有丰富的库，如Requests、BeautifulSoup、Scrapy等，这些库简化了HTTP请求发送、HTML解析和数据提取的过程。社区支持：Python有一个活跃的社区，提供了大量的教程、工具和框架，为爬虫开发提供了强大的支持。Python爬虫的关键技术1. HTTP请求发送HTTP请求是爬虫的第一步。Python的Requests库是一个简单易用的HTTP客户端，可以方便地发送GET、POST请求。2. HTML解析获取到网页内容后，需要解析HTML以提取所需数据。BeautifulSoup是一个强大的库，可以解析HTML和XML文档，提取数据。3. 数据提取从解析后的HTML中提取所需数据，可能包括文本、链接、图片等。4. 数据存储提取的数据需要存储以便进一步分析。常见的存储方式包括保存到文件（如CSV、JSON）、数据库（如MySQL、MongoDB）等。示例代码：使用Python爬虫获取数据以下是一个使用Python的Requests和BeautifulSoup库获取网页标题的示例代码：import requests
from bs4 import BeautifulSoup# 目标网页URL
url = 'https://www.example.com'# 发送GET请求
response = requests.get(url)# 检查请求是否成功
if response.status_code == 200:# 使用BeautifulSoup解析HTMLsoup = BeautifulSoup(response.text, 'html.parser')# 提取网页标题title = soup.find('title').text# 打印标题print('网页标题:', title)
else:print('请求失败，状态码：', response.status_code)在这个示例中，我们向https://www.example.com发送了一个GET请求，然后使用BeautifulSoup解析了返回的HTML内容，最后提取并打印了网页的标题。注意事项遵守法律法规：在进行数据抓取时，遵守相关法律法规，尊重目标网站的robots.txt文件和使用条款。处理异常情况：网络请求可能会遇到各种异常，如网络错误、API限制等，需要编写相应的错误处理代码。数据安全：保护用户隐私，不得泄露敏感信息。结语Python爬虫是获取网络数据的强大工具，它可以自动化数据收集过程，为数据分析和研究提供支持。通过掌握Python爬虫技术，您可以轻松获取所需的数据，从而在数据驱动的决策中占据优势。无论您是数据分析师、研究人员还是开发者，Python爬虫都是您不可或缺的技能之一。http://www.ppmy.cn/news/1540711.html相关文章基于Springboot+Vue的资源分享系统（含源码数据库）1.开发环境 
开发系统:Windows10/11 架构模式:MVC/前后端分离 JDK版本: Java JDK1.8 开发工具:IDEA 数据库版本: mysql5.7或8.0 数据库可视化工具: navicat 服务器: SpringBoot自带 apache tomcat 主要技术: Java,Springboot,mybatis,mysql,vue 
2.视频演示地址 
3.功能 
这个系…阅读更多...Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:31 +0000</pubDate>
    </item>
    <item>
      <title>基于Springboot+Vue的资源分享系统（含源码数据库）</title>
      <link>https://www.ppmy.cn/news/1540710.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维基于Springboot+Vue的资源分享系统（含源码数据库）news/2025/10/31 21:30:30/1.开发环境开发系统:Windows10/11架构模式:MVC/前后端分离JDK版本: Java JDK1.8开发工具:IDEA数据库版本: mysql5.7或8.0数据库可视化工具: navicat服务器: SpringBoot自带 apache tomcat主要技术:Java,Springboot,mybatis,mysql,vue2.视频演示地址3.功能这个系统包括两种角色：管理员和用户。管理员负责全面管理，包括轮播图、用户、资源分类、资源分享区、资源信息和系统公告的增、删、改、查等功能。管理员还可以查看评论。用户主要功能包括查看资源信息和系统公告、管理个人收藏和发布的资源信息，也可以在资源分享区进行新增、查看和评论操作。管理员和用户都可以访问前端功能，用户的前端操作包括查看资源信息和系统公告，及参与资源分享区的活动。4.图片展示5.源码获取点击直达源码获取：源码获取传送门http://www.ppmy.cn/news/1540710.html相关文章Java入门知识点1.各种程序使用的开发语言&amp;#xff1a; 数据分析类&amp;#xff1a; 大数据&amp;#xff0c;云计算--pythonsql 科学计算--python 机器学习&amp;#xff0c;深度学习--python 应用开发类&amp;#xff1a; C/S架构&amp;#xff1a; 桌面应用开发--根据环境选择开发语言 移动端app--根据环境选择开发语…阅读更多...深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:30 +0000</pubDate>
    </item>
    <item>
      <title>Java入门知识点</title>
      <link>https://www.ppmy.cn/news/1540709.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java入门知识点news/2025/10/31 21:30:29/1.各种程序使用的开发语言：数据分析类：大数据，云计算--python+sql科学计算--python机器学习，深度学习--python应用开发类：C/S架构：桌面应用开发--根据环境选择开发语言移动端app--根据环境选择开发语言游戏开发--c#等B/S架构：web开发--java2.JDK基础概念和选择:JDKjdk，英文全称：java development kit， 翻译过来就是java开发工具包jdk包含哪几部分？1.开发工具-开发java的地方, 包含javac，java，jdb，jhat等开发工具2.JVM--java文件运行的地方，java虚拟机3.核心类库-java运行需要的一些函数库/依赖JREjre，英文全称：java runtime environment，翻译过来就是java运行环境jre包含哪几部分？1.运行工具-运行需要的工具, 包括java，jhat等运行工具2.JVM--java文件运行的地方，java虚拟机3.核心类库-java运行需要的一些函数库/依赖实际开发应该选用的jdk版本：企业开发一般使用稳定的jdk8和jdk11，其中jdk11较多1.稳定， 很成熟， 出现问题也可以有很多解决方案2.是jdk长期支持版本，java官方长期维护和支持扩展:什么是jdk长期支持版本？官方会定期维护的，保证jdk可用和稳定的jdk版本jdk长期支持版本：jdk8， 也就是jdk1.8， 这俩是一个版本jdk11，jdk17，jdk213.Windows常见CMD命令：c/d/e--切换盘符cd xx\yy\zz-切换文件地址dir--查看当前文件内容start-执行当前文件，感觉有点没用，因为直接输入名字，然后回车也行cd..--退回上级文件cd \--退回总目录cls--清屏exit--退出注意：table可以补齐内容4.注释:1.注释不参与编译，也不参与运行2.除了python和Ruby，其他的单行注释为//内容,多行注释为/*内容*/5.字面量类型：1.整型2.小数3.字符串，双引号4.字符，单引号5.布尔类型，true/false6.空,null6.进制表示:1.二进制:0b开头2.十进制:不加前缀3.八进制:0开头4.十六进制:0x开头http://www.ppmy.cn/news/1540709.html相关文章深入理解WebSocket协议原理、实现与应用1. 引言 
1.1 什么是WebSocket&amp;#xff1f; 
WebSocket是一种基于TCP的通信协议&amp;#xff0c;它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同&amp;#xff0c;WebSocket允许在一个单一的TCP连接上进行双向通信&amp;#xff0c;避免了每次通信都需要重新建立连接的开…阅读更多...pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:29 +0000</pubDate>
    </item>
    <item>
      <title>深入理解WebSocket协议原理、实现与应用</title>
      <link>https://www.ppmy.cn/news/1540708.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深入理解WebSocket协议原理、实现与应用news/2025/10/31 21:30:27/1. 引言1.1 什么是WebSocket？WebSocket是一种基于TCP的通信协议，它为客户端和服务器之间提供了全双工通信能力。与传统的HTTP协议不同，WebSocket允许在一个单一的TCP连接上进行双向通信，避免了每次通信都需要重新建立连接的开销。这种协议的设计初衷是为了优化实时性要求高的应用场景，例如在线聊天、实时数据更新、游戏互动等。WebSocket由IETF在RFC 6455中定义，并由W3C标准化，广泛应用于现代的Web开发中。它的核心优势是能够维持一个长时间有效的连接，在客户端和服务器之间即时交换数据，而不需要重复的握手和断开操作。1.2 WebSocket与HTTP的区别WebSocket和HTTP都是基于TCP协议的通信方式，但它们的工作原理和应用场景有显著的区别：连接方式：HTTP是无状态的，每次请求都需要建立新的连接，而WebSocket则是在完成一次HTTP握手后，升级为持久的TCP连接，允许后续的双向数据传输。通信模式：HTTP是请求-响应模式，客户端发起请求，服务器返回响应。WebSocket则支持双向通信，服务器可以随时向客户端推送数据，而不需要等待客户端请求。性能：HTTP的每次请求都涉及到建立和关闭TCP连接，增加了延迟和开销。WebSocket通过长连接减少了频繁的握手过程，从而提升了实时性和效率。数据传输：HTTP传输的是独立的消息，而WebSocket可以分片发送数据帧，更灵活和高效。总结来说，WebSocket适用于需要频繁通信和实时数据更新的场景，而HTTP更适合一次性的、独立的请求和响应。1.3 WebSocket的应用场景由于WebSocket的双向、持久连接特性，它在许多实时性要求高的应用场景中得到了广泛应用，常见的应用场景包括：在线聊天应用：WebSocket适用于构建即时通讯系统，能够实现消息的实时发送和接收，减少延迟，提升用户体验。实时数据更新：例如股票行情、体育比分、在线竞拍等需要频繁更新的数据，WebSocket能够在数据变化时即时推送给客户端，而不需要客户端主动轮询。在线游戏：在多人在线游戏中，WebSocket可以实现低延迟的实时数据交互，使得游戏体验更加流畅。物联网（IoT）：物联网设备通常需要与服务器保持长期的连接，WebSocket的轻量级长连接特性非常适合用于设备与云端的实时通信。协作工具：如多人在线文档编辑、代码协作等场景，通过WebSocket实现实时同步，让每个用户的操作都可以实时反映在其他用户的界面上。通过WebSocket，开发者可以轻松实现实时通信需求，大大提高应用的交互性和用户体验。2. WebSocket的基础概念2.1 WebSocket协议概述WebSocket是一种通信协议，设计用于在客户端和服务器之间建立持久的双向通信通道。它基于TCP协议，通过初始的HTTP握手来升级连接，实现后续的双向数据传输。WebSocket协议的最大优势在于减少了传统HTTP请求-响应模型中频繁的连接开销，使得数据可以在服务器和客户端之间实时、无阻碍地流动。WebSocket的通信过程以数据帧（Data Frame）为单位进行传输，每个数据帧包含了控制信息和有效载荷，可以是文本、二进制数据或控制帧。WebSocket协议规定了如何传输和处理这些数据帧，同时保持连接的有效性。WebSocket协议的核心特点如下：双向通信：服务器和客户端可以随时发送消息，打破了传统HTTP中客户端请求、服务器响应的单向通信模式。实时性：通过建立持久的连接，数据可以即时传输，适合需要频繁更新的场景。低开销：通过初始握手后升级为WebSocket协议，不再需要频繁的TCP连接创建与断开，减少了带宽和时间的消耗。2.2 WebSocket的连接与握手机制WebSocket连接的建立通过一次HTTP请求完成，称为“握手”（Handshake）。这一握手过程发生在客户端和服务器之间，用于将传统的HTTP连接升级为WebSocket连接。握手过程的关键步骤如下：客户端发起握手请求：客户端向服务器发送一个特殊的HTTP请求，其中包含一个Upgrade字段，表明客户端希望将该连接从HTTP协议升级为WebSocket协议。请求的关键部分包括：GET请求：客户端使用GET方法请求与WebSocket连接。Connection字段：值为Upgrade，指示连接要从HTTP升级。Upgrade字段：值为websocket，表示升级的目标协议。Sec-WebSocket-Key：随机生成的密钥，用于握手的安全性验证。Sec-WebSocket-Version：协议版本号，通常为13。例如，客户端请求可能如下：GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Version: 13服务器响应握手请求：服务器接收到握手请求后，确认请求是否有效，并返回一个包含101 Switching Protocols状态码的响应，表示协议升级成功。服务器的响应包括：HTTP 101状态码：表示协议切换成功。Upgrade字段：与客户端相同，表明升级为WebSocket协议。Sec-WebSocket-Accept：根据客户端的Sec-WebSocket-Key计算出的验证密钥，用于完成握手的安全性校验。服务器响应示例如下：HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=连接升级完成：握手完成后，HTTP连接升级为WebSocket连接，客户端和服务器可以通过这个持久的连接开始双向通信。2.3 双向通信与全双工原理WebSocket的一个重要特性是支持全双工通信，这意味着数据可以在客户端和服务器之间同时双向传输，而不需要像传统HTTP那样等待一方发送请求后另一方才进行响应。全双工通信允许客户端和服务器随时互相发送消息，服务器可以主动推送数据到客户端，客户端也可以随时向服务器发送消息。这种机制尤其适用于需要低延迟、实时交互的应用场景，如在线游戏、即时通讯、股票行情等。WebSocket中的数据帧传输是实现双向通信的关键：数据帧类型：WebSocket的数据分为不同类型的帧，包括文本帧、二进制帧、关闭帧、Ping帧和Pong帧。文本帧：传输UTF-8编码的文本数据。二进制帧：传输二进制数据。关闭帧：用于关闭WebSocket连接。Ping和Pong帧：用于保持连接的活跃性，类似于心跳机制。帧传输过程：WebSocket会将数据分成小块（帧），并按顺序传输。每个帧包含了头部信息和有效载荷，客户端和服务器通过解析帧来传输和接收消息。在通信过程中，双方可以同时发送和接收数据，而无需等待对方的操作完成，从而大大提高了通信效率。通过这种全双工的设计，WebSocket能够在客户端和服务器之间实现快速的、低延迟的通信，使得其在实时应用中具有显著的优势。3. WebSocket工作原理3.1 握手流程详解WebSocket的工作流程从握手开始，握手过程决定了WebSocket连接是否可以成功建立。握手实际上是一个HTTP请求，在此基础上将HTTP协议升级为WebSocket协议。3.1.1 客户端发起连接请求在WebSocket连接开始时，客户端会向服务器发起一个特殊的HTTP请求，这个请求的目标是将现有的HTTP连接升级为WebSocket连接。具体请求内容如下：GET方法：使用GET方法发起连接请求，指定目标URI。Upgrade字段：该字段的值为websocket，表明客户端希望将该连接升级为WebSocket协议。Connection字段：值为Upgrade，告知服务器此次请求是要升级连接。Sec-WebSocket-Key：客户端生成的一个随机Base64编码的字符串，用于服务器验证。Sec-WebSocket-Version：指定WebSocket协议的版本，通常为13。请求示例：GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 133.1.2 服务器应答服务器收到客户端的握手请求后，首先会检查请求是否有效。如果确认请求满足WebSocket协议的要求，服务器将返回一个响应来确认连接的升级。服务器的响应包含以下信息：101 Switching Protocols：HTTP状态码101，表示协议正在切换。Upgrade字段：与客户端一致，值为websocket，表示协议升级。Connection字段：与客户端一致，值为Upgrade。Sec-WebSocket-Accept：服务器根据客户端发送的Sec-WebSocket-Key和特定的算法生成验证密钥，以完成握手的安全性校验。这个密钥是通过将Sec-WebSocket-Key与一个常量字符串进行拼接，然后通过SHA-1哈希生成，再进行Base64编码得到的。应答示例：HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=3.1.3 连接升级一旦服务器返回了正确的应答，客户端就会确认连接的升级，之后HTTP连接正式转变为WebSocket连接。此时，握手过程完成，客户端和服务器可以通过这个持久的连接进行双向通信。握手的整个过程仅涉及一次HTTP请求和一次响应，因此非常高效。3.2 数据帧结构解析WebSocket通过数据帧进行数据传输，每次传输的数据都被封装为一个数据帧。数据帧是WebSocket协议中最核心的部分，理解帧的格式和类型对掌握WebSocket协议非常重要。3.2.1 帧格式每个WebSocket数据帧包含两个主要部分：帧头（Header）和有效载荷（Payload），帧头部分包含了控制信息，而有效载荷部分则是实际传输的数据。FIN：表示该数据帧是否是消息的最后一个帧，值为1表示结束，0表示后续还有帧。Opcode：标识该数据帧的类型，如文本帧、二进制帧等。常见的值为：0x1：文本帧（UTF-8编码）0x2：二进制帧0x8：关闭帧0x9：Ping帧0xA：Pong帧Mask：标识数据帧的有效载荷是否进行了掩码操作。客户端发送的帧必须带有掩码，而服务器发送的帧可以不带掩码。Payload Length：有效载荷的长度，值为7位或更多，具体取决于载荷的大小。Masking Key：如果Mask位为1，则这个字段存在，用于解码有效载荷数据。Payload Data：实际的数据部分。3.2.2 帧的类型（文本帧、二进制帧、控制帧）WebSocket数据帧可以分为三大类：文本帧、二进制帧和控制帧。不同类型的数据帧具有不同的用途。文本帧：用于传输UTF-8编码的文本数据，通常用于实时聊天等文本交互场景。二进制帧：用于传输二进制数据，如图像、音频等。控制帧：控制帧包括关闭帧、Ping帧和Pong帧，用于控制连接状态。关闭帧表示关闭连接，Ping和Pong帧则用于保持连接的活跃性（心跳机制）。3.3 保持连接与心跳机制在WebSocket的实际使用中，保持连接的稳定性非常重要，特别是在长时间没有数据传输的情况下，可能会因为网络设备或防火墙的空闲超时设置导致连接断开。因此，WebSocket设计了心跳机制，通过Ping和Pong帧来维持连接。Ping帧：客户端或服务器可以随时发送Ping帧，要求对方立即回应一个Pong帧。Ping帧用于检测连接是否仍然活跃，常用于空闲时段发送。Pong帧：当一方收到Ping帧时，会立即发送Pong帧作为回应。Pong帧也可以主动发送，类似于心跳消息。心跳机制的存在确保了WebSocket连接在长时间没有数据交换时仍然保持活跃状态，避免了连接的意外断开。通过上述机制，WebSocket不仅实现了高效的双向通信，还能在长时间的会话中保证连接的稳定性和实时性。4. WebSocket的安全性WebSocket虽然为客户端和服务器之间的双向通信提供了高效、低延迟的通道，但它也带来了一些潜在的安全问题。因此，在使用WebSocket时，了解并防范相关的安全隐患非常重要。4.1 WebSocket的安全隐患WebSocket的长连接和全双工通信特性带来了一些独特的安全挑战，常见的安全隐患包括：缺乏原生的安全验证机制：WebSocket本身不带有请求头中的身份验证机制，除非在握手时通过额外的手段（如使用cookie、token等）进行身份验证，否则可能会导致未经验证的连接。跨域请求风险：虽然WebSocket并不依赖同源策略，但仍然可能被恶意使用来进行跨域攻击。如果服务器没有正确配置跨域策略，攻击者可以利用WebSocket进行跨域通信并获取敏感数据。资源滥用：由于WebSocket是长连接，服务器资源在连接期间会一直占用，恶意用户可能会发起大量WebSocket连接，导致服务器资源耗尽，形成DoS（拒绝服务）攻击。数据劫持与篡改：由于WebSocket连接是持久的，如果在不加密的情况下传输数据，攻击者可能会通过中间人攻击（MITM）拦截并篡改通信数据。4.2 防止XSS和CSRF攻击WebSocket在与传统的HTTP通信中共享一些常见的安全威胁，例如XSS（跨站脚本攻击）和CSRF（跨站请求伪造）。为防止这些攻击，需要特别关注以下几点：XSS（跨站脚本攻击）XSS攻击通过在Web页面中插入恶意脚本，通常用于盗取用户的敏感信息或劫持会话。虽然WebSocket本身不直接执行JavaScript代码，但在传输数据时如果没有严格的输入验证，服务器或客户端可能会被恶意脚本注入，从而导致XSS攻击。防范措施：数据输入验证：所有进入WebSocket的数据必须经过严格的验证和消毒，以防止恶意代码的注入。使用内容安全策略（CSP）：CSP可以防止未经授权的脚本执行，减少XSS攻击的风险。HTML转义：确保任何从WebSocket传输的数据在插入到DOM时都被正确地转义，防止恶意代码执行。CSRF（跨站请求伪造）WebSocket在没有保护机制的情况下容易受到CSRF攻击。攻击者可以通过伪造请求，利用用户在另一网站的已登录身份发起WebSocket请求，进行未授权的操作。防范措施：同源策略检查：服务器应检查WebSocket连接的来源，确保只接受来自可信源的请求。Token验证：在建立WebSocket连接时，可以通过token等方式进行身份验证，确保请求来自合法的用户。使用CSRF防护机制：结合传统的HTTP请求防护措施，可以为WebSocket握手添加CSRF保护，确保每个请求都有唯一的、无法伪造的token。4.3 WebSocket的加密通信（WSS）为了保护WebSocket的通信数据不被窃听和篡改，可以通过使用加密的WebSocket（WSS）来实现安全传输。WSS类似于HTTPS，它在TCP和WebSocket之间增加了一层TLS（传输层安全协议），从而确保数据传输的保密性和完整性。WSS的优势：防止数据窃听：通过加密的TLS层，确保传输的数据在传输过程中不会被第三方窃取。防止数据篡改：通过加密校验，防止数据在传输过程中被篡改。身份验证：TLS证书可以用于验证服务器的身份，防止客户端连接到恶意的服务器。如何启用WSS：配置服务器：首先，需要在服务器上安装并配置TLS证书。常见的Web服务器如Nginx、Apache等都支持TLS证书的配置。修改WebSocket URL：在客户端，WebSocket的连接URL从ws://改为wss://，例如：letws=newWebSocket("wss://example.com/socket");处理证书验证：客户端在握手过程中会验证服务器的TLS证书，确保连接的安全性。WSS的实践场景：金融交易系统：在需要保护敏感信息（如交易数据、支付信息）的场景下，WSS是必不可少的加密通信手段。物联网（IoT）设备通信：在物联网设备与服务器进行通信时，WSS能够有效防止设备数据的泄露或篡改。企业内部通信：在企业的内部通信应用中，WSS可以确保内部数据的安全性，防止外部窃听和攻击。通过启用WSS和正确的安全策略，可以极大提升WebSocket应用的安全性，确保通信数据的私密性和完整性。在实现实时通信时，安全性和性能同等重要，因此建议在所有敏感数据传输的场景中都使用WSS。5. WebSocket与传统轮询、长连接对比WebSocket、传统轮询以及长轮询是解决客户端与服务器之间实时通信的常见方法。这三种方法在技术实现、性能开销和适用场景上各有不同，以下对它们进行详细的对比。5.1 传统HTTP轮询的不足HTTP轮询是最早的一种实现客户端和服务器之间通信的方式，它通过定期向服务器发送HTTP请求来获取最新的数据。这种方法简单易实现，但在实时性要求较高的场景中存在明显的不足。资源浪费：轮询意味着客户端定期发出请求，即使服务器没有新的数据，也会返回一个空的响应。这种行为在服务器端消耗了大量带宽和计算资源，同时客户端也需要不断发起请求。高延迟：由于客户端是定时发起请求（例如每隔几秒钟），用户在收到更新数据时会有一定的延迟，延迟的大小取决于轮询的频率。如果轮询间隔较大，数据的实时性就会受到影响；如果轮询间隔较小，则增加了服务器的负载和网络流量。无法实现推送：传统轮询方式是客户端主动请求，服务器无法主动向客户端推送数据。这导致服务器只能被动等待客户端的请求，限制了实时应用的效率。因此，虽然HTTP轮询非常直观和容易实现，但在实时性要求高的场景中（如聊天、股票行情、在线游戏等），其不足十分明显。5.2 长轮询与WebSocket的对比长轮询（Long Polling）是一种改进的轮询机制，试图在不增加请求频率的情况下减少轮询的资源消耗和延迟。客户端发起请求后，服务器会保持连接不立即返回响应，直到有数据可返回或超时。当响应返回后，客户端立即发起下一个请求。这种机制在一定程度上提高了效率，但与WebSocket相比，仍然存在诸多差异。连接的持久性：长轮询：每次客户端请求到服务器响应后，连接就会断开，下一次请求时需要重新建立连接。这会导致每次请求都有较高的网络开销。WebSocket：WebSocket在握手成功后建立的连接是持久的，服务器和客户端可以通过同一连接多次交互数据，无需每次重新建立连接。实时性：长轮询：虽然相比传统轮询减少了一些延迟，但仍然需要客户端轮询请求，数据的实时性依然有限。WebSocket：支持全双工通信，服务器可以随时向客户端推送数据，真正实现了低延迟的实时数据传输。资源占用：长轮询：长轮询虽然减少了请求次数，但每次请求结束后，仍然需要重新建立HTTP连接，并在每次轮询时占用资源，尤其是在高并发情况下，服务器负载会明显增加。WebSocket：通过一次握手建立持久连接，显著减少了连接开销，服务器端可以高效管理大量并发连接，并通过单一连接处理多次通信。复杂性：长轮询：实现相对简单，可以与现有的HTTP协议无缝集成。WebSocket：需要服务器支持WebSocket协议，且在某些网络设备（如防火墙、代理）上可能会有兼容性问题。5.3 WebSocket的优势相较于传统的轮询和长轮询，WebSocket具备明显的优势，尤其是在实时性和资源利用率方面。真正的全双工通信：WebSocket支持客户端和服务器之间的双向通信，服务器可以在任何时刻主动向客户端推送数据。这种双工通信使得WebSocket在实时性要求较高的场景中具有不可替代的优势，如在线聊天、实时数据更新等。减少连接开销：WebSocket只需要一次握手即可建立持久的连接，后续的数据传输都在同一连接上进行。这种方式避免了传统HTTP协议中频繁的连接建立和断开，大幅降低了资源开销，特别是在高并发场景下，WebSocket的性能优势更加明显。低延迟：由于WebSocket是持久连接，服务器可以在数据可用时立即推送给客户端，避免了轮询方式中定时请求带来的延迟。因此，在需要低延迟的应用场景中，WebSocket可以提供更优的用户体验。带宽节省：传统轮询和长轮询每次请求都会传输完整的HTTP头，而WebSocket连接一旦建立，后续的每次通信仅传输必要的数据信息，没有多余的HTTP头部信息，显著减少了带宽的占用。更灵活的数据传输：WebSocket不仅支持传输文本数据，还可以高效地传输二进制数据，这使得它在需要传输文件、图像、音视频等二进制数据的场景下表现更加出色。WebSocket相较于传统的HTTP轮询和长轮询具有更高效的连接管理和数据传输方式，特别是在实时性、双向通信和高并发情况下具有显著的性能优势。因此，WebSocket已成为实现实时通信的首选技术，在聊天系统、游戏、金融数据更新等场景中得到广泛应用。6. WebSocket的实现与应用WebSocket广泛应用于需要实时性和双向通信的场景，如在线聊天、股票行情、游戏等。通过WebSocket，客户端和服务器可以在一个持久连接中进行高效的数据传输。以下将详细介绍如何在前端和服务端实现WebSocket通信，并通过实践案例展示其应用场景。6.1 前端实现WebSocket通信前端可以通过WebSocket API方便地与服务器建立连接、发送和接收消息，并在合适的时机关闭连接。6.1.1 创建WebSocket连接在前端创建WebSocket连接非常简单，使用JavaScript可以通过WebSocket对象进行操作。创建连接的过程如下：// 创建WebSocket对象，并连接到服务器constws=newWebSocket('wss://example.com/socket');// 监听连接成功事件ws.onopen=()=&gt;{console.log('WebSocket 连接成功');};// 监听连接关闭事件ws.onclose=(event)=&gt;{console.log('WebSocket 连接关闭',event);};// 监听连接错误事件ws.onerror=(error)=&gt;{console.error('WebSocket 错误',error);};WebSocket构造函数接受WebSocket服务器的URL作为参数，通常使用wss://（加密连接）或ws://（不加密连接）协议。6.1.2 发送与接收消息WebSocket的一个核心功能是能够在客户端和服务器之间发送和接收消息。通过send方法，客户端可以发送数据到服务器，而通过监听onmessage事件，客户端可以接收服务器发送的数据。// 发送消息到服务器ws.send('Hello, Server!');// 监听来自服务器的消息ws.onmessage=(event)=&gt;{console.log('收到来自服务器的消息:',event.data);};WebSocket可以发送文本或二进制数据，具体数据格式取决于实际的应用需求。6.1.3 关闭连接在合适的时机关闭WebSocket连接有助于释放资源并保证应用的稳定性。关闭连接可以通过close方法来实现，或者在接收到服务器的关闭消息时自动关闭。// 主动关闭连接ws.close();// 监听连接关闭事件ws.onclose=(event)=&gt;{console.log('WebSocket 连接关闭',event);};关闭连接时可以传递状态码和关闭原因，帮助服务器或客户端了解连接关闭的详细原因。6.2 服务端实现WebSocket支持不同的服务器语言和框架提供了对WebSocket的支持。以下是使用Java和Node.js两种常见语言实现WebSocket服务器的示例。6.2.1 Java实现WebSocket在Java中，可以使用javax.websocket包来实现WebSocket支持。以下是一个简单的Java WebSocket服务器实现。importjavax.websocket.*;importjavax.websocket.server.ServerEndpoint;@ServerEndpoint("/websocket")publicclassWebSocketServer{@OnOpenpublicvoidonOpen(Sessionsession){System.out.println("连接已打开: "+session.getId());}@OnMessagepublicvoidonMessage(Stringmessage,Sessionsession){System.out.println("收到消息: "+message);session.getAsyncRemote().sendText("你好，客户端！");}@OnClosepublicvoidonClose(Sessionsession){System.out.println("连接已关闭: "+session.getId());}@OnErrorpublicvoidonError(Sessionsession,Throwablethrowable){System.out.println("发生错误: "+throwable.getMessage());}}在这个示例中，我们通过注解@ServerEndpoint定义了一个WebSocket服务器端点，该端点会监听来自客户端的连接和消息，并返回相应的响应。6.2.2 Node.js实现WebSocket在Node.js中，使用ws库可以非常方便地实现WebSocket服务器。以下是一个基本的Node.js WebSocket服务器示例：首先安装ws库：npminstallws然后实现WebSocket服务器：constWebSocket=require('ws');// 创建WebSocket服务器constwss=newWebSocket.Server({port:8080});// 监听客户端连接wss.on('connection',(ws)=&gt;{console.log('客户端已连接');// 监听消息事件ws.on('message',(message)=&gt;{console.log('收到消息:',message);ws.send('你好，客户端！');});// 监听关闭事件ws.on('close',()=&gt;{console.log('客户端已断开连接');});});这个Node.js服务器会在端口8080上监听WebSocket连接，并在收到客户端消息时进行响应。6.3 WebSocket在实时应用中的实践案例WebSocket因其高效、低延迟的通信特性，广泛应用于各种需要实时数据更新的场景中。以下是几个实践案例：6.3.1 在线聊天应用在即时通讯（如聊天应用）中，WebSocket是理想的解决方案。通过WebSocket，客户端和服务器可以进行实时的消息传递，用户可以在毫秒级的延迟内收到对方发送的消息。使用WebSocket还能减少传统轮询造成的资源浪费，提升系统的扩展能力。6.3.2 实时数据推送股票行情、体育比赛得分等应用都需要频繁推送数据给客户端。WebSocket允许服务器在数据发生变化时立即将新数据推送给所有连接的客户端，而不是依赖客户端轮询数据状态，从而大大降低了带宽使用和延迟。6.3.3 多人在线游戏在多人在线游戏中，实时性至关重要。WebSocket为游戏服务器与客户端提供了低延迟的通信通道，能够快速同步玩家之间的动作、状态和事件，保证了游戏的流畅性和互动性。6.3.4 实时协作工具在在线文档、白板等协作工具中，多个用户需要在同一个界面上协同工作。WebSocket可以实现每个用户的操作实时同步给其他用户，保证所有人看到的数据和状态一致，从而提升协作效率。WebSocket在前端和服务端的实现都较为简单，但其强大的双向通信能力使得它成为了许多实时应用的核心技术。通过前端与服务端的高效协同，WebSocket能够在各种需要实时性和低延迟的场景中提供卓越的性能。7. WebSocket的性能优化WebSocket在实时性要求高的应用场景中表现出色，但在大量并发连接或数据频繁传输的情况下，性能仍然需要优化。下面介绍几种常见的WebSocket性能优化技术，以提升握手速度、减少数据传输带宽，并有效管理大规模连接。7.1 减少握手延迟WebSocket连接的建立依赖于HTTP握手，尽管这一步骤只发生一次，但在高并发环境下，握手延迟可能影响系统的整体性能。以下是减少握手延迟的几种方式：使用HTTP/2或HTTP/3：HTTP/2和HTTP/3支持多路复用，能够在同一TCP连接上同时进行多个请求。通过这种方式，握手请求可以并行发送，从而减少等待时间并提升连接效率。启用连接池：对于短期频繁的WebSocket连接，可以通过连接池技术复用已有的TCP连接，避免频繁的握手过程。虽然WebSocket通常是长连接，但在某些特殊场景下，启用连接池可以降低连接建立的开销。优化网络延迟：选择靠近客户端的服务器位置，使用CDN（内容分发网络）等技术，减少握手过程中的网络延迟。负载均衡：当WebSocket服务部署在多个服务器上时，通过负载均衡技术可以将客户端连接分配到不同的服务器，避免单台服务器负载过高导致的延迟。7.2 数据压缩与传输优化WebSocket传输数据频繁且实时，如何在保证性能的前提下减少带宽消耗是优化的重要目标。以下是一些优化数据传输的常见技术：启用数据压缩：WebSocket支持Per-message Deflate扩展，通过压缩每一条消息的内容，显著减少传输的数据大小。客户端和服务器可以在握手阶段协商启用压缩扩展，从而在传输文本数据时节省带宽。例如，启用permessage-deflate扩展可以实现消息级别的压缩：Sec-WebSocket-Extensions: permessage-deflate减少帧开销：WebSocket的帧头较小，但每个数据帧仍然会带来一些开销。通过适当的策略减少数据帧的数量或合并多个小帧为一个大的数据帧，可以减少传输时的帧头开销。数据批量传输：如果在某些场景下可以接受稍微延迟的实时性，可以将数据进行批量合并后再通过WebSocket发送，这样可以减少小消息频繁发送导致的额外开销。尤其在数据更新较为频繁时，批量传输可以显著提高传输效率。合理选择帧类型：在二进制数据传输中，二进制帧（Binary Frame）通常比文本帧（Text Frame）更高效。因此，对于文件、图片等二进制数据的传输，优先选择二进制帧以降低数据量。7.3 大规模连接的管理与优化在大规模的WebSocket连接场景中（如实时聊天或在线游戏），管理成千上万的并发连接是一个巨大的挑战。以下几种策略有助于提升WebSocket在高并发下的稳定性和性能：使用事件驱动的非阻塞服务器：选择适合处理高并发连接的服务器框架（如Node.js、Netty等），这些框架基于事件驱动，能够更高效地处理大量WebSocket连接。与传统的线程池模型不同，非阻塞的事件驱动架构能够显著降低资源消耗。水平扩展（Scaling horizontally）：当单台服务器无法处理大量WebSocket连接时，可以通过水平扩展，将连接分布在多个服务器节点上。结合负载均衡（如Nginx、HAProxy等），可以实现WebSocket服务的分布式部署，处理大规模并发连接。状态同步与会话持久化：由于WebSocket连接通常是长连接，服务器节点可能会发生故障或重启。因此，需要通过会话持久化或状态同步技术，确保用户连接能够在服务器故障后自动迁移到其他节点。可以使用Redis、Memcached等分布式缓存系统来存储用户的连接状态。动态资源分配：根据当前的服务器负载情况，动态分配资源（如带宽、CPU、内存等），确保高峰期时WebSocket连接的稳定性。自动伸缩（Auto-scaling）技术可以帮助应对突然增加的连接需求。限流与连接管理：为了防止恶意用户或错误行为导致服务器资源耗尽，可以设置连接数限制、消息速率限制等策略。例如，可以通过限流算法控制每个IP的最大连接数，或对频繁发送消息的客户端进行限速。心跳机制与连接断开检测：大规模连接中，维护连接的有效性和及时断开不活跃的连接非常重要。通过Ping-Pong机制定期检查连接的存活状态，可以及时释放已断开的连接资源，避免空闲连接占用系统资源。通过上述优化策略，WebSocket在处理高并发和大规模连接时能够保持高效和稳定的性能，满足实时性要求较高的应用场景。8. WebSocket协议的扩展与未来发展WebSocket协议自定义标准以来，已经广泛应用于多种场景。随着技术的发展，WebSocket协议也逐渐扩展和演进，尤其在与其他新兴协议如HTTP/2和HTTP/3结合时，展现了其灵活性与可拓展性。未来，WebSocket还会进一步优化，以满足更多实时通信需求。8.1 WebSocket SubprotocolsWebSocket Subprotocols（子协议）是指在WebSocket基础之上，通过指定协议名称来定义更具体的通信规则。因为WebSocket本身只是一个底层的双向通信协议，子协议可以为应用层定义更多的上下文和业务逻辑，使得不同的应用能够使用各自特定的协议进行通信。定义子协议：在WebSocket连接握手的过程中，客户端可以通过Sec-WebSocket-Protocol字段来指定希望使用的子协议，而服务器则可以通过响应头中的同一字段确认使用的协议。例如：Sec-WebSocket-Protocol: chat, superchat常见的子协议：STOMP（Simple/Streaming Text Oriented Messaging Protocol）：常用于消息队列系统，特别是与实时消息传递系统的集成。AMQP（Advanced Message Queuing Protocol）：一种常见的消息协议，用于消息中间件系统。MQTT：一种轻量级的消息协议，通常用于物联网（IoT）设备通信中。通过子协议，WebSocket可以在更高层次上定义不同应用场景下的通信规则，从而确保数据格式和行为一致性。这使得WebSocket不仅可以作为通用的双向通信协议，还能够适配特定业务需求。8.2 WebSocket与HTTP/2、HTTP/3的结合虽然WebSocket协议本身是基于HTTP/1.1设计的，但随着HTTP/2和HTTP/3的普及，WebSocket与这些新型协议的结合也成为了未来发展的重要方向。WebSocket与HTTP/2：HTTP/2支持多路复用，允许多个请求在同一TCP连接上复用，理论上可以提高效率并降低连接开销。然而，WebSocket并未直接支持在HTTP/2的流（stream）中进行通信。近年来，社区提出了RFC 8441，扩展HTTP/2以支持WebSocket。这意味着WebSocket的握手和数据传输可以在HTTP/2流中进行复用，减少了对多个TCP连接的需求。主要优点：多路复用：在同一个HTTP/2连接上可以支持多个WebSocket通信，这减少了频繁打开和关闭TCP连接的成本。头部压缩：HTTP/2的头部压缩机制可以进一步降低WebSocket握手的开销。WebSocket与HTTP/3：HTTP/3基于QUIC协议，而QUIC是运行在UDP上的多路复用协议，能够实现快速连接建立、低延迟的可靠传输。WebSocket与HTTP/3的结合仍在探索阶段，但理论上，使用QUIC可以显著减少WebSocket握手和数据传输的延迟。未来潜力：更快的连接建立：HTTP/3基于UDP，握手过程比TCP更快速，适合高实时性需求的WebSocket应用。更高的可靠性：QUIC的丢包恢复机制可以有效减少传输中的数据丢失，特别是在移动网络等不稳定的环境下。WebSocket与HTTP/2和HTTP/3的结合将为高并发、低延迟应用场景提供更好的支持，尤其是在需要大量并发连接时，多路复用和快速连接建立可以显著提升系统的效率和性能。8.3 WebSocket的未来趋势随着实时通信需求的增加，WebSocket作为核心协议将继续发展。以下是未来WebSocket可能的发展趋势：更强的安全性和隐私保护：随着数据隐私和安全的需求提升，WebSocket在未来可能会进一步增强其加密与认证机制，尤其是在与现代认证标准（如OAuth 2.0、OpenID Connect）结合时，通过更强的身份验证和加密传输来保护用户的数据隐私。增强的高并发处理能力：在物联网、实时游戏、多人协作等场景下，WebSocket将面临更高的并发连接需求。通过与HTTP/2、HTTP/3的结合以及负载均衡技术的改进，WebSocket未来将能更高效地处理大量并发连接，确保实时通信的顺畅。IoT中的应用：物联网（IoT）设备的数量正在迅速增加，WebSocket的轻量级和实时通信特性使其成为连接设备的理想选择。未来WebSocket可能会进一步优化以适应更广泛的IoT场景，特别是与低功耗网络（如LoRa、NB-IoT）结合时的适应性。与边缘计算结合：WebSocket的实时通信需求在边缘计算中也会得到更广泛的应用。通过在边缘节点上建立WebSocket连接，可以减少数据传输的延迟并实现更快速的响应，尤其是在需要实时反馈的场景中，如智能交通、智能城市等。与WebRTC的结合：WebRTC（Web Real-Time Communication）是一种用于浏览器之间实现实时音视频通信的技术。虽然WebRTC专注于媒体流的传输，但在信令的交换上通常使用WebSocket。未来WebSocket可能与WebRTC进一步结合，以提供更加一体化的实时音视频和数据传输解决方案，适用于视频会议、实时协作等场景。WebSocket作为一种高效的双向通信协议，已经在许多实时应用中发挥了重要作用。通过子协议的扩展、与HTTP/2和HTTP/3的结合，WebSocket未来在高并发、低延迟场景中将发挥更大的作用。随着物联网、边缘计算、实时视频等技术的发展，WebSocket的应用场景将继续扩大，成为实时通信领域的核心技术之一。9. 总结9.1 WebSocket的核心优势与挑战WebSocket的核心优势：双向通信：WebSocket支持全双工通信，客户端和服务器之间可以同时发送和接收消息，打破了传统HTTP单向请求-响应的模式，实现了实时数据交互。持久连接：一次握手后，WebSocket建立了一个持久的连接，无需为每次数据传输重新建立连接，大幅降低了连接开销和延迟。低延迟：WebSocket在建立连接后可以立即进行数据传输，适用于低延迟要求较高的场景，如在线聊天、游戏、股票交易等。高效传输：WebSocket仅在建立连接时使用一次HTTP请求，后续数据传输不需要携带冗长的HTTP头部，减少了数据传输中的开销。此外，WebSocket支持二进制数据和文本数据的传输，灵活性高。广泛支持：现代浏览器和服务器广泛支持WebSocket协议，客户端和服务器的实现相对简单，开发者能够快速集成该技术。WebSocket的挑战：连接资源管理：WebSocket是长连接，服务器需要持续管理大量并发连接，这对服务器的内存、CPU、网络带宽等资源提出了更高要求。在高并发场景中，需要使用负载均衡、连接池等技术来优化资源管理。防火墙和代理兼容性：部分企业防火墙或代理服务器可能会阻止或干扰WebSocket连接，因为它不使用标准的HTTP协议，而是通过升级的方式进行通信。这可能导致一些网络环境下WebSocket连接失败。安全性风险：WebSocket是持久连接，长时间的连接可能会带来额外的安全风险，如DDoS攻击、数据劫持、跨站请求伪造（CSRF）等。WebSocket需要结合安全措施如TLS加密、身份验证、访问控制等，来保障通信安全。断线重连与错误处理：在网络环境不稳定的情况下，WebSocket可能会出现连接中断的问题。开发者需要处理连接的断线重连和错误恢复，以确保应用的稳定性。9.2 如何根据应用场景选择通信协议在开发实时应用时，选择合适的通信协议至关重要。WebSocket、HTTP轮询、长轮询、SSE（Server-Sent Events）等协议各有优劣，下面总结如何根据应用场景选择合适的通信协议。实时性要求高的场景：例如在线聊天、多人在线游戏、股票行情等场景，需要极低的延迟和即时性。推荐使用WebSocket：WebSocket提供双向、低延迟的持久连接，能够在实时性要求高的应用中表现出色。数据更新频率较高的场景：如实时体育比分、社交媒体动态推送等，数据频繁更新，需要及时推送给客户端。推荐使用WebSocket或SSE：WebSocket支持频繁的双向通信，SSE虽然是单向通信，但也可以有效地推送服务端更新的数据。大规模并发连接的场景：如物联网设备、直播平台等需要管理大量并发连接的场景。推荐使用WebSocket：WebSocket在高并发情况下通过持久连接减少了连接开销。结合水平扩展和负载均衡技术，WebSocket可以有效处理大规模连接。数据实时性要求不高且低频通信的场景：如定期更新的天气应用、用户状态检查等场景，实时性要求不高且数据更新频率较低。推荐使用HTTP轮询或长轮询：在这些场景中，轮询虽然相对低效，但实现简单，适合低频通信场景。需要保持连接的持久性且不要求双向通信的场景：如实时新闻推送、通知系统等，只需要服务器向客户端推送数据，不需要客户端发送请求。推荐使用SSE：SSE是一种简单、轻量的单向通信方式，适合持续推送更新内容的场景。兼容性要求高的场景：例如需要在不同的网络环境、企业网络中运行，需要解决防火墙和代理兼容性的问题。推荐使用长轮询或SSE：在某些企业环境中，WebSocket可能被防火墙或代理阻止。长轮询和SSE在这些情况下具有更好的兼容性。WebSocket凭借其双向通信、低延迟和持久连接的特点，在需要实时性和高并发的应用中表现优越。然而，开发者在选择通信协议时，应结合应用的实时性需求、连接规模、数据频率和网络环境等因素做出合理选择，确保应用的高效性和稳定性。http://www.ppmy.cn/news/1540708.html相关文章pgAdmin不显示template1数据库，该如何设置才可以显示？pgAdmin和其他数据库管理工具一样&amp;#xff0c;可能是考虑到使用者&amp;#xff08;比如普通开发人员&amp;#xff09;可能并不是特别的了解PostgreSQL的(相对)底层的逻辑&amp;#xff1b;因此&amp;#xff0c;为了方便使用&amp;#xff08;提高使用体验&amp;#xff09;&amp;#xff0c;默认情况下&amp;#xff…阅读更多...单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:28 +0000</pubDate>
    </item>
    <item>
      <title>pgAdmin不显示template1数据库，该如何设置才可以显示？</title>
      <link>https://www.ppmy.cn/news/1540707.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维pgAdmin不显示template1数据库，该如何设置才可以显示？news/2025/10/31 21:30:26/pgAdmin和其他数据库管理工具一样，可能是考虑到使用者（比如普通开发人员）可能并不是特别的了解PostgreSQL的(相对)底层的逻辑；因此，为了方便使用（提高使用体验），默认情况下，pgAdmin是不会显示模板库、以及一些内置的模式和对象。但是如果是针对了解部分底层逻辑的使用者（比如DBA），他们可能需要这些比较底层的功能。我们可以通过设置来显示他们，具体步骤：File--&gt;Browser--&gt;Display--&gt;勾选：Show system objects? 和 Show template databases?设置后我们重连一下数据库，就能看到模式数据库和内置模式了。http://www.ppmy.cn/news/1540707.html相关文章单链表的经典算法OJ目录 
1.反转链表 
2.链表的中间节点 
3.移除链表元素 
——————————————————————————————————————————— 
正文开始 1.反转链表 typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(…阅读更多...PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:26 +0000</pubDate>
    </item>
    <item>
      <title>单链表的经典算法OJ</title>
      <link>https://www.ppmy.cn/news/1540706.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维单链表的经典算法OJnews/2025/10/31 21:30:25/目录1.反转链表2.链表的中间节点3.移除链表元素———————————————————————————————————————————正文开始1.反转链表typedef struct ListNode ListNode;
struct ListNode* reverseList(struct ListNode* head) {//判空if(head == NULL)return head;//创建3个指针ListNode* n1,*n2,*n3;n1 = NULL; n2 = head; n3 = n2-&gt;next;while(n2){n2-&gt;next = n1;n1 = n2;n2 = n3;if(n3)n3 = n3-&gt;next;}return n1;
}2.链表的中间节点typedef struct ListNode ListNode;
struct ListNode* middleNode(struct ListNode* head) {//创建快慢指针ListNode* slow = head; ListNode* fast = head;while(fast &amp;&amp; fast-&gt;next){slow = slow-&gt;next;fast = fast-&gt;next-&gt;next;}return slow;
}3.移除链表元素//创建新链表，pcur不为val则尾插到新链表中
typedef struct ListNode ListNode;
struct ListNode* removeElements(struct ListNode* head, int val) {//创建一个空链表ListNode* newHead, * newTail;newHead = newTail = NULL;//遍历原链表ListNode* pcur = head;while (pcur){//找值不为val的节点,尾插到新链表中if (pcur-&gt;val != val){//链表为空if (newHead == NULL){newHead = newTail = pcur;}else {//链表不为空newTail-&gt;next = pcur;newTail = newTail-&gt;next;}}pcur = pcur-&gt;next;}if (newTail)newTail-&gt;next = NULL;return newHead;
}———————————————————————————————————————————完http://www.ppmy.cn/news/1540706.html相关文章PyTorch 中 functional.py 文件介绍PyTorch 
PyTorch 是一个开源的机器学习库&amp;#xff0c;广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发&amp;#xff0c;并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下&amp;#xff1a; 动态…阅读更多...【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:25 +0000</pubDate>
    </item>
    <item>
      <title>PyTorch 中 functional.py 文件介绍</title>
      <link>https://www.ppmy.cn/news/1540705.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维PyTorch 中 functional.py 文件介绍news/2025/10/31 21:30:24/PyTorchPyTorch 是一个开源的机器学习库，广泛用于计算机视觉和自然语言处理等应用。它由 Facebook 的人工智能研究团队开发，并得到了许多研究机构和企业的支持。PyTorch 以其易用性、灵活性和强大的社区支持而受到欢迎。一些特点如下：动态计算图（Dynamic Computation Graphs）：PyTorch 使用动态计算图，这意味着图在运行时构建，允许更直观和灵活的模型设计。这与传统的静态图框架（如 TensorFlow 1.x）不同，后者需要在执行前定义整个图。自动微分（Automatic Differentiation）：PyTorch 提供了自动微分功能，可以自动计算梯度，这对于训练深度学习模型至关重要。丰富的API：PyTorch 提供了大量的预定义层、优化器和损失函数，使得模型的构建和训练变得简单。多GPU支持：PyTorch 支持多GPU训练，可以有效地利用硬件资源，加速模型训练。序列化和模型共享：PyTorch 允许轻松地保存和加载模型，便于模型的共享和部署。社区支持：PyTorch 拥有一个活跃的社区，提供了大量的教程、文档和预训练模型。functional.py功能介绍在 PyTorch 中，torch.nn.functional.py是一个包含多种函数的模块，这些函数提供了不包含可学习参数的层的实现。这意味着，与 torch.nn.Module 中的层不同，torch.nn.functional.py中的函数不跟踪梯度或在训练过程中更新参数。这些函数通常用于执行各种操作，如卷积、池化、激活函数、损失函数等。常用函数卷积函数torch.nn.functional.conv1d: 一维卷积函数。torch.nn.functional.conv2d: 二维卷积函数。torch.nn.functional.conv3d: 三维卷积函数。torch.nn.functional.conv_transpose1d,torch.nn.functional.conv_transpose2d,torch.nn.functional.conv_transpose3d: 转置卷积（也称为去卷积）函数。池化函数torch.nn.functional.avg_pool1d,torch.nn.functional.avg_pool2d,torch.nn.functional.avg_pool3d: 平均池化函数。torch.nn.functional.max_pool1d,torch.nn.functional.max_pool2d,torch.nn.functional.max_pool3d: 最大池化函数。torch.nn.functional.adaptive_max_pool1d,torch.nn.functional.adaptive_max_pool2d: 自适应最大池化函数。torch.nn.functional.adaptive_avg_pool1d,torch.nn.functional.adaptive_avg_pool2d: 自适应平均池化函数。非线性激活函数torch.nn.functional.relu: 修正线性单元（ReLU）激活函数。torch.nn.functional.sigmoid: Sigmoid 激活函数。torch.nn.functional.tanh: 双曲正切激活函数。归一化函数torch.nn.functional.batch_norm: 批量归一化函数。线性函数torch.nn.functional.linear: 线性变换函数。Dropout 函数torch.nn.functional.dropout: Dropout 函数。距离函数torch.nn.functional.pairwise_distance: 计算两个张量之间的成对距离。损失函数torch.nn.functional.cross_entropy: 交叉熵损失函数。torch.nn.functional.binary_cross_entropy: 二进制交叉熵损失函数。torch.nn.functional.nll_loss: 负对数似然损失函数。视觉函数torch.nn.functional.pixel_shuffle: 用于将张量重新排列以增加空间分辨率的函数。torch.nn.functional.pad: 用于填充张量的函数。使用示例卷积函数示例importtorchimporttorch.nn.functionalasF# 创建一个输入张量，假设是一个单通道的28x28图像input=torch.randn(1,1,28,28)# 定义卷积核的权重和偏置weight=torch.randn(1,1,3,3)bias=torch.randn(1)# 使用 F.conv2d 进行卷积操作output=F.conv2d(input,weight,bias)print(output.shape)# 输出张量的形状池化函数示例# 使用 F.max_pool2d 进行最大池化，# 池化（Pooling）是卷积神经网络（CNN）中常用的一种技术，它用于降低特征的空间维度（高和宽），# 同时保留最重要的信息。池化操作通常在卷积层之后应用，可以减少模型的参数数量和计算量，# 提高模型的抽象能力，并且有助于提取更具有泛化性的特征。pooled=F.max_pool2d(input,kernel_size=2)print(pooled.shape)# 输出张量的形状激活函数示例# 使用 F.relu 作为激活函数activated=F.relu(input)print(activated.shape)# 输出张量的形状损失函数示例# 假设我们有一些预测和目标标签predictions=torch.randn(10)targets=torch.tensor([1,2,3,4,5,6,7,8,9,10])# 使用 F.cross_entropy 计算交叉熵损失loss=F.cross_entropy(predictions,targets)print(loss.item())# 输出损失值归一化函数示例# 假设我们有一个批量的输入数据inputs=torch.randn(20,10)# 使用 F.batch_norm 进行批量归一化output=F.batch_norm(inputs,running_mean=torch.zeros(10),running_var=torch.ones(10))print(output.shape)# 输出张量的形状Dropout 函数示例# 使用 F.dropout 进行dropout操作，正则化技术，Dropout 通过在训练过程中随机“丢弃”（即将输出设置为零）# 一部分神经元的输出，来减少神经元之间复杂的共适应关系。dropped=F.dropout(input,p=0.2)print(dropped.shape)# 输出张量的形状相关源码GitHub地址：https://github.com/pytorch/pytorch/blob/main/torch/nn/functional.pyhttp://www.ppmy.cn/news/1540705.html相关文章【openwrt-21.02】Openwrt NAT配置举例Openwrt NAT配置举例 
DNAT 
Port forwarding for IPv4 (DNAT) 此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH &amp;#xff08;22&amp;#xff09; 端口。 
config redirectoption target          DNAToption src             wanoption dest…阅读更多...云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:24 +0000</pubDate>
    </item>
    <item>
      <title>【openwrt-21.02】Openwrt NAT配置举例</title>
      <link>https://www.ppmy.cn/news/1540704.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【openwrt-21.02】Openwrt NAT配置举例news/2025/10/31 21:30:22/Openwrt NAT配置举例DNATPort forwarding for IPv4 (DNAT)此规则的目标是将端口 2222 上的所有 WAN 端 SSH 访问重定向到 单个 LAN 端工作站的 SSH （22） 端口。config redirectoption target          DNAToption src             wanoption dest            lanoption proto           tcpoption src_dport       2222option dest_ip         192.168.10.20option dest_port       22option enabled         1规则测试要从 WAN 端工作站 （STA1） 进行测试，请在端口 2222 上通过 SSH 连接到 LAN 端网络上不存在的 IPv4 地址：ssh -p 2222 192.168.10.13 hostname; cat /proc/version启用该规则后，STA2 将回复其主机名和内核版本。 禁用规则后，连接将被拒绝。添加规则如下iptables -t nat -A zone_wan_prerouting -p tcp -m tcp --dport 2222 -m comment --comment "!fw3: @redirect[0]" -j DNAT --to-destination 192.168.10.20:22
...
iptables -t nat -A zone_lan_prerouting -p tcp -s 192.168.10.0/255.255.255.0 -d 192.168.3.185/255.255.255.255 -m tcp --dport 2222 -m comment --comment "!fw3: @redirect[0] (reflection)" -j DNAT --to-destination 192.168.10.20:22第一条规则匹配在 TCP 端口 2222 上进入 WAN 端的数据包，并跳转到过滤器以将目标转换为 . 第二条规则匹配从 LAN 端传入 WAN 端的数据包（如果在 TCP 端口 2222 上）。 DNAT 目标使用与第一条规则相同的参数在 conntrack 表中查找“反射”。DNAT192.168.10.20:22--to-destination连接跟踪表记录ipv4     2 tcp      6 117 TIME_WAIT src=192.168.3.171 dst=192.168.10.13 sport=51390 dport=2222 packets=21 bytes=4837 src=192.168.10.20 dst=192.168.3.171 sport=22 dport=51390 packets=23 bytes=4063 [ASSURED] mark=0 use=2此记录显示 WAN 端 src=STA1 和 dst=192.168.10.13：2222 以及反向 LAN 端 src=STA2：22 src=STA1。DNAT to translate a LAN-side address on the WAN-side此重定向规则将导致路由器将 WAN 端源 1.2.3.4 转换为 LAN 端 STA2，并将 ICMP 回显路由到该 STA2。 该规则是自反的，因为 STA2 将在 WAN 端转换为 1.2.3.4。config redirectoption src      wanoption src_dip  1.2.3.4option proto    icmpoption dest     lanoption dest_ip  192.168.10.20option target   DNAToption name     DNAT-ICMP-WAN-LANoption enabled  1LAN-side public server所有重定向都需要某种形式的 NAT 和连接跟踪。为 防火墙后面的公共服务器，则 DNAT 目标用于转换 WAN 端的公网 IP 地址到 LAN 端服务器的私有地址。config redirectoption target DNAToption src wanoption src_dport 25option proto tcpoption family ipv4option dest lanoption dest_ip 192.168.10.20option dest_port 2525option name DNAT-MAIL-SERVERoption enabled 1在此示例中，STA2 正在运行一个电子邮件服务器（例如 postfix），该服务器在端口 2525 上侦听传入电子邮件。此重定向规则规定：来自端口 25 上的 WAN 的任何传入流量，重定向到 STA1 端口 2525。要验证 dump 上的内容，请观察传入流量的动态连接。 其中可能有相当多的 conntrack 记录，因此我们只搜索使用端口 2525 的记录：...
ipv4     2 tcp      6 7436 ESTABLISHED src=192.168.3.171 dst=192.168.3.11 sport=41370 dport=25 packets=4 bytes=229 src=192.168.10.20 dst=192.168.3.171 sport=2525 dport=41370 packets=3 bytes=164 [ASSURED] mark=0 use=2
...连接从 STA1 端口 25 到 DUT，并转换为 STA2 在端口 2525 上，响应目标为 STA1。相关流量与 OpenWrt 防火墙允许遍历区域的 DNAT conntrack 状态匹配，因此不需要额外的宽松规则。Source NAT (SNAT)此规则的目标是将源 IP 地址从真实 station 转换为 端口 8080 上的虚构版本。config redirectoption target           SNAToption src              lanoption dest             wanoption proto            tcpoption src_ip           192.168.10.20option src_dip          192.168.10.13option dest_port        8080option enabled          1要测试：使用 netcat 侦听 STA1，即 WAN 端站：nc -l 8080使用 Netcat 在 STA2 上进行连接，即 LAN 端工作站：nc -v 192.168.3.171 8080在 LAN 端工作站上键入内容，并在 WAN 端工作站上看到它的回声。 使用 WAN 侧工作站检查连接并查看线路：netstat -ntaptcp        0      0 192.168.3.171:8080      192.168.10.13:47970 ESTABLISHED 16746/ncWAN 端工作站在端口 8080 上显示连接到它的 SNAT 地址！单独使用时，源 NAT 用于限制计算机对 Internet 的访问，同时允许它通过转发看似 一些本地服务，例如 NTP，连接到 Internet。 DNAT 对 Internet 隐藏本地网络，而 SNAT 对本地网络隐藏 Internet。MASQUERADE这是最常用和最有用的 NAT 函数。 它将 LAN 端的本地专用网络转换为 WAN 端的单个公共地址/端口数，然后反之。 它是每个IPv4 路由器的默认防火墙配置。 因此，这是一个非常简单的 fw4 配置。LAN 端使用专用网络。 路由器将私有地址转换为路由器 address：port，netfilter conntrack 模块管理连接。伪装会设置在 WAN 端config zoneoption name 'wan'list network 'wan'....option masq '1'路由器通常会从上游 DHCP 服务器获取其 WAN IP 地址，并成为 LAN 站的 DHCP 服务器（通常是 DNS 服务器）。网络配置文件定义私有网络，dhcp 配置文件定义 OpenWrt 路由器如何分配 LAN 端 IPv4 地址。启用 MASQUERADE 后，WAN 和 LAN 之间的所有转发流量都会被转换。从本质上讲，MASQUERADE 防火墙规则几乎不会出错。cat /proc/net/nf_conntrack 检查当前的 MASQUERADE 连接。以下连接跟踪从 STA1 到 STA2 的 SSH （22） 访问。ipv4     2 tcp      6 4615 ESTABLISHED src=192.168.3.171 dst=192.168.10.20 sport=60446 dport=22 packets=27 bytes=1812 src=192.168.10.20 dst=192.168.3.171 sport=22 dport=60446 packets=21 bytes=2544 [ASSURED] mark=0 use=2Transparent proxy rule (external)以下规则通过侦听端口 3128 的 192.168.1.100 上的外部代理重定向所有 LAN 端 HTTP 流量。 它假定lan地址为 192.168.1.1 - 这是伪装向代理的重定向流量所必需的。config redirectoption src              lanoption proto            tcpoption src_ip           !192.168.1.100option src_dport        80option dest_ip          192.168.1.100option dest_port        3128option target           DNATconfig redirectoption dest             lanoption proto            tcpoption src_dip          192.168.1.1option dest_ip          192.168.1.100option dest_port        3128option target           SNATNAT在 WAN 区域上启用伪装又名 NAT。uci set firewall.@zone[1].masq="1"
uci commit firewall
service firewall restartIPv6 NAT在 WAN 区域启用 IPv6 伪装，又名 NAT66uci set firewall.@zone[1].masq6="1"
uci commit firewall
service firewall restart通告ULA 前缀的 IPv6 默认路由。uci set dhcp.lan.ra_default="1"
uci commit dhcp
service odhcpd restart在上游接口上禁用 IPv6 源过滤器。uci set network.wan6.sourcefilter="0"
uci commit network
service network restartSelective NAT为特定源子网有选择地启用伪装。uci -q delete firewall.nat
uci set firewall.nat="nat"
uci set firewall.nat.family="ipv4"
uci set firewall.nat.proto="all"
uci set firewall.nat.src="wan"
uci set firewall.nat.src_ip="192.168.2.0/24"
uci set firewall.nat.target="MASQUERADE"
uci commit firewall
service firewall restartIPv6 selective NAT有选择地为特定源子网启用 IPv6 伪装。uci -q delete firewall.nat6
uci set firewall.nat6="nat"
uci set firewall.nat6.family="ipv6"
uci set firewall.nat6.proto="all"
uci set firewall.nat6.src="wan"
uci set firewall.nat6.src_ip="fd00:2::/64"
uci set firewall.nat6.target="MASQUERADE"
uci commit firewall
service firewall restartIPv6 to IPv4 NAT with Jool使用 Jool 为仅 IPv6 网络启用 IPv6 到 IPv4 NAT，又名 NAT64。 使用 DNS64 解析域名。opkg update
opkg install jool-tools-netfilter
. /usr/share/libubox/jshn.sh
json_init
json_add_string "instance" "default"
json_add_string "framework" "netfilter"
json_add_object "global"
json_add_string "pool6" "64:ff9b::/96"
json_close_object
json_dump &gt; /etc/jool/jool-nat64.conf.json
uci set jool.general.enabled="1"
uci set jool.nat64.enabled="1"
uci commit jool
service jool restartIPv6 to IPv4 NAT with Tayga使用 Tayga 为仅 IPv6 网络启用 IPv6 到 IPv4 NAT，又名 NAT64。 使用 DNS64 解析域名。opkg update
opkg install tayga
uci del_list firewall.lan.network="nat64"
uci add_list firewall.lan.network="nat64"
uci commit firewall
service firewall restart
uci -q delete network.nat64
uci set network.nat64="interface"
uci set network.nat64.proto="tayga"
uci set network.nat64.prefix="64:ff9b::/96"
uci set network.nat64.ipv6_addr="fd00:ffff::1"
uci set network.nat64.dynamic_pool="192.168.255.0/24"
uci set network.nat64.ipv4_addr="192.168.255.1"
uci commit network
service network restartTTL修改出口流量的 TTL。cat &lt;&lt; "EOF" &gt; /etc/nftables.d/ttl.sh
WAN_TTL="65"
. /lib/functions/network.sh
network_flush_cache
network_find_wan WAN_IF
network_get_device WAN_DEV "${WAN_IF}"
nft add rule inet fw4 mangle_postrouting \
oifname "${WAN_DEV}" ip ttl set "${WAN_TTL}"
EOF
uci -q delete firewall.ttl
uci set firewall.ttl="include"
uci set firewall.ttl.path="/etc/nftables.d/ttl.sh"
uci commit firewall
service firewall restartIPv6 hop limit修改出口流量的 IPv6 跃点限制。cat &lt;&lt; "EOF" &gt; /etc/nftables.d/hlim.sh
WAN_HLIM="65"
. /lib/functions/network.sh
network_flush_cache
network_find_wan6 WAN_IF
network_get_device WAN_DEV "${WAN_IF}"
nft add rule inet fw4 mangle_postrouting \
oifname "${WAN_DEV}" ip6 hoplimit set "${WAN_HLIM}"
EOF
uci -q delete firewall.hlim
uci set firewall.hlim="include"
uci set firewall.hlim.path="/etc/nftables.d/hlim.sh"
uci commit firewall
service firewall restart参考链接[OpenWrt Wiki] NAT exampleshttps://openwrt.org/docs/guide-user/firewall/fw3_configurations/fw3_nat#npthttp://www.ppmy.cn/news/1540704.html相关文章云计算-----单机LNMP结构WordPress网站LNMP结构 博客网站     day1 
小伙伴们&amp;#xff0c;LNMP结构在第一二阶段浅浅的学习过&amp;#xff0c;这里我们可以离线部署该结构。L指&amp;#xff08;虚拟机&amp;#xff09;服务器&amp;#xff0c;nginx&amp;#xff08;前端代理服务器&amp;#xff09;mysql数据库&amp;#xff0c;最后基于php建设动态…阅读更多...如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:23 +0000</pubDate>
    </item>
    <item>
      <title>云计算-----单机LNMP结构WordPress网站</title>
      <link>https://www.ppmy.cn/news/1540703.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维云计算-----单机LNMP结构WordPress网站news/2025/10/31 21:30:21/LNMP结构 博客网站day1小伙伴们，LNMP结构在第一二阶段浅浅的学习过，这里我们可以离线部署该结构。L指（虚拟机）服务器，nginx（前端代理服务器）+mysql数据库，最后基于php建设动态资源网站。#也有前端代理服务器是apache的，建站语言还有tomcat(*^▽^*)#服务器一般都是用linux系统的，好处安全隔离，不占空间内存大。nginx担任前端代理服务器，负责负载均衡和前端代理作用。它可以配置多台web网页服务器，访问相关站点资源。NFS是起文件共享作用，mysql的作用是存储网页数据。一般网站都会架构mysql主从同步读写分离的数据库。php需要在nginx安装的环境下，才能产生作用。#准备以下机器，方便环境进行，单机环境即可，不上云平台购买。主机名IP地址client01192.168.88.10/24web1192.168.88.11/24web2192.168.88.12/24web3192.168.88.13/24database192.168.88.21/24nfs192.168.88.31/24haproxy01192.168.88.5haproxy02192.168.88.6一、单机安装WordPress#类似WordPress的博客类网站很多（织梦，帝国等），这里只是举例子，感兴趣的可以去看看。下图是wordpress博客样例。具体功能建完我再将。^_^创建虚拟机，并配置防火墙、SELINUX、主机名、IP地址、yum配置ansible管理环境#这里我们用的是云计算2阶段留下来的虚拟机（192.168.88.240）主机名随课程环境更改。你也可以自己创个master虚拟机，觉得机器多的话，可以在client虚拟机里面设置ansible相关自动化操作，批量部署配置  虚拟机软件环境。# 1. 创建工作目录[root@pubserver ~]# mkdir -p project01/files
[root@pubserver ~]# cd project01/# 2. 创建主配置文件、主机清单文件、yum配置文件[root@pubserver project01]# vim ansible.cfg 
[defaults]
inventory = inventory
host_key_checking = false[root@pubserver project01]# vim inventory 
[webservers]
web1 ansible_host=192.168.88.11[all:vars]
ansible_ssh_user=root
ansible_ssh_pass=a[root@pubserver project01]# vim files/local88.repo 
[BaseOS]
name = BaseOS
baseurl = ftp://192.168.88.240/dvd/BaseOS
enabled = 1
gpgcheck = 0[AppStream]
name = AppStream
baseurl = ftp://192.168.88.240/dvd/AppStream
enabled = 1
gpgcheck = 0[rpms]
name = rpms
baseurl = ftp://192.168.88.240/rpms
enabled = 1
gpgcheck = 0[root@pubserver project01]# vim files/local88.repo 
[BaseOS]
name = BaseOS
baseurl = ftp://192.168.88.240/dvd/BaseOS
enabled = 1
gpgcheck = 0[AppStream]
name = AppStream
baseurl = ftp://192.168.88.240/dvd/AppStream
enabled = 1
gpgcheck = 0[rpms]
name = rpms
baseurl = ftp://192.168.88.240/rpms
enabled = 1
gpgcheck = 0配置yum服务[root@pubserver project01]# vim 01-upload-repo.yml 
---
- name: config repos.dhosts: alltasks:- name: delete repos.dfile:path: /etc/yum.repos.dstate: absent- name: create repos.dfile:path: /etc/yum.repos.dstate: directorymode: '0755'- name: upload local88copy:src: files/local88.repodest: /etc/yum.repos.d/[root@pubserver project01]# ansible-playbook 01-upload-repo.yml配置nginx[root@pubserver project01]# vim 02-config-web1.yml 
---
- name: config web1hosts: webserverstasks:- name: install pkgs   # 安装软件包yum:name:- nginx- mysql-server- php-mysqlnd- php-fpm- php-jsonstate: present- name: start service   # 循环启动多个服务service:name: "{{item}}"state: startedenabled: yesloop:- nginx- php-fpm- mysqld
[root@pubserver project01]# ansible-playbook 02-config-web1.yml编写php文件，并访问http://192.168.88.11/测试#再次提醒，必须先配置NGINX和php相关依赖，才能出现下图。[root@web1 ~]# vim /usr/share/nginx/html/index.php
&lt;?phpphpinfo();
?&gt;#测试能看到这个界面，说明环境配置成功。二、分离数据库安装Wordpress网站，需要数据库，创建数据库并授权# 1. 编写用于创建数据库和用户的脚本
[root@pubserver project01]# vim files/config_mysql.sh
#!/bin/bashmysql -e "create database wordpress character set utf8mb4"
mysql -e "create user wpuser01@localhost identified by 'wordpress'"
mysql -e "grant all privileges on wordpress.* to wpuser01@localhost"#上面是编写了脚本，执行了创建数据库用户和密码，下图则是通过ansible的script模块调用脚本文件。# 2. 通过ansible的script模块执行脚本
[root@pubserver project01]# vim 03-config-mysql.yml 
---
- name: config mysqlhosts: web1tasks:- name: create databasescript: files/config_mysql.sh[root@pubserver project01]# ansible-playbook 03-config-mysql.yml# 3. 测试账号，如果可以成功登陆mysql，则数据库和用户创建正确
[root@web1 ~]# mysql -uwpuser01 -pwordpress -hlocalhost wordpress# 1. 拷贝wordpress到web1
[root@myhost ~]# scp /linux-soft/s2/zzg/project01_soft/wordpress-6.1.1-zh_CN.tar.gz 192.168.88.11:/root/# 2. 解压并复制文件到nginx文档目录
[root@web1 ~]# tar xf wordpress-6.1.1-zh_CN.tar.gz  
[root@web1 ~]# cp -r wordpress/* /usr/share/nginx/html/# 3. php程序是由php-fpm处理的，php-fpm以apache身份运行
[root@web1 ~]# ps aux | grep php-fpm
root        5655  0.0  0.4 395620 19056 ?        Ss   12:13   0:00 php-fpm: master process (/etc/php-fpm.conf)
apache      5670  0.0  0.3 412108 13812 ?        S    12:13   0:00 php-fpm: pool www# 4. 为了让php-fpm程序能对html目录进行读写操作，需要为他授予权限
[root@web1 ~]# chown -R apache:apache /usr/share/nginx/html/#这里我们可以直接，进入wordpress官网下载中文版，之后从真机传入虚拟机服务器。最后按照上述骤检查 。访问http://192.168.88.11/，根据提示进行初始化#这里的数据库名和密码，和你前面设置的mysql数据库的对应上，不然进不去嗷。#网站登录密码，自己设置好记的，邮箱随便填写。#博客网站取名随意注意：注销登陆后，如果再次登陆，需访问http://192.168.88.11/wp-login.php三、配置额外的web服务器web与数据库服务分离#只有1台web服务器肯定是不行的，所以需要配置多台web服务器，进行负载均衡的选择。搭建好 database 服务器，之后配好IP192.168.88.21修改ansible配置环境
[root@pubserver project01]# vim inventory 
[webservers]
web1 ansible_host=192.168.88.11[dbs]
database ansible_host=192.168.88.21[all:vars]
ansible_ssh_user=root
ansible_ssh_pass=a配置数据库服务器# 1. 修改yum配置
[root@pubserver project01]# ansible-playbook 01-upload-repo.yml # 2. 安装数据库服务，并创建数据库及用户
[root@pubserver project01]# vim files/config_mysql2.sh
#!/bin/bashmysql -e "create database wordpress character set utf8mb4"
mysql -e "create user wpuser01@'%' identified by 'wordpress'"
mysql -e "grant all privileges on wordpress.* to wpuser01@'%'"[root@pubserver project01]# vim 04-config-database.yml
---
- name: config databasehosts: dbstasks:- name: install mysql    # 安装数据库服务yum:name: mysql-serverstate: present- name: start service    # 启动数据库服务service:name: mysqldstate: startedenabled: yes- name: create databasescript: files/config_mysql2.sh[root@pubserver project01]# ansible-playbook 04-config-database.yml迁移数据库 （测试新数据库的功能）#文章里面的区块附近，可以点击查看相关设置，有网页设计知识的都看得懂，比较简单。结构都是HTML ,CSS,JAVAscript的相关内容，不涉及JAVA前端Vue框架知识。都看得懂注意：默认的wordpress对中文标题支持有bug，需要修改源码修复bug。或者更改【固定链接】配置，如下：迁移数据库# 1. 在源服务器上备份数据库中的数据。备份数据库wordpress中的数据到wordpress.sql文件
[root@web1 ~]# mysqldump wordpress &gt; wordpress.sql# 2. 将备份文件拷贝到新数据库服务器
[root@web1 ~]# scp wordpress.sql 192.168.88.21:/root/# 3. 在新数据库服务器上，导入数据。将wordpress.sql中的数据导入到wordpress数据库中
[root@database ~]# mysql wordpress &lt; wordpress.sql # 4. 修改php网站，将数据库服务器地址，指向新数据库服务器
[root@web1 ~]# vim /usr/share/nginx/html/wp-config.php 
...略...31 /** Database hostname */32 define( 'DB_HOST', '192.168.88.21' );
...略...
# 5. 停止web1上的数据库服务，wordpress网站仍然可以访问
[root@web1 ~]# systemctl stop mysqld
[root@web1 ~]# yum remove -y mysql-server# 6. 停止database上的数据库服务，wordpress将不能访问查询数据库中的内容[root@database ~]# mysql   # 打开mysql命令行
mysql&gt; show databases;     # 查看有哪些数据库
mysql&gt; use wordpress;      # 切换到wordpress数据库
mysql&gt; show tables;        # 查看wordpress库中有哪些表
mysql&gt; select * from wp_posts\G  # 查看wp_posts表中的内容配置额外的web服务器#注意如果你们一开始机器就准备好了，这里的两台web2-web3服务器，和它们的IP地址就别设置到了 。你们应该看出来了，机器和相应的ansible自动化配置，没有一开始配完。主要是考虑思路，循序渐进的演示，如果一开始ip和机器配好，自动化也设置好，就会有点知识不过脑。修改ansible配置[root@pubserver project01]# vim inventory 
[webservers]
web1 ansible_host=192.168.88.11
web2 ansible_host=192.168.88.12
web3 ansible_host=192.168.88.13[dbs]
database ansible_host=192.168.88.21[all:vars]
ansible_ssh_user=root
ansible_ssh_pass=a配置web服务# 1. 配置yum
[root@pubserver project01]# ansible-playbook 01-upload-repo.yml # 2. 配置web服务器
[root@pubserver project01]# vim 05-config-webservers.yml 
---
- name: config webservershosts: webserverstasks:- name: install pkgs    # 安装软件包yum:name:- nginx- php-mysqlnd- php-fpm- php-jsonstate: present- name: start service   # 循环启动多个服务service:name: "{{item}}"state: startedenabled: yesloop:- nginx- php-fpm[root@pubserver project01]# ansible-playbook 05-config-webservers.yml将web1的html目录打包并下载[root@pubserver project01]# vim 06-fetch-web1.yml 
---
- name: copy webhosts: web1tasks:- name: compress html    # 压缩html目录到/root下archive:path: /usr/share/nginx/htmldest: /root/html.tar.gzformat: gz- name: download html    # 下载压缩文件fetch:src: /root/html.tar.gzdest: files/flat: yes[root@pubserver project01]# ansible-playbook 06-copy-web.yml释放html压缩包到web2和web3上[root@pubserver project01]# vim 07-deploy-web23.yml
---
- name: deploy web2 and web3hosts: web2,web3tasks:- name: unarchive to web    # 解压文件到指定位置unarchive:src: files/html.tar.gzdest: /usr/share/nginx/[root@pubserver project01]# ansible-playbook 07-deploy-web23.yml访问http://192.168.88.12/和http://192.168.88.13/将会得到与http://192.168.88.11/相同的页面LNMP结构 博客网站day2深入理解程序的数据存储程序将文字数据保存到数据库中程序将非文字数据（如图片、视频、压缩包等）保存到相应的文件目录中验证发一篇文章，文章内容包含文字和图片在数据库中查看文字数据。在最新的一条记录中，可以查看到图片的保存位置#去博客上面发哈。[root@database ~]# mysql
mysql&gt; use wordpress;
mysql&gt; select * from wp_posts\G在文件系统中查看图片文件。/usr/share/nginx/html/wp-content/uploads/是固定位置，其后的2024/10是年和月目录。每个月上传的图片，都会保存到相应的月份目录。[root@web1 html]# ls /usr/share/nginx/html/wp-content/uploads/2024/10/
snow.jpg配置NFS服务器#老样子，首先配好nfs服务器IP，以后可以更具需求架构图，先配置好配置ansible环境[root@pubserver project01]# vim inventory 
[webservers]
web1 ansible_host=192.168.88.11
web2 ansible_host=192.168.88.12
web3 ansible_host=192.168.88.13[dbs]
database ansible_host=192.168.88.21[storages]
nfs ansible_host=192.168.88.31[all:vars]
ansible_ssh_user=root
ansible_ssh_pass=a配置nfs服务# 1. 配置yum
[root@pubserver project01]# ansible-playbook 01-upload-repo.yml # 2. 配置nfs服务
[root@pubserver project01]# vim 08-config-nfs.yml
---
- name: config nfshosts: nfstasks:- name: install nfs        # 安装nfsyum:name: nfs-utilsstate: present- name: mkdir /nfs_root    # 创建共享目录file:path: /nfs_rootstate: directorymode: "0755"- name: nfs share          # 修改配置文件lineinfile:path: /etc/exportsline: '/nfs_root 192.168.88.0/24(rw)'- name: start service      # 循环启动服务service:name: "{{item}}"state: startedenabled: yesloop:- rpcbind       # nfs服务依赖rpcbind服务- nfs-server[root@pubserver project01]# ansible-playbook 08-config-nfs.yml# 3. 查看共享输出
[root@nfs ~]# showmount -e
Export list for nfs:
/nfs_root 192.168.88.0/24
迁移文件至nfs共享迁移文件至nfs共享# 1. 重新下载web1的html目录
[root@pubserver project01]# cp 06-fetch-web1.yml 09-fetch-web1.yml
---
- name: copy webhosts: web1tasks:- name: compress html        # 压缩html目录到/root下archive:path: /usr/share/nginx/htmldest: /root/html2.tar.gzformat: gz- name: download htmlfetch:src: /root/html2.tar.gz  # 下载压缩文件dest: files/flat: yes[root@pubserver project01]# ansible-playbook 09-fetch-web1.yml# 2. 释放压缩包到nfs服务器
[root@pubserver project01]# cp 07-deploy-web23.yml 10-deploy-nfs.yml
[root@pubserver project01]# vim 10-deploy-nfs.yml 
---
- name: deploy nfshosts: nfstasks:- name: unarchive to web     # 将控制端压缩文件解压到指定位置unarchive:src: files/html2.tar.gzdest: /nfs_root/[root@pubserver project01]# ansible-playbook 10-deploy-nfs.yml# 3. 清除web服务器的html目录
[root@pubserver project01]# vim 11-rm-html.yml
---
- name: rm htmlhosts: webserverstasks:- name: rm htmlfile:path: /usr/share/nginx/htmlstate: absent- name: create htmlfile:path: /usr/share/nginx/htmlstate: directoryowner: apachegroup: apachemode: "0755"[root@pubserver project01]# ansible-playbook 11-rm-html.yml# 4. 挂载nfs到web服务器
[root@pubserver project01]# vim 12-mount-nfs.yml
---
- name: mount nfshosts: webserverstasks:- name: install nfsyum:name: nfs-utilsstate: present- name: mount nfsmount:path: /usr/share/nginx/htmlsrc: 192.168.88.31:/nfs_root/htmlfstype: nfsstate: mounted[root@pubserver project01]# ansible-playbook 12-mount-nfs.yml配置代理服务器#配置好机器IP配置ansible环境[root@pubserver project01]# vim inventory 
[webservers]
web1 ansible_host=192.168.88.11
web2 ansible_host=192.168.88.12
web3 ansible_host=192.168.88.13[dbs]
database ansible_host=192.168.88.21[storages]
nfs ansible_host=192.168.88.31[lb]
haproxy1 ansible_host=192.168.88.5
haproxy2 ansible_host=192.168.88.6[all:vars]
ansible_ssh_user=root
ansible_ssh_pass=a配置高可用、负载均衡功能# 1. 配置yum
[root@pubserver project01]# ansible-playbook 01-upload-repo.yml # 2. 配置调度服务器
[root@pubserver project01]# vim 13-install-lb.yml 
---
- name: install lbhosts: lbtasks:- name: install pkgyum:name: haproxy,keepalivedstate: present[root@pubserver project01]# ansible-playbook 13-install-lb.yml# 3. 修改配置文件并启动服务
[root@pubserver project01]# vim 14-config-lb.yml
---
- name: config haproxyhosts: lbtasks:- name: rm linesshell: sed -i '64,$d' /etc/haproxy/haproxy.cfg- name: add linesblockinfile:path: /etc/haproxy/haproxy.cfgblock: |listen wordpressbind 0.0.0.0:80balance roundrobinserver web1 192.168.88.11:80 check inter 2000 rise 2 fall 5server web2 192.168.88.12:80 check inter 2000 rise 2 fall 5server web3 192.168.88.13:80 check inter 2000 rise 2 fall 5listen monbind 0.0.0.0:1080stats refresh 30sstats uri /monstats auth admin:admin- name: start serviceservice:name: haproxystate: startedenabled: yes[root@pubserver project01]# ansible-playbook 14-config-lb.yml# 4. haproxy1配置keepalived，实现高可用集群
[root@haproxy1 ~]# vim /etc/keepalived/keepalived.conf 
...略...12    router_id haproxy1   # 为本机取一个唯一的id13    vrrp_iptables        # 自动开启iptables放行规则
...略...20 vrrp_instance VI_1 {21     state MASTER        # 主服务器状态是MASTER22     interface eth023     virtual_router_id 5124     priority 10025     advert_int 126     authentication {27         auth_type PASS28         auth_pass 111129     }30     virtual_ipaddress {31         192.168.88.80       # vip地址32     }33 }
# 以下全部删除# #########  33行下面去哪删除 ！！！！！！！！！！！！！！！！！！！！# 5. haproxy2配置keepalived
[root@haproxy1 ~]# scp /etc/keepalived/keepalived.conf 192.168.88.6:/etc/keepalived/
[root@haproxy2 ~]# vim /etc/keepalived/keepalived.conf 
...略...12    router_id haproxy2   # 为本机取一个唯一的id13    vrrp_iptables        # 自动开启iptables放行规则
...略...20 vrrp_instance VI_1 {21     state BACKUP        # 备份服务器状态是BACKUP22     interface eth023     virtual_router_id 5124     priority 80         # 备份服务器优先级低于主服务器25     advert_int 126     authentication {27         auth_type PASS28         auth_pass 111129     }30     virtual_ipaddress {31         192.168.88.8032     }33 }#区别1个是master,1个配置为了backup.服务器ID不一样，优先级不一样。别搞混乱了# 6. 启动服务
[root@haproxy1 ~]# systemctl enable keepalived.service --now
[root@haproxy2 ~]# systemctl enable keepalived.service --now# 7. 验证。haproxy1上出现VIP。客户端访问http://192.168.88.80即可
[root@haproxy1 ~]# ip a s | grep 192inet 192.168.88.5/24 brd 192.168.88.255 scope global noprefixroute eth0inet 192.168.88.80/32 scope global eth0配置名称解析通过本机hosts文件实现名称解析
[root@myhost ~]# echo "192.168.88.80 www.danei.com" &gt;&gt; /etc/hosts如果客户端是windows主机，则使用记事本程序打开C:\windows\System32\drivers\etc\hosts添加名称解析当点击http://www.danei.com页面中任意链接时，地址栏上的地址，都会变成192.168.88.11。通过以下方式修复它：# 在nfs服务器上修改配置文件
[root@nfs ~]# vim /nfs_root/html/wp-config.php 
# define('DB_NAME', 'wordpress')它的上方添加以下两行：
define('WP_SITEURL', 'http://www.danei.com');
define('WP_HOME', 'http://www.danei.com');以上就是全部的云计算第一个简单项目了，该项目主要讲述了，搭建网站的lnmp结构。和相关的数据库读写分离，web服务器的keepalived，与NGINX的负载均衡设值。彩蛋：很多国产监控面板，上面都有一键建站功能，你熟悉了上述功能之后，你就可以快速上手使用了。功能也很多，和华为云、阿里云也有合作。在两家平台创建服务器时，可以自己勾选宝塔面板，安装在服务器上。设置也方便绑定ip。windterm等远程连接软件，都可以在命令行输入bt      调用出bt终端。想要下载可以点下方链接，下载电脑对应版本。宝塔面板下载，免费全能的服务器运维软件我不是打广告的，宝塔也没给我钱嗷，喜欢就可以试试，毕竟宝塔本省也是国产监控软件 的一种，了解一下。^_^问题：  单机版可以进入自己的域名网站，自己也可以领ssl测试证书。如果是公网部署网站，需要自己买域名，配置SSL安全证书，网站工商局网上备案等相关细微操作。http://www.ppmy.cn/news/1540703.html相关文章如何利用动态IP进行数据采集？在数据驱动的时代&amp;#xff0c;动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限&amp;#xff0c;从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集&amp;#xff0c;为企业提升信息获取能力提供实用指导。 
如何利用动态IP进行…阅读更多...前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:22 +0000</pubDate>
    </item>
    <item>
      <title>如何利用动态IP进行数据采集？</title>
      <link>https://www.ppmy.cn/news/1540702.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维如何利用动态IP进行数据采集？news/2025/10/31 21:30:20/在数据驱动的时代，动态IP成为进行高效数据采集的利器。动态IP可以通过频繁更换IP地址避免因频繁访问而受限，从而实现更顺畅的数据获取。本文将详细探讨如何利用动态IP进行数据采集，为企业提升信息获取能力提供实用指导。如何利用动态IP进行数据采集？1. 理解动态IP的基本原则在开始利用动态IP进行数据采集之前，理解其工作原理至关重要。动态IP，即动态分配的互联网协议地址，指的是用户每次连接网络时，其IP地址都可能发生变化。主要好处：规避访问限制：通过不断更换IP地址，避免因请求频率过高而引起的限制。提升采集成功率：扩大IP资源多样性，增加获取难以访问数据的成功几率。2. 选择合适的动态IP服务商数据采集的效果很大程度上依赖于动态IP服务商的质量和技术支持。在选择服务商时，需要考量以下几点。选择标准：IP覆盖范围：选择拥有广泛全球IP覆盖的服务商，以便访问全球市场数据。切换速度与频率：优选支持快速频繁切换的动态IP服务，确保数据采集的连续性和多样性。服务的可靠性与可用性：寻找能够提供高可用率和稳定IP资源池的供应商，例如青果网络。3. 在采集中应用动态IP在实践中，利用动态IP进行数据采集涉及多个步骤和策略，以确保高效且稳妥的数据获取。采集策略：设计分布式采集架构：将采集任务分布在多个代理节点，最大限度地利用动态IP的多样性，提升整体采集效率。智能IP轮换机制：设定合理的IP切换频率，在不触发目标网站反制策略的前提下，获得更丰富且稳定的数据。调整数据请求调度：精心设计请求频率和间隔时间，根据目标网站的防护策略调整采集节奏。4. 确保数据采集的合规性尽管动态IP在技术上为数据采集提供了便利，但企业仍需遵守各地区法律法规，确保采集活动的合规性。合规建议：遵循robots.txt协议：在采集数据前检查网站的robots.txt文件，确定可被合法抓取的数据范围。尊重隐私保护法：确保数据采集过程中不侵犯个人隐私，遵守数据保护相关法律。结论动态IP通过其灵活的切换和广泛的覆盖，为数据采集提供了实质性的推动力。拥有适合的动态IP支持，能够显著提升企业的信息获取能力，并保障数据采集过程的持续性和合法性。希望本文为您指明了利用动态IP采集数据的有效方法，并为您的业务增长提供持续动力。http://www.ppmy.cn/news/1540702.html相关文章前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试一、开篇寄语&amp;#xff1a; 
在准备考研复试的关键时期&amp;#xff0c;许多学弟学妹们往往会寻求各种资料来辅助复习&amp;#xff0c;市面上也因此涌现了大量的“考研复试全流程全攻略”。然而&amp;#xff0c;这些攻略往往存在以下问题&amp;#xff1a; 
1、内容不完整性 
遗漏关键信息&amp;#x…阅读更多...OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:20 +0000</pubDate>
    </item>
    <item>
      <title>前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试</title>
      <link>https://www.ppmy.cn/news/1540701.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维前言——25机械考研复试专业面试问题汇总 机械复试超全流程攻略 机械复试看这一个专栏就够用了！机械复试调剂英语自我介绍口语专业面试常见问题总结 机械保研面试news/2025/10/31 21:30:19/一、开篇寄语：在准备考研复试的关键时期，许多学弟学妹们往往会寻求各种资料来辅助复习，市面上也因此涌现了大量的“考研复试全流程全攻略”。然而，这些攻略往往存在以下问题：1、内容不完整性遗漏关键信息：许多攻略在描述考研复试流程时，未能全面覆盖所有关键环节，导致考生可能忽视某些重要的准备事项。浅尝辄止：即便某些攻略提到了复试的各个环节，但在具体细节和应对策略上往往一带而过，缺乏深度和实用性。2、缺乏深入剖析框架信息为主：多数攻略仅停留在提供复试的基本框架信息层面，如流程、时间节点等，而未能深入剖析每个环节的内在要求和应对策略。无完整的专业面试题总结：对于复试中的专业知识深化、英语口语提升、面试技巧训练以及心理状态调整等关键方面，这些攻略往往缺乏具体、实用的技巧和策略指导。3、误导性与时间浪费信息误导：由于内容的不完整和缺乏深入剖析，这些攻略可能给考生带来误导，使他们在复习过程中偏离正确的方向。时间成本高昂：考生需要花费大量时间和精力去筛选和验证这些攻略中的信息，这不仅浪费了宝贵的时间，还可能影响复习效率和效果。为了解决上述问题，我们的专栏则致力于为考生提供一份真正全流程详细且完整的考研复试指南。从复试的各个环节入手，我们不仅全面梳理了复试的流程、内容、形式等基本信息，还深入挖掘了每个环节背后的核心要点和应对策略。专栏包括：复试全流程及经验总结、个人简历模板凝练与导师邮件、英语口语自我介绍模板、36个超详细常见英语口语话题模板、50问综合素质面试话题模板、13门机械专业最常见专业面试问题真题【重点！按科目章节总结80000字】、以及调剂全流程。本专栏全文10w字体！一个专栏在手，面试你无需再寻找其他资料，节省大量的时间。因此，我们诚挚地建议正在为考研复试努力的学弟学妹们，在选择复习资料时务必谨慎。与其在众多的不完整攻略中浪费时间、迷失方向，不如选择我们专栏这份真正全流程详细且完整的复试指南！下面为本栏全目录的展示：↓↓一、复试面试全流程及经验篇【即本文篇章内容】1.1、出国家线前的准备】1.2、复试的准备】1.3、联系导师的准备及附上参考邮件】1.4、复试前材料的提交准备】1.5、复试心理准备的调节】1.6、模拟面试与技巧提升】1.7、面试套路之遇到不懂的回答】二、个人简历内容凝练2.1、个人简历核心内容提取】2.2、个人简历模板参考】2.3、个人简历没有内容写，重要内容排序】2.4、联系导师邮件模板--出成绩前和出成绩后】2.5、联系导师的时机】2.6、如何选择导师】2.7、与导师沟通的注意事项】2.8、导师未回复的情况】2.9、联系导师的策略】2.10、联系导师的常见问题】2.11、面试的准备】2.12、制定计划】三、英语口语面试自我介绍篇【10篇自我介绍】3.1、英文自我介绍的整体框架3.2、考研复试英语自我介绍的6点注意事项：3.3、英语自我介绍模板【直接用！】3.4、如何快速提高自我介绍的能力3.5、如何快速提高英语口语能力3.6、应对口语不流利的策略3.7、结语--复试面试全流程及经验四、英语口语面试常见面试话题攻略【36个热门话题+答案】4.1、个人信息类话题4.2、社会科学实践类话题4.3、本科学习成绩类话题4.4、院校报考动机类话题4.5、未来职业规划类话题4.6、成长压力面试类话题4.7、快速提高英语口语能力策略4.8、应对口语不流畅技巧五、综合素质面试常见面试话题攻略【50问话题+答案】5.1、中文个人信息类话题5.2、中文社会科学实践类话题5.3、中文本科学习成绩类话题5.4、中文院校报考动机类话题5.5、中文未来职业规划类话题5.6、中文成长压力面试类话题5.7 中文简历类话题5.8 闲聊类话题5.9 总结六、25机械专业面试最常见面试问题总结--按科目章节总结【超详细！】6.1材料力学面试重点概念43题6.2控制工程面试重点概念提问52题6.3数控技术面试重点概念提问44题6.4机械制造技术基础面试重点概念提问65题6.5机械设计重点面试概念提问61题6.6理论力学面试重点知识提问63题6.7液压传动面试重点知识提问38题6.8机械原理面试重点提问65题6.9工程材料面试重点提问57题6.10互换性与技术测量面试重点提问34题6.11测试技术面试重点题目54题6.12汽车理论重点面试48问6.13程序设计与C语言面试题6.14常见面试题目汇总60题七、考研调剂信息的全流程7.1、考研调剂的基本概念7.2、自主划线与国家线的差异7.3、调剂的类别与优先级7.4、申请调剂的资格准则7.5、基本申请门槛:7.6、调剂的九大禁忌情形7.7、调剂的详细流程7.8、调剂的关键时间节点7.9、如何高效搜集调剂信息？7.10、准备调剂所需材料7.11、调剂是否需要提前联系导师？7.12、调剂的六大原则7.13、调剂注意事项：避免调剂过程中的常见误区7.14、为何有些学校会有调剂名额？二、你能够获得什么目标？当你深入阅读并实践我们这份考研复试专栏的内容时，你将不仅仅是在为复试做准备，更是在为未来的学术生涯或职业生涯奠定坚实的基础。我们的目标是帮助你：全面掌握复试技巧：从专业知识到面试技巧，再到心理调适，全方位提升你的复试能力。精准定位个人优势：通过自我分析和定位，发掘并强化你的个人亮点，让面试官眼前一亮。高效备考，事半功倍：提供科学的复习方法和时间管理技巧，让你的备考之路更加高效、有序。三、最大的亮点：一站式复习：无需四处搜集资料，一本在手，本科核心重点精华全部掌握。高效备考：短时间内快速巩固基础，直击考点，为面试做好充分准备。实战导向：紧贴最新面试趋势，用真题说话，提升应试实战能力。专业认可：专业教师作答，确保内容权威，提升个人竞争力。四、第七部分专业面试问题内容形式：按科目结构细分：指南按各科目的每一章节进行排序，能够让考生逐一击破每门科目，条理清晰，更容易加深印象，帮助读者循序渐进地掌握每一门学科的核心内容，有效避免信息过载和混淆，让学习更加高效有序。问答题形式呈现：所有内容均以问答题形式呈现，回答经过与资深专业教师反复讨论，确保答案的专业性和准确性，彰显应试者的专业素养。24最新真题融入：加入了2024年度的各大高校面试真题，不仅帮助考生紧跟考试动态，还能深入洞察命题趋势，为面试备考提供精准导航。多场景适用性：无论是机械大类、车辆工程专业的考研复试、夏令营选拔，还是考博的专业面试，本指南都能成为你不可或缺的备考利器，助力你在激烈的竞争中脱颖而出。五、内容目标受众：准备参加考研复试的学子。参加夏令营的学子。准备参加博士面试的学子。六、学习建议系统学习：按照专栏的章节顺序，系统学习每一个知识点和技巧。实践应用：将学到的知识应用到模拟试题和真实场景中，不断检验和提升自己。定期回顾：定期回顾已学内容，巩固记忆，确保知识掌握得更加牢固。心态调整：保持积极乐观的心态，面对挑战时保持冷静和自信。七、版权说明本专栏的所有内容均受版权保护，未经授权，任何单位和个人不得以任何形式进行复制、传播或销售。我们尊重每一位创作者的劳动成果，也希望你能够尊重我们的版权，共同维护一个健康、有序的知识分享环境。八、专栏致谢感谢每一位参与创作和审核的团队成员，是你们的辛勤付出和无私奉献，才使得这份专栏得以问世。同时，也要感谢所有支持和关注我们的读者朋友们，是你们的鼓励和反馈，让我们不断前行，追求卓越。九、建议如果你对专栏有任何疑问或建议，或者需要进一步的个性化指导，欢迎随时联系。http://www.ppmy.cn/news/1540701.html相关文章OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用操作系统&amp;#xff1a;ubuntu22.04 OpenCV版本&amp;#xff1a;OpenCV4.9 IDE:Visual Studio Code 编程语言&amp;#xff1a;C11 
算法描述 
允许用户在给定的图像上选择多个 ROI。 
该函数创建一个窗口&amp;#xff0c;并允许用户使用鼠标来选择多个 ROI。控制方式&amp;#xff1a;使用空格键或…阅读更多...论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:19 +0000</pubDate>
    </item>
    <item>
      <title>OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用</title>
      <link>https://www.ppmy.cn/news/1540700.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维OpenCV高级图形用户界面(14)交互式地选择一个或多个感兴趣区域函数selectROIs()的使用news/2025/10/31 21:30:18/操作系统：ubuntu22.04OpenCV版本：OpenCV4.9IDE:Visual Studio Code编程语言：C++11算法描述允许用户在给定的图像上选择多个 ROI。该函数创建一个窗口，并允许用户使用鼠标来选择多个 ROI。控制方式：使用空格键或回车键完成当前的选择并开始一个新的选择，使用 ESC 键终止多个 ROI 的选择过程。注意该函数使用 cv::setMouseCallback(windowName, …) 为指定的窗口设置自己的鼠标回调。工作完成后，将为使用的窗口设置一个空的回调。函数原型voidcv::selectROIs(constString&amp;windowName,InputArray 	img,std::vector&lt;Rect&gt;&amp;boundingBoxes,boolshowCrosshair=true,boolfromCenter=false,boolprintNotice=true)参数参数windowName 显示选择过程的窗口的名称。参数wimg 用于选择 ROI 的图像。参数wboundingBoxes 选定的 ROIs。参数wshowCrosshair 如果为真，则将显示选择矩形的十字光标。参数wfromCenter 如果为真，则选择的中心将匹配初始鼠标位置。相反的情况下，选择矩形的一个角将对应于初始鼠标位置。参数wprintNotice 如果为真，则将在控制台中打印选择 ROI 或取消选择的通知。代码示例#include&lt;iostream&gt;#include&lt;opencv2/opencv.hpp&gt;intmain(){// 加载图像cv::Mat img=cv::imread("/media/dingxin/data/study/OpenCV/sources/images/hawk.jpg",cv::IMREAD_COLOR);if(img.empty()){std::cerr&lt;&lt;"Error: Image not found!"&lt;&lt;std::endl;return-1;}// 创建窗口std::string windowName="Select ROIs";cv::namedWindow(windowName,cv::WINDOW_NORMAL);// 显示图像cv::imshow(windowName,img);// 准备存储 ROI 的向量std::vector&lt;cv::Rect&gt;boundingBoxes;// 提示用户如何进行选择std::cout&lt;&lt;"Use the mouse to draw rectangles around the regions you want to select."&lt;&lt;" Press space or enter to confirm a selection and start a new one."&lt;&lt;" Press ESC to finish the selection process."&lt;&lt;std::endl;// 选择 ROIscv::selectROIs(windowName,img,boundingBoxes,false,false,true);// 检查是否有 ROI 被选中if(!boundingBoxes.empty()){// 打印所选区域的信息std::cout&lt;&lt;"Selected ROIs:"&lt;&lt;std::endl;for(constauto&amp;roi:boundingBoxes){std::cout&lt;&lt;"ROI at ("&lt;&lt;roi.x&lt;&lt;", "&lt;&lt;roi.y&lt;&lt;") with size ("&lt;&lt;roi.width&lt;&lt;", "&lt;&lt;roi.height&lt;&lt;")"&lt;&lt;std::endl;}// 在原图上画出所选区域的边界框for(constauto&amp;roi:boundingBoxes){cv::rectangle(img,roi,cv::Scalar(0,255,0),2);}// 显示带有边界框的图像cv::imshow(windowName,img);cv::waitKey(0);// 等待用户按键}else{std::cout&lt;&lt;"No ROIs were selected."&lt;&lt;std::endl;}// 关闭所有窗口cv::destroyAllWindows();return0;}运行结果http://www.ppmy.cn/news/1540700.html相关文章论文阅读-U3M(2)HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE? 文章目录 HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络&amp;#xff08;PosENet&amp;#xff09;二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosEN…阅读更多...【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:18 +0000</pubDate>
    </item>
    <item>
      <title>论文阅读-U3M(2)</title>
      <link>https://www.ppmy.cn/news/1540699.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维论文阅读-U3M(2)news/2025/10/31 21:30:16/HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?文章目录HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?前言一、位置编码网络（PosENet）二、训练数据三、实验3.1 位置信息的存在性3.2 分析PosENet3.3 位置信息存储在哪里？3.4 位置信息来自哪里？四、结论在阅读Segformer论文中，设计一个高效、有用、轻量的分割模型，其中对编码器的设计中对位置嵌入做了改进，使用一个卷积来完成位置编码。这个思想就是借鉴了“HOW MUCH POSITION INFORMATION DO CONVOLUTIONAL NEURAL NETWORKS ENCODE?”这篇文章。中文名翻译过来就是多少位置编码信息被卷积神经网络学习？前言在使用基于CNN的模型学习数据特征时，由于CNN是使用卷积在输入图像局部的滑动卷积提取特征，所以想当然的认为基于CNN的方法很难感知到图像的绝对位置信息。但是作者发现了一个有趣的现象，我们通常认为图像的显著性区域集中在图像中心，在对图像进行裁剪后（显著性区域内容不会变化，但是位置会发生变化），模型仍然可以感知到显著性区域。因此作者提出一个假设：卷积神经网络能够隐式地将图像的绝对位置编码进特征图中。作者通过一系列随机化测试来验证该假设。一、位置编码网络（PosENet）前馈网络编码器：编码器由5个特征提取器组成f θ 1 , f θ 2 , f θ 3 , f θ 4 , f θ 5 f_{\theta}^1,f_{\theta}^2,f_{\theta}^3,f_{\theta}^4,f_{\theta}^5fθ1​,fθ2​,fθ3​,fθ4​,fθ5​，网络从浅层到深层提取不同层次的特征f p o s 1 , f p o s 2 , f p o s 3 , f p o s 4 , f p o s 5 f_{pos}^1,f_{pos}^2,f_{pos}^3,f_{pos}^4,f_{pos}^5fpos1​,fpos2​,fpos3​,fpos4​,fpos5​。编码器部分的计算过程被表示如下：f p o s i = f θ i ( W α ∗ I m ) f_{pos}^i=f_\theta^i(W_\alpha * I_m)fposi​=fθi​(Wα​∗Im​)其中W α W_\alphaWα​表示冻结的权重。∗ *∗表示卷积操作。前馈网络编码器只用于提取特征提取，其权重是由预训练是预训练得到的。位置编码器：位置编码器的输入是经过前馈网络得到的多尺度特征f p o s 1 , f p o s 2 , f p o s 3 , f p o s 4 , f p o s 5 f_{pos}^1,f_{pos}^2,f_{pos}^3,f_{pos}^4,f_{pos}^5fpos1​,fpos2​,fpos3​,fpos4​,fpos5​。然后应用双线性插值拉起多尺度特征图的空间维度，然后对它们做concat操作,得到特征图f p o s c f_{pos}^cfposc​, 然后对f p o s c f_{pos}^cfposc​做卷积操作和变换方程T p o s \mathcal{T}_{pos}Tpos​将特征图为位置图。具体的操作如下：f p o s c = ( f p o s 1 ⊕ . . . ⊕ f p o s 5 ) f ^ p = W p o s c ∗ f p o s c f_{pos}^c=(f_{pos}^1\oplus...\oplus f_{pos}^5) \ \ \ \ \ \ \ \ \ \ \hat{f}_p={W_{pos}^c*f_{pos}^c}fposc​=(fpos1​⊕...⊕fpos5​)f^​p​=Wposc​∗fposc​其中W p o s c W_{pos}^cWposc​是与变换函数T p o s \mathcal{T}_{pos}Tpos​相连的可训练权重。编码模块添加主要目的是用于验证前馈网络编码器是否隐式地学习了位置信息。如果没有在特征图中编码位置信息，那么PosENet的输出应该是随机的。二、训练数据为了验证卷积神经网络中是否学习到位置信息，我们分配一个归一化类似梯度的位置图作为Ground Truth来进行随机化测试。在实施过程中，选择了五种类似梯度的掩码：水平方向（H）、垂直方向（V）、高斯方向（G）、水平条纹（HS）以及垂直条纹（VS）。从图中可以看到Ground Truth 和图像内容无关，所以每一张位置GT可以对应任意的图像。作者采用了多种位置编码去验证卷积神经网络对位置编码的学习情况。如果特征图中没有特征编码信息，那么输出则很难匹配GT，相反，如果特征图中隐式地编码了位置信息，那么，就可以匹配到GT。三、实验在实验结果中，VGG表示PosENet基于VGG16模型中提取特征。ResNet表示PosENet基于ResNet模型提取特征，而PosENet则表示仅应用PosENet模型直接从输入图像中学习位置信息。为了证明卷积神经网络可以隐式的编码绝对位置这个假设，作者做了4组实验：位置信息的存在性（对比有无前馈编码器提取特征）、分析PosENet（分析PosENet中卷积的大小和卷积层的层数对读取绝对位置的能力）、位置信息存储位置（主要是通过分析前馈神经不同层中对位置编码的能力）、位置信息来自哪里（对比有无zero-padding）。3.1 位置信息的存在性在这部分，在5种GT图像上训练带有前馈编码VGG和ResNet的PosNet网络以及仅仅应用PosENet网络（用于验证位置信息是不是从对物体的内容感知中获取的，此外在本部分的实验中PosENet仅使用了3x3的单个卷积层，并且未使用zero-padding），对应的定量的结果如Table1所示。从Table1中可以看到在5种GT实验中，使用前馈编码器的PosENent模型，不使用前馈编码器的PosENet的得分普遍较低。这个结果说明，仅仅从输入图像中提取位置信息是非常困难的。PosENet仅仅从输入图像中提取位置信息是非常困难的，只有在与深度编码网络结合时，才能提取与真实位置图一致的定位信息。通过不同模式下的测试，可以较好证明了模型并非盲目的过度拟合噪声，而是正在提取真实的定位信息。3.2 分析PosENet在这部分，作者设计了两个消融实验来检验编码网络的作用。（1）卷积层的堆叠长度的作用（a图）（2）卷积核大小的作用（b图）。从（a）图中的结果中可以看到，增加更多的层能够使模型获得更高的得分，其中一个原因时堆叠多个卷积层可以使网络具有更大的感受野，另一个可能是位置信息的转换可能需要高于一阶推理的方式表示。从（b）图中可以看到，较大的卷积核可能更有利于捕获更多的位置信息，这意味着位置信息可能在层内和特征空间中分布的更加广泛，进而更大感受野可以更好的解析位置信息。3.3 位置信息存储在哪里？前面的实验揭示了位置信息被编码在一个预训练的CNN模型中，那么那一层回编码更多的信息呢？作者使用基于VGG-16作为前馈编码器的模型为例用于检验在f p o s 1 , f p o s 2 , f p o s 3 , f p o s 4 , f p o s 5 f_{pos}^1,f_{pos}^2,f_{pos}^3,f_{pos}^4,f_{pos}^5fpos1​,fpos2​,fpos3​,fpos4​,fpos5​中哪一层中编码了更多的信息。从表3中可以看到来自深层的f p o s 5 f_{pos}^5fpos5​特征相比浅层的f p o s 1 f_{pos}^1fpos1​特征得到了更好的表现。因此这表明网络越深层处的编码器对位置信息的编码能力更强。同样这也和深层视觉特征看的特征更偏向全局的观点相吻合。3.4 位置信息来自哪里？作者在实验中证明了CNN能够学习到位置编码主要归因于zero-padding过程。是的，是源自如此基础性的内容。作者是通过对比在编码器中使用Zero-padding和不使用Zero-padding来验证这一点。实验结果如表4和图6所示，可以看的，在没有zero-padding的实验中。模型的性能表现最差，远低于默认设置（zero-padding）的情况。当设置更多的zero-padding时，位置信息的作用也变得更加明显。四、结论在本篇文章中，探讨了绝对位置信息是否被隐式地编码在卷积神经网络中的假设。通过对比是否使用前馈编码器输出的特征的实验证明了卷积神经网络确实能够隐式地学习到图像的绝对位置信息。通过分析卷积核的大小和卷积层的层数证明了，更大的感受野和非线性读取位置信息进一步增强了单层3x3PosENet对位置的读取能力。通过分析前馈编码器不同层的位置编码能力得出更深的特征提取层具有更好的位置编码能力。通过对比编码器中是否设置zero-padding操作，验证了卷积神经网络对图像的位置编码能力主要来源于zero-padding。http://www.ppmy.cn/news/1540699.html相关文章【LeetCode每日一题】——523.连续的子数组和文章目录 一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】 一【题目类别】 
前缀和 
二【题目难度】 
中等 
三【题目编号】 
523.连续的子数组和 
四【题目描述】 
给你一个…阅读更多...第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:17 +0000</pubDate>
    </item>
    <item>
      <title>【LeetCode每日一题】——523.连续的子数组和</title>
      <link>https://www.ppmy.cn/news/1540698.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【LeetCode每日一题】——523.连续的子数组和news/2025/10/31 21:30:15/文章目录一【题目类别】二【题目难度】三【题目编号】四【题目描述】五【题目示例】六【题目提示】七【解题思路】八【时间频度】九【代码实现】十【提交结果】一【题目类别】前缀和二【题目难度】中等三【题目编号】523.连续的子数组和四【题目描述】给你一个整数数组nums和一个整数k，如果nums有一个好的子数组返回true，否则返回false：一个好的子数组是：长度至少为2，且子数组元素总和为k的倍数。注意：子数组是数组中连续的部分。如果存在一个整数n，令整数x符合x = n * k，则称x是k的一个倍数。0始终视为k的一个倍数。五【题目示例】示例 1：输入：nums = [23,2,4,6,7], k = 6输出：true解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。示例 2：输入：nums = [23,2,6,4,7], k = 6输出：true解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。示例 3：输入：nums = [23,2,6,4,7], k = 13输出：false六【题目提示】1 &lt; = n u m s . l e n g t h &lt; = 1 0 5 1 &lt;= nums.length &lt;= 10^51&lt;=nums.length&lt;=1050 &lt; = n u m s [ i ] &lt; = 1 0 9 0 &lt;= nums[i] &lt;= 10^90&lt;=nums[i]&lt;=1090 &lt; = s u m ( n u m s [ i ] ) &lt; = 2 31 − 1 0 &lt;= sum(nums[i]) &lt;= 2^{31} - 10&lt;=sum(nums[i])&lt;=231−11 &lt; = k &lt; = 2 31 − 1 1 &lt;= k &lt;= 2^{31} - 11&lt;=k&lt;=231−1七【解题思路】前缀和思想：设prefix_sum[i]表示数组nums的前缀和，即prefix_sum[i]表示nums从第0到第i的元素的和。对于任意两个下标i和j（i &lt; j），子数组nums[i+1:j+1]的和可以表示为prefix_sum[j] - prefix_sum[i]。取模运算：我们需要找到两个前缀和prefix_sum[j] 和 prefix_sum[i]，使得它们的差prefix_sum[j] - prefix_sum[i]是k的倍数。我们可以通过对前缀和取模的方式（哈希表）来简化这个问题：如果prefix_sum[j] % k == prefix_sum[i] % k，那么prefix_sum[j] - prefix_sum[i]一定是k的倍数（同余定理）。边界情况处理：如果k == 0，则子数组的和必须为0，所以需要特判。由于子数组的长度至少为2，所以当找到满足条件的前缀和时，还需要确保两个下标之间的距离大于等于2。最后返回结果即可具体细节可以参考下面的代码八【时间频度】时间复杂度：O ( m ) O(m)O(m)，m mm为传入的数组的长度空间复杂度：O ( m i n ( m , k ) ) O(min(m, k))O(min(m,k))，m mm为传入的数组的长度，k kk为计算得到的余数的个数九【代码实现】Java语言版classSolution{publicbooleancheckSubarraySum(int[]nums,intk){// 用于存储取模后的前缀和与其下标, 初始化表示前缀和为0时在-1位置HashMap&lt;Integer,Integer&gt;hashMap=newHashMap&lt;Integer,Integer&gt;();hashMap.put(0,-1);// 初始化前缀和intprefixSum=0;for(inti=0;i&lt;nums.length;i++){// 更新前缀和prefixSum+=nums[i];if(k!=0){// 对 k 取模prefixSum%=k;}// 检查当前取模后的前缀和是否已经在哈希表中if(hashMap.containsKey(prefixSum)){// 如果存在，并且下标差大于等于 2，则找到符合条件的子数组if(i-hashMap.get(prefixSum)&gt;1){returntrue;}}else{// 不存在则记录当前前缀和对应的下标hashMap.put(prefixSum,i);}}returnfalse;}}Python语言版classSolution:defcheckSubarraySum(self,nums:List[int],k:int)-&gt;bool:# 用于存储取模后的前缀和与其下标, 初始化表示前缀和为0时在-1位置hash_map={0:-1}# 初始化前缀和prefix_sum=0fori,numinenumerate(nums):# 更新前缀和prefix_sum+=numifk!=0:# 对 k 取模prefix_sum%=k# 检查当前取模后的前缀和是否已经在哈希表中ifprefix_suminhash_map:# 如果存在，并且下标差大于等于 2，则找到符合条件的子数组ifi-hash_map[prefix_sum]&gt;1:returnTrueelse:# 不存在则记录当前前缀和对应的下标hash_map[prefix_sum]=ireturnFalseC++语言版classSolution{public:boolcheckSubarraySum(vector&lt;int&gt;&amp;nums,intk){// 用于存储取模后的前缀和与其下标, 初始化表示前缀和为0时在-1位置unordered_map&lt;int,int&gt;hashMap;hashMap[0]=-1;// 初始化前缀和intprefixSum=0;for(inti=0;i&lt;nums.size();i++){// 更新前缀和prefixSum+=nums[i];if(k!=0){// 对 k 取模prefixSum%=k;}// 检查当前取模后的前缀和是否已经在哈希表中if(hashMap.find(prefixSum)!=hashMap.end()){// 如果存在，并且下标差大于等于 2，则找到符合条件的子数组if(i-hashMap[prefixSum]&gt;1){returntrue;}}else{// 不存在则记录当前前缀和对应的下标hashMap[prefixSum]=i;}}returnfalse;}};十【提交结果】Java语言版Python语言版C++语言版http://www.ppmy.cn/news/1540698.html相关文章第2节 如何学习鸿蒙技术以下是学习鸿蒙技术的一些途径&amp;#xff1a; 一、官方文档与资源 1. 华为开发者官网 
• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档&amp;#xff0c;包括架构介绍、开发指南、API参考等内容。例如&amp;#xff0c;对于初学者来说&amp;#xff0c;可以从入门教程开始&amp;am…阅读更多...015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:16 +0000</pubDate>
    </item>
    <item>
      <title>第2节 如何学习鸿蒙技术</title>
      <link>https://www.ppmy.cn/news/1540697.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维第2节 如何学习鸿蒙技术news/2025/10/31 21:30:14/以下是学习鸿蒙技术的一些途径：一、官方文档与资源1. 华为开发者官网• 这是最权威的学习资源平台。官网提供了详细的鸿蒙操作系统的文档，包括架构介绍、开发指南、API参考等内容。例如，对于初学者来说，可以从入门教程开始，逐步了解鸿蒙系统的基本概念、开发环境搭建等基础知识。• 还有一些官方的代码示例和案例分析，通过研究这些示例，可以快速掌握鸿蒙应用开发的基本流程和代码规范。2. 鸿蒙开源项目• 参与鸿蒙开源项目可以深入学习其代码结构和实现原理。在开源社区中，可以与其他开发者交流经验，共同解决遇到的问题。同时，通过阅读开源代码，可以学习到鸿蒙系统的先进技术和设计思想。二、在线课程与培训1. 华为官方培训课程• 华为提供了一系列针对鸿蒙开发的线上线下培训课程。这些课程由华为的专家和工程师授课，内容涵盖了从基础到高级的鸿蒙技术知识。课程中通常包含实践操作环节，有助于提高开发者的实际动手能力。2. 在线学习平台• 在线学习平台也有不少关于鸿蒙开发的课程。这些课程由有经验的开发者或培训机构制作，适合不同层次的学习者。有些课程专门针对零基础的初学者，从鸿蒙开发环境搭建开始讲解；而有些课程则侧重于高级开发技巧，如鸿蒙系统的性能优化等。三、实践项目1. 个人小项目开发• 从简单的鸿蒙应用开始做起，如开发一个简单的鸿蒙手机应用，实现一个基本功能，如天气查询、待办事项管理等。通过实践项目，可以加深对鸿蒙技术的理解，掌握开发工具的使用和应用的部署流程。2. 参与开源项目或竞赛• 参与鸿蒙相关的开源项目，可以与其他开发者合作，拓宽技术视野。同时，参加鸿蒙开发竞赛也是一个很好的学习机会，在竞赛中可以接触到更多有挑战性的项目需求，促使自己不断学习和提高。http://www.ppmy.cn/news/1540697.html相关文章015集——c# 实现CAD excel交互（CAD—C#二次开发入门）第一步&amp;#xff1a;添加引用 程序集—&gt;扩展 namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e…阅读更多...GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:14 +0000</pubDate>
    </item>
    <item>
      <title>015集——c# 实现CAD excel交互（CAD—C#二次开发入门）</title>
      <link>https://www.ppmy.cn/news/1540696.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维015集——c# 实现CAD excel交互（CAD—C#二次开发入门）news/2025/10/31 21:30:13/第一步：添加引用 程序集—&gt;扩展namespace WindowsFormsApp2
{public partial class Form1 : Form{public Form1(){InitializeComponent();}private void Form1_Load(object sender, EventArgs e){}private void 获取当前excel_Click(object sender, EventArgs e){try{//后期绑定获取当前exceldynamic Excelapp = System.Runtime.InteropServices.Marshal.GetActiveObject("Excel.Application");//object换成动态dynamicExcelapp.visible = true;dynamic wbk = Excelapp.Workbooks.Add();dynamic wst = wbk.Worksheets[1];//com中数组第一个item是1wst.Name = "dz";string[] title = new string[] { "姓名", "年龄", "住所" };wst.Range["A1:C1"].Value = title;}catch (Exception){MessageBox.Show(" 错了");}}private void 关闭当前excel_Click(object sender, EventArgs e){dynamic Excelapp = System.Runtime.InteropServices.Marshal.GetActiveObject("Excel.Application");//object换成动态dynamic//Excelapp.DisplayAlerts = false;Excelapp.Quit();Excelapp.Quit();}private void 打开excel_Click(object sender, EventArgs e){System.Type ET = System.Type.GetTypeFromProgID("Excel.Application");dynamic Excelapp = System.Activator.CreateInstance(ET);Excelapp.visible = true;dynamic wbk = Excelapp.Workbooks.Add();dynamic wst = wbk.Worksheets[1];//com中数组第一个item是1wst.Name = "dz";string[] title = new string[] { "姓名", "年龄", "住所" };wst.Range["A1:C1"].Value = title;}private void 关闭窗口_Click(object sender, EventArgs e){this.Close();}}
}http://www.ppmy.cn/news/1540696.html相关文章GNU 链接脚本官方手册 The GNU linker 目录 3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令 3.5 为符号赋值3.5.1 简单赋值…阅读更多...数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:13 +0000</pubDate>
    </item>
    <item>
      <title>GNU 链接脚本</title>
      <link>https://www.ppmy.cn/news/1540695.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维GNU 链接脚本news/2025/10/31 21:30:12/官方手册 The GNU linker目录3 链接脚本3.1 基本链接脚本概念3.2 链接脚本格式3.3 简单链接脚本示例3.4 简单链接脚本命令3.4.1 设置入口点3.4.2 处理文件的命令3.4.3 处理对象文件格式的命令3.4.4 为内存区域指定别名3.4.5 其他链接器脚本命令3.5 为符号赋值3.5.1 简单赋值3.5.2 隐藏3.5.3 提供3.5.4 提供隐藏3.5.5 源代码参考3.6 SECTIONS 命令3.6.1 输出部分描述3.6.2 输出部分名称3.6.3 输出部分地址3.6.4 输入部分描述3.6.4.1 输入节基本说明3.6.4.2 输入节通配符模式3.6.4.3 常用符号输入部分3.6.4.4 输入段和垃圾回收3.6.4.5 输入部分示例3.6.5 输出部分数据3.6.6 输出部分关键字3.6.7 输出部分的丢弃3.6.8 输出分段的丢弃3.6.8.1 输出分段类型3.6.8.2 输出部分 LMA3.6.8.3 强制输出对齐3.6.8.4 强制输入对齐3.6.8.5 输出分段约束3.6.8.6 输出分段区域3.6.8.7 输出节 Phdr3.6.8.8 输出剖面填充3.6.9 叠加说明3.7 内存命令3.8 PHDRS 命令3.9 VERSION 命令3.10 连接器脚本中的表达式3.10.1 常量3.10.2 符号常量3.10.3 符号名3.10.4 缺省节3.10.5 位置计数器3.10.6 运算符3.10.7 评估3.10.8 表达式的分段3.10.9 内置函数3.11 隐式链接器脚本3 链接脚本每个链接都由一个链接脚本控制。该脚本使用链接器命令语言编写。链接脚本的主要目的是描述如何将输入文件中的各个部分映射到输出文件中，并控制输出文件的内存布局。大多数链接脚本仅此而已。但是，必要时，链接器脚本也可以使用下面描述的命令来指导链接器执行更多的其它操作。链接器通常使用一个链接脚本。如果没有为其提供，链接器将会使用默认的编译在链接器执行文件内部的脚本。可以使用命令 ’–verbose’ 显示默认的链接脚本。某些命令行选项，例如 ’-r’，’-N’ 会影响默认的链接脚本。你可以通过在命令行使用 ’-T’ 命令使用自己的脚本。如果使用此命令，你的链接脚本将会替代默认链接脚本。也可以通过将脚本作为链接器输入文件隐式的使用链接脚本，参考Implicit Linker Scripts。Basic Script Concepts: 链接器脚本的基本概念Script Format: 链接器脚本的格式Simple Example: 简单的链接器脚本例子Simple Commands: 简单的链接器脚本命令Assignments: 为符号指定数值SECTIONS: 段命令MEMORY: 内存命令PHDRS: PHDRS命令VERSION: 版本命令Expressions: 链接脚本的表达式Implicit Linker Scripts: 隐式链接脚本3.1 基本链接脚本概念为了描述链接脚本语言，我们需要定义一些基本概念和词汇。链接器将输入文件(一个或多个)合并为一个输出文件。输出文件和每个输入文件都采用一种特殊的数据格式，称为目标文件格式。每个文件称为目标文件。输出文件通常称为可执行文件，但出于我们的目的，我们也将其称为目标文件。每个目标文件都有一个段（section）列表。有时把输入文件的段称作输入段，类似的，输出文件的段称作输出段。目标文件中的每个段都有名称和大小。大多数段还具有关联的数据块，称为段内容。一个段可能被标记为可加载(loadable)，这意味着在运行输出文件时，段内容需要先加载到内存中。一个没有内容的段是可分配的，这意味着应该在内存中预留一个区域，但是这里不需要加载任何东西（在某些情况下，该内存必须清零）。既不可装载也不可分配的部分通常包含某种调试信息。每个可加载或可分配的输出段都有两个地址。第一个是VMA或称为虚拟内存地址。这是运行输出文件时该段将具有的地址。第二个是LMA，即加载内存地址。这是段将会被加载的地址。在大多数情况下，这两个地址是相同的。当然它们也可能不同，一个示例是将数据段加载到ROM中，然后在程序启动时将其复制到RAM中（此技术通常用于初始化基于ROM的系统中的全局变量）。在这种情况下，ROM地址将是LMA，而RAM地址将是VMA。您可以将 *objdump*程序与 ’ -*h* '选项一起使用，以查看目标文件中的各个部分。每个目标文件还具有一个符号列表，称为符号表。符号可以是定义的也可以是未定义的。每个符号都有一个名称，每个定义的符号都有一个地址，以及其他信息。如果将C或C ++程序编译到目标文件中，则将会将所有定义过的函数和全局变量以及静态变量作为已定义符号。输入文件中引用的每个未定义函数或全局变量都将成为未定义符号。您可以使用 *nm* 程序或带有 ‘-*t*’ 选项的 *objdump*程序在目标文件中查看符号。3.2 链接脚本格式链接脚本是文本文件。一个链接器脚本是一系列的命令。每个命令都是一个关键字，可能后面还跟有一个参数，或者一个符号的赋值。使用分号分割命令，空格通常被忽略。类似于文件名或者格式名的字串可以直接输入。如果文件名含有一个字符例如逗号（逗号被用来分割文件名），你可以将文件名放在双引号内部。但是禁止在文件名内使用双引号字符。你可以像C语言一样在链接脚本内包含注释，由’/’和’/’划分。和C一样，注释在句法上被当作空格。3.3 简单链接脚本示例大多数的链接脚本非常简单。最简单的链接脚本只有一个命令：’SECTIONS’ 。 您可以使用 ’SECTIONS’ 命令来描述输出文件的内存布局。’SECTIONS’ 命令功能非常强大。 在这里，我们将描述它的一个简单用法。 假设您的程序仅包含代码，初始化数据和未初始化数据。 它们分别位于“.text”，“.data”和“.bss”段中。 我们进一步假设这些是唯一将会出现在输入文件中的段。在此示例中，假设代码应在地址0x10000处加载，数据应从地址0x8000000开始。下面的链接脚本将会执行如下操作：SECTIONS{.=0x10000;.text:{*(.text)}.=0x8000000;.data:{*(.data)}.bss:{*(.bss)}}您将 ’SECTIONS’ 命令作为关键字 ’SECTIONS’ 编写，然后在花括号中包含一系列符号的赋值和输出段的描述。上例中 ’SECTIONS’ 命令中的第一行设置特殊符号 “.” 的值，即位置计数器。如果未通过其他方式指定输出段的地址（稍后将介绍其他方式），地址就会被设置为位置计数器的当前值。然后将位置计数器增加输出段的大小。在‘SECTIONS’命令的开头，位置计数器的值为 ‘0’ 。第二行定义了一个输出段“.text”。冒号是必需的语法，现在可以忽略它。在输出段名称后面的花括号中，列出应放置在此输出段中的输入段的名称。 “” 是与任何文件名匹配的通配符。表达式 ‘ **(.text)* ’ 表示所有输入文件中的所有 ‘.text*’ 输入段。由于在定义输出段 ‘.text’ 时位置计数器为‘0x10000’，因此链接程序会将输出文件中 ‘.text’ 段的地址设置为‘0x10000’。剩下的行定义了定义输出文件中的‘.data’ 和‘.bss’ 段。链接器会将‘.data’ 输出段放置在地址’0x8000000’处。在链接器放置‘.data’ 段后，位置计数器为’0x8000000’加上‘.data’ 段的大小。因此‘.bss’ 输出段在内存中将会紧紧挨在‘.data’段后面。链接器将通过增加位置计数器（如有必要）来确保每个输出部分具有所需的对齐方式。在此示例中， ‘.text’ 和‘.data’ 段的指定地址可以满足任何对齐方式约束，但链接器可能必须在‘.data’ 和‘.bss’ 段之间创建一个小的间隙。如上，这就是一个简单完整的链接脚本。3.4 简单链接脚本命令在本节中，我们将介绍一些简单的链接脚本命令。Entry Point: 设置入口点File Commands: 处理文件的命令Format Commands: 处理目标文件格式的命令REGION_ALIAS: 为内存区域分配别名Miscellaneous Commands: 其它链接脚本命令3.4.1 设置入口点在程序中执行的第一条指令称为入口点。 您可以使用ENTRY链接器脚本命令来设置入口点。 参数是符号名称：ENTRY(symbol)有几种设置入口点的方法。 链接器将通过依次尝试以下每种方法来设置入口点，并在其中一种成功后停止：‘-e’输入命令行选项；链接描脚本中的ENTRY(symbol)命令；目标专用符号值（如果已定义）； 对于许多目标来说是start符号，但是例如基于PE和BeOS的系统检查可能的输入符号列表，并与找到的第一个符号匹配。‘.text’ 部段的第一个字节的地址（如果存在）；地址0。3.4.2 处理文件的命令以下是链接器脚本处理文件的几个常用命令:（1）*INCLUDE filename*在命令处包含链接脚本文件filename，将在当前目录以及-L选项指定的任何目录中搜索文件。INCLUDE调用嵌套最多10个级别。可以直接把INCLUDE放到顶层、MEMORY或者SECTIONS命令中，或者在输出段的描述中。（2）*INPUT(file, file, …) / INPUT(file file …)*INPUT命令指示链接程序在链接中包含指定的文件，就好像它们是在命令行上命名的一样。例如，如果您始终希望在每次执行链接时都包含subr.o，但又不想将其放在每个链接命令行中，则可以在链接脚本中放置 ‘INPUT (subr.o)’。实际上，您可以在链接描述文件中列出所有输入文件，然后仅用‘-T’选项调用链接脚本。如果配置了sysroot前缀，且文件名以‘/’符开头，并且正在处理的脚本位于sysroot前缀内，则将在sysroot前缀中查找文件名。也可以通过指定=作为文件名路径中的第一个字符，或在文件名路径前加上$ SYSROOT来强制使用sysroot前缀。另请参阅命令行选项中对‘-L’ 的描述(Command-line Options)。如果未使用sysroot前缀，则链接器将尝试打开包含链接器脚本的目录中的文件。如果没有找到，链接器将搜索当前目录。如果仍未找到，链接器将搜索库的搜索路径。如果您使用 ‘INPUT (-lfile)’ ，则ld会将名称转换为libfile.a，就像命令行参数‘-l’一样。当您在隐式链接脚本中使用INPUT命令时，文件在链接脚本文件被包含的时刻才会被加入。这可能会影响库的搜索。（3）*GROUP(file, file, …) / GROUP(file file …)*GROUP命令类似于INPUT，不同之处在于，所有file指出的名字都应该为库，并且所有库将会被重复搜索直到没有新的未定义引用被创建。 请参阅命令行选项中 ‘-(’ 的说明(Command-line Options)。（4）*AS_NEEDED(file, file, …) / AS_NEEDED(file file …)*此构造只能出现在INPUT或GROUP命令以及其他文件名中。命令中的文件将会以类似于直接出现在INPUT或GROUP命令中的文件一样处理，除了ELF共享库，ELF共享库仅在真正需要使用时才被添加。这个构造实质上为其中列出的所有文件启用了 -as-needed 选项，为了恢复以前编译环境，之后需设置 --no-as-needed。（5）*OUTPUT(filename)*OUTPUT命令为输出文件命名。 在链接脚本中使用OUTPUT（filename）*与在命令行中使用 ‘*-o filename’ 一样（请参阅Command-line Options)。 如果两者都使用，则命令行选项优先。您可以使用OUTPUT命令为输出文件定义默认名称，以此替代默认名称a.out。（6）*SEARCH_DIR(path)*SEARCH_DIR命令添加一个ld搜索库的路径。使用SEARCH_DIR(path)与在命令行上使用’ -L path’ 完全一样(参见Command-line Options)。如果同时使用了这两条路径，那么链接器将会搜索所有路径。首先搜索使用命令行选项指定的路径。（7）*STARTUP(filename)*STARTUP命令与INPUT命令类似，除了filename将成为要链接的第一个输入文件，就像它是在命令行中首先指定的一样。在一些把第一个文件当作入口点的系统上这个命令非常有效。3.4.3 处理对象文件格式的命令有两个链接器脚本命令可以用来处理对象文件格式：OUTPUT_FORMAT(bfdname)OUTPUT_FORMAT(default,big,little)OUTPUT_FORMAT命令使用BFD格式的命名方式（请参见BFD）。使用OUTPUT_FORMAT（bfdname）与在命令行上使用 ‘–oformat bfdname’ 完全相同（请参见Command-line Options）。如果两者都使用，则命令行选项优先。您可以将OUTPUT_格式与三个参数一起使用，以根据 ’-EB’ 和 ‘-EL’ 命令行选项使用不同的格式。这允许链接器脚本根据所需的endianness设置输出格式。如果未使用 ’-EB’ 和 ‘-EL’ '，那么输出格式将会使用第一个参数作为默认值。如果使用 ’-EB'，输出格式将是第二个参数big。如果使用 ‘-EL’ '，输出格式将是第三个参数，little。例如，MIPS ELF目标的默认链接器脚本使用以下命令：OUTPUT_FORMAT(elf32-bigmips,elf32-bigmips,elf32-littlemips)这说明输出文件的默认格式是 ‘elf32-bigmips’，但如果用户使用’-EL’ '命令行选项，则将以‘elf32-littlemips’格式创建输出文件。TARGET(bfdname)TARGET命令设置读取输入文件时的BFD格式。这将影响后面的INPUT和GROUP命令。此命令类似使用命令行指令 ‘-b bfdname’ （参见Command-line Options）。如果使用了TARGET命令，但OUTPUT_FORMAT命令没使用，则最后的TARGET命令还被用来设置输出文件的格式（参见BFD）。3.4.4 为内存区域指定别名可以为MEMORY命令创建的内存区域提供别名。 每个名称最多对应一个存储区域REGION_ALIAS(alias,region)REGION_ALIAS函数为 内存区域创建别名 。这允许灵活地将输出部分映射到内存指定区域。下面有一个例子。假设我们有一个用于嵌入式系统的应用程序，它带有各种内存存储设备。它们都有一个通用的，易失性内存RAM，允许代码执行或数据存储。一些可能有一个只读的、非易失性内存ROM，允许代码执行和只读数据访问。最后一个是只读、非易失性存储器ROM2，允许对只读数据段读取，不允许代码执行。现在有四个输出段：.text ：程序代码.rodata ：只读数据.data ：可读写且需要初始化数据.bss ：可读写的置零初始化数据目标是提供一个链接器脚本文件，该文件包含定义系统无关的输出段的部分，和将输出段映射到系统上可用内存区域的系统相关部分。我们的嵌入式系统有三种不同的内存设置A、B和C：Section	Variant A	Variant B	Variant C.text	RAM	         ROM	    ROM.rodata	RAM	         ROM	    ROM2.data	RAM	         RAM/ROM	RAM/ROM2.bss	RAM	         RAM	    RAMRAM/ROM或RAM/ROM2表示将此段分别加载到区域ROM或ROM2中。请注意，三个设置的.data段的起始地址都位于.rodata段的末尾。接下来是处理输出段的基本链接脚本。 它包含描述内存布局的系统相关链接cmds.memory文件：INCLUDE linkcmds.memory
SECTIONS{.text :{(.text)} &gt; REGION_TEXT.rodata :{(.rodata)rodata_end = .;} &gt; REGION_RODATA.data : AT (rodata_end){data_start = .;(.data)} &gt; REGION_DATAdata_size = SIZEOF(.data);data_load_start = LOADADDR(.data);.bss :{(.bss)} &gt; REGION_BSS}现在我们需要三个不同的linkcmds.memory来定义内存区域以及别名。下面是A，B，C不同的linkcmds.memory：A ：所有都存入RAMMEMORY{RAM : ORIGIN = 0, LENGTH = 4M}
REGION_ALIAS("REGION_TEXT", RAM);REGION_ALIAS("REGION_RODATA", RAM);REGION_ALIAS("REGION_DATA", RAM);REGION_ALIAS("REGION_BSS", RAM);B ：代码和只读数据存入ROM。可读写数据放入RAM。一个已初始化了的数据的镜像被加载到ROM，并在系统启动的时候读入RAMMEMORY{ROM : ORIGIN = 0, LENGTH = 3MRAM : ORIGIN = 0x10000000, LENGTH = 1M}
REGION_ALIAS("REGION_TEXT", ROM);REGION_ALIAS("REGION_RODATA", ROM);REGION_ALIAS("REGION_DATA", RAM);REGION_ALIAS("REGION_BSS", RAM);C ：代码放入ROM，只读数据放入ROM2。可读写数据放入RAM。一个已初始化了的数据的镜像被加载到ROM2，并在系统启动的时候读入RAMMEMORY{ROM : ORIGIN = 0, LENGTH = 2MROM2 : ORIGIN = 0x10000000, LENGTH = 1MRAM : ORIGIN = 0x20000000, LENGTH = 1M}
REGION_ALIAS("REGION_TEXT", ROM);REGION_ALIAS("REGION_RODATA", ROM2);REGION_ALIAS("REGION_DATA", RAM);REGION_ALIAS("REGION_BSS", RAM);如有必要，可以编写通用的系统初始化程序以将.data段从ROM或ROM2复制到RAM：#include&lt;string.h&gt;externchardata_start[];externchardata_size[];externchardata_load_start[];voidcopy_data(void){if(data_start!=data_load_start){memcpy(data_start,data_load_start,(size_t)data_size);}}3.4.5 其他链接器脚本命令还有一些其他链接器脚本命令：ASSERT(exp, message)注意此断言会在最终链接阶段之前进行检查。这表示，在段内使用PROVIDE的定义如果用户没有为其设置值，此表达式将无法通过检测。唯一的例外是PROVIDE的符号刚刚引用了’.’。因此，一个如下断言：确保exp不为零。 如果为零，则退出链接并显示错误代码，并打印一些相关的信息。请注意，在链接的最后阶段发生之前会检查断言。 这意味着，如果用户没有为这些符号设置值，则涉及段定义中提供的符号的表达式将失败。 该规则的唯一例外是仅引用点的提供的符号。 因此，这样的断言：.stack:{PROVIDE(__stack=.);PROVIDE(__stack_size=0x100);ASSERT((__stack&gt;(_end+__stack_size)),"Error: No room left for the stack");}如果没有在其他地方定义stack_size，则会失败。在段外定义的符号会在此前被求值，可以在ASSERTions使用它们，因此:PROVIDE(__stack_size=0x100);.stack:{PROVIDE(__stack=.);ASSERT((__stack&gt;(_end+__stack_size)),"Error: No room left for the stack");}将会工作。EXTERN(symbol symbol …)强制将符号作为未定义符号输入到输出文件中。 这样做可能会例如触发标准库中其他模块的链接。 您可以为每个EXTERN列出几个符号，并且可以多次使用EXTERN。 此命令与 ‘-u’ 命令行选项具有相同的作用。FORCE_COMMON_ALLOCATION这个命令与’-d’ 命令行选项具有相同的效果:即便是使用了’-r’ 的重定位输出文件，也让ld为普通符号分配空间。INHIBIT_COMMON_ALLOCATION这个命令与命令行选项‘–no-define-common’ 具有相同的效果 : 让ld不为普通符号分配空间，即便是一个非可重定位输出文件。FORCE_GROUP_ALLOCATION这个命令与命令行选项 ‘–force-group-allocation’ 具有相同的效果 : 使ldplace 段组成员像普通的输入段一样，并且即使指定了可重定位的输出文件(’ -r ')也可以删除段组。INSERT [ AFTER | BEFORE ] output_section此命令通常在‘-T’ 指定的脚本中使用，用来增强默认的SECTIONS。例如，重复占位程序段。它将把所有此前的链接脚本的声明插入output_section的后面（或者前面），并且使’-T’不要覆盖默认链接脚本。实际插入点类似于孤儿段。参见Location Counter。插入发生在链接器把输入段映射到输出段后。在插入前，因为’-T’的脚本在默认脚本之前被解析，在’-T’脚本中的声明会先于默认内部脚本的声明而执行。特别是，将对默认脚本中的’-T’输出段进行输入段分配。下例为’-T’脚本使用INSERT可能的情况：SECTIONS{OVERLAY:{.ov1{ov1*(.text)}.ov2{ov2*(.text)}}}INSERT AFTER.text;NOCROSSREFS(section section …)此命令可能被用来告诉ld，如果引用了section的参数就报错。在特定的程序类型中，比如使用覆盖技术的嵌入式系统，当一个段被加载到内存中，另一个段不会被加载。任何两个段之间直接的引用都会带来错误。例如，如果一个段中的代码调用另一个段中的函数，将会产生错误。NOCROSSREFS命令列出了一系列输出段的名字。如果ld检测到任何段间交叉引用，将会报告错误并返回非零退出码。注意NOCROSSREFS使用输出段名称，而不是输入段名称。NOCROSSREFS_TO(tosection fromsection …)此命令可能被用来告诉ld，从其他段列表中对某个段的任何引用就会引发错误。当需要确保两个或多个输出段完全独立，但是在某些情况下需要单向依赖时，NOCROSSREFS命令很有用。 例如，在多核应用程序中，可能存在可以从每个核调用的共享代码，但是出于安全考虑，绝不能回调。NOCROSSREFS_TO命令携带(给出)输出段名称的列表。 其他任何部分都不能引用第一部分。 如果ld从其他任何部分中检测到对第一部分的任何引用，它将报告错误并返回非零退出状态。 请注意，NOCROSSREFS_TO命令使用输出段名称，而不是输入段名称。OUTPUT_ARCH(bfdarch)指定一个特定的输出机器架构。该参数是BFD库使用的名称之一(请参阅BFD)。通过使用带有 ’-f’ 选项的objdump程序，您可以看到目标文件的体系结构。LD_FEATURE(string)此命令可用于修改ld行为。如果字符串是“SANE_EXPR”，那么脚本中的绝对符号和数字将被在任何地方当作数字对待。请参考 Expression Section。3.5 为符号赋值可以给链接器脚本中的符号赋值。这会定义符号并将其放入具有全局作用域的符号表中。Simple Assignments 简单赋值HIDDEN 隐藏PROVIDE PROVIDEPROVIDE_HIDDEN PROVIDE_HIDDENSource Code Reference 如何在源代码中使用一个链接脚本定义的符号3.5.1 简单赋值您可以使用任何C赋值操作符来赋值符号:symbol=expression;symbol+=expression;symbol-=expression;symbol*=expression;symbol/=expression;symbol&lt;&lt;=expression;symbol&gt;&gt;=expression;symbol&amp;=expression;symbol|=expression;第一种情况将表达式的值赋值给符号。 在其他情况下，必须先定义符号，并相应地调整符号的值。特殊符号名称 ‘. ’ 表示位置计数器。 您只能在SECTIONS命令中使用它。 请参阅 Location Counter。表达式后面的分号不能省略。表达式定义如下； 请参阅Expressions。你在写表达式赋值语句时，可以把它们作为单独的部分,也可以作为 ’SECTIONS’ 命令中的一个语句,或者作为 ’SECTIONS’ 命令中输出段描述的一个部分。符号的有效作用区域由表达式所在的段决定，Expression Section。下面是是三个不同位置为符号赋值的示例：floating_point=0;SECTIONS{.text:{*(.text)_etext=.;}_bdata=(.+3)&amp;~3;.data:{*(.data)}}在本例中，符号 ‘floating_point’ 将被定义为零。符号 ’_etext’ 将被设置为紧随 ’.text’ 最后一个输入段后面的地址。符号’ _bdata '将被定义为在 ’.text’ 输出段后面的一个4字节向上对齐的地址。3.5.2 隐藏语法HIDDEN(symbol = expression)为ELF目标的端口定义一个符号，符号将被隐藏并且不会被导出。下面是Simple Assignments的例子，使用HIDDEN重写：HIDDEN(floating_point=0);SECTIONS{.text:{*(.text)HIDDEN(_etext=.);}HIDDEN(_bdata=(.+3)&amp;~3);.data:{*(.data)}}在本例中，这三个符号在此模块之外都不可见3.5.3 提供在某些情况下，仅当一个符号被引用了却没有定义在任何链接目标中，才需要为链接脚本定义一个符号。例如，传统链接器定义了符号‘etext’。然而，ANSI C要求用户能够使用’etext'作为函数名而不会引发错误。PROVIDE关键字可以用来定义一个符号，比如‘etext’ ，只有当它被引用但没有被定义时才使用。语法是PROVIDE(symbol = expression)。下面是一个使用提供定义‘etext’的例子:SECTIONS{.text:{*(.text)_etext=.;PROVIDE(etext=.);}}在本例中，如果程序定义了’_etext‘(带有前导下划线)，链接器将给出重复定义错误。另一方面，如果程序定义了’etext‘(没有前导下划线)，链接器会默认使用程序中的定义。如果程序引用了’etext'但没有定义它，链接器将使用链接器脚本中的定义。注意 -PROVIDE指令将考虑定义一个普通符号，即使这样的符号可以与PROVIDE将创建的符号组合在一起。当考虑构造函数和析构函数列表符号时，这一点尤其重要，因为它们通常被定义为普通符号。3.5.4 提供隐藏与PROVIDE类似。对于ELF目标的端口，符号将被隐藏且不会被输出。3.5.5 源代码参考从源代码获取链接器脚本定义的变量并不直观。 特别是，特别是链接脚本中的符号与高级语言定义的变量声明不同的时候，将使用一个没有值的变量替代它。在进一步讨论之前，必须注意，当编译器将源代码中的名称存储在符号表中时，它们通常会将它们转换为不同的名称。 例如，Fortran编译器通常在前面或后面加上下划线，而C ++则执行大量的 ‘name mangling’。 因此，在源代码中使用的变量名称与在链接脚本中定义的相同变量的名称之间可能会有差异。 例如，在C语言中，链接脚本变量可能称为：externintfoo;但是在链接器脚本中，它可能被定义为:_foo=1000;然而，在其余的例子中，假设没有发生名称转换。当一个符号用高级语言，比如C语言，声明了一个符号，会发生两件事。首先，编译器在程序内存中保留足够的空间来保存符号的值。第二种方法是编译器在程序的符号表中创建一个条目，用来保存符号的地址。例如下面的C声明：intfoo=1000;在符号表中创建一个名为’foo'的条目。这个入口保存了一个‘int’ 大小的内存块的地址，数字1000最初存储在这里。当程序引用一个符号时，编译器生成的代码首先访问符号表以查找该符号的内存块地址，然后代码从该内存块读取值。所以:foo=1;在符号表中查找符号’foo'，获取与该符号关联的地址，然后将值1写入该地址。而:int*a=&amp;foo;在符号表中查找符号’foo'，获取它的地址，然后将这个地址复制到与变量 ’a’ 相关联的内存块中。相比之下，链接器脚本符号声明在符号表中创建一个条目，但不给它们分配任何内存。因此，它们是一个没有值的地址。例如链接器脚本定义:foo=1000;在符号表中创建一个名为’foo'的条目，该条目保存内存位置1000的地址，但地址1000上没有存储任何特殊内容。这意味着您无法访问链接程序脚本定义的符号的值-它没有值。您所能做的就是访问链接器脚本定义符号的地址。因此，当您在源代码中使用链接器脚本定义的符号时，您应该始终获取该符号的地址，并且永远不要尝试使用它的值。例如，假设你想把内存的 .ROM 拷贝到 .FLASH 中，链接器脚本包含了这些声明:start_of_ROM=.ROM;end_of_ROM=.ROM+sizeof(.ROM);start_of_FLASH=.FLASH;那么执行复制的C源代码为:externcharstart_of_ROM,end_of_ROM,start_of_FLASH;memcpy(&amp;start_of_FLASH,&amp;start_of_ROM,&amp;end_of_ROM-&amp;start_of_ROM);注意 ‘&amp;’ 运算符的使用。上面是正确的代码。一种替换是，把符号被当作一个数组变量的名称，因此代码变成了：extern char start_of_ROM[], end_of_ROM[], start_of_FLASH[];
memcpy (start_of_FLASH, start_of_ROM, end_of_ROM - start_of_ROM);注意此时不需要操作符 ’&amp;’ 了。3.6 SECTIONS 命令SECTIONS命令告诉链接器如何将输入段映射到输出段，以及如何将输出段放在内存中。SECTIONS命令的格式为:SECTIONS{sections-commandsections-command…}每个sections-command命令可能是下面之一：ENTRY命令(请参阅Entry command)符号赋值(请参阅Assignments)输出段的描述overlay描述为了方便在这些命令中使用位置计数器，在SECTIONS命令中允许使用ENTRY命令和符号赋值。 这也可以使链接描述文件更容易理解，因为你可以在更有意义的地方使用这些命令来控制输出文件的布局。输出段描述和覆盖在下面将会分析。如果在链接脚本中未使用SECTIONS命令，则链接器将会照输入文本的顺序，将每个输入部段放置到名称相同的输出段中。例如，如果所有输入段出现在第一个文件中，输出文件的段的顺序将会与第一个输入文件保持一致。第一个段被放在地址0。Output Section Description 输出段描述Output Section Name 输出段名称Output Section Address 输出段地址Input Section 输入段描述Output Section Data 输出段数据Output Section Keywords 输出段关键字Output Section Discarding 输出段忽略的内容Output Section Attributes 输出段属性Overlay Description Overlay description3.6.1 输出部分描述输出段的完整描述如下所示：section[address][(type)]:[AT(lma)][ALIGN(section_align)|ALIGN_WITH_INPUT][SUBALIGN(subsection_align)][constraint]{output-section-commandoutput-section-command…}[&gt;region][AT&gt;lma_region][:phdr:phdr …][=fillexp][,]大部分的可选段属性在多数输出段不需要使用。SECTION边上的空格是必须的，这样段名就没有歧义了。冒号和花括号也是必需的。如果使用了fillexp，并且下一个section -命令看起来像是表达式的延续，则可能需要在末尾使用逗号。换行符和其他空格是可选的。当 fillexp 使用且接下来的sections-command看起来像是表达式的延续的时候，可能需要在后面加上逗号。每个output-section-command可以是下列命令之一:符号赋的值(参见Assignments)输入段描述(参见Input Section)直接包引用的数据值(参见Output Section Data)特殊的输出段关键字(参见Output Section Keywords))3.6.2 输出部分名称输出段的名字是section。section必须满足输出格式的规定。在只支持有限段数目的格式中，例如a.out，名称必须是该格式所支持的名称之一(例如a.out，只允许’.text’，’.data’，’.bss’)。如果输出格式支持任意数量的段，但是只有数字而不是名称(Oasys就是这种情况)，则名称应该以带引号的数字字符串的形式提供。一个段的名字可以由任意字符序列组成，但一个含有许多特殊字符(如逗号)的名称必须用引号括起来。名称为 ‘/DISCARD/’ 的输出段 ，有特殊含义; 参考Output Section Discarding.3.6.3 输出部分地址address是输出段VMA（虚拟内存地址）的表达式。此地址是可选参数，但如果提供了该地址，则输出地址就会被精确的设置为指定的值。如果没有指定输出地址，那么则依照下面的几种方式尝试选择一个地址。此地址将被调整以适应输出段的对齐要求。输出段的对齐要求是所有输入节中含有的对齐要求中最严格的一个。输出段地址探索如下：如果为该段设置了一个输出内存区域，那么它将被添加到该区域中，其地址将是该区域中的下一个空闲地址。如果使用MEMORY命令创建内存区域列表，那么将选择具有与该段兼容属性的第一个区域来包含该区域。该部分的输出地址将是该区域中的下一个空闲地址；MEMORY。如果没有指定内存区域，或者没有与段匹配的内存区域，则输出地址将基于位置计数器的当前值。例如:.text.:{*(.text)}和.text:{*(.text)}有着细微的不同。 第一个将‘.text’ 输出段的地址设置为位置计数器的当前值。 第二个参数会将其设置为位置计数器的当前值，但是该值与所有‘.text’ 输入段中最严格的对齐方式对齐。address可以是任意表达式； 例如，如果要在0x10字节(16字节)边界上对齐段，以使节地址的最低四位为零，则可以执行以下操作：.textALIGN(0x10):{*(.text)}之所以这样做，是因为ALIGN返回的当前位置计数器向上对齐到指定的值。为段指定地址将会改变位置计数器的值，前提是该段是非空的(空的段被忽略)。3.6.4 输入部分描述最常见的输出段命令（output-section-command）是输入段描述。输入段描述是链接脚本最基本的操作。 您可以使用输出段来告诉链接器如何在内存中布置程序。 您可以使用输入段描述来告诉链接器如何将输入文件映射到您的内存布局中。Input Section Basics 基本的输入段Input Section Wildcards 输入段通配符模板Input Section Common 普通符号的输入段Input Section Keep 输入段与垃圾回收Input Section Example 输入段例子3.6.4.1 输入节基本说明输入段说明由一个文件名和一个括号中的段名列表（可选）组成。文件名和段名可以是通配符，我们将在下面进一步描述（请参阅Input Section Wildcards）。最常见的输入段描述是在输出段中包括所有具有特定名称的输入段。 例如，把所有输入段放入’.text’段，可以这么写：*(.text)这里的 ‘*’ 是一个通配符，它可以用来匹配任何文件名。要排除与文件名通配符匹配的文件列表，可以使用EXCLUDE_FILE来匹配除EXCLUDE_FILE列表中指定的文件以外的所有文件。例如：EXCLUDE_FILE(*crtend.o*otherfile.o)*(.ctors)将导致包括除crtend.o和otherfile.o以外的所有文件的所有.ctors段。EXCLUDE_FILE 也可以放在段的列表中，例如：*(EXCLUDE_FILE(*crtend.o*otherfile.o).ctors)其结果与前面的示例相同。如果段列表包含多个段，则支持 EXCLUDE_FILE 的两个语法非常有用，如下所述。有两种方法可以包含多个段：*(.text.rdata)*(.text)*(.rdata)两种方法的区别是输入段的 ’.text’ 和 ’.rata’ 段出现在输出段中的顺序。第一个例子里，他们将被混合在一起，按照链接器找到它们的顺序存放。另一个例子中，所有 ’.text’ 输入段将会先出现，后面是 ’.rdata’ 输入段。将EXCLUDE_FILE与多个段一起使用时，这个排除命令仅仅对紧随其后的段有效，例如：*(EXCLUDE_FILE(*somefile.o).text.rdata)将导致包含除somefile.o以外的所有文件的所有‘.text’段，而包括somefile.o在内的所有文件的所有‘.rdata’ 段都将被包含。要从somefile.o中排除‘.rdata’ 段部分，可以将示例修改为：*(EXCLUDE_FILE(*somefile.o).textEXCLUDE_FILE(*somefile.o).rdata)或者，将EXCLUDE_FILE放在段列表之外(在选择输入文件之前)，将导致排除操作对所有段有效。因此，前一示例可以重写为：EXCLUDE_FILE(*somefile.o)*(.text.rdata)你可以指定一个文件名来包含特定文件的段。如果一个或者多个你的文件需要被放在内存中的特定位置，你可能需要这么做。例如：data.o(.data)如果想使用段标志来选择输入文件的段，可以使用INPUT_SECTION_FLAGS。下面是一个为ELF段使用段头标志的简单示例:SECTIONS{.text:{INPUT_SECTION_FLAGS(SHF_MERGE&amp;SHF_STRINGS)*(.text)}.text2:{INPUT_SECTION_FLAGS(!SHF_WRITE)*(.text)}}在本例中，输出段 ‘.text’ 将被由那些与 *(.text) 能匹配的段（名字）且段头部标志设置了SHF_MERGE和SHF_STRINGS的段构成。输出段 ‘.text2’ 由那些与 *(.text) 能匹配的段（名字）且段头部标志未设置SHF_WRITE的段构成。你也可以指出特别的关联库名称的文件，命令是[ 库匹配模板:与文件匹配的模式 ]，冒号两边不能有空格。‘archive:file’ 在库中寻找能够匹配的文件‘archive:’ 匹配整个库‘:file’ 匹配文件但不匹配库‘archive’ 和 ‘file’ 中的一个或两个都可以包含shell通配符。在基于DOS的文件系统上，链接器会假定一个单字跟着一个冒号是一个特殊的驱动符，因此 ‘c:myfile.o’ 是一个文件的特殊使用，而不是关联库’c’的 ’myfile.o’ 文件。‘archive:file’：可以使用在EXCLUDE_FILE列表中，但不能出现在其他链接脚本内部。例如，你不能使用 ‘archive:file’从 INPUT命令中取出一个库相关的文件。如果你使用一个文件名而不指出段列表，则所有的输入文件的段将被放入输出段。通常不会这么做，但有些场合比较有用，例如：data.o当你使用一个文件名且不是 ‘archive:file’特殊命令，并且不含任何通配符，链接器将先查看你是否在命令行上或者在INPUT命令里指定了该文件。如果没有这么做，链接器尝试将文件当作输入文件打开，就像文件出现在了命令行一样。注意与INPUT命令有区别，因为链接器不会在库文件路径搜索文件。3.6.4.2 输入节通配符模式在输入段描述中，文件名和段名都可以使用通配符模式。在许多示例中看到的文件名’ * '是一个简单的文件名通配符模式。通配符模式类似于Unix shell使用的那些模式。‘*’ 匹配任意数量字符‘?’ 匹配任意单字‘[chars]’ 匹配任何字符的单个实例；‘-’ 字符可被用来指出一个字符的范围，例如 ‘[a-z]’ 可以用来匹配所有小写字母‘\’ 引用后面的字符当文件名与通配符匹配时，通配符将不匹配 ‘/’ 字符（在Unix上用于分隔目录名）。由单个 ‘*’ 字符组成的模式是除外；它将始终匹配任何文件名，无论它是否包含 ‘/’ 。在段名称中，通配符将匹配 ‘/’ 字符。文件名通配符模式只匹配在命令行或输入命令中显式指定的文件。链接器不会搜索目录以扩展通配符。如果一个文件名匹配多个通配符，或者一个文件名被显示指定了，且又被通配符匹配了，则链接器将使用链接器脚本中的第一个匹配项。例如，例如，下面的输入段描述可能有错误，因为data.o的规则不会被应用：.data:{*(.data)}.data1:{data.o(.data)}通常情况下，链接器将按照链接过程中出现通配符的顺序放置文件和段。您可以通过使用SORT_BY_NAME关键字来更改此行为，该关键字出现在括号中的通配符模式之前（例如，SORT_BY_NAME（.text*））。当使用SORT_BY_NAME关键字时，链接器将按名称按升序对文件或段进行排序，然后将它们放入输出文件中。SORT_BY_ALIGNMENT对齐方式类似于SORT_BY_NAME.SORT_BY_ALIGNMENT将在将段放入输出文件之前，按对齐方式的降序对段进行排序。大的对齐被放在小的对齐前面可以减少所需的填充量。SORT_BY_INIT_PRIORITY与SORT_BY_NAME相似，区别是SORT_BY_INIT_PRIORITY把段按照GCC的嵌入在段名称的init_priority数字属性值升序排列后放入输出文件。.init_array.NNNNN和.fini_array.NNNNN, NNNNN是init_priority 。.ctors.NNNNN和.dtors.NNNNN, NNNNN是65535减去 init_priority 。SORT是SORT_BY_NAME的别名。当链接器脚本中有嵌套的段排序命令时，段排序命令最多可以有1个嵌套级别。（1）SORT_BY_NAME (SORT_BY_ALIGNMENT (wildcard section pattern))。它将首先按名称对输入部分进行排序，如果两个部分同名，则按对齐方式排序。（2）SORT_BY_ALIGNMENT (SORT_BY_NAME (wildcard section pattern))。它将首先按对齐方式对输入段进行排序，如果两个段具有相同的对齐方式，则按名称排序。（3）*SORT_BY_NAME (SORT_BY_NAME (wildcard section pattern))*与SORT_BY_NAME (wildcard section pattern)相同。（4）SORT_BY_ALIGNMENT (SORT_BY_ALIGNMENT (wildcard section pattern))与SORT_BY_ALIGNMENT (wildcard section pattern)相同。（5）除此之外，其它所有嵌套段排序命令都是无效的。当同时使用命令行段排序选项和链接器脚本段排序命令时，段排序命令总是优先于命令行选项。如果链接器脚本中的段排序命令不是嵌套的，那么命令行选项将使段排序命令被视为嵌套的排序命令。（1）SORT_BY_NAME (wildcard section pattern )与–sort-sections alignment连用等价于SORT_BY_NAME (SORT_BY_ALIGNMENT (wildcard section pattern)) 。（2）SORT_BY_ALIGNMENT (wildcard section pattern)与–sort-section name连用等价于SORT_BY_ALIGNMENT (SORT_BY_NAME (wildcard section pattern))。如果链接器脚本中的段排序命令是嵌套的，那么命令行选项将被忽略。SORT_NONE通过忽略命令行部段排序选项来禁用段排序。如果您对输入段的去向感到困惑，可以使用 ’ -*M* ’ 链接器选项来生成映射文件。映射文件精确地显示了如何将输入段映射到输出段。下面这个示例展示了通配符如何被用来分隔文件。这个链接脚本指引链接器把所有 ‘.text’ 段放在’ ‘.text’ 里，以及所有 ’.bss’ 段放到 ’.bss’ 中。链接器将会把所有以大写字母开头的文件的 ’.data’ 段放入 ’.DATA’ ，其他文件的 ’.data’ 段放入 ’.data’ 。SECTIONS{.text:{*(.text)}.DATA:{[A-Z]*(.data)}.data:{*(.data)}.bss:{*(.bss)}}3.6.4.3 常用符号输入部分普通符号需要一个特别的标记，因为很多目标文件格式中没有特定的普通符号输入段。链接器把普通符号当作位于一个名为 ’COMMON’ 的输入段中。像使用其它文件名与段一样，你也可以使用文件名与 ’COMMON’ 段的组合。通过这种方法把一个特定文件的普通符号放入一个段内，同时把其它输入文件的普通符号放入另一个段内。大多数情况下，输入文件的普通符号会被放到输出文件的 ’.bss’ 段里面。例如：.bss{*(.bss)*(COMMON)}有些目标文件格式含有多种普通符号的类型。例如，MIPS ELF目标文件把标准普通符号和小型普通符号区分开来。在这种情况下，链接器会为另一个类型的普通符号使用其它的特殊段名称。在MIPS ELF中，链接器为普通符号使用 ’COMMON’ 以及为小型普通符号使用 ’.scommon’ 。这样就可以把不同类型的普通符号映射到内存中的不同位置。有时在老的链接脚本中能看见 ’[COMMON]’ 。这个标记现在已废弃。它等价于’*(COMMON)’ 。3.6.4.4 输入段和垃圾回收使用了链接时垃圾收集(‘–gc-sections’)的功能，在把段标记为不应被消除非常常用。此功能通过把一个输入段的通配符入口使用KEEP()实现，类似于KEEP((.init))或KEEP(SORT_BY_NAME()(.ctors))。3.6.4.5 输入部分示例下面是一个完整的链接脚本的例子。它告诉链接器从all.o读取所有段，把它们放到输出段’outputa’的开头位置，’outputa’的起始地址为 ’0x10000’ 。所有文件foo.o中的 ’.input1’ 段紧跟其后。所有文件foo.o中的 ’input2’ 段放入输出文件的 ’outputb’ 中，跟着是foo1.o中的 ’input1’ 段。所有其它的 ’.input1” 和 .input2’ 段被放入输出段 ’outputc’ 。SECTIONS{outputa0x10000:{all.ofoo.o(.input1)}outputb:{foo.o(.input2)foo1.o(.input1)}outputc:{*(.input1)*(.input2)}}如果输出段的名称与输入段的名称相同，并且可以表示为C标识符，那么链接器将自动看到 PROVIDE两个符号:余下的*__start_SECNAME* 和_stop_SECNAME，其中SECNAME是段的名称。它们分别指示输出段的开始地址和结束地址。注意:大多数段名不能表示为C标识符，因为它们包含 ‘.’ 字符。3.6.5 输出部分数据你可以通过使用输出段命令BYTE,SHORT,LONG,QUAD, 或者SQUAD在输出段显式的包含几个字节的数据。每个关键字后面跟着一个括号包裹的表达式指出需要存储的数值（参照Expressions）。表达式的值被存储在当前位置计数器值的地方。BYTE,SHORT,LONG,QUAD命令分别存储1，2，4，8字节。在存储字节后，位置计数器会按照存储的字节数增加。例如，下面将会存储一个单字节数据1，然后存储一个符号为 ’addr’ 四字节数据的值：BYTE(1)LONG(addr)当使用64位主机或目标时，QUAD和SQUAD是相同的;它们都存储一个8字节或64位的值。主机和目标都是32位时，表达式被当作32位计算。在这种情况下QUAD存储一个32位的值，并使用0扩展到64位，SQUAD保存32位值并使用符号位扩展到64位。如果输出文件的目标文件格式显式的指定endiannes，在正常的情况下，值将按照大小端存储。当对象文件格式没有显式的指定endianness，例如，S-records，值将被按照第一个输入目标文件的大小端存储。注意 - 这些命令仅在段描述内部工作，因此下面的例子会使链接器产生错误：SECTIONS{.text:{*(.text)}LONG(1).data:{*(.data)}}而下面这是可行的：SECTIONS{.text:{*(.text);LONG(1)}.data:{*(.data)}}您可以使用FILL命令设置当前段的填充模式。该命令后面跟着一个括号包裹的表达式。所有其它没有被特别指定段的内存区域（例如因为对齐需要而留出来的缝隙）按照表达式的值填充，如果有必要可以重复填充。一个FILL语句仅会覆盖它本身在段定义中出现的位置后面的所有内存区域；通过使用不同的FILL声明，你可以在一个输出段中使用不同的填充模板。这个例子显示了如何使用 ’0x90’ 填充未定义内存区域：FILL(0x90909090)FILL命令类似 ’=fillexp’ 输出段属性，但其仅影响FILL命令后面的段，而不是整个段。如果同时使用，FILL命令为高优先级。参考 Output Section Fill获取更多填充细节。3.6.6 输出部分关键字这里有两个关键字可以作为输出段的命令：CREATE_OBJECT_SYMBOLS此命令告诉链接器为每个输入文件创建一个符号。每个符号的名字为对应输入文件的名字。每个符号出现的位置位于包含CREATE_OBJECT_SYMBOLS命令的输出段中。这个命令常常是a.out目标文件格式特有的。 它一般不为其它的目标文件格式所使用。CONSTRUCTORS当链接时使用a.out目标文件的格式，链接器使用一个特殊构造集来支持C++ 全局构造函数和析构函数。在链接不支持任意段的文件格式时，例如ECOFF和XCOFF，链接器将会通过名字自动识别C++全局构造函数和析构函数。对于这些格式的目标文件，CONSTRUCTORS命令告诉链接器把构造函数信息放到出现CONSTRUCTORS命令的输出段中。其它文件格式中CONSTRUCTORS命令被忽略。符号__CTOR_LIST__ 标记全局构造函数的开始，符号__CTOR_END__标记结束。同样的，__DTOR_LIST__和__DTOR_END__分别标记全局析构函数的开始和结束。第一个列表中的字是入口的数量，后面是每个构造函数或者析构函数的地址，最后是一个全零的字。编译器必须安排实际运行代码。对于这些目标文件格式，GNU C++通常从一个 __main 子程序中调用构造函数，而对 __main 的调用自动被插入到main的启动代码中。GNU C++通常使用atexit运行析构函数，或者直接从函数exit中退出。对于COFF或者ELF等支持任意段名字的目标文件格式，GNU C++通常把全局构造函数和析构函数放入 .ctors和 .dtors段。把下面的代码放入你的链接脚本，将会创建GUN C++运行时期望的表。__CTOR_LIST__=.;LONG((__CTOR_END__-__CTOR_LIST__)/4-2)*(.ctors)LONG(0)__CTOR_END__=.;__DTOR_LIST__=.;LONG((__DTOR_END__-__DTOR_LIST__)/4-2)*(.dtors)LONG(0)__DTOR_END__=.;如果你正在使用GUN C++支持的初始化优先级，初始化优先级提供了一些对全局构造函数运行顺序的控制，则你必须在链接时对构造函数排序以保证它们以正确的顺序执行。当你使用CONSTRUCTORS命令，使用 ‘SORT_BY_NAME(CONSTRUCTORS)’ 替换它。当使用 .ctors和 .dtors段,使用 ‘(SORT_BY_NAME(.ctors))’ 和’ *(SORT_BY_NAME(.dtors))’ 取代 ‘*(.ctors)’ 和’ ‘(.dtors)’ 。通常编译器和链接器会自动处理这些问题，您不需要关心它们。但是，在你自己写链接脚本且正在使用C++的时候，你可能需要考虑这些。3.6.7 输出部分的丢弃链接器通常不会创建没有内容的输出段。这是为了方便引用那些有可能出现或者不出现任何输入文件中的段。例如：.foo:{*(.foo)}只有在至少有一个输入文件含有 ’.foo’ 段且 ’.foo’ 段不为空的时候才会在输出文件创建一个 ’.foo’ 段。其它链接脚本指出在一个段中间分配空间也会创建输出段。赋值也一样即使赋值没有创建空间，除了‘. = 0’, ‘. = . + 0’, ‘. = sym’, ‘. = . + sym’ 和‘. = ALIGN (. != 0, expr, 1)’ 其中 ’sym’ 是一个值为0的已定义绝对符号。因此你可以强制一个空的输出段使用 ‘. = .’。链接器将忽略为丢弃的输出段进行地址赋值（请参见Output Section Address），除非链接器脚本在输出段中定义符号。在这种情况下，链接器将遵守地址赋值，有可能更新 ’.’ 的值，即便段被抛弃了。特殊输出段名称 ’/DISCARD/’ 可被用来抛弃输入段。一个被分派到名为 ’/DISCARD/’ 的输出段的输入段将不会被包含在输出文件中。3.6.8 输出分段的丢弃我们在前面展示了输出部分的完整描述如下:section[address][(type)]:[AT(lma)][ALIGN(section_align)|ALIGN_WITH_INPUT][SUBALIGN(subsection_align)][constraint]{output-section-commandoutput-section-command…}[&gt;region][AT&gt;lma_region][:phdr:phdr …][=fillexp]我们已经描述了section,address, andoutput-section-command命令。在本节中，我们将描述其余的段属性。Output Section Type: 输出段类型Output Section LMA: 输出段LMA —加载地址Forced Output Alignment: 强制输出对齐Forced Input Alignment: 强制输入对齐Output Section Constraint: 输出段限制Output Section Region: 输出段区域Output Section Phdr: 输出段phdrOutput Section Fill: 输出段填充3.6.8.1 输出分段类型每个输出段可以有一个类型。类型是圆括号中的关键字。定义了以下类型:NOLOAD此段应标记为不可加载，以便在程序运行时不会将其加载到内存中。DSECT
COPY
INFO
OVERLAY支持这些类型名称是为了向后兼容，而且很少使用。它们都具有相同的效果:该段应该标记为不可分配，以便在程序运行时不会为该段分配内存。链接器通常根据映射到输出段的输入段设置输出段的属性。您可以使用section类型来覆盖它。例如，在下面的脚本示例中，’ROM’ 部分位于内存位置 ’ 0 '，在程序运行时不需要加载它。SECTIONS{ROM0(NOLOAD):{…}…}3.6.8.2 输出部分 LMA每个段有一个虚拟地址(VMA)和一个加载地址(LMA);参见 Basic Script Concepts。虚拟地址由前面描述的 Output Section Address指定。加载地址由AT或AT&gt;关键字指定。指定加载地址是可选的。*AT* 关键字把一个表达式当作自己的参数。这将指定段的实际加载地址。关键字 AT&gt; 使用内存区域的名字作为参数。参考MEMORY。段的加载地址被设置为该区域的当前空闲位置，并且按照段对齐要求对齐。如果没有为可分配段使用AT和AT&gt;，链接器会使用下面的方式尝试来决定加载地址：如果段有一个特定的VMA地址，则LMA也使用该地址。如果段为不可分配的则LMA被设置为它的VMA。否则如果可以找到符合当前段的一个内存区域，且此区域至少包含了一个段，则设置LMA在那里。如此VMA和LMA的区别类似于VMA和LMA在该区域的上一个段的区别。如果没有声明内存区域且默认区域覆盖了整个地址空间，则采用前面的步骤。如果找不到合适的区域或者没有前面存在的段，则LMA被设置为等于VMA。这些功能旨在使构建ROM映像变得容易。例如，以下链接器脚本创建三个输出段：一个名为“.text”，从0x1000开始；一个名为“.mdata”，即使其VMA为0x2000，也加载在“.text”节的末尾；另一个名为“.bss”，用于在地址0x3000保存未初始化的数据。符号’_data’被定义为值0x2000，这表明位置计数器保存VMA值，而不是LMA值。SECTIONS{.text0x1000:{*(.text)_etext=.;}.mdata0x2000:AT(ADDR(.text)+SIZEOF(.text)){_data=.;*(.data);_edata=.;}.bss0x3000:{_bstart=.;*(.bss)*(COMMON);_bend=.;}}此链接脚本的运行时初始化代码应该类似于下面的形式，把初始化数据从ROM镜像复制到运行时地址。注意这些代码是如何利用链接器脚本定义的符号的。externchar_etext,_data,_edata,_bstart,_bend;char*src=&amp;_etext;char*dst=&amp;_data;/*ROM hasdataatendoftext;copy it./while(dst&lt;&amp;_edata)dst++=*src++;/*Zero bss./for(dst=&amp;_bstart;dst&lt;&amp;_bend;dst++)dst=0;3.6.8.3 强制输出对齐你可以使用ALIGN增加输出段的对齐。作为替换，你可以通过ALIGN_WITH_INPUT属性强制VMA与LMA自始至终保持它们之间的区别。您可以使用ALIGN来增加输出段的对齐方式。作为一种替代方法，您可以使用ALIGN_WITH_INPUT属性在整个输出段保持VMA和LMA之间的差异。3.6.8.4 强制输入对齐您可以使用SUBALIGN来强制输出段中的输入段对齐。指定的值将覆盖输入段提供的任何对齐方式，无论比原来大还是小。3.6.8.5 输出分段约束通过分别使用关键字ONLY_IF_RO和ONLY_IF_RW，可以指定只有在所有输入段都是只读或所有输入段都是读写的情况下才创建输出段。3.6.8.6 输出分段区域可以使用 ’&gt;region’ 把一个段指定到此前设置的内存区域内。参见MEMORY。下面是一个例子：MEMORY{rom:ORIGIN=0x1000,LENGTH=0x1000}SECTIONS{ROM:{*(.text)}&gt;rom}3.6.8.7 输出节 Phdr您可以使用 ':phdr’ 将一个段分配给先前定义的程序段。参见 PHDRS。如果一个段被分配给一个或多个段，那么所有后续分配的段也将被分配给这些段，除非它们显式地使用 :phdr修饰符。您可以使用:NONE来告诉链接器根本不要将该段放在任何段中。这里有一个简单的例子:PHDRS{text PT_LOAD;}SECTIONS{.text:{*(.text)}:text}3.6.8.8 输出剖面填充你可以使用’=fillexp’为整个段设置填充模板。fillexp是一个表达式（参考Expressions）。任何其它的未被特殊指定的输出段的内存区域（例如，因为对其输入段产生的缝隙）将会被用fillexp的值填充，如果有需要可以重复填充。如果表达式是一个简单的hex数字，例如一个十六进制数字由’0x’开头且结尾没有 ’k’ 或 ’M’，则一个任意长的十六进制数字可以被用来给填充模板赋值，前面的0同样成为模板的一部分。在其它情况中，包含额外的括号或者一个一元+，填充模板为表达式值的最低4个有意义的字节。在所有情况中，数字总是大端的。你也可以使用FILL命令设置填充值（参考Output Section Data）。这里有一个简单的例子:SECTIONS{.text:{*(.text)}=0x90909090}3.6.9 叠加说明覆盖描述提供了一种简单的方法来描述将作为单个内存映像的一部分加载但将在相同内存地址上运行的段。在运行时，某种类型的覆盖管理器将根据需要从运行时内存地址复制覆盖的段，可能通过简单地操作寻址位来实现。这种方法可能很有用，例如，当某个内存区域比另一个区域更快时。覆盖描述使用OVERLAY命令。OVERLAY命令和SECTIONS命令一起使用，就像一个输出段描述符。完整的OVERLAY命令的语义如下：OVERLAY[start]:[NOCROSSREFS][AT(ldaddr)]{secname1{output-section-commandoutput-section-command…}[:phdr…][=fill]secname2{output-section-commandoutput-section-command…}[:phdr…][=fill]…}[&gt;region][:phdr…][=fill][,]除了OVERLAY（关键字），以及每个段都必须有一个名字（上面的secname1和secname2），所有的部分都是可选的。除了OVERLAY中不能为段定义地址和内存区域，使用OVERLAY结构定义的段类似于那些普通的SECTIONS中的结构（参考SECTIONS）。结尾的逗号可能会被使用，如果使用了fill且下一个sections-command看起来像是表达式的延续。所有的段都使用同样的开始地址定义。所有段的载入地址都被排布，使它们在内存中从整个’OVERLAY’的载入地址开始都是连续的（就像普通的段定义，载入地址是可选的，缺省的就是开始地址；开始地址也是可选的，缺省是当前的位置计数器的值）。如果使用了关键字NOCROSSREFS，并且在任何段间有互相引用，链接器将会产生一个错误报告。因为所有的段运行在同样的地址，直接引用其它的段通常没有任何意义。参考NOCROSSREFS。每个伴随OVERLAY的段，链接器自动提供两个符号。符号*__load_start_secname被定义为段的起始地址。符号__load_stop_secname被定义为段结束地址。任何不符合C定义的伴随secname*的字符都将被移除。C（或者汇编）代码可以使用这些符号在需要时搬移复盖代码。覆盖之后，位置计数器的值设置为覆盖的起始值加上最大段的长度。下面是例子，请记住这应该放在SECTIONS结构内。OVERLAY0x1000:AT(0x4000){.text0{o1/*.o(.text) }.text1 { o2/*.o(.text) }}这将把 ’.text0’ 和 ’.text1’ 的起始地址设置为地址0x1000。’.text0’ 的加载地址为0x4000，’.text1’ 会加载到 ’.text0’ 后面。下面的符号如果被引用则会被定义：__load_start_text0,__load_stop_text0,__load_start_text1,__load_stop_text1。C代码拷贝覆盖.text1到覆盖区域可能像下面的形式。externchar__load_start_text1,__load_stop_text1;memcpy((char*)0x1000,&amp;__load_start_text1,&amp;__load_stop_text1-&amp;__load_start_text1);注意’OVERLAY’命令只是为了语法上的便利，因为它所做的所有事情都可以用更加基本的命令加以代替。上面的例子可以用下面的写法：.text00x1000:AT(0x4000){o1/*.o(.text) }PROVIDE (__load_start_text0 = LOADADDR (.text0));PROVIDE (__load_stop_text0 = LOADADDR (.text0) + SIZEOF (.text0));.text1 0x1000 : AT (0x4000 + SIZEOF (.text0)) { o2/*.o(.text) }PROVIDE (__load_start_text1 = LOADADDR (.text1));PROVIDE (__load_stop_text1 = LOADADDR (.text1) + SIZEOF (.text1));. = 0x1000 + MAX (SIZEOF (.text0), SIZEOF (.text1));3.7 内存命令链接器的默认配置允许分配所有可用内存。您可以使用MEMORY命令来重载它。*MEMORY* 命令描述目标中内存块的位置和大小。您可以使用它来描述链接器可以使用哪些内存区域，以及链接器必须避免使用哪些内存区域。你可以把段放到特定的内存区域里。链接器将会基于内存区域设置段地址，如果区域趋于饱和将会产生警告信息。链接器不会为了把段更好的放入内存区域而打乱段的顺序。链接器脚本可能包含MEMORY命令的许多用法，但是，定义的所有内存块都被视为在单个MEMORY命令中指定的。内存的语法是:MEMORY{name[(attr)]:ORIGIN=origin,LENGTH=len…}name是链接器脚本中用于引用内存区域的名称。区域名称在链接器脚本之外没有任何意义。区域名称存储在单独的名称空间中，不会与符号名、文件名或段冲突。每个内存区域在MEMORY命令中必须有一个不同的名称。但是你此后可以使用REGION_ALIAS命令为已存在的内存区域添加别名。attr字符是一个可选的属性列表，用于指定是否对链接器脚本中未显式映射的输入段使用特定的内存区域。如 SECTIONS中所述，如果不为某些输入段指定输出段，则链接器将创建一个与输入段同名的输出段。如果定义区域属性，链接器将使用它们为它创建的输出段选择内存区域。attr字符串只能使用下面的字符组成：‘R’ 只读段‘W’ 读写段‘X’ 可执行段‘A’ 可分配段‘I’ 已初始化段‘L’ 类似于’I’‘!’ 反转其后面的所有属性如果一个未映射段匹配了上面除 ’!’ 之外的一个属性，它就会被放入该内存区域。’!’ 属性对该测试取反，所以只有当它不匹配上面列出的行何属性时，一个未映射段才会被放入到内存区域。origin是内存区域起始地址的数值表达式。表达式的计算结果必须为常量，并且不能包含任何符号。关键字ORIGIN可以缩写为org或o（但不能是ORG）。len是内存区域的字节大小的表达式。与原始表达式一样，表达式必须仅为数值，并且必须计算为常量。关键字长度可以缩写为len或l。在下面的示例中，我们指定有两个内存区域可供分配：一个从“0”开始空间大小为256k字节，另一个从“0x40000000”开始空间大小为4M字节。链接器将把未显式映射到内存区域的每个部分放入“rom” 内存区域，这些部分要么是只读的，要么是可执行的。链接器会将未显式映射到内存区域的其他部分放入 “ram” 内存区域。MEMORY{rom(rx):ORIGIN=0,LENGTH=256Kram(!rx):org=0x40000000,l=4M}定义内存区域后，可以使用 ‘&gt;region’ 输出段属性指引链接器把特殊输出段放到该内存区域。例如，如果您有一个名为 ‘mem’ 的内存区域，你可以在输出段定义中使用 ’&gt;mem’。请参见Output Section Region。如果没有为输出段指定地址，链接器将把地址设置为内存区域内的下一个可用地址。如果指向某个内存区域的组合输出段对于该区域来说太大，则链接器将发出错误消息。可以通过ORIGIN(memory)和LENGTH(memory)函数获得内存区域的起始地址以及长度：_fstack=ORIGIN(ram)+LENGTH(ram)-4;3.8 PHDRS 命令ELF对象文件格式使用程序头，类似于段。程序头描述了如何将程序加载到内存中。您可以使用带有 ’ -p ’ 选项的objdump程序将它们打印出来。当您在本地运行ELF程序时，系统加载程序将读取程序头以确定如何加载程序。只有当程序头设置正确时，这才会工作。本手册没有详细描述系统加载程序如何解释程序头;有关更多信息，请参见ELF ABI。默认的链接器将会创建合适的程序头部。但是，有些情况下，你可能需要更加精确地指定程程序头。可以使用PHDRS命令达到此目的。当链接器在链接器脚本中看到PHDRS命令时，它将只创建指定的程序头。链接器仅在创建ELF输出文件时才会关注PHDRS命令。其他情况下链接器将会忽视PHDRS。下面是PHDRS的语法。PHDRS,FILEHDR,AT,FLAGS都是关键字：PHDRS{name type[FILEHDR][PHDRS][AT(address)][FLAGS(flags)];}name仅用于链接器脚本的SECTIONS命令中的引用。它不会被放到输出文件中。程序头名称存储在单独的名称空间中，不会与符号名称、或者段名产生冲突。每个程序头必须有一个不同的名称。头按照顺序执行，且通常将它们以上升的加载顺序映射到段。具体的程序头类型描述系统加载程序将从文件加载的头部段。在链接器脚本中，可以通过放置可再分配输出段在头部段内来指定头部段的内容。您可以使用’:phdr '输出段属性将段放在特定的段中。请参阅Output Section Phdr。将某一个段放在多于一个的段中是很正常的。这仅仅意味着一个内存段包含另一个内存段。可以为每个应当包含段的头部段重复使用 ’:phdr’ 命令。如果使用 ‘：phdr’ 将段放在一个或多个段中，则链接器会将所有未指定 ‘：phdr’ 的后续可分配段放在同一段中。 这是为了方便起见，因为通常将一整套连续段放在单个段中。 您可以使用：NONE覆盖默认段，并告诉链接器不要将该段放在任何段中。您可以在程序头类型之后使用FILEHDR和PHDRS关键字来进一步描述段的内容。FILEHDR关键字意味着该段应包含ELF文件头。PHDRS关键字意味着该段应包括ELF程序头本身。 如果应用于可加载段（PT_LOAD），则所有先前的可加载段都必须具有以下关键字之一。类型可以是以下之一。 数字表示关键字的值。PT_NULL (0)表示未使用的程序头。PT_LOAD (1)表示此程序头描述了要从文件中加载的段。PT_DYNAMIC (2)表示可以找到动态链接信息的段。PT_INTERP (3)表示可以在其中找到程序解释器名称的段。PT_NOTE (4)表示包含注释信息的段。PT_SHLIB (5)保留的程序头类型，由ELF ABI定义但未指定。PT_PHDR (6)表示可以在其中找到程序头的段。PT_TLS（7）指示包含线程本地存储的段。expression 该表达式给出程序头的数字类型。 这可以用于上面未定义的类型。您可以使用AT表达式指定将段加载到内存中的特定地址。 这与AT作为输出段使用属性时的方法一样（参考Output Section LMA）。程序头的AT命令会覆盖输出段属性。链接器通常会根据组成段的段来设置段标志。 您可以使用FLAGS关键字来显式指定段标志。 标志的值必须是整数。 它用于设置程序头的p_flags字段。下面是一个PHDRS例子， 显示了在本机ELF系统上使用的一组典型的程序头。PHDRS{headers PT_PHDR PHDRS;interp PT_INTERP;text PT_LOAD FILEHDR PHDRS;dataPT_LOAD;dynamicPT_DYNAMIC;}SECTIONS{.=SIZEOF_HEADERS;.interp:{(.interp)}:text:interp.text:{(.text)}:text.rodata:{(.rodata)}/defaultsto:text/….=.+0x1000;/movetoa new pageinmemory/.data:{(.data)}:data.dynamic:{*(.dynamic)}:data:dynamic…}3.9 VERSION 命令使用ELF时，链接器支持符号版本。符号版本仅在使用共享库时有用。当动态链接器运行的程序可能已链接到共享库的早期版本时，动态链接器可以使用符号版本来选择函数的特定版本。可以在主链接器脚本中直接包含版本脚本，也可以将版本脚本作为隐式链接器脚本提供。您也可以使用’–version script’链接器选项。VERSION命令的语法是：VERSION{version-script-commands}版本脚本命令的格式与solaris2.5中 Sun链接器使用的格式相同。版本脚本定义了一个版本节点树。您可以在版本脚本中指定节点名称和相互依赖关系。可以指定将哪些符号绑定到哪个版本节点，还可以把一组指定的符号限定到本地范围，这样在共享库的外面它们就不是全局可见的了。演示版本脚本语言的最简单方法是使用几个示例：VERS_1.1 {global:foo1;local:old*;original*;new*;
};VERS_1.2 {foo2;} VERS_1.1;VERS_2.0 {bar1; bar2;extern "C++" {ns::*;"f(int, double)";};} VERS_1.2;这个示例版本脚本定义了三个版本节点。定义的第一个版本节点是VERS_1.1’；它没有其他依赖项。脚本将符号 ‘foo1’ 绑定到 ‘VERS_1.1’ 。脚本把一些符号缩减到局部可见，因此在共享库外部它们将是不可见的；这是使用通配符模式完成的，因此以’old’,’original’,’new’开头的符号将被匹配上。通配符模板与shell匹配文件名时使用的方法一致。但是，如果把特指的符号名放在双引号中，则名字被按照字面意思处理，而不是正则表达式模板。接下来，版本脚本定义节点 ‘VERS_1.2’ 。此节点依赖于 ‘VERS_1.1’。脚本将符号 ‘foo2’绑定到版本节点 ‘VERS_1.2’。最后，版本脚本定义节点 ‘VERS_2.0’ 。此节点依赖于 ‘VERS_1.2’ 。脚本将符号 ‘bar1’ 和 ‘bar2’ 绑定到版本节点 ‘VERS_2.0’。当链接器发现在库中定义的符号没有特别绑定到版本节点时，它将有效地将其绑定到库的未指定的基本版本。通过在版本脚本的某个地方使用 ‘*global:;’，可以将所有其他未指定的符号绑定到给定的版本节点。注意，在全局规范中使用通配符有点疯狂，除了在最后一个版本节点上。其他地方的全局通配符可能会意外地将符号添加到为旧版本导出的集合中。这是错误的，因为旧版本应该有一套固定的符号。版本节点的名字没有什么特殊含义，但会给人阅读带来便利。‘2.0’版本也可以出现在 ‘1.1’ 和 ‘1.2’ 之间。然而，这将是一种令人困惑的编写版本脚本的方法。节点名可以省略，前提是它是版本脚本中唯一的版本节点。这样的版本脚本不为符号指定任何版本，只选择哪些符号将全局可见，哪些符号不可见。{global:foo;bar;local:*;};当您将应用程序链接到具有版本化符号的共享库时，应用程序本身知道它需要每个符号的哪个版本，还知道它需要链接到的每个共享库中的哪个版本节点。因此，在运行时，动态加载程序可以快速检查以确保链接到的库实际上提供了应用程序解析所有动态符号所需的所有版本节点。以这种方式，动态链接器可以确定地知道它所需要的所有外部符号将是可解析的，而不必搜索每个符号引用。符号版本控制实际上是一种更为复杂的方法，可以进行SunOS所做的次要版本检查。这里要解决的基本问题是，对外部函数的引用通常根据需要进行绑定，而不是在应用程序启动时全部绑定。如果共享库过期，则可能缺少所需的接口；当应用程序尝试使用该接口时，它可能会突然意外地失败。使用符号版本控制，如果应用程序使用的库太旧，用户在启动程序时会收到警告。Sun的版本控制方法有几个GNU扩展。其中第一项功能是将符号绑定到源文件中定义符号的版本节点，而不是在版本控制脚本中。这主要是为了减轻库维护的工作量。你可以这样做：__asm__(".symver original_foo,foo@VERS_1.1");在C源文件中。这会将函数‘original_foo’ 重命名为绑定到版本节点 ‘VERS’1.1’ 的 ‘foo’ 的别名。‘local:’ 指令可用于阻止导出符号 ‘original_foo’ 。‘.symver’ 指令优先于版本脚本。第二个GNU扩展允许同一个函数的多个版本出现在给定的共享库中。通过这种方式，您可以在不增加共享库的主要版本号的情况下对接口进行不兼容的更改，同时仍然允许与旧接口链接的应用程序继续运行。为此，必须在源文件中使用多个‘.symver’ 指令。下面是一个例子：__asm__(".symver original_foo,foo@");__asm__(".symver old_foo,foo@VERS_1.1");__asm__(".symver old_foo1,foo@VERS_1.2");__asm__(".symver new_foo,foo@@VERS_2.0");在本例中，’foo@’ 表示符号 ’foo’ 绑定到没有指定基础版本的符号版本。源文件包含此例子将会定义四个C函数：’original_foo’, ‘old_foo’, ‘old_foo1’, ‘new_foo’。当给定符号有多个定义时，需要使用某种方法指定对该符号的外部引用将绑定到的默认版本。您可以使用‘.symver’指令 的’foo@@VERS_2.0'类型的’来完成此操作。以这种方式，只能将符号的一个版本声明为默认值;否则，您将实际上拥有同一符号的多个定义。如果你希望绑定共享库中的一个符号到特定版本，只需很方便的使用别名（例如，’old_foo’），或者可以用 ’.symver’ 指令指定一个绑定到外部函数的特定版本。也可以指定版本脚本使用的语言：VERSIONextern"lang"{version-script-commands}支持的 ‘lang’是‘C’、‘C++’ 和 ‘Java’。链接器会在链接时遍历符号列表，并根据‘lang’将它们与‘version-script-commands’中指定的模式进行匹配。默认的 ‘lang’是‘C’。被分解的名字可能含有空格以及其他特殊字符。按照上面说的，可以使用正则表达式模板匹配分解的名字，或者可以使用双引号包裹的字符串来精确匹配字符串。在后一种情况中，注意位于版本脚本和分解输出间一个小的不同（比如空格）将会引起不匹配。分解器创建的字符串在未来可能会改变，即便将被重新组合的名字本身没变，在升级版本时你需要检查所有的版本指令是否都按照你期待的那样工作。3.10 连接器脚本中的表达式链接器脚本语言中的表达式的语法与C表达式的语法相同。所有表达式都被计算为整数。所有表达式都以相同的大小计算，如果主机和目标都是32位，则为32位，否则为64位。可以在表达式中使用和设置符号值。链接器定义了几个用于表达式的特殊用途内建函数。Constants: 常数Symbolic Constants: 符号常量Symbols: 符号名称Orphan Sections: 孤儿段ocation Counter: 位置计数器Operators: 运算符号Evaluation: 求值Expression Section: 表达式的段Builtin Functions: 内建函数3.10.1 常量所有的常量都是整数。与C中一样，链接器认为以 ‘0’ 开头的整数是八进制数，以 ‘0x’ 或 ‘0X’开头的整数是十六进制数。另外，链接器接受后缀 ‘h’ 或 ‘H’ 表示十六进制，‘o’ 或 ‘O’ 表示八进制，‘b’ 或 ‘B’ 表示二进制，‘d’ 或 ‘D’ 表示十进制。任何没有前缀或后缀的整数值都被认为是小数。此外，您可以使用后缀K和M分别将一个常数缩放为1024或1024*1024。例如，以下均为同一数量:_fourk_1=4K;_fourk_2=4096;_fourk_3=0x1000;_fourk_4=10000o;注意，K和M后缀不能与前面的其他系数同时使用。3.10.2 符号常量可以通过使用CONSTANT(name)操作符来引用特定于目标的常量，其中name为:MAXPAGESIZE：目标的最大页面大小。COMMONPAGESIZE：目标的默认页大小。例如：.textALIGN(CONSTANT(MAXPAGESIZE)):{*(.text)}将会创建一个对齐到目标支持的最大页边界的代码段。3.10.3 符号名除引号外，符号名称以字母、下划线或句点开始，可以包括字母、数字、下划线、句点和连字符。非引用符号名称不能与任何关键字冲突。你可以指定一个包含奇数字符的符号或与关键字同名的符号，用双引号包围符号名称:"SECTION"=9;"with a space"="also with a space"+10;由于符号可以包含许多非字母字符，用空格分隔符号是最安全的。例如，‘A-B’ 是一个符号，而 ‘A - B’ 是一个包含减法的表达式。3.10.4 缺省节输出文件中没有显式放置在链接器文件中的段。链接器仍将通过查找或创建适当的输出段将这些段复制到输出文件中，以便在其中放置孤立的输入段。如果孤立输入段的名称与现有输出段的名称完全匹配，则孤立输入段将放置在该输出段的末尾。如果没有具有匹配名称的输出段，则将创建新的输出段。每个新的输出段都将具有与其中放置的孤立段相同的名称。如果有多个具有相同名称的孤立段，这些将被合并到一个新的输出段中。如果创建新的输出节段来保存孤立的输入段，则链接器必须决定将这些新输出段相对于现有输出节的位置。在大多数现代目标上，链接器试图将孤立段放在同一属性的段之后，例如代码与数据、可加载与不可加载等。如果找不到具有匹配属性的段，或者目标缺少此支持，则孤儿段将放在文件的末尾。命令行选项 ‘–orphan-handling’ 和 ‘–unique’ (请参Command-line Options)可以用于控制孤儿放在哪个输出段。3.10.5 位置计数器特殊的链接器变量 ‘.’ 始终包含当前输出位置计数器。因为 ’.’ 经常当作一个输出段的地址使用，因此它只能位于SECTIONS命令中以一个表达式形式出现。任何普通符号可以出现在表达式中的位置都可以使用 ’.’。为 ’.’ 赋值将会使得位置计数器移动。这可以用来在输出段中创建空的区域。位置计数器不能在一个输出段内向回移动，也不能在段外回退，如果这么做了将会创建重叠的LMA。SECTIONS{output:{file1(.text).=.+1000;file2(.text).+=1000;file3(.text)}=0x12345678;}在上面的例子里，文件file1的 ’text’ 段位于输出段output的起始位置。其后有个1000字节的缝隙。此后file2的 ’.text’ 段出现在输出段内，其后也有1000字节的缝隙，最后是file3的 ’.text’ 段。标记 ’=0x12345678’ 指定了应当向缝隙中填充的内容（参考Output Section Fill）。注：’.’ 实际上是指从当前包含对象开始的字节偏移量。通常为SECTIONS声明，起始地址为0，因此 ’.’ 可以被当作一个绝对地址使用。但是如果 ’.’ 被在段描述符内使用，它表示从该段开始的偏移地址，不是一个绝对地址。因此在下面脚本中：SECTIONS{.=0x100.text:{*(.text).=0x200}.=0x500.data:{*(.data).+=0x600}}‘.text’ 段将会被安排到起始地址0x100，实际大小为0x200字节，即便 ’.text’ 输入段没有足够的数据填充该区域（反之如果数据过多，将会产生一个错误，因为将会尝试向前回退 ’.’ ）。段 ’.data’ 将会从0x500开始，并且输出段会有额外的0x600字节空余空间在输入段’.text’。如果链接器需要放置孤儿段，则将符号设置为输出段语句外部的位置计数器的值可能会导致意外的值。例如，给定如下:SECTIONS
{start_of_text = . ;.text: { *(.text) }end_of_text = . ;start_of_data = . ;.data: { *(.data) }end_of_data = . ;
}如果链接器需要放置一些脚本中没有提到的输入部分，如.rodata，它可能会选择将该部分放在.text和.data之间。你可能会认为链接器应该把.rodata放在上述脚本中的空白行上，但空白行对链接器来说并无特别意义。同样，链接器也不会将上述符号名称与它们的部分联系起来。相反，它假定所有赋值或其他语句都属于前一个输出部分，但赋值到.的特殊情况除外。 也就是说，链接器将把.rodata部分放在无主部分，就像脚本是这样写的一样：如果链接器需要放置一些输入段，例如 ’.rodata’ 没有在脚本中提及，可能会被选择放到 ’.text’ 和 ’.data’ 段中间。你可能会觉得链接器应该把 ’.rodata’ 放在上面脚本的空行处，但空行对于链接器来说没有任何实际意义。同样的，链接器也不会把符号名与段联系起来。实际上，它假设所有定义或者其他声明属于前面的输出段，除了特殊情况设定 ’.’。例如，链接器将会类似于下面的脚本放置孤儿段：SECTIONS
{start_of_text = . ;.text: { *(.text) }end_of_text = . ;start_of_data = . ;.rodata: { *(.rodata) }.data: { *(.data) }end_of_data = . ;
}这可能是脚本作者对start_of_data值的意图，也可能不是。影响孤儿部分位置的一种方法是将位置计数器赋值给自己，因为链接器认为赋值给 .是在设置后续输出部分的起始地址，因此应与该部分归为一组。因此可以写：SECTIONS
{start_of_text = . ;.text: { *(.text) }end_of_text = . ;. = . ;start_of_data = . ;.data: { *(.data) }end_of_data = . ;
}这样以来，孤儿段 ’.rodata’ 将会被放置在end_of_text和start_of_data之间。3.10.6 运算符链接器识别标准的C算术运算符集，具有标准绑定和优先级级别:precedence      associativity   OperatorsNotes(highest)1left!-~(1)2left*/%3left+-4left&gt;&gt;&lt;&lt;5left==!=&gt;&lt;&lt;=&gt;=6left&amp;7left|8left&amp;&amp;9left||10right?:11right&amp;=+=-=*=/=(2)(lowest)注意:(1)前缀操作符(2)参见 Assignments。3.10.7 评估链接器惰性地计算表达式。它只在绝对必要时才会去计算表达式的值。链接器需要一些信息，例如第一部分的起始地址的值，以及内存区域的来源和长度，才能够完成所有的链接工作。这些值会在链接器读链接脚本的时候立即计算。但是其他的值（例如符号值）在存储分配之后才能知道或者需要。这种值将会推迟计算，直到符号赋值表达式的其他信息（例如输出段的大小）都可获得后。分区的大小在分配之后才能知道，因此依赖它的赋值都将在分配后才会执行。某些表达式（例如依赖于位置计数器 ‘.’ 的表达式）必须在段分配期间求值。如果表达式的结果是必需的，但该值不可用，则会产生错误。例如，下面这样的脚本：SECTIONS{.text9+this_isnt_constant:{*(.text)}}会导致错误消息：‘non constant expression for initial address’3.10.8 表达式的分段地址和符号可以是段相对的，也可以是绝对的。段的相对符号是可重定位的。如果使用 ‘-r’ 选项请求可重定位输出，则进一步的链接操作可能会更改段相对符号的值。另一方面，绝对符号将在任何进一步的链路操作中保持相同的值。链接器表达式中的某些术语是地址。对于段相关符号和返回地址的内置函数（如ADDR、LOADADDR、ORIGIN和SEGMENT_START），都是如此。其他术语只是数字，或者是返回非地址值（如长度）的内置函数。一个复杂的问题是，除非您设置LD_FEATURE（“SANE_EXPR”）（请参见Miscellaneous Commands），否则数字和绝对符号将根据其位置进行不同的处理，以与旧版本的LD兼容。出现在输出段定义之外的表达式将所有数字视为绝对地址。出现在输出段定义中的表达式将绝对符号视为数字。如果给定了LD_FEATURE（“SANE_EXPR”），则任何位置的绝对符号和数字都被简单的当作数字。在下面这个简单的例子中：SECTIONS{.=0x100;__executable_start=0x100;.data:{.=0x10;__data_start=0x10;*(.data)}…}在上述两个赋值例子中：’.’ 和 ’__executable_start’ 都被设置为绝对地址0x100，在后两个赋值中，’.’ 和 ’__data_start’ 被设置为相对于 ’.data’ 的0x10。对于涉及数字、相对地址和绝对地址的表达式，ld采用以下规则求值:对绝对地址或数字进行一元运算，对两个绝对地址或两个数字进行二进制运算，或在一个绝对地址和一个数字之间进行二元运算，在数值上应用运算符。对一个相对地址的一元运算，以及对同一部分中的两个相对地址或一个相对地址与一个数字之间的两个相对地址的二进制运算，将运算符应用于地址的偏移部分。其他二进制操作，即不在同一段中的两个相对地址之间，或相对地址和绝对地址之间，在应用运算符之前，首先将任何非绝对项转换为绝对地址。每个子表达式的结果部分如下:只有数字参与的运算符结果为数字。比较运算’&amp;&amp;’和’||’的结果也是数字。对同一部分中的两个相对地址或两个绝对地址（在上述转换之后）进行的其他二进制算术和逻辑操作的结果，当LD_FEATURE（“SANE_EXPR”）或在输出部分定义内时，也是一个数字，但在其他情况下是绝对地址。对相对地址或一个相对地址和一个数字进行其他操作的结果是，在相对操作数的同一部分中有一个相对地址。对绝对地址的其他操作（在上述转换之后）的结果是一个绝对地址。可以使用内建函数ABSOLUTE来强制一个本来是相对地址的表达式变为绝对地址。例如，要创建一个设置为输出段‘.data’结尾地址的绝对符号：SECTIONS{.data:{*(.data)_edata=ABSOLUTE(.);}}如果不使用’ABSOLUTE’，’_edata’将会为’.data’段的相对地址。使用LOADADDR也会强制一个表达式变为绝对地址，因为此特殊内建函数返回一个绝对地址。3.10.9 内置函数链接器脚本语言包括许多用于链接器脚本表达式的内建函数。ABSOLUTE(exp)返回表达式exp的绝对值(不可重定位，非负)。主要用于在段定义中为符号赋绝对值，其中符号值通常是段相对的。参见ABSOLUTE(exp)。ADDR(section)返回名为 ’*section*’ 的段的地址（VMA）。你的脚本必须事先为该段定义了位置。在下面的例子里，start_of_output_1,symbol_1,symbol_2分配了同样的值，除了symbol_1将是相对于.output1段的，而其他两个值是绝对的:SECTIONS{….output1:{start_of_output_1=ABSOLUTE(.);…}.output:{symbol_1=ADDR(.output1);symbol_2=start_of_output_1;}…}ALIGN(align)ALIGN(exp,align)返回位置计数器(.)或任意表达式对齐到下一个align指定边界的值。单操作数ALIGN并不会改变位置计数器的值，它只是对其进行算术运算。两个操作数ALIGN允许任意表达式向上对齐(ALIGN(ALIGN)等价于ALIGN(绝对(.)，ALIGN))。下面是一个示例，它将输出 .data段对齐到上一段之后的下一个0x2000字节边界，并将该段中的一个变量设置为输入段之后的下一个0x8000字节边界:SECTIONS{….dataALIGN(0x2000):{*(.data)variable=ALIGN(0x8000);}…}在本例中，ALIGN的第一次使用指定了段的位置，因为它被用作段定义的可选地址属性(参见Output Section Address)。ALIGN的第二种用法用于定义符号的值。内建函数NEXT与ALIGN密切相关。ALIGNOF(section)如果section已分配，返回名为section的对齐字节。如果段还没被分配，链接器会报错。下面的例子里，.output段的对齐存储在该段的第一个值。SECTIONS{….output{LONG(ALIGNOF(.output))…}…}BLOCK(exp)这是ALIGN的同义词，用于与旧的链接器脚本兼容。在设置输出段的地址时最常见。DATA_SEGMENT_ALIGN(maxpagesize, commonpagesize)它等于任何一个(ALIGN(maxpagesize)+(.&amp;(maxpagesize-1)))或者(ALIGN(maxpagesize)+((.+commonpagesize-1)&amp;(maxpagesize-commonpagesize)))这取决于后者对数据段(表达式结果和DATA_SEGMENT_END之间的区域)使用的commonpagesize大小的页面是否比前者更少。如果使用后一种形式如果后面的形式被使用了，表示着保存commonpagesize字节的运行时内存，花费的代价最多浪费commonpagesize大小的磁盘空间。此表达式只能直接在SECTIONS命令中使用，不能在任何输出段描述中使用，并且只能在链接器脚本中使用一次。commonpagesize应该小于或等于maxpagesize，并且应该是对象希望优化的系统页面大小，同时仍在系统页面大小达到maxpagesize时运行。但是请注意，如果系统页面大小大于commonpagesize，则‘-z relro’保护将无效。例如：.=DATA_SEGMENT_ALIGN(0x10000,0x2000);DATA_SEGMENT_END(exp)此命令为DATA_SEGMENT_ALIGN运算定义了数据段的结尾。.=DATA_SEGMENT_END(.);DATA_SEGMENT_RELRO_END(offset, exp)此命令为使用 ’-z relro’ 命令的情况定义了PT_GNU_RELRO段的结尾。当 ’-z relro’ 选项不存在时，DATA_SEGMENT_RELRO_END不做任何事情，否则将填充DATA_SEGMENT_ALIGN，以便exp+ 偏移量与DATA_SEGMENT_ALIGN给定的commonpagesize参数对齐。如果它出现在链接器脚本中，那么它必须放在DATA_SEGMENT_ALIGN和DATA_SEGMENT_END之间。计算为第二个参数加上PT_GNU_RELRO段末尾由于节对齐而需要的任何填充。.=DATA_SEGMENT_RELRO_END(24,.);DEFINED(symbol)如果符号在链接器全局符号表中，并且在脚本中定义的语句之前定义，则返回1，否则返回0。可以使用此函数为符号提供默认值。例如，以下脚本片段演示如何将全局符号 ‘begin’ 设置为 ‘.text’ 段中的第一个位置，但如果名为 ‘begin’ 的符号已经存在，则其值将被保留。SECTIONS{….text:{begin=DEFINED(begin)?begin:.;…}…}LENGTH(memory)返回名为memory内存区域的长度。LOADADDR(section)返回名为section的段的LMA绝对地址（参见Output Section LMA）。LOG2CEIL(exp)返回exp的二进制对数，取整为无穷大。LOG2CEIL（0）返回0。MAX(exp1, exp2)返回exp1和exp2的最大值。MIN(exp1, exp2)返回exp1和exp2的最小值。NEXT(exp)返回下一个未分配的地址，它是exp的倍数。此函数与 A*LIGN(exp)*密切相关；除非使用MEMORY命令为输出文件定义不连续内存，否则这两个函数是等效的。ORIGIN(memory)返回名为memory的内存区域的起始地址。SEGMENT_START(segment, default)返回命名段的基址。如果已经为此段指定了显式值（使用命令行 ‘-T’ 选项），则将返回该值，否则该值将为默认值。目前，’-T’命令行选项只能用于设置 “text” 、“data” 和 “bss” 段的基址，但你可以使用SEGMENT_START搭配任何段名字。SIZEOF(section)返回名为section段的字节数。如果段还没被分配就是用函数求值，将会产生错误。下面是一个例子，symbol_1和symbol_2的值相同：SECTIONS{….output{.start=.;….end=.;}symbol_1=.end-.start;symbol_2=SIZEOF(.output);…}SIZEOF_HEADERSsizeof_headers返回输出文件头的大小（以字节为单位）。这是一个会出现在输出文件的起始位置的信息。如果您愿意，您可以在设置第一段的起始地址时使用此数字，以方便分页。生成ELF输出文件时，如果链接器脚本使用SIZEOF_HEADERS内建函数，则链接器必须在确定所有节地址和大小之前计算程序头的数量。如果链接器后来发现它需要额外的程序头，它将报告一个错误“没有足够的空间来容纳程序头”。要避免此错误，必须避免使用SIZEOF_HEADERS函数，或者必须重新编写链接器脚本以避免强制链接器使用其他程序头，或者必须使用PHDRS命令自己定义程序头（请参见 PHDRS）。3.11 隐式链接器脚本如果你指定了一个链接输入文件，而链接器无法将其识别为一个目标文件或者库文件，它将尝试将该文件作为链接器脚本读取。如果无法将文件解析为链接器脚本，则链接器将报告错误。隐式链接器脚本不会替换默认链接器脚本。通常，隐式链接器脚本只包含符号分配，或INPUT、GROUP或VERSION命令。读取任何输入文件时，由于隐式链接器脚本将在命令行中读取隐式链接器脚本的位置读取，这会影响库的搜索。http://www.ppmy.cn/news/1540695.html相关文章数据中台业务架构图数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。 
数据源层涵盖了企业内部各个业务系统的数据&amp;#xff0c;如 ERP、CRM 等&amp;#xff0c;以及外部数据来源&amp;#xff0c;如社交媒体、行业数据…阅读更多...C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:12 +0000</pubDate>
    </item>
    <item>
      <title>数据中台业务架构图</title>
      <link>https://www.ppmy.cn/news/1540694.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维数据中台业务架构图news/2025/10/31 21:30:10/数据中台的业务架构是企业实现数据驱动决策和业务创新的关键支撑。它主要由数据源层、数据存储与处理层、数据服务层以及数据应用层组成。数据源层涵盖了企业内部各个业务系统的数据，如 ERP、CRM 等，以及外部数据来源，如社交媒体、行业数据等。这些数据通过数据采集工具被抽取到数据中台。数据存储与处理层负责对采集到的数据进行清洗、转换和存储。通常会使用大数据技术，如 Hadoop、Spark 等，构建数据仓库和数据湖，以满足不同类型数据的存储和处理需求。同时，通过数据治理确保数据的质量和一致性。数据服务层为企业提供统一的数据服务接口，包括数据查询、数据分析、数据挖掘等功能。这一层使得不同的业务部门能够方便地获取和使用数据，而无需关心底层的数据存储和处理细节。数据应用层则是基于数据中台提供的数据服务构建各种业务应用，如智能报表、数据分析平台、精准营销系统等。这些应用帮助企业实现数据的价值转化，提升业务效率和竞争力。总之，数据中台业务架构通过整合企业内外的数据资源，提供高效的数据服务和应用，推动企业实现数字化转型和业务创新。http://www.ppmy.cn/news/1540694.html相关文章C06.L11.二维前缀和.课堂练习2.打砖块(brick)hi&amp;#xff01;我是AC使者&amp;#xff01; 题目描述 
KXT 是一个很无聊的小朋友&amp;#xff0c;一天到晚都在打坐...... 
一天&amp;#xff0c;被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中&amp;#xff0c;他可以消掉以他为左上角顶点的一个 n*nn∗n 的…阅读更多...无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:11 +0000</pubDate>
    </item>
    <item>
      <title>C06.L11.二维前缀和.课堂练习2.打砖块(brick)</title>
      <link>https://www.ppmy.cn/news/1540693.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C06.L11.二维前缀和.课堂练习2.打砖块(brick)news/2025/10/31 21:30:09/hi！我是AC使者！题目描述KXT 是一个很无聊的小朋友，一天到晚都在打坐......一天，被他发现了一个比打坐更无聊的事情——打砖块。很多块砖分布在一个m*mm∗m 的矩阵中，他可以消掉以他为左上角顶点的一个 n*nn∗n 的矩阵里的所有砖块。喜欢偷懒的他请来了你帮他计算可以消掉最多的砖块数（只能消一次）。输入格式第一行：用空格隔开的三个整数 nn、mm、kk。接下来 kk 行，每行 22 个用空格隔开的整数 x_ixi​、y_iyi​，表示第 ii 块砖在 x_ixi​ 行、y_iyi​ 列的位置。数据范围n \le mn≤m; k \le m*mk≤m∗m60% 的数据：n \le 70n≤70; m \le 70m≤70; k \le 4900k≤4900100% 的数据：n \le 1000n≤1000; m \le 1000m≤1000; k \le 1000000k≤1000000;输出格式一个整数，为可以消掉最多的砖块数。样例输入数据 15 10 11
2 1
4 6
4 9
3 9
9 7
9 9
7 9
8 10
8 8
8 6
10 2Copy输出数据 16Copy样例解释站在第 4 行、 6 列的位置，可以消除 6 个方块。答案：#include&lt;bits/stdc++.h&gt;
using namespace std;
const int t=1001;
void construction(int n,int m,int array[][t],int prefix[][t])
{for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=m;j++){prefix[i][j]=prefix[i-1][j]+prefix[i][j-1]-prefix[i-1][j-1]+array[i][j];}}
}
int regionsum(int n,int m,int xf,int xs,int yf,int ys,int prefix[][t])
{return prefix[xs][ys]-prefix[xf-1][ys]-prefix[xs][yf-1]+prefix[xf-1][yf-1];
}
int n,m,k,a[t][t],x,y,ma[t][t],L;
int main(){cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;for(int i=1;i&lt;=k;i++){cin&gt;&gt;x&gt;&gt;y;a[x][y]=1;}construction(m,m,a,ma);for(int i=1;i&lt;=m-n+1;i++){for(int j=1;j&lt;=m-n+1;j++){L=max(L,regionsum(m,m,i,i+n-1,j,j+n-1,ma));}}cout&lt;&lt;L;return 0;
}http://www.ppmy.cn/news/1540693.html相关文章无人机电机故障率骤降：创新设计与六西格玛方法论双赢项目背景 
TBR-100是消费级无人机头部企业推出的主打消费级无人机&amp;#xff0c;凭借其出色的续航能力和卓越的操控性&amp;#xff0c;在市场上获得了广泛认可。在产品运行过程&amp;#xff0c;用户反馈电机故障率偏高&amp;#xff0c;尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定…阅读更多...ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:09 +0000</pubDate>
    </item>
    <item>
      <title>无人机电机故障率骤降：创新设计与六西格玛方法论双赢</title>
      <link>https://www.ppmy.cn/news/1540692.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维无人机电机故障率骤降：创新设计与六西格玛方法论双赢news/2025/10/31 21:30:08/项目背景TBR-100是消费级无人机头部企业推出的主打消费级无人机，凭借其出色的续航能力和卓越的操控性，在市场上获得了广泛认可。在产品运行过程，用户反馈电机故障率偏高，尤其是在飞行一段时间后出现电机过热、损坏以及运行不稳定等问题。这不仅影响了产品的使用寿命，也增加了维修和售后成本，对公司品牌声誉带来了负面影响。因此，该公司与张驰咨询合作，启动了一个六西格玛黑带项目，结合DMAIC方法论和第一性原理，系统化解决TBR-100电机故障率过高的问题。问题定义电机是无人机的核心组件，电机故障率过高会直接导致无人机飞行性能下降，甚至引发飞行安全问题。本次项目的目标是通过优化电机设计和制造工艺，降低电机故障率，将其从原有的5%降低到1%以下，同时保证无人机的整体性能不受影响。关键客户需求项目团队在顾问指导下，从客户反馈中归纳出以下关键需求：•电机可靠性：电机在各种环境下能够长时间稳定运行，无故障或性能下降。•散热性能：电机在高负荷或高温环境中能够有效散热，避免过热损坏。•低维护性：电机故障率低，减少维修和更换频次，降低用户维护成本。这些需求转化为设计目标，即提高电机的稳定性、耐用性和散热效率。当前性能基准为了精确了解现有电机的性能问题，项目组对TBR-100进行了一系列故障数据收集与分析，重点关注以下三个指标：•电机故障率：通过统计生产批次和售后数据，当前TBR-100的电机故障率为5%。•电机过热时间：在高负荷飞行条件下，电机达到过热阈值的时间。•电机使用寿命：统计电机在不同使用条件下的平均寿命（以飞行小时数衡量）。通过这些数据，明确了改进的主要方向是电机的散热和结构优化，以减少过热和延长使用寿命。根本原因分析结合现有数据和第一性原理，项目组对电机故障率高的原因进行了深入分析，使用了因故分析和5 Why分析。从材料、工艺、设计、环境等多个维度展开讨论，得出以下几点根本原因：•散热设计不足：电机散热片设计未能充分考虑高负荷下的热量传导和散发，导致电机在持续飞行中过热。•料选择问题：电机绕组材料的耐温性能不足，长时间运行后容易出现绝缘层老化。•制造工艺波动：在电机装配过程中，绕组张力和定子组装的工艺参数不稳定，导致部分电机内部存在应力集中，容易导致电机运行不稳定或损坏。故障模式与影响分析（FMEA）小组进一步进行了FMEA分析，评估每个可能的失效模式对电机性能的影响以及其发生的可能性。通过打分，我们发现散热不足和绕组材料老化是主要的故障模式，需要优先解决。第一性原理分析在电机的设计和制造中，散热是由热传导和对流的物理定律控制的，而电机的耐久性则由材料的物理特性决定。基于第一性原理的分析，小组从根本上探讨了影响电机性能的物理因素，发现解决散热问题的核心是提升热传导效率和改善散热设计，而提升绕组材料的性能则需要从材料选择和工艺控制入手。设计优化结合DMAIC流程中的分析结果和第一性原理，项目组对电机的设计进行了一系列优化：•散热结构优化：通过CFD（计算流体动力学）模拟，小组设计了一种新型散热片结构，从而将电机内部热量更有效地传导到外部。同时，小组改进了电机外壳的通风孔设计，以增强空气对流散热效果。•材料选择改进：小组采用更耐高温的绝缘材料和绕组材料，能够承受更高的温度，延长电机的使用寿命。通过实验室测试，新材料在高温下的老化速率比原材料降低了30%。•工艺改进：在电机装配过程中，引入了新的自动化绕线设备，以提高绕组张力的均匀性，减少内部应力集中。同时，通过引入SPC（统计过程控制）工具，动态监控生产过程中关键工艺参数的波动，确保每批电机的质量一致性。试验设计（DOE）为优化新设计的电机性能，小组进行了多因素试验设计（DOE），测试了不同散热片形状、材料组合和工艺参数对电机性能的影响。通过经典试验设计法，确定了最优的设计参数组合，在确保成本可控的前提下，实现了电机性能的最大化改进。效果验证经过多轮改进设计后的电机在实验室环境和实际飞行测试中表现出显著的性能提升：•电机故障率：由原来的5%降低到0.8%，超出项目设定的目标。•电机过热时间：延长了35%，在高负荷飞行条件下能够持续稳定运行。•电机使用寿命：寿命提升了20%，客户反馈中的维修频率显著降低。控制计划为确保改进后的电机在量产过程中能够保持高质量水平，小组制定了详细的控制计划：•关键参数监控：通过SPC对生产过程中的关键参数进行实时监控，确保绕组张力、散热片装配精度等关键指标在受控范围内。•预防性维护：制定了新的设备维护计划，确保自动化绕线设备和其他关键生产设备始终保持最佳工作状态，避免因设备问题导致的产品质量波动。•客户反馈跟踪：建立了长期的客户反馈系统，定期收集市场上的电机故障数据，持续监控产品性能，并进行必要的改进。通过此次六西格玛DMAIC项目的实施，TBR-100无人机的电机故障率得到了显著降低，解决了影响产品可靠性的关键问题。项目的成功归功于六西格玛方法论的系统化应用和第一性原理的深入思考，使项目组能够从根本上理解并解决问题。本项目的成功有效降低了客户投诉，也为公司未来无人机产品的电机设计和优化提供了宝贵经验。下一步，项目组将继续探索更高效的电机设计和制造技术，结合智能控制算法和新材料应用，进一步提升无人机的整体性能和客户满意度。特别鸣谢：张驰管理咨询 张驰/张国生二位老师的悉心指导http://www.ppmy.cn/news/1540692.html相关文章ubuntu安装golang并设置goproxy在Ubuntu上安装Go语言&amp;#xff08;Golang&amp;#xff09;通常有几种方法&amp;#xff0c;以下是一些常见的安装步骤&amp;#xff1a; 
方法一&amp;#xff1a;使用包管理器安装 更新包列表&amp;#xff1a; sudo apt update安装Go&amp;#xff1a; sudo apt install golang-go验证安装&amp;#xff1a; go …阅读更多...Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:08 +0000</pubDate>
    </item>
    <item>
      <title>ubuntu安装golang并设置goproxy</title>
      <link>https://www.ppmy.cn/news/1540691.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维ubuntu安装golang并设置goproxynews/2025/10/31 21:30:07/在Ubuntu上安装Go语言（Golang）通常有几种方法，以下是一些常见的安装步骤：方法一：使用包管理器安装更新包列表：sudoaptupdate安装Go：sudoaptinstallgolang-go验证安装：go version方法二：从源代码编译安装安装依赖：sudoaptinstall-ygitmercurial下载Go源代码：gitclone https://go.googlesource.com/go编译安装Go：cdgo/src
./all.bash设置环境变量：将以下内容添加到你的~/.bashrc或~/.profile文件中：exportGOROOT=/home/yourusername/goexportPATH=$PATH:$GOROOT/bin替换yourusername为你的用户名，并重新加载配置文件：source~/.bashrc验证安装：go version方法三：使用版本管理工具安装（如gvm）安装GVM：bash&lt;&lt;(curl-s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)安装Go：gvminstallgo1.18.3# 替换为你需要的版本gvm use go1.18.3验证安装：go version注意事项安装完成后，确保将GOPATH环境变量设置到你的系统路径中，这是Go语言工作区的路径。你可以使用go get命令来安装第三方库。请根据你的Ubuntu版本和个人偏好选择合适的安装方法。如果你需要安装特定版本的Go，可能需要查找该版本的特定安装命令。要在Ubuntu系统中设置Go代理（goproxy），你可以按照以下步骤操作：启用Go Modules功能：对于Go 1.13及以上版本，你需要启用Go Modules功能。可以通过以下命令设置环境变量GO111MODULE：goenv-wGO111MODULE=on配置GOPROXY环境变量：你可以选择使用不同的Go代理服务。以下是一些常用的Go代理服务及其配置方法：官方Go代理（推荐）：goenv-wGOPROXY=https://goproxy.io,direct这将设置Go代理为官方的Go代理服务，该服务提供了全球CDN加速，并且支持官方sumdb。阿里云Go代理：goenv-wGOPROXY=https://mirrors.aliyun.com/goproxy/,direct阿里云提供的Go代理服务，适用于中国大陆地区，可以提供较快的下载速度。七牛云Go代理：goenv-wGOPROXY=https://goproxy.cn,direct七牛云提供的Go代理服务，同样适用于中国大陆地区，提供了极速下载和无带宽限制的特点。使配置长久生效：如果你希望这些设置长期有效，可以将上述命令添加到你的shell配置文件中，例如~/.bashrc或~/.profile：echo"export GO111MODULE=on"&gt;&gt;~/.bashrcecho"export GOPROXY=https://goproxy.io,direct"&gt;&gt;~/.bashrcsource~/.bashrc请根据你使用的shell类型（如bash, zsh等）选择正确的配置文件。验证配置：设置完成后，你可以通过以下命令来验证GOPROXY是否已经正确设置：goenv|grepGOPROXY如果输出显示了你设置的代理地址，那么配置就成功了。通过以上步骤，你就可以在Ubuntu系统中成功设置Go代理，从而加速Go依赖包的下载。http://www.ppmy.cn/news/1540691.html相关文章Kafka之消费者组与消费者消费者&amp;#xff08;Consumer&amp;#xff09;在Kafka的体系结构中是用来负责订阅Kafka中的主题&amp;#xff08;Topic&amp;#xff09;&amp;#xff0c;并从订阅的主题中拉取消息后进行处理。 
与其他消息中间件不同&amp;#xff0c;Kafka引入一个逻辑概念——消费组&amp;#xff08;Consumer Group&amp;…阅读更多...《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:07 +0000</pubDate>
    </item>
    <item>
      <title>Kafka之消费者组与消费者</title>
      <link>https://www.ppmy.cn/news/1540689.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Kafka之消费者组与消费者news/2025/10/31 21:30:05/消费者（Consumer）在Kafka的体系结构中是用来负责订阅Kafka中的主题（Topic），并从订阅的主题中拉取消息后进行处理。与其他消息中间件不同，Kafka引入一个逻辑概念——消费组（Consumer Group），我们可以理解为消费者的分类，每个消费者都对应一个消费组，消费组与消费组之间的关系是完全独立的，互不影响。1 消费组我对消费组的理解是这样的：（为了便于理解）我将它看做一个“大号的消费者”，既然它是一个“消费者”，那它就能订阅主题（即从主题那里拉取消息），所以对于主题中的一个消息来说，订阅了该主题的所有“大号的消费者（即消费组）”们都能拉取到该消息（实际上是消费组中的消费者），如下图：图①的理解是：将消费组A和消费组B看做两个“大号的消费者”，并且都订阅了主题A。图②的理解是：由于“大号的消费者A”和“大号的消费者B”都订阅了主题A，所以【消息A-1】会发送给这两个“大号的消费者（实际是消费组）”。图③的理解是：实际上【消息A-1】是被“大号消费者A”（即消费组A）和“大号消费者B”（即消费组B）中的【消费者A-1】和【消费者B-1】拉取了并处理了。再进一步来说，消费组内的消费者们实质上都处理相同的业务（可以将他们理解为同一个消费者的多个副本），而不同消费组的消费者通常来说处理的都是不同的业务。我们再举个例子来解释下：假设这样一个场景：一个请假的审批流程，请假审批通过后，会分别通知请假申请人和人力资源部门。从中我们定义出一个主题和二个消费者：主题：请假审批结果消费者A0：通知请假申请人消费者B0：通知人力资源部门期初公司人员较少请假审批的申请并不多（也就是说要消费的消息并不多），此时一个处理“通知请假申请人”的消费者节点和一个处理“通知人力资源部门”的消费者节点就可以支撑业务了，如下图：假设公司团队迅速扩张（员工人数大量增加），请假也越来越多，之前分别处理“通知请假申请人”、“通知人力资源部门”的单节点无法快速的处理消息，所以这个时候我们就需要增加节点，如下图：2 分区分配逻辑基于默认的分区分配策略，我们再来看下消费组内的消费者数量变化会对分区分配有怎样的影响（也就是分配逻辑是什么样的），如下图：图①表示：消费组内只有一个消费者时，所有分区的消息将都分配给该消费者。图②、图③表示：将原本分配给【消费者A-0】的部分分区分配给【消费者A-1】和【消费者A-2会】。图④表示：当消费组内消费者的数量等于分区数量的时候，则每个分区都会被分配一个对应消费者。图⑤表示：当消费组内的消费者数量大于分区数量的时候，并不能提高消费的效率，因为多出来的消费者分配不到任何分区也就无法消费任何消息。3 Kafka的消息投递模式消息的投递方式主要有以下两种：点对点（P2P，Point-to-Point）模式：点对点模式是基于队列的，消息生产者（Producer）将消息发送给队列，消息消费者（Consumer）从队列中接收消息并进行消费。发布/订阅（Pub/Sub）模式：发布/订阅模式是基于主题（Topic）的，消息生产者（Producer）将消息发送给主题，消息消费者（Consumer）接收所订阅主题的消息并进行消费。这两种消息投递方式Kafka同时支持，那么Kafka是如何实现的点对点模式和订阅/发布模式的呢？点对点模式：将所有订阅某主题的消费者放到一个消费组中，这样的话该主题的每条消息就只会被消费组中的一个消费者消费掉，也就相当于点对点模式的应用了。以上图为例，被分配到【分区0】的消息，只能被【消费者A-0】拉取到。订阅/发布模式：使订阅某主题的所有消费者都隶属一个专属的消费组，这样的话该主题的每条消息将会被所有消费者都处理一遍，也就相当于发布/订阅模式的应用了。以上图为例，被分配到【分区0】的消息，会被【消费者0】、【消费者1】、【消费者2】…【消费者N】拉取到。上一篇：《Kafka之生产者》下一篇：《Kafka之消费者客户端开发》http://www.ppmy.cn/news/1540689.html相关文章《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析太吾绘卷风灵月影修改器可调整游戏多项数据&amp;#xff0c;助力玩家轻松过关。启动游戏后&amp;#xff0c;按数字键1开启无敌模式&amp;#xff0c;数字键2锁定时间&amp;#xff0c;数字键3实现物品不消耗&amp;#xff0c;Ctrl数字键1则能获得无限银钱等功能&amp;#xff0c;为玩家提供全方位的游戏辅助…阅读更多...IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:05 +0000</pubDate>
    </item>
    <item>
      <title>《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析</title>
      <link>https://www.ppmy.cn/news/1540688.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维《太吾绘卷》风灵月影游戏辅助好不好用？《太吾绘卷》风灵月影游戏辅助功能 全解析news/2025/10/31 21:30:03/太吾绘卷风灵月影修改器可调整游戏多项数据，助力玩家轻松过关。启动游戏后，按数字键1开启无敌模式，数字键2锁定时间，数字键3实现物品不消耗，Ctrl+数字键1则能获得无限银钱等功能，为玩家提供全方位的游戏辅助。修改器安装地址：https://bbs.18183.com/thread-10687-1-1.htmlhttps://bbs.18183.com/thread-10687-1-1.html修改器功能说明：数字键数字键 1 - 无敌模式数字键 2 - 锁定时间数字键 3 - 物品不减数字键 4 - 无限装备/道具耐久度数字键 5 - 无限突破次数数字键 6 - 必定连接成功 (突破)数字键 7 - 无限耐心 (研读)数字键 8 - 超级速度数字键 9 - 子弹时间数字键 0 - 超级伤害/一击必杀Ctrl+数字键Ctrl+数字键 1 - 无限银钱Ctrl+数字键 2 - 无限威望Ctrl+数字键 3 - 无限资源Ctrl+数字键 4 - 无限历练点数Ctrl+数字键 5 - 无限特质点数其他按键F1~F4 - 2/4/8/16倍银钱F5~F8 - 2/4/8/16倍威望F9~F12 - 2/4/8/16倍资源Home - 取消全部部分高级功能说明无敌模式：激活后，玩家将几乎不受任何伤害，大多数攻击都会变为无效或造成极小的伤害。无限银钱/威望/资源：这些功能在相应的数值发生变化时生效，为你提供大量的游戏内货币、声望或资源。请注意，这些效果可能在生效后自动取消，需要时可重新激活。快速修习/研读：允许你更快地提升技能或研读书籍，节省大量时间。一回合建造/扩建：在建造或扩建建筑时，该功能可让你在单个回合内完成所有工作。最高促织品质：在捕捉促织时，该功能可显著提高你获得高品质促织的几率。注意事项兼容性：请确保你下载的修改器版本与你的游戏版本相匹配，以避免出现兼容性问题。备份：在使用修改器之前，建议备份你的游戏存档，以防万一出现不可预见的后果。谨慎使用：过度依赖修改器可能会降低游戏的挑战性和乐趣，建议适度使用并享受游戏本身的魅力。遵守规则：在某些多人游戏或在线服务中，使用修改器可能违反游戏规则或条款，请确保你的行为符合相http://www.ppmy.cn/news/1540688.html相关文章IO进程---day51、使用有名管道实现两个进程之间的相互通信 //管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",066…阅读更多...【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:03 +0000</pubDate>
    </item>
    <item>
      <title>IO进程---day5</title>
      <link>https://www.ppmy.cn/news/1540687.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维IO进程---day5news/2025/10/31 21:30:02/1、使用有名管道实现两个进程之间的相互通信//管道文件
#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//创建有名管道文件1if(mkfifo("./pipe1",0664)==-1){perror("创建管道文件失败");return 0;}if(mkfifo("./pipe2",0664)==-1){perror("创建管道文件失败");return 0;}getchar();  //防止当前进程结束unlink("pipe1");unlink("pipe2");return 0;
}#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//以只写的形式打开管道文件1int fd1=open("./pipe1",O_WRONLY);if(fd1 == -1){perror("open error");return -1;}printf("fd1=%d\n",fd1);//以只读的形式打开管道文件2int fd2=open("./pipe2",O_RDONLY);if(fd2 == -1){perror("open error");return -1;}printf("fd2=%d\n",fd2);//创建子进程pid_t pid1=fork();//判断读写进程if(pid1&gt;0){//接收数据字符数组char arr[180]="";while(1){printf("请输入数据：");fgets(arr,sizeof(arr),stdin);  //向终端输入字符串arr[strlen(arr)-1]='\0';  //将'\n'换成'\0'//向管道文件1中写入数据write(fd1,arr,strlen(arr));printf("发送成功\n");if(strcmp(arr,"q") == 0){break;}}}else if(pid1==0){//接收数据字符数组char brr[180]="";while(1){bzero(brr,sizeof(brr));   // 清空文件中读取的数据read(fd2,brr,sizeof(brr));printf("\n收到的消息为：%s\n",brr);if(strcmp(brr,"q")==0){break;}}//退出子进程exit(EXIT_SUCCESS);}wait(NULL);//关闭文件close(fd1);close(fd2);return 0;
}#include&lt;myhead.h&gt;
int main(int argc, const char *argv[])
{//以只读的形式打开管道文件1int fd2=open("./pipe1",O_RDONLY);if(fd2 == -1){perror("open error");return -1;}printf("fd2=%d\n",fd2);//以只写的形式打开管道文件1int fd1=open("./pipe2",O_WRONLY);if(fd1 == -1){perror("open error");return -1;}printf("fd1=%d\n",fd1);//创建子进程pid_t pid2=fork();//判断读写进程if(pid2&gt;0){//接收数据字符数组char brr[180]="";while(1){bzero(brr,sizeof(brr));   // 清空文件中读取的数据read(fd2,brr,sizeof(brr));printf("\n收到的消息为：%s\n",brr);if(strcmp(brr,"q")==0){break;}}}else if(pid2==0){//接收数据字符数组char arr[180]="";while(1){printf("请输入数据：");fgets(arr,sizeof(arr),stdin);  //向终端输入字符串arr[strlen(arr)-1]='\0';  //将'\n'换成'\0'//向管道文件1中写入数据write(fd1,arr,strlen(arr));printf("发送成功\n");if(strcmp(arr,"q") == 0){break;}}//退出子进程exit(EXIT_SUCCESS);}wait(NULL);//关闭文件close(fd1);close(fd2);return 0;
}2、思维导图http://www.ppmy.cn/news/1540687.html相关文章【无标题】海尔AI英语面试1.自我介绍 Good morning. I am delighted to have this English interview.  My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge. I posses…阅读更多...【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:02 +0000</pubDate>
    </item>
    <item>
      <title>【无标题】海尔AI英语面试</title>
      <link>https://www.ppmy.cn/news/1540686.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【无标题】海尔AI英语面试news/2025/10/31 21:30:01/1.自我介绍Good morning. I am delighted to have this English interview.My name is fu guilin. I graduated from CDUT with a degree in Information engineering. During my university years, I have laid a solid foundation in my professional knowledge.I possess several key skills. Firstly, I have strong analytical and problem - solving abilities. Independently completed competitions and achieved excellent results.Secondly, I am proficient in c、c++、Linux、keil. These skills have enabled me to handle various tasks with ease.I am also a highly motivated and self - disciplined individual. I always set clear goals for myself and strive to achieve them.I am very interested in this position. I believe that my skills and enthusiasm will enable me to make significant contributions to the company. I am looking forward to further discussion in this interview. Thank you.2.职业规划Firstly，In my career plan, in the short - term, if I am lucky enough to join this company, I would focus on quickly adapting to the new working environment and  culture. My goal is to master the basic job requirements and processes proficiently within the first three months. By actively communicating with colleagues and supervisors, I hope to gain a deep understanding of my specific responsibilities.Secondly， with one to three years, I plan to continuously improve my professional skills. I expect to become a key member of the team, handling more complex tasks independently.I believe that through continuous learning and hard work, I can achieve these career goals step by step.In addition, throughout my career development, I will always pay attention to industry trends and technological advancements. I will constantly adjust my plan according to the actual situation to ensure that my skills and abilities always meet the company's and the market's requirements.3.应对deadlineWhen it comes to dealing with deadlines，Clarify Details andBreak Down the Task。Firstly, addressing the most important part, appropriate overtime is also necessary4.怎么学习新技能Set Clear GoalsWatch instructional videos。Develop a Learning PlanSchedule Regular Study Time。Practical training is very important5.下面就是翻译复试什么的2) 你认为你工作中一次成功经历(?不太记得了3)一次运用自己专业知识解决困难的经历4)好像是你负责的一次项目经历（http://www.ppmy.cn/news/1540686.html相关文章【项目案例】-音乐播放器-Android前端实现-Java后端实现精品专题&amp;#xff1a; 
01.C语言从不挂科到高绩点 
https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm1001.2014.3001.5482 
02. SpringBoot详细教程 
https://blog.csdn.ne…阅读更多...Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:01 +0000</pubDate>
    </item>
    <item>
      <title>【项目案例】-音乐播放器-Android前端实现-Java后端实现</title>
      <link>https://www.ppmy.cn/news/1540685.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【项目案例】-音乐播放器-Android前端实现-Java后端实现news/2025/10/31 21:29:59/精品专题：01.C语言从不挂科到高绩点https://blog.csdn.net/yueyehuguang/category_12753294.html?spm=1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12753294.html?spm=1001.2014.3001.548202. SpringBoot详细教程https://blog.csdn.net/yueyehuguang/category_12789841.html?spm=1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12789841.html?spm=1001.2014.3001.548203.SpringBoot电脑商城项目https://blog.csdn.net/yueyehuguang/category_12752883.html?spm=1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12752883.html?spm=1001.2014.3001.548204.VUE3.0 核心教程https://blog.csdn.net/yueyehuguang/category_12769996.html?spm=1001.2014.3001.5482https://blog.csdn.net/yueyehuguang/category_12769996.html?spm=1001.2014.3001.5482================================||   持续分享系列教程，关注一下不迷路  ||||   视频教程：小破站：墨轩大楼             ||================================🌳 查询音乐列表功能🌾 后端查询列表功能🍄 数据库sql语句/*
Navicat MySQL Data TransferSource Server         : hui
Source Server Version : 50525
Source Host           : localhost:3306
Source Database       : musicTarget Server Type    : MYSQL
Target Server Version : 50525
File Encoding         : 65001Date: 2023-09-07 00:34:12
*/SET FOREIGN_KEY_CHECKS=0;-- ----------------------------
-- Table structure for `music`
-- ----------------------------
DROP TABLE IF EXISTS `music`;
CREATE TABLE `music` (`id` int(11) NOT NULL AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`pic` varchar(255) DEFAULT NULL,`author` varchar(255) DEFAULT NULL,`location` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ----------------------------
-- Records of music
-- ----------------------------
INSERT INTO `music` VALUES ('1', '听说爱情回来过', null, '蔡依林', 'music/听说爱情回来过 - 蔡依林.mp3');
INSERT INTO `music` VALUES ('2', '天外来物', null, '薛之谦', 'music/天外来物 - 薛之谦.mp3');
INSERT INTO `music` VALUES ('3', '药水歌', null, '药水哥', 'music/药水歌 - 药水哥.mp3');🍄 添加数据库驱动依赖访问Mysql数据库，需要用到Mysql的驱动，我们在Pom.xml中添加数据库的依赖，代码如下：&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;version&gt;5.1.46&lt;/version&gt;
&lt;/dependency&gt;🍄 数据库操作工具类在项目的util包中添加DBUtil类，该类用来访问mysql数据，具体代码如下：package com.softeem.webService.util;import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;/*** 操作数据库的工具类  -》  Mybatis 的原理*/
public class DBUtils {private static final String DRIVER_CLASS = "com.mysql.jdbc.Driver";/** url��ַ  192.168.32.125 **/private static final String URL = "jdbc:mysql://127.0.0.1:3306/music?useUnicode=true&amp;characterEncoding=utf8";private static final String USER = "root";private static final String PASSWORD = "123456";static {try {Class.forName(DRIVER_CLASS);} catch (ClassNotFoundException e) {e.printStackTrace();}}/*** 链接数据库的方法*/public static Connection getConn() {try {return DriverManager.getConnection(URL, USER, PASSWORD);} catch (SQLException e) {e.printStackTrace();}return null;}/*** 数据库更新的工具方法* @param sql   需要执行的sql语句* @param params  执行sql语句需要的参数* @return* @throws SQLException*/public static boolean exeUpdate(String sql,Object ...params) throws SQLException {//获取数据库链接Connection conn = getConn();//预编译sql语句PreparedStatement ps = conn.prepareStatement(sql);//配置sql语句中的问号for(int i = 0;i&lt;params.length;i++) {ps.setObject(i+1, params[i]);}//执行sql语句int i = ps.executeUpdate();//关闭数据库链接ps.close();conn.close();//返回执行结果return i &gt; 0 ? true : false;}/*** 查询多条数据的工具方法* @param t* @param sql* @param params* @param &lt;T&gt;* @return*/public static &lt;T&gt; List&lt;T&gt; queryList(Class&lt;T&gt; t, String sql, Object... params) {List&lt;T&gt; list = new ArrayList&lt;&gt;();T obj = null;Connection conn = null;PreparedStatement ps = null;try {conn = getConn();ps = conn.prepareStatement(sql);for (int i = 0; i &lt; params.length; i++) {ps.setObject(i + 1, params[i]);}ResultSet rs = ps.executeQuery();ResultSetMetaData rsmd = rs.getMetaData();Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();while (rs.next()) {map.clear();for (int i = 0; i &lt; rsmd.getColumnCount(); i++) {String cname = rsmd.getColumnLabel(i + 1);Object value = rs.getObject(cname);map.put(cname, value);}if (!map.isEmpty()) {Set&lt;String&gt; columnNames = map.keySet();obj = t.newInstance();for (String column : columnNames) {Object value = map.get(column);if(Objects.nonNull(value)){	Field f = t.getDeclaredField(column);f.setAccessible(true);f.set(obj, value);}}list.add(obj);}}} catch (SQLException e) {e.printStackTrace();} catch (InstantiationException e) {e.printStackTrace();} catch (IllegalAccessException e) {e.printStackTrace();} catch (NoSuchFieldException e) {e.printStackTrace();} catch (SecurityException e) {e.printStackTrace();}return list;}/*** 查询单条数据的工具方法* @param t* @param sql* @param params* @param &lt;T&gt;* @return*/public static &lt;T&gt; T queryOne(Class&lt;T&gt; t, String sql, Object... params) {T obj = null;Connection conn = null;PreparedStatement ps = null;try {conn = getConn();ps = conn.prepareStatement(sql);for (int i = 0; i &lt; params.length; i++) {ps.setObject(i + 1, params[i]);}ResultSet rs = ps.executeQuery();ResultSetMetaData rsmd = rs.getMetaData();if (rs.next()) {obj = t.newInstance();for (int i = 0; i &lt; rsmd.getColumnCount(); i++) {String cname = rsmd.getColumnLabel(i + 1);Object value = rs.getObject(cname);if(Objects.nonNull(value)){						Field field = t.getDeclaredField(cname);field.setAccessible(true);field.set(obj, value);}}}} catch (SQLException e) {e.printStackTrace();} catch (InstantiationException e) {e.printStackTrace();} catch (IllegalAccessException e) {e.printStackTrace();} catch (NoSuchFieldException e) {e.printStackTrace();} catch (SecurityException e) {e.printStackTrace();}return obj;}}🍄添加实体类在项目中添加Music类，其中的属性与数据库中的music表字段对应，用来暂存从数据库中查询出来的音乐数据。具体代码如下：package com.softeem.webService.entity;import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;@Data
@NoArgsConstructor
@AllArgsConstructor
public class Music {private int id;private String name;private String pic;private String author;private String location ;
}🍄 编写查询音乐列表的接口在Controller包中添加MusicListController并绑定music_list请求，当发送music_list请求时，访问service方法，去查询出所有的音乐列表，返回给客户端，具体代码如下：package com.softeem.webService.controller;import com.alibaba.fastjson2.JSONObject;
import com.softeem.webService.service.MusicService;
import com.softeem.webService.util.Result;import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;@WebServlet("/music_list")
public class MusicListController extends HttpServlet {@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {// 设置请求编码req.setCharacterEncoding("utf-8");// 设置响应编码resp.setContentType("text/html;charset=utf-8");// 创建业务端MusicService service = new MusicService();// 调用服务端获取所有的音乐Result result = service.getAllMusics();// 将音乐列表转换成json对象JSONObject jsonObject = JSONObject.from(result);// 将结果返回给客户端PrintWriter out = resp.getWriter();out.println(jsonObject);}
}🍄 编写业务端，查询音乐列表在项目中新建一个MusicService类，用来作为业务端口，负责处理有关于音乐的业务，具体代码如下：package com.softeem.webService.service;import com.softeem.webService.dao.MusicDao;
import com.softeem.webService.entity.Music;
import com.softeem.webService.util.Result;import java.util.List;public class MusicService {/*** 获取所有的音乐* @return*/public Result getAllMusics() {// 创建DaoMusicDao dao = new MusicDao();// 操作数据库，查询所有的音乐列表List&lt;Music&gt; musicList = dao.findAllMusics();// 将查询出来的音乐列表进行封装return Result.success(musicList);}
}🍄 操作数据库，查询音乐在项目中新建一个MusicDao类，该类负责操作数据库中的music表，目前我们先暂时只添加一个查询所有音乐的方法，具体代码如下：package com.softeem.webService.dao;import com.softeem.webService.entity.Music;
import com.softeem.webService.util.DBUtils;import java.util.List;public class MusicDao {public List&lt;Music&gt; findAllMusics() {String sql = "select * from music";return DBUtils.queryList(Music.class,sql);}
}🍄测试编写完毕之后，启动服务器，在浏览器中输入以下地址：http://localhost:8080/music_list显示结果如下：🌾 前端Android程序🍄 编写列表布局界面在layout文件夹中新建music_list.xml，添加ListView代码如下：&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:layout_width="match_parent"android:layout_height="match_parent"android:orientation="vertical"android:background="#000000"&gt;
&lt;ListViewandroid:id="@+id/music_list"android:layout_width="match_parent"android:layout_height="match_parent"android:divider="@drawable/category_item_bg77"android:gravity="center"/&gt;
&lt;/LinearLayout&gt;🍄 编写列表选项布局界面在layout文件夹中新建music_item.xml布局文件，为列表中的每一个选项进行布局，具体代码如下：&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:layout_width="match_parent"android:layout_height="wrap_content"android:gravity="center"&gt;&lt;TextViewandroid:id="@+id/num"android:layout_width="100px"android:layout_height="50dp"android:textSize="30px"android:gravity="center_vertical"android:textColor="#FFFFFF"android:singleLine="true"/&gt;&lt;TextViewandroid:id="@+id/music_name"android:layout_width="194dp"android:layout_height="50dp"android:layout_marginLeft="30px"android:text="过火"android:textSize="30px"android:gravity="center_vertical"android:textColor="#FFFFFF"android:singleLine="true"&gt;&lt;/TextView&gt;&lt;TextViewandroid:id="@+id/music_author"android:layout_width="138dp"android:layout_height="50dp"android:layout_marginLeft="50px"android:text="张信哲"android:textSize="30px"android:gravity="center_vertical"android:textColor="#FFFFFF"android:singleLine="true"&gt;&lt;/TextView&gt;&lt;TextViewandroid:id="@+id/music_id"android:layout_width="100px"android:layout_height="50dp"android:textSize="30px"android:gravity="center_vertical"android:textColor="#FFFFFF"android:singleLine="true"/&gt;
&lt;/LinearLayout&gt;🍄Music实体类：package com.moxuan.mytest;public class Music {private int id;private String name;private String pic;private String author;private String location ;public int getId() {return id;}public void setId(int id) {this.id = id;}public String getName() {return name;}public void setName(String name) {this.name = name;}public String getPic() {return pic;}public void setPic(String pic) {this.pic = pic;}public String getAuthor() {return author;}public void setAuthor(String author) {this.author = author;}public String getLocation() {return location;}public void setLocation(String location) {this.location = location;}
}🍄 编写列表适配器新建MusicListAdapter类，用来适配查询出来的音乐数据和列表布局界面，具体代码如下：package com.moxuan.mytest;import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;import androidx.recyclerview.widget.RecyclerView;import java.util.List;public class MusicListAdapter extends BaseAdapter {// 音乐列表数据源private List mData;// 声明布局服务private LayoutInflater mLayoutInflater;/*** 构造方法，创建适配器* @param context* @param data*/public MusicListAdapter(Context context, List data){mData = data;mLayoutInflater = LayoutInflater.from(context);}/*** 获取列表的总条目数* @return*/@Overridepublic int getCount() {return mData.size();}/*** 获取列表中指定位置上的条目* @param position* @return*/@Overridepublic Object getItem(int position) {return mData.get(position);}/*** 获取条目在列表中的位置* @param position* @return*/@Overridepublic long getItemId(int position) {return position;}/*** 适配数据到布局文件中* @param position 位置* @param convertView 选项布局视图* @param parent* @return*/@Overridepublic View getView(int position, View convertView, ViewGroup parent) {ViewHolder viewHolder;if (convertView == null) {// 获取布局文件convertView = mLayoutInflater.inflate(R.layout.music_item, parent, false);viewHolder = new ViewHolder();//获取显示歌曲名称的视图viewHolder.nameView = convertView.findViewById(R.id.music_name);// 获取歌手的视图viewHolder.authorView = convertView.findViewById(R.id.music_author);// 获取歌曲编号的视图viewHolder.numView = convertView.findViewById(R.id.num);viewHolder.idView = convertView.findViewById(R.id.music_id);// 将视图设置到布局中convertView.setTag(viewHolder);} else {viewHolder = (ViewHolder) convertView.getTag();}// 将音乐数据，适配到对应的视图中Music music = (Music) mData.get(position);viewHolder.nameView.setText(music.getName());viewHolder.authorView.setText(music.getAuthor());viewHolder.numView.setText((position+1)+".");// 传入id，方便后续根据id查找歌曲Log.i("info",music.getId()+"");viewHolder.idView.setText(music.getId()+"");// 将id隐藏起来viewHolder.idView.setVisibility(View.GONE);return convertView;}/*** 自定义子选项布局视图* 对应music_item.xml中的组件*/static class ViewHolder {TextView numView;TextView nameView;TextView authorView;TextView idView;}
}🍄 编写MusicListActivity编写MusicListActivity发送请求，向服务器获取音乐列表，并通过适配器，显示出来，具体代码如下：package com.moxuan.mytest;import android.app.Activity;
import android.app.DownloadManager;
import android.os.Bundle;
import android.util.Log;
import android.widget.ListView;
import android.widget.Toast;import androidx.annotation.Nullable;import com.loopj.android.http.AsyncHttpClient;
import com.loopj.android.http.AsyncHttpResponseHandler;
import com.loopj.android.http.RequestParams;import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;import java.util.ArrayList;
import java.util.List;import cz.msebera.android.httpclient.Header;public class MusicListActivity extends Activity {// 显示音乐列表的列表视图ListView musicListView;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {super.onCreate(savedInstanceState);// 加载布局文件setContentView(R.layout.music_list);// 获取列表视图musicListView = findViewById(R.id.music_list);// 封装请求参数RequestParams requestParams = new RequestParams();// 发送异步请求 想服务端请求音乐列表数据// 注意：192.168.5.107 为我电脑上的IP，大家写的时候需要换成自己服务器端ip地址new AsyncHttpClient().post("http://192.168.5.107:8080/music_list", requestParams, new AsyncHttpResponseHandler() {/*** 当服务器成功响应时会执行的方法* @param status  服务器当前的状态， 值为200时，代表着服务成功处理请求，并返回了数据* @param headers* @param responseBody 服务器返回的数据*/@Overridepublic void onSuccess(int status, Header[] headers, byte[] responseBody) {// 如果服务器成功返回数据if(status==200){// 将返回的数据转换成json对象try {JSONObject jsonObject = new JSONObject(new String(responseBody));// 获取json数组，数组中存放的是音乐数据JSONArray musics_array = jsonObject.getJSONArray("data");List&lt;Music&gt; musicList = new ArrayList&lt;&gt;();// 遍历音乐数据，将音乐数据封装到音乐列表中for(int i=0;i&lt;musics_array.length();i++){Music music = new Music();JSONObject jo = musics_array.getJSONObject(i);music.setId(jo.getInt("id"));music.setAuthor(jo.getString("author"));music.setLocation(jo.getString("location"));music.setName(jo.getString("name"));musicList.add(music);}// 创建音乐列表适配器，将查询出来的音乐列表显示出来MusicListAdapter adapter = new MusicListAdapter(MusicListActivity.this,musicList);musicListView.setAdapter(adapter);} catch (JSONException e) {e.printStackTrace();}}}/*** 如果服务器响应失败会执行的方法* @param i* @param headers* @param bytes* @param throwable*/@Overridepublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {Toast.makeText(MusicListActivity.this,"服务器繁忙",Toast.LENGTH_LONG).show();}});}
}🍄 注册MusicListActivity在AndroidManifest.xml中注册MusicListActivity，并将其设置为启动页，具体代码如下：&lt;activity android:name=".MusicListActivity"&gt;&lt;intent-filter&gt;&lt;action android:name="android.intent.action.MAIN" /&gt;&lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt;
&lt;/activity&gt;🍄测试效果启动模拟器，运行程序，效果如下所示：🌳 歌曲详情页🌾 后端查询歌曲详情🍄编写查询接口编写查询单曲的接口，调用业务端，传入id根据id查找歌曲，查询完毕之后，将查询出来的结果封装到Result中并转化为json对象，并返回给客户端。package com.softeem.webService.controller;import com.alibaba.fastjson2.JSONObject;
import com.softeem.webService.service.MusicService;
import com.softeem.webService.util.Result;import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;@WebServlet("/music")
public class MusicController extends HttpServlet {@Overrideprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {req.setCharacterEncoding("utf-8");resp.setContentType("text/html;charset=utf-8");// 获取请求参数中的music_idint id = Integer.parseInt(req.getParameter("music_id"));// 创建业务端MusicService service = new MusicService();// 业务端根据id获取音乐，并封装成resultResult result = service.getMusicById(id);// 将result转换为json对象JSONObject jsonObject = JSONObject.from(result);// 返回数据到客户端PrintWriter out = resp.getWriter();out.println(jsonObject);}
}🍄 编写业务端在业务端调用dao，根据id查询歌曲详情，并封装到result对象中，具体代码如下：public Result getMusicById(int id) {MusicDao dao = new MusicDao();Music music = dao.findMusicById(id);return Result.success(music);
}🍄 编写Dao在Dao中使用工具类，根据id查询出歌曲信息，具体代码如下:public Music findMusicById(int id) {String sql = "select * from music where id=?";return DBUtils.queryOne(Music.class,sql,id);
}🍄 测试运行服务器测试，输入以下请求地址进行测试：🌾 前端展示歌曲详情🍄 编写显示详情布局文件&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="vertical"android:layout_width="fill_parent"android:layout_height="fill_parent"android:background="#000000"&gt;&lt;TextViewandroid:id="@+id/music_name"android:text="旺财小宝贝"android:layout_width="match_parent"android:layout_height="wrap_content"android:gravity="center"android:textSize="30sp"android:textColor="#FFFFFF"android:layout_marginTop="10dp"&gt;&lt;/TextView&gt;&lt;TextViewandroid:id="@+id/music_author"android:text="攀哥"android:layout_width="match_parent"android:gravity="center"android:layout_height="wrap_content"android:textSize="30sp"android:textColor="#FFFFFF"android:layout_marginBottom="30dp"android:layout_marginTop="10dp"&gt;&lt;/TextView&gt;&lt;LinearLayoutandroid:layout_height="wrap_content"android:id="@+id/linearLayout1"android:layout_width="match_parent"android:gravity="center"&gt;&lt;ImageButtonandroid:layout_height="wrap_content"android:layout_width="wrap_content"android:id="@+id/play"android:src="@drawable/play"&gt;&lt;/ImageButton&gt;&lt;ImageButtonandroid:layout_height="wrap_content"android:layout_width="wrap_content"android:id="@+id/pause"android:src="@drawable/pause"&gt;&lt;/ImageButton&gt;&lt;ImageButtonandroid:layout_height="wrap_content"android:layout_width="wrap_content"android:id="@+id/stop"android:src="@drawable/stop"&gt;&lt;/ImageButton&gt;&lt;/LinearLayout&gt;&lt;/LinearLayout&gt;🍄 给列表选项添加点击监听器在MusicListActivity中给ListView添加子选项点击事件监听器，代码如下：在oncreate()方法中添加如下方法：// 给列表视图添加点击事件
musicListView.setOnItemClickListener(this);添加onItemClick方法：@Override
public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {TextView tv = view.findViewById(R.id.music_id);String music_id = tv.getText().toString();Intent it = new Intent(this,MusicActivity.class);it.putExtra("music_id",music_id);startActivity(it);}🍄编写MusicActivity展示歌曲详情在MusicActivity中将music_id发送给服务端，让服务端根据music_id查询数据，并将返回的数据设置到详情页中，具体代码如下：package com.moxuan.mytest;import android.app.Activity;
import android.app.AlertDialog;
import android.content.Intent;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.view.View;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;import androidx.annotation.Nullable;import com.loopj.android.http.AsyncHttpClient;
import com.loopj.android.http.AsyncHttpResponseHandler;
import com.loopj.android.http.RequestParams;import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;import java.util.ArrayList;
import java.util.List;import cz.msebera.android.httpclient.Header;public class MusicActivity extends Activity {private ImageButton play,pause,stop;private MediaPlayer mp;private TextView music_name;private TextView music_author;public void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.music);play = findViewById(R.id.play);pause = findViewById(R.id.pause);stop = findViewById(R.id.stop);music_name = findViewById(R.id.music_name);music_author = findViewById(R.id.music_author);Intent it = getIntent();String music_id = it.getStringExtra("music_id");RequestParams requestParams = new RequestParams();requestParams.add("music_id", music_id);new AsyncHttpClient().post("http://172.17.29.89:8080/music", requestParams, new AsyncHttpResponseHandler() {/*** 当服务器成功响应时会执行的方法** @param status       服务器当前的状态， 值为200时，代表着服务成功处理请求，并返回了数据* @param headers* @param responseBody 服务器返回的数据*/@Overridepublic void onSuccess(int status, Header[] headers, byte[] responseBody) {// 如果服务器成功返回数据if (status == 200) {// 将返回的数据转换成json对象try {JSONObject jsonObject = new JSONObject(new String(responseBody));// 获取json数组，数组中存放的是音乐数据JSONObject music_str = jsonObject.getJSONObject("data");music_name.setText("歌曲名：" + music_str.getString("name"));music_author.setText("歌手：" + music_str.getString("author"));} catch (JSONException e) {e.printStackTrace();}}}/*** 如果服务器响应失败会执行的方法** @param i* @param headers* @param bytes* @param throwable*/@Overridepublic void onFailure(int i, Header[] headers, byte[] bytes, Throwable throwable) {Toast.makeText(MusicActivity.this, "服务器繁忙", Toast.LENGTH_LONG).show();}});}
}🍄 测试效果http://www.ppmy.cn/news/1540685.html相关文章Linux的Spark 环境部署前言:需自行准备hadoop集群 
1. Spark 是一款分布式内存计算引擎&amp;#xff0c; 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品&amp;#xff0c; 作为最新一代的综合计算引擎&amp;#xff0c; 支持离线计算和实 时计算。 在大数据领域广泛应用&amp;#xff0c; 是目前世界上使…阅读更多...linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:30:00 +0000</pubDate>
    </item>
    <item>
      <title>Linux的Spark 环境部署</title>
      <link>https://www.ppmy.cn/news/1540684.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Linux的Spark 环境部署news/2025/10/31 21:29:58/前言:需自行准备hadoop集群1. Spark 是一款分布式内存计算引擎， 可以支撑海量数据的分布式计算。 Spark 在大数据体系是明星产品， 作为最新一代的综合计算引擎， 支持离线计算和实 时计算。 在大数据领域广泛应用， 是目前世界上使用最多的大数据分布式计算引擎。 我们将基于前面构建的 Hadoop 集群， 部署 Spark Standalone 集群。2.安装spark镜像安装https://mirrors.aliyun.com/apache/spark/spark-3.5.3/?spm=a2c6h.25603864.0.0.12d22104b1PXSX3.解压:   命令: tar -zxvf spark-3.5.3-bin-hadoop3.tgz -C /export/server/4.创建软连接  命令:  ln -s /export/server/spark-3.5.3-bin-hadoop3 /export/server/spark5.改名命令:   cd /export/server/spark/confmv spark-env.sh.template spark-env.shmv workers.template workers6.修改配置文件， spark-env.sh加入:JAVA_HOME=/export/server/jdkHADOOP_CONF_DIR=/export/server/hadoop/etc/hadoopYARN_CONF_DIR=/export/server/hadoop/etc/hadoopexport SPARK_MASTER_HOST=wtkexport SPARK_MASTER_PORT=7077SPARK_MASTER_WEBUI_PORT=8080SPARK_WORKER_CORES=1SPARK_WORKER_MEMORY=1g7.修改配置文件，workers清空加入:各个主机名8.分发到各个主机命令  scp -r /export/server/spark-3.5.3-bin-hadoop3 wtk1:/export/server/部分文件:9.给分配主机创建软连接命令:   ln -s /export/server/spark-3.5.3-bin-hadoop3 /export/server/spark10.启动spark命令:   /export/server/spark/sbin/start-all.sh11.验证:打开spark监控页面主机ip:8081我的是192.168.10.130:8081提交测试任务:(执行以下脚本,主机名自行修改):/export/server/spark/bin/spark-submit --master spark://wtk:7077 --class org.apache.spark.examples.SparkPi /export/server/spark-3.5.3-bin-hadoop3/examples/jars/spark-examples_2.12-3.5.3.jar  examples_2.11-2.4.5.jark网页刷新,发现脚本已经执行完毕此时显示应用程序完成这就是spark的安装部署了http://www.ppmy.cn/news/1540684.html相关文章linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420jenkins的目录&amp;#xff1a; 
/usr/jenkins 
启动命令 java -Djava.awt.headlesstrue sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort8090 任意目录启动&amp;#xff1a; 
nohup java -Djava.awt.headlesstrue -Xms1024m -Xmx1024m -jar /usr/j…阅读更多...Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:59 +0000</pubDate>
    </item>
    <item>
      <title>linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420</title>
      <link>https://www.ppmy.cn/news/1540683.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维linux 环境运行 jenkins.war包，有可能会出现字体问题，jdk版本：11 jenkins 版本：2.420news/2025/10/31 21:29:57/jenkins的目录：/usr/jenkins启动命令java -Djava.awt.headless=true sudo timedatectl set-timezone Asia/Shanghai-Xmx1024m -jar jenkins.war --httpPort=8090任意目录启动：nohup java -Djava.awt.headless=true -Xms1024m -Xmx1024m -jar /usr/jenkins/jenkins.war --httpPort=8090 &gt;/usr/jenkins/log_jenkins.log 2&gt;&amp;1 &amp;服务器设置北京时间sudo timedatectl set-timezone Asia/Shanghai测试时间是否正确datejdk下载地址：【免费】linux环境-jdk11-jdk-11.0.8-linux-x64-bin.tar资源-CSDN文库jenkins的下载地址：【免费】linux环境-jenkins2.420.war资源-CSDN文库产生的秘钥a2a528c111204ba0b7eb643672540c8c安装字体sudo yum install fontconfigsudo yum install xorg-x11-fonts-type1可以尝试安装一些基本的字体库，以确保系统有可用的字体。可以使用以下命令来安装常见的字体包：sudo yum install fontconfig fontconfig-devel在某些情况下，字体配置文件可能缺失或损坏。可以尝试生成新的字体缓存。运行以下命令：fc-cache -f -v启动命令java -Djava.awt.headless=true -Xmx1024m -jar jenkins.war --httpPort=8090访问地址：http://192.168.116.156:8090/安装插件安装部署项目配置maven配置git配置git 的账号（注意 注意 注意，保存后刷新就出来下面的界面了）配置git的账号配置jdk配置远程服务器开始构建项目配置历史清理的规则配置git地址Pre Steps 打包之前删除上次的部署的代码，Build 是  构建包文件名/pom.xml配置 Post Steps   这里配置 远程服务器的名字，配置 服务器二运行脚本#!/bin/bash# 定义远程服务器信息
REMOTE_USER="root"
REMOTE_PASSWORD="vagrant"
REMOTE_HOST="192.168.116.155"# 定义远程服务器上的变量
REMOTE_JAR_PATH="/home/java/app/ruo-admin.jar"
REMOTE_JAR_SOURCE="$WORKSPACE/ruoyi-web/ruoyi-admin/target/ruoyi-admin.jar"
REMOTE_LOG_FILE="/home/java/app/logs/ruo-admin.log"
REMOTE_PID_FILE="/home/java/app/pid/ruo-admin.pid"
REMOTE_DUMP_FILE="/home/java/app/dump/ruo-admin"# 通过 sshpass 执行远程命令来删除旧的 JAR 文件
sshpass -p "$REMOTE_PASSWORD" ssh "$REMOTE_USER@$REMOTE_HOST" "bash -c '
if [ -f \"$REMOTE_JAR_PATH\" ]; thenecho \"Removing old JAR file...\"rm -f \"$REMOTE_JAR_PATH\" || { echo \"Failed to remove old JAR file\"; exit 1; }
elseecho \"No old JAR file found, skipping removal.\"
fi
'"# 通过 scp 将新的 JAR 文件拷贝到远程服务器
echo "Copying new JAR file..."
sshpass -p "$REMOTE_PASSWORD" scp "$REMOTE_JAR_SOURCE" "$REMOTE_USER@$REMOTE_HOST:$REMOTE_JAR_PATH" || { echo "Failed to copy new JAR file"; exit 1; }# 在远程服务器上执行剩下的命令，启动新的进程
sshpass -p "$REMOTE_PASSWORD" ssh "$REMOTE_USER@$REMOTE_HOST" "bash -c '
cd /home/java/app/ || { echo \"Failed to change directory\"; exit 1; }# 阻止 Jenkins 杀死项目进程
export BUILD_ID=dontKillMe# 停止旧进程（如果有 PID 文件）
if [ -f \"$REMOTE_PID_FILE\" ]; thenOLD_PID=\$(cat \"$REMOTE_PID_FILE\")if ps -p \"\$OLD_PID\" &gt; /dev/null; thenecho \"Stopping old process with PID \$OLD_PID...\"kill \"\$OLD_PID\" || { echo \"Failed to stop old process\"; exit 1; }rm \"$REMOTE_PID_FILE\" || { echo \"Failed to remove PID file\"; exit 1; }elseecho \"Old process with PID \$OLD_PID not found.\"fi
elseecho \"No PID file found, skipping old process stop.\"
fi# 启动新进程
echo \"Starting new process...\"
nohup /usr/java/jdk-11.0.8/bin/java -Dfile.encoding=UTF-8 -Xms256m -Xmx512m -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=256M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=\"$REMOTE_DUMP_FILE\" -jar ruo-admin.jar &gt;\"$REMOTE_LOG_FILE\" 2&gt;&amp;1 &amp;
NEW_PID=\$!
echo \"\$NEW_PID\" &gt; \"$REMOTE_PID_FILE\"echo \"New process started with PID \$NEW_PID.\"
'"运行失败使用 sshpass -p 需要 在目标服务器 安装sshpasssudo yum install sshpass安装完成后，可以通过以下命令确认sshpass是否成功安装：sshpass -V如果 sshpass 安装失败如果epel-release包未找到，你可以手动安装 EPEL 仓库。以下是步骤：# 下载 EPEL RPM 文件
sudo yum install -y https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm安装后再次尝试：sudo yum install -y sshpass更改软件源如果以上步骤仍然无效，可以尝试更换你的 yum 源为阿里云、清华大学等国内镜像。使用阿里云的 YUM 源运行以下命令，备份现有的 yum repo 文件并使用阿里云源：# 备份现有 repo 文件
sudo cp /etc/yum.repos.d/CentOS-* /etc/yum.repos.d/bak/# 使用阿里云的 CentOS 7 源
sudo bash -c 'cat &gt; /etc/yum.repos.d/CentOS-Base.repo &lt;&lt; EOF
[base]
name=CentOS-$releasever - Base
baseurl=http://mirrors.aliyun.com/centos/7/os/x86_64/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS7
enabled=1[updates]
name=CentOS-$releasever - Updates
baseurl=http://mirrors.aliyun.com/centos/7/updates/x86_64/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS7
enabled=1[epel]
name=EPEL for CentOS
baseurl=http://mirrors.aliyun.com/epel/7/x86_64/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-7
enabled=1
EOF'尝试安装 sshpass在更新了 repo 后，再次清理缓存并安装sshpass：sudo yum clean all
sudo yum makecache
sudo yum install -y sshpass安装成功继续运行  又出现新的 错误问题出在 SSH 连接时的主机密钥验证失败。这通常是因为目标主机的 SSH 密钥未被验证或记录。要解决这个问题，请按照以下步骤进行操作：在 Jenkins 服务器上，运行以下命令：#  ssh user@远程服务器ipssh user@192.168.116.155运行后弹出如下信息  输入 yes[root@localhost ~]# ssh user@192.168.116.155The authenticity of host '192.168.116.155 (192.168.116.155)' can't be established.ECDSA key fingerprint is SHA256:ESG6zOwTENvgNUzbTHyYjBJG5DbftIbWpT4fxtQw9NY.ECDSA key fingerprint is MD5:fc:98:53:d1:46:55:57:db:50:8a:a2:aa:11:7b:2d:85.Are you sure you want to continue connecting (yes/no)?然后 输入目标服务器的密码最后表示成功jenkins 重新部署提示新问题  是 目标路径不存在没有app目录新建 app 目录再次 重新部署提示部署成功，但是 目标服务器没启动，但是jar包已经传输过去了错误 原因是 脚本里面 的 pid 目录没找到  ，目标服务器 新建 pid 、logs、dump 等目录部署成功远程服务器 启动成功调用接口 又报错192.168.116.155:9090/captchaImage原来是linux 没对应的字体，需要安装字体安装字体sudo yum install -y fontconfig
sudo yum install -y liberation-fonts然后重新部署 删除远程服务器的jar包启动成功测试接口  成功http://www.ppmy.cn/news/1540683.html相关文章Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发开篇&amp;#xff0c;先说一个好消息&amp;#xff0c;截止到2025年1月1日前&amp;#xff0c;翻到文末找到我&amp;#xff0c;赠送定制版的开题报告和任务书&amp;#xff0c;先到先得&amp;#xff01;过期不候&amp;#xff01; 如何使用Stellar SDK for Python进行金融应用开发 
在金融科技领域&amp;#xff0c;区…阅读更多...大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:58 +0000</pubDate>
    </item>
    <item>
      <title>Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发</title>
      <link>https://www.ppmy.cn/news/1540682.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python知识点：基于Python工具，如何使用Stellar SDK进行金融应用开发news/2025/10/31 21:29:56/开篇，先说一个好消息，截止到2025年1月1日前，翻到文末找到我，赠送定制版的开题报告和任务书，先到先得！过期不候！如何使用Stellar SDK for Python进行金融应用开发在金融科技领域，区块链技术以其去中心化、透明性和安全性的特点，为金融行业带来了革命性的变化。Stellar是一个开源的分布式账本平台，旨在连接银行、支付系统和个人用户，使跨境支付变得更加快速、可靠和低成本。Stellar Python SDK，也称为py-stellar-base，是一个专为Stellar网络设计的Python库，它允许开发者与Stellar Horizon服务器及Soroban-RPC服务器进行通信，是构建Stellar应用的得力助手。Stellar Python SDK简介Stellar Python SDK提供了丰富的功能，包括：网络层API：用于Horizon端点和Soroban-RPC服务器方法的通信。交易构建与签名：方便开发者构建和签名交易，与Stellar网络进行交互。查询网络历史：支持提交交易或查询网络历史记录。该库支持Python 3.8及以上版本，以及PyPy 3.8+，确保了广泛的兼容性和高效的运行性能。安装Stellar Python SDK首先，你需要安装Stellar Python SDK。可以通过pip安装：pipinstall--upgrade stellar-sdk如果需要使用异步功能，请安装以下依赖：pipinstall--upgrade stellar-sdk[aiohttp]快速开始在开始之前，你需要了解一些Stellar的基本概念，如交易（Transactions）、支付（Payments）、操作（Operations）、密钥对（KeyPairs）等。以下是一个简单的示例，展示如何使用Stellar Python SDK进行支付交易：fromstellar_sdkimportAsset,Server,Keypair,TransactionBuilder,Network# 定义Alice和Bob的密钥对alice_keypair=Keypair.from_secret("SBFZCHU5645DOKRWYBXVOXY2ELGJKFRX6VGGPRYUWHQ7PMXXJNDZFMKD")bob_address="GA7YNBW5CBTJZZ3ZZOWX3ZNBKD6OE7A7IHUQVWMY62W2ZBG2SGZVOOPVH"# 连接到Stellar Testnetserver=Server("https://horizon-testnet.stellar.org")# 加载Alice的账户alice_account=server.load_account(alice_keypair.public_key)# 构建交易transaction=(TransactionBuilder(source_account=alice_account,network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,base_fee=100,).add_text_memo("Hello, Stellar!").append_payment_op(bob_address,Asset.native(),"10.25").set_timeout(30).build())# 签名交易transaction.sign(alice_keypair)# 提交交易response=server.submit_transaction(transaction)print(response)应用场景Stellar Python SDK的应用场景广泛，包括：金融应用：构建去中心化支付系统、跨境汇款等。供应链管理：利用区块链技术确保供应链的透明度和可追溯性。身份验证系统：构建基于区块链的身份验证和授权系统。结论Stellar Python SDK为开发者提供了一个强大的工具集，以便在Python环境中构建和部署Stellar网络应用。无论是初创企业还是成熟企业，Stellar Python SDK都能为其提供强大的技术支持，帮助他们在Stellar网络中探索无限可能。立即访问Stellar Python SDK文档，开启你的Stellar之旅吧。最后，说一个好消息，如果你正苦于毕业设计，点击下面的卡片call我，赠送定制版的开题报告和任务书，先到先得！过期不候！http://www.ppmy.cn/news/1540682.html相关文章大数据学习---快速了解clickhouse数据库ClickHouse数据库介绍 
ClickHouse是一款由Yandex开发的列式数据库管理系统&amp;#xff08;DBMS&amp;#xff09;&amp;#xff0c;适用于在线分析处理&amp;#xff08;OLAP&amp;#xff09;场景。它具有高性能、可扩展性、实时更新等特点&amp;#xff0c;适用于处理大规模数据。 
特点 列式存储&amp;#x…阅读更多...监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:56 +0000</pubDate>
    </item>
    <item>
      <title>大数据学习---快速了解clickhouse数据库</title>
      <link>https://www.ppmy.cn/news/1540681.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大数据学习---快速了解clickhouse数据库news/2025/10/31 21:29:55/ClickHouse数据库介绍ClickHouse是一款由Yandex开发的列式数据库管理系统（DBMS），适用于在线分析处理（OLAP）场景。它具有高性能、可扩展性、实时更新等特点，适用于处理大规模数据。特点列式存储：ClickHouse采用列式存储，这使得它非常适合进行聚合计算，因为只需读取相关的列数据。向量引擎：ClickHouse使用向量引擎处理数据，能够实现高效的批量数据计算。实时更新：ClickHouse支持实时更新和删除数据，这在列式数据库中较为少见。数据压缩：ClickHouse对数据进行高效压缩，减少存储空间和I/O开销。分布式处理：ClickHouse支持分布式查询和数据处理，可以轻松扩展处理能力。安装与配置ClickHouse的安装相对简单，以下是在Ubuntu系统上的安装示例：sudo apt-get update
sudo apt-get install -y clickhouse-server clickhouse-client安装完成后，可以通过以下命令启动服务：sudo service clickhouse-server start使用clickhouse-client命令行工具连接到ClickHouse服务器：clickhouse-client基本概念数据库（Database）：数据存储的逻辑空间。表（Table）：存储数据的基本单位，由列组成。列（Column）：表中的一个字段，所有数据按列存储。数据类型（Data Type）：定义了列中数据的类型，如UInt32、Float64、String等。示例以下是一个简单的ClickHouse示例，包括创建数据库、表，以及插入和查询数据。创建数据库CREATE DATABASE example;使用数据库USE example;创建表CREATE TABLE example_table (id UInt32,name String,age UInt8,created_at DateTime
) ENGINE = MergeTree()
ORDER BY id;这里我们创建了一个名为example_table的表，使用了MergeTree引擎，这是一种常用的ClickHouse表引擎。插入数据INSERT INTO example_table VALUES (1, 'Alice', 30, now()), (2, 'Bob', 25, now());查询数据查询所有数据：SELECT * FROM example_table;查询特定列：SELECT name, age FROM example_table;进行聚合计算：SELECT sum(age) FROM example_table;更新数据ClickHouse支持使用ALTER语句更新数据：ALTER TABLE example_table UPDATE age = 31 WHERE id = 1;删除数据ClickHouse支持使用ALTER语句删除数据：ALTER TABLE example_table DELETE WHERE id = 1;ClickHouse数据库表引擎介绍ClickHouse是一种列式数据库管理系统，专为在线分析处理（OLAP）场景设计。ClickHouse提供了多种表引擎，每种表引擎都有其特定的用途和特性。以下是ClickHouse中一些常用的表引擎及其简要介绍。1. MergeTree系列MergeTree系列引擎是ClickHouse中最强大的引擎系列，适用于大多数分析场景。1.1. MergeTree用途：适用于高负载的插入和查询场景。特点：支持数据分区、数据压缩、索引、数据副本等功能。1.2.ReplacingMergeTree用途：用于有重复数据的场景，可以在合并分区时删除重复的数据。特点：通过VERSION列或TTL表达式来定义重复数据的保留规则。1.3. SummingMergeTree用途：适用于聚合数据的场景，可以在合并分区时对数据进行预聚合。特点：只保留汇总列和主键列，其他列会被聚合。1.4. AggregatingMergeTree用途：用于预先聚合数据的场景，可以显著提高聚合查询的性能。特点：需要定义聚合函数，并且数据在合并时会被聚合。1.5. CollapsingMergeTree用途：用于处理具有折叠逻辑的数据，如取消操作。特点：通过SIGN列来标记数据的折叠状态。1.6. VersionedCollapsingMergeTree用途：是CollapsingMergeTree的改进版，可以处理带有版本的数据折叠。特点：除了SIGN列，还使用VERSION列来处理折叠逻辑。2. Log系列Log系列引擎适用于数据写入后很少进行修改的场景。2.1. TinyLog用途：用于非常小的表或测试场景。特点：数据存储在单个文件中，不支持并发读取。2.2. StripeLog用途：用于小到中等大小的表。特点：数据按列存储，支持并发读取。2.3. Log用途：类似于TinyLog，但支持并发读取。特点：数据存储在多个文件中，每个列一个文件。3. Integration系列Integration系列引擎用于与外部系统集成。3.1. Kafka用途：用于从Kafka主题中读取数据。特点：支持从Kafka流中消费数据并存储到ClickHouse表中。3.2. MySQL用途：用于将MySQL表映射到ClickHouse中。特点：可以查询远程MySQL数据库中的数据，无需数据迁移。4. Special系列Special系列引擎用于特殊用途。4.1. Distributed用途：用于分布式查询。特点：不是实际存储数据的引擎，而是用于在多个服务器上分布式查询数据。4.2. MaterializedView用途：用于创建物化视图。特点：物化视图可以自动更新，以反映基础表的变化。5. 其他表引擎ClickHouse还提供了其他一些表引擎，如URL、File、Memory等，用于特定场景。结论ClickHouse是一款强大的列式数据库管理系统，适用于快速、高效的大规模数据分析。通过上述示例，我们可以看到ClickHouse的易用性和强大的数据处理能力。在实际应用中，ClickHouse被广泛应用于互联网、金融、物联网等领域的数据分析场景。ClickHouse的表引擎是其强大功能的核心部分，每种表引擎都针对特定场景进行了优化。选择合适的表引擎对于实现高效的数据存储和查询至关重要。在实际使用中，应根据业务需求和数据特点来选择最合适的表引擎。http://www.ppmy.cn/news/1540681.html相关文章监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控监控易是一款强大的监控工具&amp;#xff0c;能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue&amp;#xff08;简称MSMQ&amp;#xff09;的监控&amp;#xff0c;监控易提供了详尽的指标&amp;#xff0c;以确保企业能够准确掌握消息队列的运行状况。 在MSMQ的监控中&amp;#…阅读更多...jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:55 +0000</pubDate>
    </item>
    <item>
      <title>监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控</title>
      <link>https://www.ppmy.cn/news/1540680.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维监控易监测对象及指标之：Microsoft Message Queue（MSMQ）监控news/2025/10/31 21:29:54/监控易是一款强大的监控工具，能够实时监控各类IT设施和应用程序的性能指标。对于Microsoft Message Queue（简称MSMQ）的监控，监控易提供了详尽的指标，以确保企业能够准确掌握消息队列的运行状况。在MSMQ的监控中，我们首先要关注的是WMI连接的连通性和响应时间。WMI（Windows Management Instrumentation）是Windows的一项核心技术，用于访问、控制和管理系统信息。监控易通过检查WMI的连通性和响应时间，来评估MSMQ服务的可访问性和性能。接下来，我们关注的是消息状态和会话状态的监控。这包括IP会话数、每秒传进的消息条数、进来的多路广播会话等指标。这些数据的实时监控可以帮助我们了解消息传递的效率和系统的负载情况。例如，如果IP会话数或进来的多路广播会话数异常增加，可能意味着系统正在处理大量的并发请求，这时就需要关注系统的性能和稳定性。此外，监控易还提供了关于MSMQ传进的消息条数和传出的消息条数的监控。这些数据可以帮助我们了解消息队列的吞吐量和处理速度，从而判断系统是否能够满足当前的业务需求。在消息队列状态方面，监控易提供了关于日志队列和常规队列中的字节数和消息条数的监控。这些指标可以帮助我们了解队列的负载情况，以及是否存在消息堆积或处理不及时的问题。最后，监控易还关注消息队列服务的状态，包括Message Queuing服务和Message Queuing Triggers服务的运行状态。这些服务的状态信息对于确保MSMQ的稳定运行至关重要。如果服务状态出现异常，如停止或崩溃，将直接影响到消息队列的正常工作。综上所述，监控易为Microsoft Message Queue提供了全面的性能监控和故障排查手段。通过这些指标的实时监控和预警功能，企业可以及时发现并解决MSMQ系统中的性能问题和潜在风险，确保消息队列的稳定运行和高效性能。这些详细的数据也为系统的优化和升级提供了有力的支持。http://www.ppmy.cn/news/1540680.html相关文章jquery实现点击菜单实现高德地图定位点与数据展示联动效果&amp;#x1f34a;jquery实现点击菜单实现高德地图定位点与数据展示联动效果 版本介绍&amp;#xff1a; jQuery v3.7.1高德地图JS API 2.0 代码仓库 ⭐ 
Gitee&amp;#xff1a;实现点击菜单实现高德地图定位点与数据展示联动效果 
1.启动说明 &amp;#x1f4d4; 
推荐VS Code编辑器插件Live Ser…阅读更多...SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:54 +0000</pubDate>
    </item>
    <item>
      <title>jquery实现点击菜单实现高德地图定位点与数据展示联动效果</title>
      <link>https://www.ppmy.cn/news/1540679.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维jquery实现点击菜单实现高德地图定位点与数据展示联动效果news/2025/10/31 21:29:52/🍊jquery实现点击菜单实现高德地图定位点与数据展示联动效果版本介绍：jQuery v3.7.1高德地图JS API 2.0代码仓库 ⭐Gitee：实现点击菜单实现高德地图定位点与数据展示联动效果1.启动说明 📔推荐VS Code编辑器插件Live Server插件使用Live Server启动index.html,访问即可2. 效果图加功能说明 🔨效果图1：(点击省份进入城市marker点标记)效果图2：(点击左侧菜单定位对应marker点)效果图3：(初始页面，点击左侧市场菜单，进入菜单列表页并将marker标记添加)效果图4：(marker标记信息弹窗内点击，返回到省份)4. 文件结构 📚├─ data
│  ├─ getLeftMenu.json            # 左侧菜单数据
│  ├─ getProvinceClass.json       # 获取省code数据
│  ├─ getProvinceClass.json       # 省份信息弹窗数据
├─ css
│  ├─ amap.css                    # 地图与左侧菜单样式
│  ├─ base.css                    # 基础样式文件
├─ js
│  ├─ amap.js                     # 地图与左侧菜单js文件
│  ├─ jquery-3.7.1.json           # 基础样式文件
├─ index.html                     # 入口文件5. 示例代码 📖index.html&lt;!DOCTYPEhtml&gt;&lt;htmllang="en"&gt;&lt;head&gt;&lt;metacharset="UTF-8"&gt;&lt;metaname="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;linkrel="stylesheet"href="./css/base.css"&gt;&lt;linkrel="stylesheet"href="./css/amap.css"&gt;&lt;linkrel="stylesheet"href="https://style.feijiu.net/css/shichang/scbase.css"&gt;&lt;linkrel="stylesheet"href="https://style.feijiu.net/css/shichang/scindex.css"&gt;&lt;scriptsrc="./js/jquery-3.7.1.js"&gt;&lt;/script&gt;&lt;scriptsrc="https://webapi.amap.com/loader.js"&gt;&lt;/script&gt;&lt;scriptsrc="./js/amap.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;divclass="container"&gt;&lt;!-- 左侧菜单 --&gt;&lt;divclass="menuContainer"id="menuContainer"&gt;&lt;ahref="javascript:void(0);"onclick="getMenu('水果市场')"title="水果市场"&gt;水果市场&lt;/a&gt;&lt;/div&gt;&lt;!-- 地图区域 --&gt;&lt;divclass="mapContainer"id="mapContainer"&gt;&lt;/div&gt;&lt;/div&gt;&lt;scripttype="text/javascript"&gt;window._AMapSecurityConfig={securityJsCode:"「你申请的安全密钥」",};&lt;/script&gt;&lt;scripttype="text/javascript"src="https://webapi.amap.com/maps?v=2.0&amp;key=替换为你申请的 key"&gt;&lt;/script&gt;&lt;!-- 加载高德地图 --&gt;&lt;scripttype="text/javascript"&gt;initialize()$(document).ready(function(){$ajax('getProvinceClass',drawMapText)});&lt;/script&gt;&lt;!-- 封装ajax方法 --&gt;&lt;scripttype="text/javascript"&gt;const$ajax=(url,cb)=&gt;{$.ajax({url:`./data/${url}.json`,type:'GET',dataType:'json',success:function(data){cb&amp;&amp;cb(data)},error:function(xhr,status,error){console.error("Error loading JSON file: "+error);}});}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;逻辑文件amap.js/*** @function getPosition* @description 初始化处理省数据,用于定位Marker和targetName显示* @param {string} adcode: 区域编码*/constgetPosition=(adcode)=&gt;{letstr="";switch(adcode){case"110000":str="北京市_116.395825_39.941005";break;case"120000":str="天津市_117.210813_39.14393";break;case"130000":str="河北省_115.177813_38.206007";break;case"140000":str="山西省_112.564662_37.872049";break;case"150000":str="内蒙古_110.052771_41.34515";break;case"210000":str="辽宁省_123.004468_41.455972";break;case"220000":str="吉林省_126.346847_43.833111";break;case"230000":str="黑龙江省_128.664906_46.690662";break;case"310000":str="上海市_121.416372_31.45115";break;case"320000":str="江苏省_119.31908_32.642047";break;case"330000":str="浙江省_120.827658_30.180849";break;case"340000":str="安徽省_116.840281_31.83996";break;case"350000":str="福建省_118.680011_26.017147";break;case"360000":str="江西省_116.545924_28.190379";break;case"370000":str="山东省_118.900778_36.486773";break;case"410000":str="河南省_114.779784_34.986831";break;case"420000":str="湖北省_113.602357_30.892777";break;case"430000":str="湖南省_112.130573_27.929244";break;case"440000":str="广东省_114.083052_23.555889";break;case"450000":str="广西_109.152576_23.080123";break;case"460000":str="海南省_110.072441_19.494242";break;case"500000":str="重庆市_107.377359_29.631998";break;case"510000":str="四川省_103.182775_30.528033";break;case"520000":str="贵州省_106.199932_26.399788";break;case"530000":str="云南省_102.189321_24.66383";break;case"540000":str="西藏_92.365164_29.792605";break;case"610000":str="陕西省_108.334018_34.150637";break;case"620000":str="甘肃省_104.249818_35.756198";break;case"630000":str="青海省_100.975099_36.353776";break;case"640000":str="宁夏_107.119797_38.322051";break;case"650000":str="新疆_88.538527_43.616418";break;case"710000":str="台湾_121.359304_24.461909";break;case"810000":str="香港_115.067429_22.630108";break;case"820000":str="澳门_113.338083_22.151047";break;default:str="北京市_116.395825_39.941005";break;}constposition=str.split("_");return{targetName:position[0],longitude:position[1],latitude:position[2],};};/*** @function initialize* @description 初始化渲染地图*/letmap=undefined;constinitialize=()=&gt;{map=newAMap.Map("mapContainer",{zoom:4,zooms:[4,20],center:[116.404,39.915],});map.plugin(["AMap.Scale","AMap.ToolBar","AMap.ControlBar","AMap.HawkEye"],()=&gt;{map.addControl(newAMap.Scale());//比例尺map.addControl(newAMap.ToolBar({position:"RT",}));//工具条map.addControl(newAMap.ControlBar());//工具条方向盘map.addControl(newAMap.HawkEye());//鹰眼});};/*** @function drawMapText* @description 主要用于自定义文本点标记Marker* @param  {string} adlist:区域列表*/constdrawMapText=(adlist)=&gt;{const{list=[]}=adlist;list.forEach((item)=&gt;{constposition=getPosition(item.province_code);const{targetName,longitude,latitude}=position;constmapText=newAMap.Text({text:targetName,position:[longitude,latitude],topWhenClick:"true",anchor:"center",cursor:"pointer",style:{width:"52px",height:"18px",padding:"0",textAlign:"center",lineHeight:"18px",fontSize:"12px",fontWeight:"700",color:"#fff",border:"none",borderRadius:"5px",backgroundColor:"#f5222d",whiteSpace:"nowrap",MozUserSelect:"none",},});mapText.on("mouseover",()=&gt;{mapText.setStyle({backgroundColor:"#096dd9",});});mapText.on("mouseout",()=&gt;{mapText.setStyle({backgroundColor:"#f5222d",});});mapText.on("click",()=&gt;{drawProvinceInfo(item.province_code,position);});mapText.add(map);});};/*** @function drawProvinceInfo* @description 点击自定义Marker省份按钮,渲染信息窗体* @param  {string} adcode:区域编码* @param  {string} targetName:当前省名称* @param  {string} longitude:当前经度* @param  {string} latitude:当前维度*/constdrawProvinceInfo=(adcode,{targetName,longitude,latitude})=&gt;{$ajax("getProvinceInfo",({data:{domContent="",count=0}})=&gt;{constcontent=`&lt;div class="infoContainer"&gt;&lt;div class="infoTitle"&gt;&lt;h2&gt;${targetName}&lt;/h2&gt;&lt;span&gt;${targetName}范围内共&lt;b style="color:#f5222d;"&gt;${count}&lt;/b&gt;种水果&lt;/span&gt;&lt;/div&gt;&lt;div class="infoContent"&gt;&lt;div class="infoContentTitle"&gt;水果种类&lt;/div&gt;&lt;ul class="infoContentBox"&gt;${domContent}&lt;/ul&gt;&lt;/div&gt;&lt;div class="infoBottom"&gt;&lt;button οnclick="drawProvinceDistribute('${adcode}')"&gt;${targetName}市场分布&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;`;constinfoWindow=newAMap.InfoWindow({isCustom:false,closeWhenClickMap:true,content,offset:newAMap.Pixel(0,-10),});infoWindow.open(map,[longitude,latitude]);});};/*** @function drawProvinceDistribute* @description 点击市场分布按钮,查看全部市场分部与渲染区域边界* @param  {string} adcode:区域编码*/constdrawProvinceDistribute=(adcode)=&gt;{const{targetName,longitude,latitude}=getPosition(adcode);// 清除地图图层等操作map.setZoomAndCenter(6,[longitude,latitude],true);map.setZooms([5,20]);// 绘制边界drawBounds(adcode);// 获取市场数据getMenu(targetName);};/*** @function drawBounds* @description 绘制行政省边界区域* @param  {string} keyword:行政区code*/letdistrict=null;letpolygon=null;constdrawBounds=(keyword)=&gt;{map.plugin("AMap.DistrictSearch",()=&gt;{if(!district){//实例化DistrictSearchdistrict=newAMap.DistrictSearch({subdistrict:0,extensions:"all",level:"province",});}// 行政区查询district.search(keyword,(status,result)=&gt;{if(polygon){map.remove(polygon);//清除上次结果polygon=null;}if(status!=="complete"){return;}constbounds=result.districtList[0].boundaries;if(bounds){//生成行政区划polygonfor(leti=0;i&lt;bounds.length;i+=1){//构造MultiPolygon的pathbounds[i]=[bounds[i]];}polygon=newAMap.Polygon({strokeWeight:1,path:bounds,fillOpacity:0.4,fillColor:"#80d8ff",strokeColor:"#0091ea",});map.add(polygon);// 视口自适应map.setFitView(polygon,true,[60,60,60,60]);}});});};/*** @Start 市场分布* --------------------------------------------------------------------*//*** @function getMenu* @description 获取市场列表数据并渲染在左侧菜单区域* @param  {string} urlFlag: 区分url标记* @param  {string} title:行业标题* @param  {string} adcode:区域编码*/constgetMenu=(title)=&gt;{map.clearMap();// 请求菜单数据$ajax("getLeftMenu",({list:menus=[]})=&gt;{letmenuHTML=`&lt;div class="menuTitle"&gt;&lt;a href="javascript:void(0)" οnclick="location.reload()"&gt;所有市场&lt;/a&gt;&gt;&lt;span&gt;所选：&lt;/span&gt;&lt;span class="menuSelected"&gt;${title}&lt;/span&gt;&lt;/div&gt;&lt;div&gt;`;menus.forEach((menu,idx)=&gt;{menuHTML+=`&lt;div class="menuBox" sort="${idx+1}"&gt;&lt;div class="icon"&gt;${idx+1}&lt;/div&gt;&lt;div class="menuContent"&gt;&lt;div class="menuName"&gt;${menu.name}&lt;/div&gt;&lt;div class="menuInfo"&gt;&lt;p&gt;经营范围：${menu.businessScope}&lt;/p&gt;&lt;p&gt;供求信息：${menu.supplyNum}条&lt;/p&gt;&lt;p&gt;现货信息：${menu.stockNum}条&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;`;// 地图添加市场标记drawMapMarker(menu,idx+1+"");});document.getElementById("menuContainer").innerHTML=menuHTML+"&lt;/div&gt;";// 绑定事件bindMenuEvent(menus);});};/*** @function bindMenuEvent* @description 左侧菜单元素绑定移入移出和点击事件*/constbindMenuEvent=(menus)=&gt;{jQuery("div.menuBox").hover(function(){$(this).children("div.icon").css("background-color","#fff");$(this).children("div.icon").css("color","#2e3243");constsort=$(this).attr("sort");mapMarkHighlight(sort,true);},function(){$(this).children("div.icon").css("background-color","#333333");$(this).children("div.icon").css("color","#fff");constsort=$(this).attr("sort");mapMarkHighlight(sort);});jQuery("div.menuBox").click(function(){$(this).children("div.icon").css("background-color","#fff");$(this).children("div.icon").css("color","#2e3243");constsort=$(this).attr("sort");drawMarketInfo(menus[sort-1]);});};/*** @function drawMapMarker* @description 为地图上添加市场对应的Marker标记* @param {object} menu:市场数据* @param {string} idx:索引*/constdrawMapMarker=(menu,idx)=&gt;{constlongitude=menu.longitude*1;constlatitude=menu.latitude*1;constmapMarker=newAMap.Marker({map:map,size:newAMap.Size(25,33),content:`&lt;div class="marketIcon"&gt;${idx}&lt;/div&gt;`,position:[longitude,latitude],offset:newAMap.Pixel(-13,-30),});mapMarker.on("mouseover",()=&gt;{mapMarkHighlight(idx,true);});mapMarker.on("mouseout",()=&gt;{mapMarkHighlight(idx);});mapMarker.on("click",()=&gt;{drawMarketInfo(menu);});};/*** @function mapMarkHighlight* @description 地图标志高亮* @param  {string} idx: 当前移入的marker索引* @param  {boolean} isHover:是否移入*/constmapMarkHighlight=(idx,isHover=false)=&gt;{jQuery.each(jQuery("div.marketIcon"),function(){if(jQuery(this).html()===idx&amp;&amp;isHover){jQuery(this).addClass("marketIcon-hover");}else{jQuery(this).removeClass("marketIcon-hover");}});};/*** @function drawMarketInfo* @description 点击市场信息自定义Marker点,渲染市场详情信息窗体* @param  {string} info:当前市场详情信息*/letmarketInfo=null;constdrawMarketInfo=(info)=&gt;{if(marketInfo!==null){marketInfo.close();marketInfo=null;}constcontent=`&lt;div class="marketContainer"&gt;&lt;a href='${info.link}' target='_blank'&gt;&lt;img src='${info.photo||"https://img1.baidu.com/it/u=2063777893,3765279289&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=GIF?w=218&amp;h=218"}'&gt;&lt;/a&gt;&lt;div class='marketContent'&gt;&lt;ul&gt;&lt;li&gt;&lt;b style='font-size:14px;'&gt;&lt;a href='${info.link}' target='_blank'&gt;${info.name}&lt;/a&gt;&lt;/b&gt;&lt;/li&gt;&lt;li&gt;经营范围：${info.businessScope}&lt;/li&gt;&lt;li&gt;供求信息：${info.supplyNum}&lt;/li&gt;&lt;li&gt;现货信息：${info.stockNum}&lt;/li&gt;&lt;/ul&gt;&lt;div class= 'marketBottom'&gt;&lt;a href="javascript:void(0);" οnclick="drawProvinceDistribute('${info.province}')"&gt;${getPosition(info.province)["targetName"]}所有市场&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;`;marketInfo=newAMap.InfoWindow({isCustom:false,closeWhenClickMap:true,content,offset:newAMap.Pixel(-5,-32),});constlongitude=info.longitude*1;constlatitude=info.latitude*1;map.setCenter([longitude,latitude],true);marketInfo.open(map,[longitude,latitude]);};amap.css/* 点击省按钮信息窗体样式 */.amap-info-content{padding:0;}/* close 按钮 */.amap-info-close{top:2px;right:2px;background:#fff;}.infoContainer{width:320px;display:flex;flex-direction:column;}.infoTitle{display:flex;justify-content:space-between;align-items:center;padding:8px;}.infoTitle span{margin-right:10px;}.infoContent{padding:5px 0 0 8px;color:#666;border-top:2px solid #d9d9d9;background-color:#e8e6e6;}.infoContentTitle{font-size:12px;font-weight:bold;border-bottom:1px dotted #ccc}ul.infoContentBox{height:60px;padding-top:6px;}.infoBottom{padding:8px 0;background:#fff;text-align:center;}.infoBottom button{height:30px;padding:2px 5px;background:linear-gradient(45deg,#f5222d,#096dd9);color:#fff;border:none;border-radius:4px;cursor:pointer;}.infoBottom button:hover{filter:brightness(120%);filter:drop-shadow(0 0 2pxrgba(0,0,0,.5))}/* 市场信息窗体样式 */.marketContainer{display:flex;width:350px;height:110px;overflow:hidden;border:1px solid #999;background:#f6f6f6;}.marketContainer a img{width:130px;height:100px;margin:5px;object-fit:cover;}.marketContent{display:flex;flex-direction:column;justify-content:space-between;overflow:hidden;margin:5px;}.marketContent ul{overflow:auto;}.marketBottom{width:200px;height:20px;margin-top:5px;border-top:1px solid #ccc;}.marketIcon{position:absolute;width:20px;height:32px;line-height:16px;text-align:center;font-size:12px;font-weight:700;color:#fff;background:url('../images/icon_position.png')no-repeat 0 0px;cursor:pointer;white-space:nowrap;}/* 修改Marker移入样式 */.marketIcon-hover{background-position:0 -33px!important;}/* 左侧菜单样式 */.menuTitle{width:100%;height:50px;color:#fff;overflow:hidden;line-height:50px;text-indent:15px;font-size:14px;background-color:#2e3243;border-bottom:1px solid #f5222d;}.menuTitle a{color:#fff;}.menuSelected{color:#faad14;font-weight:700;}.menuBox{display:flex;justify-content:space-between;padding:10px;border-bottom:1px dotted #2e3243;cursor:pointer;}.menuBox:hover{color:#fff;background-color:#2e3243;}.menuBox .icon{width:20px;height:20px;text-align:center;line-height:18px;color:#fff;background-color:#333333;border-radius:20px;}.menuBox .menuContent{display:flex;flex:1;flex-direction:column;margin-left:8px;line-height:16px}.menuBox .menuContent .menuName{font-weight:700}.menuBox .menuContent .menuInfo p{margin:5px 0;}6. 数据文件: 文件内为虚拟数据，仅为展示效果getLeftMenu.json左侧菜单数据{"list":[{"id":1,"name":"苏州**交易市场","businessScope":"各种新鲜水果，如苹果、香蕉、橙子、梨、桃、葡萄等销售","photo":"https://inews.gtimg.com/om_bt/OP0mBSVgib26rrdC7oEbQWPeeAcQzNydGaqw6REufiCXcAA/641","province":"320000","city":"320500","stockNum":7,"supplyNum":28,"link":"#","longitude":"120.448306","latitude":"31.433461"},{"id":2,"name":"上海**水果交易中心","businessScope":" ","photo":"https://inews.gtimg.com/om_bt/O5zWPSXGHr-o-U1vUxCw8AJ7onRB6wNsX9Qi82hPbTGDoAA/1000","province":"310000","city":"310100","stockNum":3,"supplyNum":0,"link":"#","longitude":"121.311438","latitude":"31.032425"},{"id":3,"name":"河北**水果商圈","businessScope":"水果销售、水果礼盒、水果批发、水果配送、水果加工、水果咨询服务、代客挑选水果等","photo":"https://imgservice.suning.cn/uimg1/b2c/image/Wgur-Xf1xyKN3mwAnWLC0Q.jpg_800w_800h_4e","province":"130000","city":"130300","stockNum":4,"supplyNum":57,"link":"#","longitude":"119.604368","latitude":"39.945462"},{"id":4,"name":"苏州**市场","businessScope":"水果咨询服务、代客挑选水果","photo":"https://inews.gtimg.com/om_bt/OY7EgDCa_kppQRisS50oOP_N-sLr0eCG7XByq1ju_altsAA/1000","province":"320000","city":"320500","stockNum":10,"supplyNum":154,"link":"#","longitude":"120.442089","latitude":"31.440047"},{"id":5,"name":"**水果加工市场","businessScope":"制作果汁、果酱、果干等，以满足不同消费者的需求","photo":"https://www.miao-an.com/img/cooperate11.da46bd23.jpg","province":"420000","city":"420100","stockNum":5,"supplyNum":4,"link":"#","longitude":"114.303476","latitude":"30.503601"},{"id":6,"name":"衡水故城县**水果批发市场","businessScope":"提供配送服务，将水果送至客户指定的地点","photo":"https://q9.itc.cn/images01/20240228/3796398619454ec9ad65c0fb33e7363c.jpeg","province":"130000","city":"131100","stockNum":4,"supplyNum":0,"link":"#","longitude":"115.879459","latitude":"37.164535"},{"id":7,"name":"山东临沂华东**水果城","businessScope":"各种水果销售","photo":"https://img2.baidu.com/it/u=2811054594,2149935890&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=545&amp;h=500","province":"370000","city":"371300","stockNum":7,"supplyNum":1,"link":"#","longitude":"118.343533","latitude":"35.142088"},{"id":8,"name":"郑州市**水果交易市场 ","businessScope":"水果批发业务，将水果销售给其他商家或餐厅","photo":"https://q6.itc.cn/q_70/images03/20240310/7deaeb3405944bf69773002b8e3af4e7.jpeg","province":"410000","city":"410100","stockNum":0,"supplyNum":0,"link":"#","longitude":"113.698629","latitude":"34.702777"},{"id":9,"name":"**水果礼盒市场","businessScope":"为了满足送礼需求，水果店可以将水果搭配成精美的礼盒，并在礼盒上印制祝福语","photo":"https://ww4.sinaimg.cn/mw690/68d8c97fgy1hr8jw3x753j20ku0rs7an.jpg","province":"210000","city":"210100","stockNum":0,"supplyNum":0,"link":"#","longitude":"123.347174","latitude":"41.843021"},{"id":10,"name":"辽宁**水果基地","businessScope":"水果销售：这是水果店最主要的经营范围，包括各种新鲜水果，如苹果、香蕉、橙子、梨、桃、葡萄等。水果店应该保证水果新鲜、品质优良，以满足消费者的需求","photo":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage109.360doc.com%2FDownloadImg%2F2024%2F03%2F2010%2F281210346_4_20240320101958209.jpeg&amp;refer=http%3A%2F%2Fimage109.360doc.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1731310501&amp;t=aa98bd64ce1b04be69c987fe92037097","province":"130000","city":"130100","stockNum":0,"supplyNum":0,"link":"#","longitude":"114.501084","latitude":"38.055933"},{"id":11,"name":"**水果市场","businessScope":"各种水果销售","photo":"","province":"120000","city":"120100","stockNum":10,"supplyNum":20,"link":"#","longitude":"117.333198","latitude":"39.094294"},{"id":12,"name":"兰州**水果专业市场","businessScope":"种植水果，如草莓、蓝莓等","photo":"https://inews.gtimg.com/om_bt/OSTnVUPg6ncorDwbP4zqi017K1aViojDpPFJJ3Y1x8eEIAA/1000","province":"620000","city":"620100","stockNum":120,"supplyNum":103,"link":"#","longitude":"103.776014","latitude":"36.074689"},{"id":13,"name":"汉中**交易市场","businessScope":"在销售水果的基础上，提供送货上门服务等配送服务","photo":"https://img0.baidu.com/it/u=904203784,1480640225&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=750&amp;h=500","province":"610000","city":"610700","stockNum":0,"supplyNum":4,"link":"#","longitude":"107.019721","latitude":"33.112655"},{"id":14,"name":"广东**水果市场","businessScope":"各种新鲜水果，如苹果、梨、草莓、香蕉等销售","photo":"https://copyright.bdstatic.com/vcg/creative/3d3ed3cdbdbca952c43f44a51bc80d20.jpg","province":"440000","city":"440300","stockNum":0,"supplyNum":1,"link":"#","longitude":"113.90666","latitude":"22.566552"},{"id":15,"name":"红宇**水果有限公司","businessScope":"水果销售、水果配送、水果种植等方面","photo":"https://inews.gtimg.com/om_bt/On_IyOQaQwcp76QPnLQJZu67XFp43B6ijaLYxLB-BaMtUAA/1000","province":"440000","city":"441900","stockNum":0,"supplyNum":0,"link":"#","longitude":"113.840617","latitude":"22.882198"}]}getProvinceClass.json获取省code数据{"list":[{"province_code":"110000"},{"province_code":"120000"},{"province_code":"130000"},{"province_code":"140000"},{"province_code":"150000"},{"province_code":"210000"},{"province_code":"220000"},{"province_code":"230000"},{"province_code":"310000"},{"province_code":"320000"},{"province_code":"330000"},{"province_code":"340000"},{"province_code":"350000"},{"province_code":"360000"},{"province_code":"370000"},{"province_code":"410000"},{"province_code":"420000"},{"province_code":"430000"},{"province_code":"440000"},{"province_code":"450000"},{"province_code":"500000"},{"province_code":"510000"},{"province_code":"520000"},{"province_code":"530000"},{"province_code":"610000"},{"province_code":"620000"},{"province_code":"630000"},{"province_code":"640000"},{"province_code":"650000"},{"province_code":"810000"}]}getProvinceInfo.json省份信息弹窗数据{"data":{"count":82,"domContent":"&lt;li&gt;&lt;a href=\"javascript:void(0);\" οnclick=\"drawProvinceDistribute('130000');\"&gt;苹果&lt;/a&gt;&lt;/li&gt;"}}7. 备注：页面UI色值参考TinyVuehttps://opentiny.design/tiny-vue/zh-CN/smb-theme/components/colorhttp://www.ppmy.cn/news/1540679.html相关文章SDUT数据结构与算法第四次机测7-1 统计工龄 
给定公司 n 名员工的工龄&amp;#xff0c;要求按工龄增序输出每个工龄段有多少员工。 
输入格式: 
输入首先给出正整数 n&amp;#xff08;≤105&amp;#xff09;&amp;#xff0c;即员工总人数&amp;#xff1b;随后给出 n 个整数&amp;#xff0c;即每个员工的工龄&amp;#xff0c;范围在 [0, 5…阅读更多...解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:53 +0000</pubDate>
    </item>
    <item>
      <title>SDUT数据结构与算法第四次机测</title>
      <link>https://www.ppmy.cn/news/1540678.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维SDUT数据结构与算法第四次机测news/2025/10/31 21:29:51/7-1 统计工龄给定公司 n 名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。输入格式:输入首先给出正整数 n（≤105），即员工总人数；随后给出 n 个整数，即每个员工的工龄，范围在 [0, 50]。输出格式:按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为 0 则不输出该项。输入样例:8
10 2 0 5 7 2 5 2输出样例:0:1
2:3
5:2
7:1
10:1#include&lt;stdio.h&gt;
int main()
{int age[10001]={0};int n;int i;scanf("%d",&amp;n);int a;for(i=0;i&lt;n;i++){scanf("%d",&amp;a);age[a]++;}for(i=0;i&lt;51;i++){if(age[i]!=0){printf("%d:%d\n",i,age[i]);}}return 0;
}7-2 公路村村通现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。输入格式:输入数据包括城镇数目正整数 n（≤1000）和候选道路数目 m（≤3n）；随后的 m 行对应 m 条道路，每行给出 3 个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从 1 到 n 编号。输出格式:输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出 −1，表示需要建设更多公路。输入样例:6 15
1 2 5
1 3 3
1 4 7
1 5 4
1 6 2
2 3 4
2 4 6
2 5 2
2 6 6
3 4 6
3 5 1
3 6 1
4 5 10
4 6 8
5 6 3输出样例:12#include&lt;bits/stdc++.h&gt;
using namespace std;
int f[1001];
struct road
{int x,y,cost;
}s[3001];
int cmp(road a,road b)
{return a.cost&lt;b.cost;
}
int find(int x)
{if(f[x]==x)return x;elsereturn f[x]=find(f[x]);
}
int merg(int x,int y)
{if(find(x)!=find(y)){f[find(x)]=find(y);return 1;}return 0;
}
int main()
{int n,m;scanf("%d %d",&amp;n,&amp;m);for(int i=1;i&lt;n;i++){f[i]=i;}for(int i=0;i&lt;m;i++){scanf("%d %d %d",&amp;s[i].x,&amp;s[i].y,&amp;s[i].cost);}sort(s,s+m,cmp);int sum=0;for(int i=0;i&lt;m&amp;&amp;n&gt;1;i++){if(merg(s[i].x,s[i].y)==1){sum=sum+s[i].cost;n--;}}if(n==1)printf("%d",sum);elseprintf("-1");return 0;
}7-3 旅游规划有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。输入格式:输入说明：输入数据的第 1 行给出 4 个正整数 n、m、s、d，其中 n（2≤n≤500）是城市的个数，顺便假设城市的编号为 0~(n−1)；m 是高速公路的条数；s 是出发地的城市编号；d 是目的地的城市编号。随后的 m 行中，每行给出一条高速公路的信息，分别是：城市 1、城市 2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过 500。输入保证解的存在。输出格式:在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。输入样例:4 5 0 3
0 1 1 20
1 3 2 30
0 3 4 10
0 2 2 20
2 3 1 20输出样例:3 40#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[500][500];
int b[500][500];
int n,m,s,d;
int main()
{scanf("%d %d %d %d",&amp;n,&amp;m,&amp;s,&amp;d);for(int i=0;i&lt;n;i++){for(int j=0;j&lt;n;j++){a[i][j]=b[i][j]=10086;}}for(int i=0;i&lt;m;i++){int x,y,length,money;scanf("%d %d %d %d",&amp;x,&amp;y,&amp;length,&amp;money);a[x][y]=a[y][x]=length;b[x][y]=b[y][x]=money;}for(int k=0;k&lt;n;k++){for(int i=0;i&lt;n;i++){for(int j=0;j&lt;n;j++){if(a[i][j]&gt;a[i][k]+a[k][j]||a[i][j]==a[i][k]+a[k][j]&amp;&amp;b[i][j]&gt;b[i][k]+b[k][j]){a[i][j]=a[i][k]+a[k][j];b[i][j]=b[i][k]+b[k][j];}}}}printf("%d %d",a[s][d],b[s][d]);return 0;
}7-4 任务调度的合理性假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和 C 程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如 C 程序设计和数据结构两门课，必须先学习前者。但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务 a 依赖于子任务 b，子任务 b 依赖于子任务 c，子任务 c 又依赖于子任务 a”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。你现在的工作是写程序判定任何一个给定的任务调度是否可行。输入格式:输入说明：输入第一行给出子任务数 n（≤100），子任务按 1~n 编号。随后 n 行，每行给出一个子任务的依赖集合：首先给出依赖集合中的子任务数 k，随后给出 k 个子任务编号，整数之间都用空格分隔。输出格式:如果方案可行，则输出 1，否则输出 0。输入样例1:12
0
0
2 1 2
0
1 4
1 5
2 3 6
1 3
2 7 8
1 7
1 10
1 7输出样例1:1输入样例2:5
1 4
2 1 4
2 2 5
1 3
0输出样例2:0#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
int f[105][105];
int degree[105] , book[105];
int main(){int n , k;int temp;cin&gt;&gt;n;for(int i = 1 ; i &lt;= n ; i++){cin&gt;&gt;k;for(int j = 1 ; j &lt;= k ; j++){cin&gt;&gt;temp;f[temp][i] = 1;}degree[i] = k;}for(int i = 1 ; i &lt;= n ; i++){int ans , flag = -1;for(int j = 1 ; j &lt;= n ; j++){if(degree[j] == 0 &amp;&amp; book[j] == 0){flag = 1;ans = j;book[j] = 1;break;}}if(flag == 1){for(int j = 1 ; j &lt;= n ; j++){if(f[ans][j] == 1){f[ans][j] = 0;degree[j]--;}}}else break;}int flag = 1;for(int i = 1 ; i &lt;= n ; i++){if(degree[i] != 0){flag = 0;break;}}if(flag) cout&lt;&lt;"1";else cout&lt;&lt;"0";
}7-5 这是二叉搜索树吗？一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，其左子树中所有结点的键值小于该结点的键值；其右子树中所有结点的键值大于等于该结点的键值；其左右子树都是二叉搜索树。所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。输入格式：输入的第一行给出正整数 N（≤1000）。随后一行给出 N 个整数键值，其间以空格分隔。输出格式：如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出YES，然后在下一行输出该树后序遍历的结果。数字间有 1 个空格，一行的首尾不得有多余空格。若答案是否，则输出NO。输入样例 1：7
8 6 5 7 10 8 11输出样例 1：YES
5 7 6 8 11 10 8输入样例 2：7
8 10 11 8 6 7 5输出样例 2：YES
11 8 10 7 5 6 8输入样例 3：7
8 6 8 5 10 9 11输出样例 3：NO#include&lt;bits/stdc++.h&gt;
using namespace std;
int num[1010],n,pre[1010];
int flag=1;
void dfs(int l,int r)
{if(l&gt;r)return;int i=l+1,j=r;if(flag){while(i&lt;=r&amp;&amp;pre[i]&lt;pre[l])i++;while(j&gt;l&amp;&amp;pre[j]&gt;=pre[l])j--;}else{while(i&lt;=r&amp;&amp;pre[i]&gt;=pre[l])i++;while(j&gt;l&amp;&amp;pre[j]&lt;pre[l])j--;}dfs(l+1,j);dfs(i,r);num[++num[0]]=pre[l];
}
int main()
{cin&gt;&gt;n;int i,j,k;for(i=1;i&lt;=n;i++){cin&gt;&gt;pre[i];}dfs(1,n);if(num[0]!=n){flag=0;num[0]=0;dfs(1,n);}if(num[0]!=n)cout&lt;&lt;"NO";else{cout&lt;&lt;"YES\n"&lt;&lt;num[1];for(i=2;i&lt;=num[0];i++)cout&lt;&lt;" "&lt;&lt;num[i];}return 0;
}7-6 二分查找输入n值(1&lt;=n&lt;=1000)、n个非降序排列的整数以及要查找的数x，使用二分查找算法查找x，输出x所在的下标（0~n-1）及比较次数。若x不存在，输出-1和比较次数。输入格式:输入共三行：第一行是n值；第二行是n个整数；第三行是x值。输出格式:输出x所在的下标（0~n-1）及比较次数。若x不存在，输出-1和比较次数。输入样例:4
1 2 3 4
1输出样例:0
2#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[1005];
int main(){int n,i,x,y=0,l,r,k=0,mid;cin&gt;&gt;n;for(i=0;i&lt;n;i++)cin&gt;&gt;a[i];cin&gt;&gt;x;for(i=0;i&lt;n;i++){if(x==a[i]){k=1;break;}}l=0;r=n-1;while(l&lt;=r){y++;mid=(l+r)/2;if(a[mid]&gt;x)r=mid-1;else l=mid+1;}if(k==1) cout&lt;&lt;mid&lt;&lt;endl&lt;&lt;y;else cout&lt;&lt;"-1\n"&lt;&lt;y;return 0;
}http://www.ppmy.cn/news/1540678.html相关文章解决一个android service启动无法开文件的问题问题描述 
android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段&amp;#xff0c;我直接将service push到板卡上&amp;#xff0c;进行调试&amp;#xff0c;未出现问题无法开的问题。在最后集成完成后&amp;#xff0c;放到板卡上&amp;#xff0c;出现启动无法…阅读更多...VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:51 +0000</pubDate>
    </item>
    <item>
      <title>解决一个android service启动无法开文件的问题</title>
      <link>https://www.ppmy.cn/news/1540677.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维解决一个android service启动无法开文件的问题news/2025/10/31 21:29:50/问题描述android hal层一般是通过service给系统提供服务的。一般需要将service配置为开机启动。调试阶段，我直接将service push到板卡上，进行调试，未出现问题无法开的问题。在最后集成完成后，放到板卡上，出现启动无法打开/dev/uinput的问题，报错为：10-14 08:21:02.550360360E ca_ins_hal:open/dev/uinput failed: Permission denied提示为权限问题。但是系统并没有报avc: denied的问题。avc 相关的已经在集成时，解决了所有的 avc 报错。但是现在无法打开/dev/uinput。猜测 te 文件添加的权限已经没有问题了。还有与权限相关的就是 rc 文件了。android.hardware.gnss@2.1-service-ca_ins.rc:servicegnss-hal-service /vendor/bin/hw/android.hardware.gnss@2.1-service-ca_insclass haluser systemgroup system解决这里我抄了一个demo的 rc 配置，使用的 class 是 hal，user 和 group 都是system，android 系统中只有root权限和非root权限。因此猜测在这里使用root权限可以解决上述问题。因此在系统里找了一个使用 root 权限的配置copy过来：servicegnss-hal-service /vendor/bin/hw/android.hardware.gnss@2.1-service-ca_insclass mainuser rootgroup root重新编译集成，再次启动，/dev/uinput打开正常。接下来报除了一些 uinput 相关的 avc 权限问题，将需要的权限添加到 te 文件中即可，可能需要多次调试添加。在解决权限问题时，最后会有一条无法解决：10-14 08:52:08.847475475I gnss@2.1-servic:type=1400audit(0.0:7): avc: denied{dac_override}forcapability=1scontext=u:r:hal_gnss_ca_ins:s0tcontext=u:r:hal_gnss_ca_ins:s0tclass=capabilitypermissive=1将相应的权限添加到 te 文件会导致编译不通过。自己定义的权限和全局设置的权限要求冲突了。解决方式参考：https://blog.csdn.net/k663514387/article/details/107983037需要将进程添加到需要访问的文件所在的文件组：dev/uinput:se1000:/# ls /dev/uinput  -alcrw-rw----1uhid uhid10,2231970-01-01 00:00 /dev/uinputte 文件：servicegnss-hal-service /vendor/bin/hw/android.hardware.gnss@2.1-service-ca_insclass haluser systemgroup system uhid重新编译集成，不会在报 dac_override avc 错误。并且，/dev/uinput也能正常打开。root 权限不可乱用 : (http://www.ppmy.cn/news/1540677.html相关文章VMware虚拟机三种网络模式详解主要内容 1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用 3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网 4. 总结 参考资料&amp;#xff1a; 1.Vmware虚拟机三种网络模式详解 VMware虚拟机三种网络模式详解之Bridged&amp;#xff0…阅读更多...基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:50 +0000</pubDate>
    </item>
    <item>
      <title>VMware虚拟机三种网络模式详解</title>
      <link>https://www.ppmy.cn/news/1540676.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维VMware虚拟机三种网络模式详解news/2025/10/31 21:29:49/主要内容1. 桥接模式2. NAT模式VMware Network Adapter VMnet8虚拟网卡的作用3. 仅主机模式VMware Network Adapter VMnet1虚拟网卡的作用设置虚拟机联通外网4. 总结参考资料：1.Vmware虚拟机三种网络模式详解VMware虚拟机三种网络模式详解之Bridged（桥接模式）VMware虚拟机三种网络模式详解之NAT（地址转换模式）VMware虚拟机三种网络模式详解之Host-Only（仅主机模式）以下部分截图来源上面的参考资料，仅用于学习记录。vmware为我们提供了三种网络工作模式，它们分别是：Bridged（桥接模式）、NAT（网络地址转换模式）、Host-Only（仅主机模式）。打开vmware虚拟机，可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。1. 桥接模式桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。经测试，主机与虚拟机在桥接模式下可以互相ping通[如果请求超时，大概率是防火墙开着的原因]。在主机上利用xshell[下载地址]，通过ssh访问虚拟机，主机与虚拟机通信正常。xshell连接显示Connect failed，应该是虚拟机端未安装OpenSSH服务器，ps:Windows中如何安装SSH2. NAT模式如果网络ip资源紧缺，但是又希望虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。(将私有IP地址转换为 公有IP地址，以便能够访问 Internet 。)DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。以下图片来源于此处NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。VMnet8子网地址：192.168.47.0，如下所示NAT设置中，网关IP：192.168.47.2DHCP设置中，IP地址的范围是192.168.47.128~192.168.47.254；默认租用时间是30min，最长租用时间是2h。VMware Network Adapter VMnet8虚拟网卡的作用禁用VMware Network Adapter VMnet8虚拟网卡之后，依然能ping通百度（外网），说明并不是通过VMware Network Adapter VMnet8虚拟网卡来连接外网。经测试，将VMware Network Adapter VMnet8禁用之后，主机和虚拟机之间互相ping不通。将VMware Network Adapter VMnet8禁用之后，发现远程工具XShell连接不上虚拟机；将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机。因此，VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。3. 仅主机模式Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通信。仅主机模式下不能联网。VMnet1子网地址：192.168.208.0，DHCP设置中，IP地址的范围是192.168.208.128~192.168.208.254；默认租用时间是30min，最长租用时间是2h。VMware Network Adapter VMnet1虚拟网卡的作用经测试，设置为仅主机模式，主机和虚拟机之间可以互相ping通。将VMware Network Adapter VMnet1禁用之后，主机和虚拟机之间互相ping不通。将VMware Network Adapter VMnet1禁用之后，发现远程工具XShell连接不上虚拟机；将VMware Network Adapter VMnet1启用之后，发现远程工具可以连接上虚拟机。因此，VMware Network Adapter VMnet1虚拟网卡是用来与虚拟机通信的。ps:此处虚拟网卡的作用同2中VMnet8。设置虚拟机联通外网仅主机模式，不能联通外网。要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。共享方式如下，共享之后VMware Network Adapter VMnet1的IPv4地址为192.168.137.1修改虚拟网络编辑器中VMnet1的子网地址，以及DHCP设置。在虚拟机中进行配置至此，仅主机模式也可以联通外网。4. 总结桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。相当于插了一根网线。NET模式下，借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。可以不用手动配置IP。仅主机模式下，是NAT模式去除了虚拟NAT设备，然后使用VMware Network AdapterVMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通信。仅主机模式不能连接外网，除非将主机网卡共享给VMware Network Adapter VMnet1网卡，才能达到虚拟机联网的目的。http://www.ppmy.cn/news/1540676.html相关文章基于SpringBoot的出租车拼车系统【附源码】基于SpringBoot的出租车拼车系统 
效果如下&amp;#xff1a; 
系统首页界面 用户注册界面 拼单信息界面 公告信息界面 管理员登录界面 管理员功能界面 用户界面 司机界面 拼车订单界面 拼单信息界面 拼单申请界面 司机主界面 研究背景 
随着科学技术的不断发展&amp;#xff0c;计算机现…阅读更多...java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:49 +0000</pubDate>
    </item>
    <item>
      <title>基于SpringBoot的出租车拼车系统【附源码】</title>
      <link>https://www.ppmy.cn/news/1540675.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维基于SpringBoot的出租车拼车系统【附源码】news/2025/10/31 21:29:48/基于SpringBoot的出租车拼车系统效果如下：系统首页界面用户注册界面拼单信息界面公告信息界面管理员登录界面管理员功能界面用户界面司机界面拼车订单界面拼单信息界面拼单申请界面司机主界面研究背景随着科学技术的不断发展，计算机现在已经成为了社会的必需品，人们通过因特网可以获得海量的信息，这些信息可以和各行各业进行关联，出租车拼车系统也不例外[1]。传统线下方式管理的起源可以追溯到20世纪60年代末期。当时的计算机技术已经步入了实用技术阶段，由于各行业的工作大部分为高重复度的手工查找，这些工作耗费了大量人力资源又很容易出现细小的差错。这些问题恰恰可以通过计算机来解决，只是碍于技术条件限制，所以信息管理系统的发展比较迟缓。研究意义面对高重复性机械性的工作，工作者不可避免的会出现失误，而改正失误的成本也相当高。特别是近年来，互联网的来临，无论是对人类社会，还是对政治、经济等多方面领域影响深远，也给新时代的信息管理和信息系统带来新的机遇和挑战。网络电脑化越深入，影响越大，社会就越进入互联网时代，出租车拼车系统作为计算机应用，适合做单一重复的操作，对高速发展的技术有着更强的适应性，只需要维护更新得当，大大的降低了人力成本。相关技术JavaJava语言作为现在主流编程语言之一，就是因为它有很多自己的特点和优势。Java语言具有以下几个特点：（1）跨平台性平时所说的一次编译，到处执行，指的就是这个跨平台性。Java的源代码编译后会生成字节码文件，这些文件可以被Java虚拟机执行，得到想要的结果。在设备上安装对应的虚拟机，Java的字节码文件就可以运行。（2）面向对象Java是一个面向对象的编程语言。面向对象是指把属性和方法进行封装，通过创建的对象调用里面的方法，实现一些功能。（3）多线程Java是支持多线程的，它允许在一个程序中同时开启多个线程，同时处理多个任务，这样可以提高它的效率。Spring BootSpring Boot是近几年最为流行的后台开发框架，它的诞生一改过去Spring框架开发中繁琐的配置，极大地简化了Spring应用的搭建和开发。Spring Boot框架不仅保有了Spring框架中的所有优秀特性，还通过使用特定的配置方式，在底层帮助开发人员在工程创建是就预先做了很多配置，这样在开发时就不再需要开发人员过多进行繁琐的配置了。另外在Spring Boot中集成了大量框架，这就使得开发人员不再需要到处寻找在导入开发中需要依赖的jar包，同时也解决了依赖包版本冲突问题，从而提高了依赖包引用的稳定性，从而实现了对Spring应用搭建和开发过程的简化。MySQLMySQL是一种关系型的数据库管理系统，属于Oracle旗下的产品。MySQL的语言是非结构化的，使用的用户可以在数据上进行工作。这个数据库管理系统一经问世就受到了社会的广泛关注。在各个方面，与同等的数据库相比，MySQL的优点极为突出，它的运行速度快，适用的范围广泛，而且数据库的安全性这一方面独树一帜。在语言结构方面，MySQL的语言简单，其他数据库需要一大段代码来实现的操作，MySQL仅需要一小部分代码甚至几行。综上所述，MySQL这种关系型数据库管理系统，已经成为了开发者进行项目的数据开发、存储的不二之选。可行性分析技术可行性分析对系统进行分析，出租车拼车系统的大部分功能都需要管理员完成，springboot框架只需要新增少量代码就可以很好适配管理员功能。也可以提高HTML文件的复用率，提高效率。在数据库方面，ORM简化了表的创建和使用，采用了Oracle旗下开源的关系型数据管理系统MySQL，多表存储的特点使数据更加规范化，增删改查更容易。综上所述，技术开发上并无太大的难点。经济可行性分析由于开发本系统主要是为了测试自身的专业和设计能力，基本不考虑经济效益和后来的发展方向，只注重自身水平和设计能力的提高，并且对自身经济的要求也不高，只要有一台普通电脑就可以了，所以不需要考虑经济问题。市场可行性分析出租车拼车系统作为非盈利性的系统，其职能在方便人民群众。图书馆作为承载知识的载体，高校与社会都有不计其数的图书馆，而出租车拼车系统需要平台的支撑，自然在市场上可行。测试目的任何人系统开发中也不能保证没有一点错误，在开发的过程中错误是不可避免的，所以在发现错误时要及时改正，不能让错误一直存在，否则会引发系统崩溃等不可小觑的后果，所以才需要系统测试来在一定程度上避免这些问题的发生。在测试中发现错误并及时改正才会让系统长久稳定的运行，虽然这是耗时耗力的，但为了系统能够长期使用，系统测试这一步骤也是十分重要的。代码：packagecom.example.taxisharing;importorg.springframework.boot.SpringApplication;importorg.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublicclassTaxiSharingApplication{publicstaticvoidmain(String[]args){SpringApplication.run(TaxiSharingApplication.class,args);}}http://www.ppmy.cn/news/1540675.html相关文章java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；有两种方法&amp;#xff1a; 通过提供的现成api进行调用读取pdf文件&amp;#xff0c;或doc、xlsx、pptx文件&amp;#xff1b;可能商业需要付费 https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.html Spire.PDF for Java  
import com.spire.pdf…阅读更多...electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:48 +0000</pubDate>
    </item>
    <item>
      <title>java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；</title>
      <link>https://www.ppmy.cn/news/1540674.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维java关于如何实现读取各种类型的文件核心属性方法，比如获取标题和作者、主题等；附带远程的https的地址文件读取方法；news/2025/10/31 21:29:46/有两种方法：通过提供的现成api进行调用读取pdf文件，或doc、xlsx、pptx文件；可能商业需要付费https://www.e-iceblue.cn/pdf_java_document_operation/set-pdf-document-properties-in-java.htmlSpire.PDF for Javaimportcom.spire.pdf.*;importjava.io.*;publicclassgetPDFProperties{publicstaticvoidmain(String[]args)throwsIOException{//创建 PdfDocument 类的对象PdfDocumentpdf=newPdfDocument();//从磁盘加载PDF文档pdf.loadFromFile(""+"setPDFProperties.pdf");//创建 StringBuilder 的对象以储存获取的属性数据StringBuilderstringBuilder=newStringBuilder();//获取PDF文档的属性数据并储存于创建的 StringBuilderstringBuilder.append("标题："+pdf.getDocumentInformation().getTitle()+"\r\n");stringBuilder.append("作者"+pdf.getDocumentInformation().getAuthor()+"\r\n");stringBuilder.append("主题："+pdf.getDocumentInformation().getSubject()+"\r\n");stringBuilder.append("关键词："+pdf.getDocumentInformation().getKeywords()+"\r\n");stringBuilder.append("创建者："+pdf.getDocumentInformation().getCreator()+"\r\n");stringBuilder.append("创建时间："+pdf.getDocumentInformation().getCreationDate()+"\r\n");stringBuilder.append("制作工具："+pdf.getDocumentInformation().getProducer()+"\r\n");//创建一个TXT文件Filefile=newFile("getPDFProperties.txt");file.createNewFile();//将 StringBuilder 写入TXT文件FileWriterfileWriter=newFileWriter(file,true);BufferedWriterbufferedWriter=newBufferedWriter(fileWriter);bufferedWriter.write(stringBuilder.toString());bufferedWriter.flush();}}第二种方法：通过Apache POI进行读取实现；另外不同版本 方法实现也会有所不同；Apache POI 的不同版本引入依赖&lt;dependency&gt;&lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;&lt;artifactId&gt;pdfbox&lt;/artifactId&gt;&lt;version&gt;2.0.24&lt;/version&gt;&lt;!--请检查最新版本--&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;commons-io&lt;/groupId&gt;&lt;artifactId&gt;commons-io&lt;/artifactId&gt;&lt;version&gt;2.11.0&lt;/version&gt;&lt;!--检查是否有更新的版本--&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j-api&lt;/artifactId&gt;&lt;version&gt;2.17.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;&lt;version&gt;5.2.2&lt;/version&gt;&lt;!--请检查最新版本--&gt;&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;&lt;artifactId&gt;log4j-api&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;&lt;/dependency&gt;最后直接提供方法实现：packagecom.ruoyi.project.backstage.pdf;importorg.apache.pdfbox.pdmodel.PDDocument;importorg.apache.pdfbox.pdmodel.PDDocumentInformation;importorg.apache.poi.ooxml.POIXMLDocument;importorg.apache.poi.ooxml.POIXMLProperties;importorg.apache.poi.ss.usermodel.Workbook;importorg.apache.poi.ss.usermodel.WorkbookFactory;importorg.apache.poi.xslf.usermodel.XMLSlideShow;importorg.apache.poi.xwpf.usermodel.XWPFDocument;importorg.openxmlformats.schemas.officeDocument.x2006.extendedProperties.CTProperties;importorg.apache.poi.openxml4j.opc.OPCPackage;importorg.apache.poi.poifs.filesystem.POIFSFileSystem;importorg.apache.poi.xssf.usermodel.XSSFWorkbook;importorg.apache.xmlbeans.XmlObject;importorg.apache.xmlbeans.XmlOptions;importorg.apache.xmlbeans.impl.values.XmlComplexContentImpl;importjava.io.File;importjava.io.FileInputStream;importjava.io.IOException;/*** @className: FileUtils* @author: 3.0* @date: 2024/10/16* @Version: 1.0* @description:*/publicclassFileUtils{//    public static void main(String[] args) {//        try (PDDocument document = PDDocument.load(new File("E:\\project\\" + "1.pdf"))) {//            PDDocumentInformation info = document.getDocumentInformation();//            System.out.println("Title: " + info.getTitle());//            System.out.println("Author: " + info.getAuthor());//            System.out.println("Subject: " + info.getSubject());//            // 其他属性...//        } catch (IOException e) {//            e.printStackTrace();//        }////    }//    public static void main(String[] args) throws Exception {//        XWPFDocument doc = new XWPFDocument(new FileInputStream(new File("E:\\project\\log.sh用法(1).docx")));CTProperties coreProps = doc.getProperties().getCoreProperties();//        POIXMLProperties.CoreProperties coreProps = doc.getProperties().getCoreProperties();//        System.out.println("Title: " + coreProps.getTitle());//        System.out.println("Author: " + coreProps.getCreator());//        System.out.println("主题: " + coreProps.getSubject());//        // 更多属性...//        doc.close();//    }publicstaticvoidmain(String[]args)throwsException{Workbookworkbook=WorkbookFactory.create(newFileInputStream(newFile("E:\\project\\工作簿1 - 副本.xls")));if(workbookinstanceofPOIXMLDocument){POIXMLDocumentpoixmlDocument=(POIXMLDocument)workbook;POIXMLPropertiesproperties=poixmlDocument.getProperties();POIXMLProperties.CorePropertiescoreProperties=properties.getCoreProperties();// 现在你可以访问核心属性了Stringtitle=coreProperties.getTitle();Stringsubject=coreProperties.getSubject();Stringcreator=coreProperties.getCreator();// ... 其他属性// 打印属性到控制台System.out.println("Title: "+title);System.out.println("Subject: "+subject);System.out.println("Creator: "+creator);// ...}else{System.out.println("The workbook is not a POIXMLDocument (not an .xlsx file?).");}// 关闭工作簿（在try-with-resources中自动关闭fis，但这里显式关闭workbook以强调）workbook.close();}////    public static void main(String[] args) throws Exception {//        XMLSlideShow ppt = new XMLSlideShow(OPCPackage.open(new FileInputStream(new File("E:\\project\\演示文稿1.pptx"))));//        System.out.println("Title: " + ppt.getProperties().getCoreProperties().getTitle());//        System.out.println("Author: " + ppt.getProperties().getCoreProperties().getCreator());//        System.out.println("主题: " + ppt.getProperties().getCoreProperties().getSubject());//        // 更多属性...//        ppt.close();//    }}如果有需要读取https地址的需求；可以实现下面的：从远程 HTTPS URL 读取文件并将其转换为 FileInputStream 对象，你可以先将远程文件下载到本地磁盘，然后再使用 FileInputStream 打开它。以下是实现这一过程的一种方法：下载文件到本地：1、使用 Java 的 HttpURLConnection 或者 HttpClient 等工具来下载文件。2、创建 FileInputStream：使用下载后的本地文件路径创建 FileInputStream。publicstaticvoidmain(String[]args)throwsException{StringremoteUrl="http://s3.api.com/diaoyun//survey/answer/.xlsx";StringlocalPath="E:\\project\\file11.xlsx";// 本地临时文件路径downloadFileFromURL(remoteUrl,localPath);Filefile=newFile(localPath);FileInputStreamfileInputStream=newFileInputStream(file);Workbookworkbook=WorkbookFactory.create(fileInputStream);//        Workbook workbook = WorkbookFactory.create(new FileInputStream(new File("E:\\project\\工作簿1 - 副本.xls")));if(workbookinstanceofPOIXMLDocument){POIXMLDocumentpoixmlDocument=(POIXMLDocument)workbook;POIXMLPropertiesproperties=poixmlDocument.getProperties();POIXMLProperties.CorePropertiescoreProperties=properties.getCoreProperties();// 现在你可以访问核心属性了Stringtitle=coreProperties.getTitle();Stringsubject=coreProperties.getSubject();Stringcreator=coreProperties.getCreator();// ... 其他属性// 打印属性到控制台System.out.println("Title: "+title);System.out.println("Subject: "+subject);System.out.println("Creator: "+creator);// ...}else{System.out.println("The workbook is not a POIXMLDocument (not an .xlsx file?).");}// 关闭工作簿（在try-with-resources中自动关闭fis，但这里显式关闭workbook以强调）workbook.close();file.delete();}privatestaticvoiddownloadFileFromURL(StringurlStr,StringlocalPath)throwsIOException{URLurl=newURL(urlStr);HttpURLConnectionurlConnection=(HttpURLConnection)url.openConnection();try(InputStreamin=urlConnection.getInputStream();FileOutputStreamout=newFileOutputStream(localPath)){byte[]buffer=newbyte[1024];intbytesRead;while((bytesRead=in.read(buffer))!=-1){out.write(buffer,0,bytesRead);}}}http://www.ppmy.cn/news/1540674.html相关文章electron-vite_11各平台 Electron 镜像存到哪里了？建议设置了 NPM 镜像和 Electron 源&amp;#xff1b;速度会快一点&amp;#xff1b;electron-builder 在打包的时候&amp;#xff0c;会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源&amp;#xff1b; 各操作系统对应的 NPM 缓存路径分别为&amp;#xff1a; 
Linux: $XDG_CACHE_H…阅读更多...六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:47 +0000</pubDate>
    </item>
    <item>
      <title>electron-vite_11各平台 Electron 镜像存到哪里了？</title>
      <link>https://www.ppmy.cn/news/1540673.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维electron-vite_11各平台 Electron 镜像存到哪里了？news/2025/10/31 21:29:45/建议设置了 NPM 镜像和 Electron 源；速度会快一点；electron-builder 在打包的时候，会根据系统的不同去各自的 NPM 缓存目录下查找对应版本的 Electron 源；各操作系统对应的 NPM 缓存路径分别为：Linux: $XDG_CACHE_HOME or ~/.cache/electron/MacOS: ~/Library/Caches/electron/Windows: %LOCALAPPDATA%/electron/Cache or ~/AppData/Local/electron/Cache/如果是win的话；C:\Users\Administrator\AppData\Local\electron\CacheC:\Users\Administrator\AppData\Local\electron-builder\Cachehttp://www.ppmy.cn/news/1540673.html相关文章六、存储过程和触发器及视图和临时表一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。 
下面是对存储过程和触发器的详细讲解和示例说明&amp;#xff1a;存储过程&amp;#xff1a; 存储过程是一组预定义的SQL语句&amp;#xff0c;封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出…阅读更多...【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:45 +0000</pubDate>
    </item>
    <item>
      <title>六、存储过程和触发器及视图和临时表</title>
      <link>https://www.ppmy.cn/news/1540672.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维六、存储过程和触发器及视图和临时表news/2025/10/31 21:29:44/一. 存储过程和触发器是数据库中用于实现复杂业务逻辑和自动化操作的重要工具。下面是对存储过程和触发器的详细讲解和示例说明：存储过程：存储过程是一组预定义的SQL语句，封装在数据库中并可通过名称调用。存储过程可以接受输入参数和输出参数，并可以包含条件判断、循环和异常处理等逻辑。存储过程的好处包括减少网络通信开销、提高性能和安全性、简化应用程序开发等。创建存储过程的语法：CREATEPROCEDUREprocedure_name([parameter1 datatype,parameter2 datatype,...])[LANGUAGE{SQL|specific_language }][BEGIN-- SQL statementsEND;]示例：CREATEPROCEDUREGetCustomerOrders(INcustomer_idINT)BEGINSELECT*FROMordersWHEREcustomer_id=customer_id;END;这个示例创建了一个名为GetCustomerOrders的存储过程，接受一个输入参数customer_id，并返回该顾客的所有订单。触发器：触发器是与表相关联的数据库对象，当满足特定条件时自动触发执行一组预定义的SQL语句。触发器可以在数据插入、更新或删除时执行，并可用于实现数据的约束、审计日志、业务逻辑等。创建触发器的语法：CREATETRIGGERtrigger_name
{BEFORE|AFTER|INSTEADOF} {INSERT|UPDATE|DELETE}ONtable_name[FOR EACH ROW][WHEN(condition)]BEGIN-- SQL statementsEND;示例：CREATETRIGGERupdate_stockAFTERINSERTONorder_detailsFOR EACH ROWBEGINUPDATEproductsSETstock=stock-NEW.quantityWHEREid=NEW.product_id;END;这个示例创建了一个名为update_stock的触发器，在order_details表中插入数据后自动执行。触发器通过减少产品库存来保持数据的一致性。存储过程和触发器可以大大简化数据库应用程序的开发和维护工作，提高数据库的功能和性能。使用存储过程可以将常用的业务逻辑封装起来，使其可重复使用，而触发器可以自动处理与数据相关的操作和约束。二. 视图和临时表是在数据库中使用的两种不同的数据组织和处理方式。下面是对视图和临时表的详细讲解和示例说明：视图：视图是一种虚拟表，是基于查询结果的可视化表示。它可以由一个或多个表的数据组成，并可以通过视图进行数据的检索和操作。视图提供了一种简化和抽象数据的方式，隐藏了底层表的复杂性，使用户能够以更直观和方便的方式访问数据。创建视图的语法：CREATEVIEWview_nameASSELECTcolumn1,column2,...FROMtable_nameWHEREcondition;示例：CREATEVIEWcustomer_ordersASSELECTcustomers.customer_id,customers.customer_name,orders.order_id,orders.order_dateFROMcustomersINNERJOINordersONcustomers.customer_id=orders.customer_id;在上面的示例中，创建了一个名为customer_orders的视图，该视图将customers表和orders表连接起来，仅显示特定的列。更新视图：视图可以用于进行数据的插入、更新和删除操作，这些操作会反映到底层表中。通过更新视图，可以方便地对数据进行修改，而无需直接操作底层表。临时表：临时表是用于在查询中临时存储数据的表，会话结束后临时表会自动销毁。临时表可以在查询过程中存储中间结果，并且可以像普通表一样进行查询和操作。创建临时表的语法：CREATETEMPORARYTABLEtable_name(column1 datatype,column2 datatype,...);示例：CREATETEMPORARYTABLEtemp_orders(order_idINT,order_dateDATE,customer_idINT);在上述示例中，创建了一个名为temp_orders的临时表，用于存储订单的部分数据。临时表在查询过程中提供了临时存储和处理数据的能力，特别适用于复杂查询和需要多次使用中间结果的场景。临时表的作用范围限于当前会话，当会话结束时，临时表会自动销毁，不会对数据库的持久化数据造成影响。视图和临时表都是在数据库查询和数据处理中非常有用的工具。视图提供了一种抽象和可视化的方式来访问数据，简化了数据操作的复杂性。临时表则提供了一种临时存储和处理数据的方式，适用于需要中间结果的查询和数据处理场景。http://www.ppmy.cn/news/1540672.html相关文章【算法】深入理解布隆过滤器1. 什么是布隆过滤器&amp;#xff1f; 
布隆过滤器&amp;#xff08;Bloom Filter&amp;#xff09;是一种空间效率极高的概率型数据结构&amp;#xff0c;用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同&amp;#xff0c;布隆过滤器无法删除元素&amp;#xff0c;并且会存在一定的误判率&amp;…阅读更多...市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:44 +0000</pubDate>
    </item>
    <item>
      <title>【算法】深入理解布隆过滤器</title>
      <link>https://www.ppmy.cn/news/1540671.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【算法】深入理解布隆过滤器news/2025/10/31 21:29:43/1. 什么是布隆过滤器？布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于检测某个元素是否在一个集合中。与常见的数据结构如哈希表不同，布隆过滤器无法删除元素，并且会存在一定的误判率，即它可能会错误地判断一个不存在的元素为存在。尽管如此，布隆过滤器在大规模数据场景中具有巨大的优势，特别是在存储和计算资源有限的情况下，它可以显著减少内存占用，并提供极高效的查询性能。2. 业务场景布隆过滤器的典型应用场景包括：缓存穿透：在分布式缓存系统中，如 Redis，如果大量不存在的数据请求直接打到数据库层，会对数据库造成较大压力。布隆过滤器可以提前过滤掉这些不存在的请求，避免数据库查询。反垃圾邮件系统：判断某个电子邮件是否曾被标记为垃圾邮件。布隆过滤器可以快速检测某个邮件是否已经处理过。Web 爬虫：判断 URL 是否已经被爬取，避免重复爬取相同的页面。区块链：在比特币等加密货币中，布隆过滤器用于快速判断某个交易是否相关。3. 布隆过滤器的原理布隆过滤器的核心思想是使用多个哈希函数来映射数据到一个位数组中，并通过检查位数组中的对应位来判断某个元素是否可能存在。3.1 工作流程初始化：布隆过滤器开始时是一个长度为m的位数组，所有位都被设置为 0。插入操作：当插入一个元素时，布隆过滤器会通过k个独立的哈希函数对该元素进行哈希运算，得到k个哈希值。然后将这些哈希值对应的位数组位置置为 1。查询操作：查询时，同样使用k个哈希函数对元素进行哈希运算。如果所有哈希函数对应的位数组中的位置都为 1，则说明该元素可能存在；如果有任何一个位置为 0，则说明该元素一定不存在。3.2 错误率布隆过滤器并不能 100% 精确地判断元素是否存在，它会存在误判的可能性。即使一个元素没有插入到布隆过滤器中，它也有可能由于哈希冲突而被误认为存在。错误率取决于：位数组的长度m哈希函数的数量k插入元素的数量n通过合理选择这些参数，可以将误判率控制在可接受的范围内。3.3 最佳参数选择在实际应用中，优化误判率非常重要。哈希函数的数量k与位数组的大小m有一个最佳值，通常可以通过以下公式计算：误判率：P 是误判率k 是哈希函数的数量n 是插入的元素个数m 是位数组的大小e 是自然常数最佳哈希函数个数：k 是哈希函数的数量m 是位数组的大小n 是插入的元素个数ln⁡(2) 是 2 的自然对数4. 布隆过滤器的 Python 实现下面我们使用 Python 实现一个简单的布隆过滤器。import mmh3  # 需要安装 mmh3 库
from bitarray import bitarray  # 需要安装 bitarray 库class BloomFilter:def __init__(self, size, hash_count):self.size = sizeself.hash_count = hash_countself.bit_array = bitarray(size)self.bit_array.setall(0)def add(self, item):for i in range(self.hash_count):digest = mmh3.hash(item, i) % self.sizeself.bit_array[digest] = 1def check(self, item):for i in range(self.hash_count):digest = mmh3.hash(item, i) % self.sizeif self.bit_array[digest] == 0:return Falsereturn True# 初始化布隆过滤器
bf = BloomFilter(size=1000, hash_count=5)# 添加元素
bf.add("hello")
bf.add("world")# 查询元素
print(bf.check("hello"))  # 输出: True
print(bf.check("python"))  # 输出: False4.1 实现说明bitarray：用于表示布隆过滤器的位数组。我们使用第三方库bitarray，因为它比 Python 自带的list更加节省空间。mmh3：用于计算哈希值的库。mmh3.hash(item, i)表示对元素进行哈希运算，i用作种子，生成不同的哈希值。5. 布隆过滤器的扩展5.1 可扩展布隆过滤器当布隆过滤器的容量被填满时，误判率会急剧上升。为了解决这个问题，可以使用可扩展布隆过滤器（Scalable Bloom Filter），它通过动态增加新的布隆过滤器来保证误判率保持在设定值以下。5.2 布谷鸟过滤器布谷鸟过滤器是一种与布隆过滤器类似的数据结构，但它支持删除操作，并且通常具有更低的错误率。它通过布谷鸟哈希法在内存中为元素找到更合适的位置。6. 总结布隆过滤器是一个极具效率的数据结构，尤其适用于需要快速判断某个元素是否存在于大规模数据集中的场景。虽然它存在误判的缺点，但通过合理设置参数，可以将误判率降至较低范围。同时，布隆过滤器的轻量化和快速性使得它在缓存、爬虫、反垃圾邮件等领域得到了广泛应用。参考Bloom Filter in Pythonhttp://www.ppmy.cn/news/1540671.html相关文章市场上几个跨平台开发框架？跨平台桌面应用开发框架是一种工具或框架&amp;#xff0c;它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上&amp;#xff0c;开发者需要为每个操作系统编写不同的代码&amp;#xff0c;使用不同的开发工具和语言。而跨平台桌面应用开发框架通过…阅读更多...list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:43 +0000</pubDate>
    </item>
    <item>
      <title>市场上几个跨平台开发框架？</title>
      <link>https://www.ppmy.cn/news/1540670.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维市场上几个跨平台开发框架？news/2025/10/31 21:29:41/跨平台桌面应用开发框架是一种工具或框架，它允许开发者使用一种统一的代码库或语言来创建能够在多个操作系统上运行的桌面应用程序。传统上，开发者需要为每个操作系统编写不同的代码，使用不同的开发工具和语言。而跨平台桌面应用开发框架通过抽象底层操作系统的差异，提供一套统一的API和工具，使开发者能够在一个代码库中编写应用程序，并将其部署到多个平台。一、跨平台开发框架及其特点跨平台开发框架允许开发者使用统一的代码库为多个操作系统创建应用程序，从而提高开发效率并减少重复工作。以下是一些流行的跨平台开发框架及其特点：Electron：一个开源的跨平台桌面应用程序开发框架，由GitHub开发和维护。它基于Chromium和Node.js，使用Web技术（HTML、CSS和JavaScript）构建应用程序，支持Windows、Mac和Linux平台。Electron适用于具有复杂交互和跨平台需求的桌面应用程序。wxPython：基于Python的跨平台图形用户界面（GUI）开发框架，使用wxWidgets库。它提供了丰富的GUI控件和功能，支持Windows、Mac和Linux平台，并提供与底层操作系统交互的API。wxPython使用Python语言编写，适合快速开发桌面应用程序。FinClip：基于Flutter的跨平台应用容器，可以将Flutter应用嵌入到其他应用中运行。FinClip提供丰富的API和功能，支持Android和iOS平台，并提供可视化的开发工具。适用于需要将Flutter应用嵌入到其他应用中的场景。Tauri：用于构建跨平台原生应用程序的开源工具和框架。使用Web技术（HTML、CSS和JavaScript）构建应用程序界面，同时使用Rust语言编写底层框架和与操作系统交互的代码。Tauri支持Windows、Mac和Linux平台，适用于需要使用Web技术构建跨平台原生应用程序的场景。Flutter：由Google开发的跨平台移动应用程序开发框架，使用Dart语言编写。Flutter通过一套统一的UI框架在Android和iOS等多个平台上构建高性能、美观的应用程序。Flutter的应用程序使用Skia引擎进行渲染，并直接运行在操作系统的图形引擎上，不依赖于WebView或浏览器。Flutter适用于需要快速构建跨平台移动应用程序的场景。Taro：由京东旗下的凹凸实验室推出，基于React，特别擅长小程序和H5的跨平台开发。Taro支持微信小程序，还兼容支付宝、百度、字节跳动等多种小程序平台，同时也支持H5和React Native开发。One：作为一款新兴的React框架，专注于Web、移动端和桌面端的跨平台开发，且具备本地优先的数据同步特性。One在平台覆盖上更加广泛，支持Web、iOS、Android，还支持桌面应用程序的开发。Uniapp：由DCloud开发，基于Vue，主打“一次开发，多端适配”。Uniapp支持包括微信、支付宝、钉钉在内的多个小程序平台，同时支持H5、iOS、Android，甚至可以打包为App、桌面应用，几乎覆盖了所有主流平台。Ionic：一个开源 UI 工具包，结合使用本机和 Web 技术（如 HTML、CSS 和 JavaScript）来构建混合移动和桌面应用程序，并集成了 Angular、React 和 Vue 构架。Ionic 基于专为移动操作系统设计的 SaaS UI 框架，并提供多个用于构建应用程序的 UI 组件。Xamarin：一个开源跨平台应用程序开发框架，使用 C# 语言和 .Net 框架来开发适用于 Android、iOS 和 Windows 的应用程序。Xamarin 应用程序使用基类库（或 .NET BCL），这是一个具有一系列全面功能的类的大型集合。选择适合的跨平台开发框架应该根据项目需求、目标操作系统、开发经验和性能要求等因素进行评估和比较。二、跨平台开发框架优缺点1、Electron优缺点Electron是一个开源的跨平台桌面应用程序开发框架，由GitHub开发和维护。它基于Chromium和Node.js，使用Web技术（HTML、CSS和JavaScript）来构建应用程序。Electron可以将Web应用程序打包成桌面应用程序，并支持在Windows、Mac和Linux等多个平台上运行。它提供了丰富的API和工具，可以访问底层操作系统的功能，如文件系统、网络、窗口管理等。Electron适用于具有复杂交互和跨平台需求的桌面应用程序。2、Flutter优缺点Flutter 是最新的跨平台应用程序框架之一，由 Google 开发并于 2017 年发布。Flutter是一个免费的开源跨平台框架，它允许你用一组代码创建一个移动应用程序。它的独特之处在于它使用Dart编程语言，不同于其他跨平台应用框架，Flutter根本不使用JavaScript。你可以改变你的代码并实时看到结果，只需片刻就可以升级应用程序。您可以使用Flutter为iOS、Android和其他不太流行的移动平台创建跨平台的移动应用程序。平心而论，就目前而言，这是为 Fuchsia OS 开发应用程序的唯一途径。优点：Flutter 自带图形引擎，这意味着无需为 iOS 和 Android 分别制作界面。Dart 使您能够编写额外的结构化程序代码，从而允许您创建更多层次结构和复杂功能。基于 Flutter 的移动应用程序快速高效。与其他跨平台应用程序框架相比，Flutter 提供了更显着的性能提升。开发工具：EmacsVS CodeAndroid Studio3、Xamarin优缺点Xamarin 是一个免费的开源跨平台应用程序框架，类似于 React Native。它于 2011 年作为独立平台创建，但五年后被微软收购。Xamarin 与大多数跨平台框架不同，它基于 Mono，这是 .NET 平台的开源实现。此实现带有自己的 C# 编译器、运行时和 .NET 核心库。该项目的目标是使 C# 程序能够在 Windows 以外的操作系统上运行，例如 Unix 和 Mac OS。优点：与其他跨平台应用程序开发框架不同，Xamarin 使用起来相对简单，因为所需的只是 C# 和 .NET 环境的工作知识。有一个由公司和贡献者组成的大型社区。免费和开源框架。开发工具：Xamarin StudioVisual Studio Code三、跨平台框架共同点1、共同点：跨平台性：Electron、wxPython、FinClip、Tauri和Flutter都是跨平台框架，可以在多个操作系统上运行。开发效率：这些框架都提供了一套统一的API和工具，使开发者能够使用一种语言或代码库来编写应用程序，并将其部署到多个平台上，从而提高开发效率。社区支持：这些框架都有活跃的开发者社区，提供了丰富的文档、示例和插件，可以帮助开发者解决问题和加速开发过程。2、不同点：技术栈：Electron是基于Web技术的跨平台桌面应用开发框架，使用HTML、CSS和JavaScript来构建应用程序；wxPython是基于Python的跨平台桌面应用开发框架，使用Python语言和wxWidgets库来构建应用程序；FinClip是一个基于微信小程序的跨平台桌面应用开发框架，使用小程序开发技术来构建应用程序；Tauri是一个基于Web技术的跨平台桌面应用开发框架，使用Rust语言和WebView来构建应用程序；Flutter是一个基于Dart语言的跨平台桌面应用开发框架，使用Flutter框架和Dart语言来构建应用程序。应用类型：这些框架适用于不同类型的应用程序开发。Electron和Tauri适用于构建桌面应用程序，wxPython适用于构建Python语言的桌面应用程序，FinClip适用于构建微信小程序的桌面应用程序，Flutter适用于构建跨平台的移动应用和桌面应用程序。性能和体验：由于使用不同的底层技术和工具，这些框架在性能和用户体验方面可能有所不同。一些框架如Electron和Flutter具有较好的性能和用户体验，而其他框架可能受限于底层技术的性能和限制。http://www.ppmy.cn/news/1540670.html相关文章list(1)list 大体上与之前学的string,vector类似&amp;#xff0c;list不支持[]访问&amp;#xff0c;擅长头插&amp;#xff0c;头删&amp;#xff0c;尾插&amp;#xff0c;尾删&amp;#xff0c;中间元素插入删除&amp;#xff0c;因为list底层是双向循环带头链表 
一段代码演示&amp;#xff1a; 
#include &lt;iostream&gt;…阅读更多...tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:42 +0000</pubDate>
    </item>
    <item>
      <title>list(1)</title>
      <link>https://www.ppmy.cn/news/1540669.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维list(1)news/2025/10/31 21:29:40/list大体上与之前学的string,vector类似，list不支持[]访问，擅长头插，头删，尾插，尾删，中间元素插入删除，因为list底层是双向循环带头链表一段代码演示：#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;int main()
{//尾插list&lt;int&gt; lt1;lt1.push_back(1);lt1.push_back(1);lt1.push_back(1);lt1.push_back(1);list&lt;int&gt; lt2 = { 1,2,3,4,5 };//迭代器list&lt;int&gt;::iterator it1 = lt1.begin();//迭代器进行访问while (it1 != lt1.end()){cout &lt;&lt; *it1 &lt;&lt; " ";++it1;}cout &lt;&lt; endl;//支持迭代器也就支持范围forfor (auto e : lt2){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;
}代码结果如下：这里list的迭代器会有所不同用原生指针解决不了push_back和emplace_back先来看一段代码：class Pos
{int _row;int _col;public:Pos(int row, int col):_row(row),_col(col){cout &lt;&lt; "Pos(int row, int col)" &lt;&lt; endl;}//拷贝构造Pos(const Pos&amp; p):_row(p._row), _col(p._col){cout &lt;&lt; "Pos(const Pos&amp;p)" &lt;&lt; endl;}
};int main()
{//构造+拷贝构造//push_backlist&lt;Pos&gt; lt;//有名对象Pos p1(1, 1);lt.push_back(p1);//匿名对象lt.push_back(Pos(2, 2));//隐式类型转换lt.push_back({ 3,3 });//emplace_back，可以看作模板lt.emplace_back(p1);lt.emplace_back(Pos(2, 2));//lt.emplace_back({3,3});不可以，因为形参类型未知//可以传递多个参数，相当于直接构造了Pos//直接构造lt.emplace_back(3, 3);return 0;
}splice一个应用的地方在于可以提高修改元素内容的效率：int main()
{list&lt;int&gt; lt1 = { 1,2,3,4,5 };//LRU//这里可以理解为转移链表里面的元素int x;while (cin &gt;&gt; x){auto pos = find(lt1.begin(), lt1.end(), x);if (pos != lt1.end()){//这里的含义是把lt1里的pos转移到开头位置lt1.splice(lt1.begin(), lt1, pos);}}return 0;
}sort–排序示例代码如下：int main()
{list&lt;int&gt; lt1 = { 1,20,3,-4,5 };for (auto e : lt1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;//默认是升序lt1.sort();for (auto e : lt1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;//如果需要降序，要用到仿函数greater//有名对象的写法//greater&lt;int&gt; gt;//lt1.sort(gt);//匿名对象的写法,更推荐lt1.sort(greater&lt;int&gt;());//vector的方式也可以写vector&lt;int&gt; v1 = { 1,20,3,-4,5 };for (auto e : v1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;//这里同样也是默认升序sort(v1.begin(), v1.end());for (auto e : v1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;//降序也要用到仿函数sort(v1.begin(), v1.end(), greater&lt;int&gt;());for (auto e : v1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;
}运行结果如下：迭代器的分类不能随便乱用迭代器，因为底层是不一样的，可以理解为随机单向迭代器包含于双向迭代器，双向迭代器包含于随机迭代器上面的排序,sort的底层是特殊处理过的，vector的底层是快排效率对比测试：测试的代码：void test_op1()
{srand(time(0));const int N = 1000000;list&lt;int&gt; lt1;list&lt;int&gt; lt2;vector&lt;int&gt; v;for (int i = 0; i &lt; N; ++i){auto e = rand() + i;lt1.push_back(e);v.push_back(e);}int begin1 = clock();// 排序sort(v.begin(), v.end());int end1 = clock();int begin2 = clock();lt1.sort();int end2 = clock();printf("vector sort:%d\n", end1 - begin1);printf("list sort:%d\n", end2 - begin2);
}void test_op2()
{srand(time(0));const int N = 1000000;list&lt;int&gt; lt1;list&lt;int&gt; lt2;for (int i = 0; i &lt; N; ++i){auto e = rand();lt1.push_back(e);lt2.push_back(e);}int begin1 = clock();// 拷贝vectorvector&lt;int&gt; v(lt2.begin(), lt2.end());// 排序sort(v.begin(), v.end());// 拷贝回lt2lt2.assign(v.begin(), v.end());int end1 = clock();int begin2 = clock();lt1.sort();int end2 = clock();printf("list copy vector sort copy list sort:%d\n", end1 - begin1);printf("list sort:%d\n", end2 - begin2);
}测试结果：list的模拟实现尾插的操作与前面学习的双向循环链表类似：迭代器这里需要注意，与前面学习的string和vector不一样：这里需要注意的是迭代器不可以通过下标的方式进行访问，像我们前面学过的string和vector底层结构是数组，物理结构是连续的，但是list的底层是双向循环链表，物理空间不连续，需要借助类封装节点指针，重载运算符，模拟指针的行为operator-&gt;访问代码如下：list.hT* operator-&gt;()//访问里面元素
{return &amp;_node-&gt;_data;//取里面地址
}Test.cppsoobin::list&lt;Pos&gt; lt2;
Pos p1(1, 1);
lt2.push_back(p1);
lt2.push_back(Pos(2, 2));
lt2.push_back({ 3,3 });soobin::list&lt;Pos&gt;::iterator it2 = lt2.begin();
while (it2 != lt2.end())
{cout &lt;&lt; (*it2)._row &lt;&lt; ":" &lt;&lt; (*it2)._col &lt;&lt; endl;//为了可读性，特殊处理，省略了一个-&gt;cout &lt;&lt; it2-&gt;_row &lt;&lt; ":" &lt;&lt; it2-&gt;_col &lt;&lt; endl;//显示写法，第一个-&gt;是运算符重载，第二个-&gt;是结构体元素访问cout &lt;&lt; it2.operator-&gt;()-&gt;_row &lt;&lt; ":" &lt;&lt; it2.operator-&gt;()-&gt;_col &lt;&lt; endl;++it2;
}
cout &lt;&lt; endl;总体代码如下：List.h#include &lt;assert.h&gt;
namespace soobin
{// 惯例// 全部都是公有，一般用structtemplate&lt;class T&gt;struct list_node{T _data;list_node&lt;T&gt;* _next;list_node&lt;T&gt;* _prev;list_node(const T&amp; x = T())//模板的缺省值，匿名对象:_data(x), _next(nullptr), _prev(nullptr){}};template&lt;class T&gt;struct list_iterator{typedef list_node&lt;T&gt; Node;typedef list_iterator&lt;T&gt; Self;Node* _node;list_iterator(Node* node):_node(node){}//引用返回的好处是既可以读也可以写T&amp; operator*(){return _node-&gt;_data;}T* operator-&gt;(){return &amp;_node-&gt;_data;}Self&amp; operator++(){_node = _node-&gt;_next;return *this;}Self&amp; operator--(){_node = _node-&gt;_prev;return *this;}Self operator++(int){Self tmp(*this);_node = _node-&gt;_next;return tmp;}Self operator--(int){Self tmp(*this);_node = _node-&gt;_prev;return tmp;}bool operator!=(const Self&amp; s){return _node != s._node;}};template&lt;class T&gt;class list{typedef list_node&lt;T&gt; Node;public:typedef list_iterator&lt;T&gt; iterator;iterator begin(){return iterator(_head-&gt;_next);}iterator end(){return iterator(_head);}void empty_init(){_head = new Node();_head-&gt;_next = _head;_head-&gt;_prev = _head;}list(){empty_init();}void push_back(const T&amp; x){Node* new_node = new Node(x);Node* tail = _head-&gt;_prev;tail-&gt;_next = new_node;new_node-&gt;_prev = tail;new_node-&gt;_next = _head;_head-&gt;_prev = new_node;}private:Node* _head;};
}Test.h#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;//int main()
//{//尾插//list&lt;int&gt; lt1;//lt1.push_back(1);//lt1.push_back(1);//lt1.push_back(1);//lt1.push_back(1);//list&lt;int&gt; lt2 = { 1,2,3,4,5 };//迭代器//list&lt;int&gt;::iterator it1 = lt1.begin();//迭代器进行访问//while (it1 != lt1.end())//{//	cout &lt;&lt; *it1 &lt;&lt; " ";//	++it1;//}//cout &lt;&lt; endl;//支持迭代器也就支持范围for//for (auto e : lt2)//{//	cout &lt;&lt; e &lt;&lt; " ";//}//cout &lt;&lt; endl;
//}class Pos
{
public:int _row;int _col;Pos(int row, int col):_row(row),_col(col){cout &lt;&lt; "Pos(int row, int col)" &lt;&lt; endl;}//拷贝构造Pos(const Pos&amp; p):_row(p._row), _col(p._col){cout &lt;&lt; "Pos(const Pos&amp;p)" &lt;&lt; endl;}
};//int main()
//{//构造+拷贝构造//push_back
//	list&lt;Pos&gt; lt;//有名对象
//	Pos p1(1, 1);
//	lt.push_back(p1);
//	//匿名对象
//	lt.push_back(Pos(2, 2));//隐式类型转换
//	lt.push_back({ 3,3 });//emplace_back，可以看作模板
//	lt.emplace_back(p1);
//	lt.emplace_back(Pos(2, 2));//lt.emplace_back({3,3});不可以，因为形参类型未知//可以传递多个参数，相当于直接构造了Pos//直接构造
//	lt.emplace_back(3, 3);
//	return 0;
//}//int main()
//{//for (auto e : lt1)//{//	cout &lt;&lt; e &lt;&lt; " ";//}//cout &lt;&lt; endl;//int x;//cin &gt;&gt; x;//auto it = find(lt1.begin(), lt1.end(), x);//if (it != lt1.end())//{//	it.erase(it);//}
//	return 0;
//}//int main()//{//	list&lt;int&gt; lt1 = { 1,2,3,4,5 };//LRU//这里可以理解为转移链表里面的元素//	int x;//	while (cin &gt;&gt; x)//	{//		auto pos = find(lt1.begin(), lt1.end(), x);//		if (pos != lt1.end())//		{//这里的含义是把lt1里的pos转移到开头位置//			lt1.splice(lt1.begin(), lt1, pos);//		}//	}//	return 0;//}//int main()
//{
//	list&lt;int&gt; lt1 = { 1,20,3,-4,5 };
//	for (auto e : lt1)
//	{
//		cout &lt;&lt; e &lt;&lt; " ";
//	}
//	cout &lt;&lt; endl;//默认是升序
//	lt1.sort();
//	for (auto e : lt1)
//	{
//		cout &lt;&lt; e &lt;&lt; " ";
//	}
//cout&lt;&lt;endl;
//	//如果需要降序，要用到仿函数greater//有名对象的写法//greater&lt;int&gt; gt;//lt1.sort(gt);//匿名对象的写法,更推荐//lt1.sort(greater&lt;int&gt;());//vector的方式也可以写//vector&lt;int&gt; v1 = { 1,20,3,-4,5 };//for (auto e : v1)//{//	cout &lt;&lt; e &lt;&lt; " ";//}//cout &lt;&lt; endl;//这里同样也是默认升序//sort(v1.begin(), v1.end());//for (auto e : v1)//{//	cout &lt;&lt; e &lt;&lt; " ";//}//cout &lt;&lt; endl;//降序也要用到仿函数//sort(v1.begin(), v1.end(), greater&lt;int&gt;());//for (auto e : v1)//{//	cout &lt;&lt; e &lt;&lt; " ";
//	}//cout &lt;&lt; endl;
//}
//void test_op1()
//{
//	srand(time(0));
//	const int N = 1000000;//	list&lt;int&gt; lt1;
//	list&lt;int&gt; lt2;//	vector&lt;int&gt; v;
//
//	for (int i = 0; i &lt; N; ++i)
//	{
//		auto e = rand() + i;
//		lt1.push_back(e);
//		v.push_back(e);
//	}//	int begin1 = clock();// 排序
//	sort(v.begin(), v.end());
//	int end1 = clock();//	int begin2 = clock();
//	lt1.sort();
//	int end2 = clock();//	printf("vector sort:%d\n", end1 - begin1);
//	printf("list sort:%d\n", end2 - begin2);
//}//void test_op2()
//{
//	const int N = 1000000;//	list&lt;int&gt; lt1;
//	list&lt;int&gt; lt2;//	for (int i = 0; i &lt; N; ++i)
//	{
//		auto e = rand();
//		lt1.push_back(e);
//		lt2.push_back(e);
//	}//	int begin1 = clock();// 拷贝vector//	vector&lt;int&gt; v(lt2.begin(), lt2.end());// 排序
//	sort(v.begin(), v.end());// 拷贝回lt2
//	lt2.assign(v.begin(), v.end());//	int end1 = clock();//	int begin2 = clock();
//	lt1.sort();
//	int end2 = clock();//	printf("list copy vector sort copy list sort:%d\n", end1 - begin1);
//	printf("list sort:%d\n", end2 - begin2);
//}#include "List.h"int main()
{soobin::list&lt;int&gt; lt1;lt1.push_back(1);lt1.push_back(1);lt1.push_back(1);lt1.push_back(1);//不直接在it1上进行改动是因为会造成没有指针指向哨兵位等问题//迭代器soobin::list&lt;int&gt;::iterator it1 = lt1.begin();//迭代器进行访问while (it1 != lt1.end()){//也可以写*it1 = 2;cout &lt;&lt; *it1 &lt;&lt; " ";++it1;}cout &lt;&lt; endl;//支持迭代器也就支持范围forfor (auto e : lt1){cout &lt;&lt; e &lt;&lt; " ";}cout &lt;&lt; endl;soobin::list&lt;Pos&gt; lt2;Pos p1(1, 1);lt2.push_back(p1);lt2.push_back(Pos(2, 2));lt2.push_back({ 3,3 });soobin::list&lt;Pos&gt;::iterator it2 = lt2.begin();while (it2 != lt2.end()){cout &lt;&lt; (*it2)._row &lt;&lt; ":" &lt;&lt; (*it2)._col &lt;&lt; endl;//为了可读性，特殊处理，省略了一个-&gt;cout &lt;&lt; it2-&gt;_row &lt;&lt; ":" &lt;&lt; it2-&gt;_col &lt;&lt; endl;//显示写法，第一个-&gt;是运算符重载，第二个-&gt;是结构体元素访问cout &lt;&lt; it2.operator-&gt;()-&gt;_row &lt;&lt; ":" &lt;&lt; it2.operator-&gt;()-&gt;_col &lt;&lt; endl;++it2;}cout &lt;&lt; endl;return 0;
}http://www.ppmy.cn/news/1540669.html相关文章tftpd.exe开启调试tftpd.exe开启调试 debugFlags设置为0xf开启debug 
设置为0xf000f则开启debug和trace 第一部分&amp;#xff1a; 位置 net/tcpip/services/tftpd/service.c if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,                      "System\\CurrentControlSet\\Services\\Tftpd\\Paramet…阅读更多...【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:41 +0000</pubDate>
    </item>
    <item>
      <title>tftpd.exe开启调试</title>
      <link>https://www.ppmy.cn/news/1540668.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维tftpd.exe开启调试news/2025/10/31 21:29:39/tftpd.exe开启调试debugFlags设置为0xf开启debug设置为0xf000f则开启debug和trace第一部分：位置net/tcpip/services/tftpd/service.cif (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\Services\\Tftpd\\Parameters",0, KEY_QUERY_VALUE, &amp;parameters) != ERROR_SUCCESS)上面是注册表路径voidTftpdReadRegistryParameters() {DWORD keyType, valueSize;char path[MAX_PATH];HKEY parameters = NULL;// Open the registry key which contains all the adjustable parameters// to the service.  We will register for notification on it later incase// anything changes while we're running.if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\Services\\Tftpd\\Parameters",0, KEY_QUERY_VALUE, &amp;parameters) != ERROR_SUCCESS)parameters = NULL;if (parameters == NULL) {globals.parameters.hashEntries   =   256;globals.parameters.lowWaterMark  =     5;globals.parameters.highWaterMark =   256;globals.parameters.maxRetries    =    10;TftpdSetStartDirectory(NULL);strcpy(globals.parameters.validClients,    "*.*.*.*");strcpy(globals.parameters.validReadFiles,  "*");strcpy(globals.parameters.validMasters,    "*.*.*.*");strcpy(globals.parameters.validWriteFiles, "*");return;}#if (DBG)// Initialize debug settings (if applicable) :keyType = 0;valueSize = sizeof(globals.parameters.debugFlags);if ((RegQueryValueEx(parameters, "DebugFlags", NULL, &amp;keyType,(LPBYTE)&amp;globals.parameters.debugFlags, &amp;valueSize) != ERROR_SUCCESS) ||(keyType != REG_DWORD)) {globals.parameters.debugFlags = 0x00000000;}#endif // (DBG)第二部分：位置net/tcpip/services/tftpd/debug.c#if (DBG)#include &lt;stdio.h&gt;void __cdeclTftpdOutputDebug(ULONG flag, CHAR *format, ...) {CHAR buffer[1024];va_list args;if (!(flag &amp; globals.parameters.debugFlags))return;va_start(args, format);sprintf(buffer, "[%04X] ", GetCurrentThreadId());vsprintf(buffer + 7, format, args);va_end(args);OutputDebugString(buffer);} // TftpdOutputDebug()#endif // (DBG)第三部分：位置net/tcpip/services/tftpd/precomp.h//// Debug//#if defined(DBG)void __cdeclTftpdOutputDebug(ULONG flag, char *format, ...);#define  TFTPD_DEBUG(x)             TftpdOutputDebug x#define  TFTPD_DBG_SERVICE          0x00000001#define  TFTPD_DBG_IO               0x00000002#define  TFTPD_DBG_PROCESS          0x00000004#define  TFTPD_DBG_CONTEXT          0x00000008#define  TFTPD_TRACE_SERVICE        0x00010000#define  TFTPD_TRACE_IO             0x00020000#define  TFTPD_TRACE_PROCESS        0x00040000#define  TFTPD_TRACE_CONTEXT        0x00080000#else#define  TFTPD_DEBUG(x)#endif // defined(DBG)http://www.ppmy.cn/news/1540668.html相关文章【推导过程】常用离散分布的数学期望、方差、特征函数文章目录 相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差 泊松分布泊松定理数学期望方差 超几何分布超几何分布的二项近似数学期望方差 几何分布几何分布的无记忆性数学期望方差 负二项分布 作者&amp;#xff1a;小猪快跑 基础数学&amp;计算数…阅读更多...笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:39 +0000</pubDate>
    </item>
    <item>
      <title>【推导过程】常用离散分布的数学期望、方差、特征函数</title>
      <link>https://www.ppmy.cn/news/1540667.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【推导过程】常用离散分布的数学期望、方差、特征函数news/2025/10/31 21:29:37/文章目录相关教程相关文献常用离散分布的数学期望&amp;方差&amp;特征函数二项分布数学期望方差泊松分布泊松定理数学期望方差超几何分布超几何分布的二项近似数学期望方差几何分布几何分布的无记忆性数学期望方差负二项分布作者：小猪快跑基础数学&amp;计算数学，从事优化领域7年+，主要研究方向：MIP求解器、整数规划、随机规划、智能优化算法常用离散分布（二项分布、泊松分布、超几何分布、几何分布与负二项分布）的数学期望、方差、特征函数具体推导。如有错误，欢迎指正。如有更好的算法，也欢迎交流！！！——@小猪快跑相关教程常用分布的数学期望、方差、特征函数【推导过程】常用离散分布的数学期望、方差、特征函数【推导过程】常用连续分布的数学期望、方差、特征函数相关文献[1]茆诗松,周纪芗.概率论与数理统计 (第二版)[M].中国统计出版社,2000.常用离散分布的数学期望&amp;方差&amp;特征函数分布名称概率分布或密度函数p ( x ) p(x)p(x)数学期望方差特征函数单点分布p c = 1 \begin{array}{c}{p_{c}=1}\end{array}pc​=1​(c cc为常数)c cc0 00e i c t e^{ict}eict0 − 1 0-10−1分布p 0 = 1 − p , p 1 = p ( 0 &lt; p &lt; 1 ) \begin{array}{c} p_{0}=1-p,p_{1}=p\\ (0&lt;p&lt;1)\end{array}p0​=1−p,p1​=p(0&lt;p&lt;1)​p ppp ( 1 − p ) p(1-p)p(1−p)1 − p + p e i t 1-p+pe^{it}1−p+peit二项分布b ( n , p ) b(n,p)b(n,p)p k = ( n k ) p k ( 1 − p ) n − k k = 0 , 1 , 2 , ⋯ , n ( 0 &lt; p &lt; 1 ) p_{k}=\binom{n}{k}p^{k}(1-p)^{n-k}\\k=0,1,2,\cdots,n\\(0&lt;p&lt;1)pk​=(kn​)pk(1−p)n−kk=0,1,2,⋯,n(0&lt;p&lt;1)n p npnpn p ( 1 − p ) np(1-p)np(1−p)( 1 − p + p e i t ) n (1-p+pe^{it})^{n}(1−p+peit)n泊松分布P ( λ ) P(\lambda)P(λ)p k = λ k k ! e − k k = 0 , 1 , 2 , ⋯ ; ( λ &gt; 0 ) p_{k}=\frac{\lambda^{k}}{k!}e^{-k}\\k=0,1,2,\cdots;(\lambda&gt;0)pk​=k!λk​e−kk=0,1,2,⋯;(λ&gt;0)λ \lambdaλλ \lambdaλe λ ( e i t − 1 ) e^{\lambda(e^{it}-1)}eλ(eit−1)超几何分布h ( n , N , M ) h(n,N,M)h(n,N,M)p k = ( M k ) ( N − M n − k ) ( N n ) M ⩽ N , n ⩽ N , M , N , n 正整数, k = 0 , 1 , 2 , ⋯ , min ⁡ ( M , N ) p_{k}=\frac{\displaystyle\binom{M}{k}\binom{N-M}{n-k}}{\displaystyle\binom{N}{n}}\\M\leqslant N,n\leqslant N,M,N,n\text{ 正整数,}\\k=0,1,2,\cdots,\min(M,N)pk​=(nN​)(kM​)(n−kN−M​)​M⩽N,n⩽N,M,N,n正整数,k=0,1,2,⋯,min(M,N)n M N n\displaystyle\frac MNnNM​n M N ( 1 − M N ) N − n N − 1 \displaystyle\frac{nM}N(1-\frac MN)\frac{N-n}{N-1}NnM​(1−NM​)N−1N−n​∑ k = 0 n ( M k ) ( N − M n − k ) ( N n ) e i t k \displaystyle\sum_{k=0}^n\frac{\displaystyle\binom Mk\binom{N-M}{n-k}}{\displaystyle\binom Nn}e^{itk}k=0∑n​(nN​)(kM​)(n−kN−M​)​eitk几何分布G e ( p ) Ge(p)Ge(p)p k = ( 1 − p ) k − 1 p k = 1 , 2 , ⋯ ( 0 &lt; p &lt; 1 ) p_{k}=(1-p)^{k-1}p\\k=1,2,\cdots\\(0&lt;p&lt;1)pk​=(1−p)k−1pk=1,2,⋯(0&lt;p&lt;1)1 p \displaystyle\frac1pp1​1 − p p 2 \displaystyle\frac{1-p}{p^2}p21−p​p e i t 1 − ( 1 − p ) e i t \displaystyle\frac{pe^{it}}{1-(1-p)e^{it}}1−(1−p)eitpeit​负二项分布帕斯卡分布N b ( r , p ) Nb(r,p)Nb(r,p)p k = ( k − 1 r − 1 ) ( 1 − p ) k − r p r r 正整数 , k = r , r + 1 , ⋯ ( 0 &lt; p &lt; 1 ) \begin{gathered}p_{k}={\binom{k-1}{r-1}}(1-p)^{k-r}p^{r} \\r正整数,k=r,r+1,\cdots \\(0&lt;p&lt;1) \end{gathered}pk​=(r−1k−1​)(1−p)k−rprr正整数,k=r,r+1,⋯(0&lt;p&lt;1)​r p \displaystyle\frac rppr​r ( 1 − p ) p 2 \displaystyle\frac{r(1-p)}{p^2}p2r(1−p)​( p e i t 1 − ( 1 − p ) e i t ) r \left(\displaystyle\frac{pe^{it}}{1-(1-p)e^{it}}\right)^r(1−(1−p)eitpeit​)r二项分布如果记X XX为n nn重伯努利试验中成功（记为事件A AA）的次数，则X XX的可能取值为0 , 1 , ⋯ , n 0,1,\cdots,n0,1,⋯,n。 记p pp为每次试验中A AA发生的概率，即P ( A ) = p P(A)=pP(A)=p，则P ( A ˉ ) = 1 − p P(\bar A)=1-pP(Aˉ)=1−p。因为n nn重伯努利试验的基本结果可以记作ω = ( ω 1 , ω 2 , ⋯ , ω n ) \omega = (\omega_1, \omega_2, \cdots , \omega_n)ω=(ω1​,ω2​,⋯,ωn​)其中ω i \omega_iωi​或者为A AA，或者为A ˉ \bar AAˉ。 这样的ω \omegaω共有2 n 2^n2n个，这2 n 2^n2n个样本点ω \omegaω组成了样本空间Ω \OmegaΩ。下面求X XX的分布列，即求事件{ X = k } \{X=k\}{X=k}的概率。若某个样本点ω = ( ω 1 , ω 2 , ⋯ , ω n ) ∈ { X = k } \omega = (\omega_1,\omega_2,\cdots,\omega_n) \in \{ X = k \}ω=(ω1​,ω2​,⋯,ωn​)∈{X=k}意味着ω 1 , ω 2 , ⋯ , ω n \omega_1,\omega_2,\cdots,\omega_nω1​,ω2​,⋯,ωn​中有k kk个A , n − k A,n-kA,n−k个A ˉ \bar AAˉ，所以由独立性知P ( ω ) = p k ( 1 − p ) n − k P(\omega) = p^k(1-p)^{n-k}P(ω)=pk(1−p)n−k而事件{ X = k } \{X=k\}{X=k}中这样的ω \omegaω共有( n k ) \binom nk(kn​)个，所以X XX的分布列为P ( X = k ) = ( n k ) p k ( 1 − p ) n − k , k = 0 , 1 , ⋯ , n P(X=k)=\binom{n}{k}p^k(1-p)^{n-k}, k=0,1,\cdots,nP(X=k)=(kn​)pk(1−p)n−k,k=0,1,⋯,n数学期望E ( X ) = ∑ k = 0 n k ( n k ) p k ( 1 − p ) n − k = n p ∑ k = 1 n ( n − 1 k − 1 ) p k − 1 ( 1 − p ) ( n − 1 ) − ( k − 1 ) = n p [ p + ( 1 − p ) ] n − 1 = n p \begin{aligned} E(X)&amp; =\sum_{k=0}^nk\binom nkp^k(1-p)^{n-k} \\ &amp;=np\sum_{k=1}^n\binom{n-1}{k-1}p^{k-1}(1-p)^{(n-1)-(k-1)} \\ &amp;=np[p+(1-p)]^{n-1}=np \end{aligned}E(X)​=k=0∑n​k(kn​)pk(1−p)n−k=npk=1∑n​(k−1n−1​)pk−1(1−p)(n−1)−(k−1)=np[p+(1−p)]n−1=np​方差E ( X 2 ) = ∑ k = 0 n k 2 ( n k ) p k ( 1 − p ) n − k = ∑ k = 1 n ( k − 1 + 1 ) k ( n k ) p k ( 1 − p ) n − k = ∑ k = 1 n k ( k − 1 ) ( n k ) p k ( 1 − p ) n − k + ∑ k = 1 n k ( n k ) p k ( 1 − p ) n − k = ∑ k = 2 n k ( k − 1 ) ( n k ) p k ( 1 − p ) n − k + n p = n ( n − 1 ) p 2 ∑ k = 2 n ( n − 2 k − 2 ) p k − 2 ( 1 − p ) ( n − 2 ) − ( k − 2 ) + n p = n ( n − 1 ) p 2 + n p . \begin{align*} E(X^2) &amp; = \sum_{k=0}^nk^2\binom nkp^k(1-p)^{n-k} \\ &amp; = \sum_{k=1}^n(k-1+1)k\binom nkp^k(1-p)^{n-k} \\ &amp; = \sum_{k=1}^nk(k-1)\binom nkp^k(1-p)^{n-k} + \sum_{k=1}^nk\binom nkp^k(1-p)^{n-k} \\ &amp; = \sum_{k=2}^nk(k-1)\binom nkp^k(1-p)^{n-k} + np \\ &amp; = n(n-1)p^2\sum_{k=2}^n\binom{n-2}{k-2} p^{k-2} (1-p)^{(n-2)-(k-2)} + np \\ &amp; = n(n-1)p^2 + np. \end{align*}E(X2)​=k=0∑n​k2(kn​)pk(1−p)n−k=k=1∑n​(k−1+1)k(kn​)pk(1−p)n−k=k=1∑n​k(k−1)(kn​)pk(1−p)n−k+k=1∑n​k(kn​)pk(1−p)n−k=k=2∑n​k(k−1)(kn​)pk(1−p)n−k+np=n(n−1)p2k=2∑n​(k−2n−2​)pk−2(1−p)(n−2)−(k−2)+np=n(n−1)p2+np.​V a r ( X ) = E ( X 2 ) − [ E ( X ) ] 2 = n ( n − 1 ) p 2 + n p − ( n p ) 2 = n p ( 1 − p ) \mathrm{Var}(X) = E(X^2) - [E(X)]^2 = n(n-1)p^2 + np - (np)^2 = np(1-p)Var(X)=E(X2)−[E(X)]2=n(n−1)p2+np−(np)2=np(1−p)泊松分布在单位时间内，电话总机接到用户呼唤的次数在单位时间内，一电路受到外界电磁波的冲击次数1平方米内，玻璃上的气泡数一铸件上的砂眼数在单位时间内，某种放射性物质分裂到某区域的质点数等等设随机变量X ∼ P ( λ ) X\sim P(\lambda)X∼P(λ)P ( X = k ) = λ k k ! e − λ , k = 0 , 1 , 2 , ⋯ , P(X=k)=\frac{\lambda^k}{k!}\mathrm{e}^{-\lambda}, k=0, 1,2,\cdots,P(X=k)=k!λk​e−λ,k=0,1,2,⋯,泊松定理在n nn重伯努利试验中，记事件A AA在一次试验中发生的概率为p n p_npn​（与试验次数n nn有关），如果当n → + ∞ n\to+\inftyn→+∞时，有n p n → λ np_n\to\lambdanpn​→λ，则lim ⁡ n → + ∞ ( n k ) p n k ( 1 − p n ) n − k = λ k k ! e − λ . \lim_{n\to+\infty} \binom nk p_n^k(1-p_n)^{n-k} = \frac{\lambda^k}{k!}\mathrm{e}^{-\lambda}.n→+∞lim​(kn​)pnk​(1−pn​)n−k=k!λk​e−λ.记n p n = λ n np_n=\lambda_nnpn​=λn​，记p n = λ n / n p_n=\lambda_n/npn​=λn​/n，我们可得( n k ) p n k ( 1 − p n ) n − k = n ( n − 1 ) ⋯ ( n − k + 1 ) k ! ( λ n n ) k ( 1 − λ n n ) n − k = λ n k k ! ( 1 − 1 n ) ( 1 − 2 n ) ⋯ ( 1 − k − 1 n ) ( 1 − λ n n ) n − k . \begin{align*} \binom nk p_n^k(1-p_n)^{n-k} &amp; = \frac{n(n-1)\cdots(n-k+1)}{k!}\left( \frac{\lambda_n}n \right)^k \left( 1 - \frac{\lambda_n}n \right)^{n-k} \\ &amp; = \frac{\lambda_n^k}{k!}\left( 1 - \frac1n \right)\left( 1 - \frac2n \right) \cdots \left( 1 - \frac{k-1}n \right) \left( 1 - \frac{\lambda_n}n \right)^{n-k}. \end{align*}(kn​)pnk​(1−pn​)n−k​=k!n(n−1)⋯(n−k+1)​(nλn​​)k(1−nλn​​)n−k=k!λnk​​(1−n1​)(1−n2​)⋯(1−nk−1​)(1−nλn​​)n−k.​对固定的k kk有lim ⁡ n → + ∞ λ n = λ lim ⁡ n → + ∞ ( 1 − λ n n ) n − k = e − λ lim ⁡ n → + ∞ ( 1 − 1 n ) ⋯ ( 1 − k − 1 n ) = 1 \begin{align*} &amp; \lim_{n\to+\infty}\lambda_n = \lambda \\ &amp; \lim_{n\to+\infty}\left( 1 - \frac{\lambda_n}n \right)^{n-k} = \mathrm{e}^{-\lambda} \\ &amp; \lim_{n\to+\infty}\left( 1 - \frac1n \right) \cdots \left( 1 - \frac{k-1}n \right) = 1 \end{align*}​n→+∞lim​λn​=λn→+∞lim​(1−nλn​​)n−k=e−λn→+∞lim​(1−n1​)⋯(1−nk−1​)=1​从而lim ⁡ n → + ∞ ( n k ) p n k ( 1 − p n ) n − k = λ k k ! e − λ \lim_{n\to+\infty} \binom nk p_n^k(1-p_n)^{n-k} = \frac{\lambda^k}{k!}\mathrm{e}^{-\lambda}n→+∞lim​(kn​)pnk​(1−pn​)n−k=k!λk​e−λ对任意的k kk（k = 0 , 1 , 2 , ⋯ k=0,1,2,\cdotsk=0,1,2,⋯）成立。数学期望E ( X ) = ∑ k = 0 + ∞ k λ k k ! e − λ = λ e − λ ∑ k = 1 + ∞ λ k − 1 ( k − 1 ) ! = λ e − λ e λ = λ E(X) = \sum_{k=0}^{+\infty} k\frac{\lambda^k}{k!}\mathrm{e}^{-\lambda} = \lambda\mathrm{e}^{-\lambda} \sum_{k=1}^{+\infty}\frac{\lambda^{k-1}}{(k-1)!} = \lambda\mathrm{e}^{-\lambda} \mathrm{e}^\lambda = \lambdaE(X)=k=0∑+∞​kk!λk​e−λ=λe−λk=1∑+∞​(k−1)!λk−1​=λe−λeλ=λ方差E ( X 2 ) = ∑ k = 0 + ∞ k 2 λ k k ! e − λ = ∑ k = 1 + ∞ k λ k ( k − 1 ) ! e − λ = ∑ k = 1 + ∞ [ ( k − 1 ) + 1 ] λ k ( k − 1 ) ! e − λ = λ 2 e − λ ∑ k = 2 + ∞ λ k − 2 ( k − 2 ) ! + λ e − λ ∑ k = 1 + ∞ λ k − 1 ( k − 1 ) ! = λ 2 + λ . \begin{aligned} E(X^{2})&amp; =\sum_{k=0}^{+\infty}k^{2}\frac{\lambda^{k}}{k!}\mathrm{e}^{-\lambda}=\sum_{k=1}^{+\infty}k \frac{\lambda^{k}}{(k-1)!}\mathrm{e}^{-\lambda} \\ &amp;=\sum_{k=1}^{+\infty}[(k-1)+1]\frac{\lambda^k}{(k-1)!}\mathrm{e}^{-\lambda} \\ &amp;=\lambda^{2}\mathrm{e}^{-\lambda}\sum_{k=2}^{+\infty}\frac{\lambda^{k-2}}{(k-2)!}+\lambda\mathrm{e}^{-\lambda}\sum_{k=1}^{+\infty}\frac{\lambda^{k-1}}{(k-1)!} \\ &amp;=\lambda^{2}+\lambda. \end{aligned}E(X2)​=k=0∑+∞​k2k!λk​e−λ=k=1∑+∞​k(k−1)!λk​e−λ=k=1∑+∞​[(k−1)+1](k−1)!λk​e−λ=λ2e−λk=2∑+∞​(k−2)!λk−2​+λe−λk=1∑+∞​(k−1)!λk−1​=λ2+λ.​V a r ( X ) = E ( X 2 ) − [ E ( X ) ] 2 = λ 2 + λ − λ 2 = λ \mathrm{Var}(X)=E(X^2)-[E(X)]^2=\lambda^2+\lambda-\lambda^2=\lambdaVar(X)=E(X2)−[E(X)]2=λ2+λ−λ2=λ超几何分布从一个有限总体中进行不放回抽样常会遇到超几何分布。设有N NN个产品，其中有M MM个不合格品。若从中不放回地随机抽取n nn个，则其中含有的不合格品的个数X XX服从超几何分布，记为X ∼ h ( n , N , M ) X\sim h(n,N,M)X∼h(n,N,M)。超几何分布的概率分布列为P ( X = k ) = ( M k ) ( N − M n − k ) ( N n ) , k = 0 , 1 , ⋯ , r P(X = k) = \frac{\binom Mk \binom{N-M}{n-k}} {\binom Nn},\; k = 0,1,\cdots,rP(X=k)=(nN​)(kM​)(n−kN−M​)​,k=0,1,⋯,r其中r = min ⁡ { M , n } r=\min\{M,n\}r=min{M,n}，且M ≤ N , n ≤ N , n , N , M M\le N,n\le N,n,N,MM≤N,n≤N,n,N,M均为正整数。超几何分布的二项近似当n ≪ N n\ll Nn≪N时，即抽取个数n nn远小于产品总数N NN时，每次抽取后，总体中的不合格品率p = M / N p=M/Np=M/N改变甚徽，所以不放回抽样可近似地看成放回抽样，这时超几何分布可用二项分布近似：( M k ) ( N − M n − k ) ( N n ) ≅ ( n k ) p k ( 1 − p ) n − k , 其中 p = M N \frac{\binom Mk \binom{N-M}{n-k}} {\binom Nn} \cong \binom nkp^k(1-p)^{n-k},\;\text{其中}\,p = \frac MN(nN​)(kM​)(n−kN−M​)​≅(kn​)pk(1−p)n−k,其中p=NM​数学期望若X ∼ h ( n , N , M ) X\sim h(n,N,M)X∼h(n,N,M)，则X XX的数学期望为E ( X ) = ∑ k = 0 r k ( M k ) ( N − M n − k ) ( N n ) = n M N ∑ k = 1 r ( M − 1 k − 1 ) ( N − M n − k ) ( N − 1 n − 1 ) = n M N E(X) = \sum_{k=0}^rk\frac{\binom Mk \binom{N-M}{n-k}} {\binom Nn} = n\frac MN \sum_{k=1}^r \frac{\binom {M-1}{k-1} \binom{N-M}{n-k}} {\binom {N-1}{n-1}} = n\frac MNE(X)=k=0∑r​k(nN​)(kM​)(n−kN−M​)​=nNM​k=1∑r​(n−1N−1​)(k−1M−1​)(n−kN−M​)​=nNM​方差E ( X 2 ) = ∑ k = 1 r k 2 ( M k ) ( N − M n − k ) ( N n ) = ∑ k = 2 r k ( k − 1 ) ( M k ) ( N − M n − k ) ( N n ) + n M N = M ( M − 1 ) ( N n ) ∑ k = 2 r k ( k − 1 ) ( M − 2 k − 2 ) ( N − M n − k ) + n M N = M ( M − 1 ) ( N n ) ( N − 2 n − 2 ) + n M N = M ( M − 1 ) n ( n − 1 ) N ( N − 1 ) + n M N , \begin{align*} E(X^2) &amp; = \sum_{k=1}^rk^2\frac{\binom Mk \binom{N-M}{n-k}} {\binom Nn} = \sum_{k=2}^r k(k-1) \frac{\binom Mk \binom{N-M}{n-k}} {\binom Nn} + n \frac MN \\ &amp; = \frac{M(M-1)}{\binom Nn} \sum_{k=2}^rk(k-1) \binom{M-2}{k-2} \binom{N-M}{n-k} + n\frac MN \\ &amp; = \frac{M(M-1)}{\binom Nn} \binom{N-2}{n-2} + n \frac MN = \frac{M(M-1)n(n-1)}{N(N-1)} + n \frac MN, \end{align*}E(X2)​=k=1∑r​k2(nN​)(kM​)(n−kN−M​)​=k=2∑r​k(k−1)(nN​)(kM​)(n−kN−M​)​+nNM​=(nN​)M(M−1)​k=2∑r​k(k−1)(k−2M−2​)(n−kN−M​)+nNM​=(nN​)M(M−1)​(n−2N−2​)+nNM​=N(N−1)M(M−1)n(n−1)​+nNM​,​由此得X XX的方差为V a r ( X ) = E ( X 2 ) − [ E ( X ) ] 2 = n M ( N − M ) ( N − n ) N 2 ( N − 1 ) \mathrm{Var}(X) = E(X^2) - [E(X)]^2 = \frac{nM(N-M)(N-n)}{N^2(N-1)}Var(X)=E(X2)−[E(X)]2=N2(N−1)nM(N−M)(N−n)​几何分布在伯努利试验序列中，记每次试验中事件A AA发生的概率为p pp，如果X XX为事件A AA首次出现时的试验次数，则X XX的可能取值为1 , 2 , ⋯ 1,2,\cdots1,2,⋯，称X XX服从几何分布，记为X ∼ G e ( p ) X\sim Ge(p)X∼Ge(p)，其分布列为P ( X = k ) = ( 1 − p ) k − 1 p , k = 1 , 2 , ⋯ P(X = k) = (1 - p)^{k-1}p,\; k = 1,2,\cdotsP(X=k)=(1−p)k−1p,k=1,2,⋯实际中有不少随机变量服从几何分布，譬如，某产品的不合格率为0.05，则首次查到不合格品的检查次数X ∼ G e ( 0.05 ) X\sim Ge(0.05)X∼Ge(0.05)某射手的命中率为0.8，则首次击中目标的射击次数Y ∼ G e ( 0.8 ) Y\sim Ge(0.8)Y∼Ge(0.8)掷一颗骰子，首次出现6点的投掷次数Z ∼ G e ( 1 / 6 ) Z\sim Ge(1/6)Z∼Ge(1/6)同时掷两颗骰子，首次达到两个点数之和为8的投掷次数W ∼ G e ( 5 / 36 ) W\sim Ge(5/36)W∼Ge(5/36)几何分布的无记忆性设X ∼ G e ( p ) X\sim Ge(p)X∼Ge(p)，则对任意正整数m mm与n nn有P ( X &gt; m + n ∣ X &gt; m ) = P ( X &gt; n ) P(X &gt; m + n| X &gt; m) = P(X &gt; n)P(X&gt;m+n∣X&gt;m)=P(X&gt;n)在证明之前先解释上述概率等式的含义.在一列伯努利试验序列中，若首次成功( A ) (A)(A)出现的试验次数X服从几何分布，则事件“X &gt; m X&gt;mX&gt;m”表示前m mm次试验中A AA没有出现.假如在接下去的n nn次试验中A AA仍未出现，这个事件记为“X &gt; m + n X&gt;m+nX&gt;m+n”.这个定理表明：在前m mm次试验中A AA没有出现的条件下，则在接下去的n nn次试验中A AA仍未出现的概率只与n nn有关，而与以前的m mm次试验无关，似乎忘记了前m mm次试验结果，这就是无记忆性。因为P ( X &gt; n ) = ∑ k = n + 1 + ∞ ( 1 − p ) k − 1 p = p ( 1 − p ) n 1 − ( 1 − p ) = ( 1 − p ) n P(X &gt; n) = \sum_{k=n+1}^{+\infty}(1-p)^{k-1}p = \frac{p(1-p)^n}{1-(1-p)} = (1-p)^nP(X&gt;n)=k=n+1∑+∞​(1−p)k−1p=1−(1−p)p(1−p)n​=(1−p)n所以对任意的正整数m mm与n nn，条件概率P ( X &gt; m + n ∣ X &gt; m ) = P ( X &gt; m + n ) P ( X &gt; m ) = ( 1 − p ) m + n ( 1 − p ) m = ( 1 − p ) n = P ( X &gt; n ) \begin{align*} P(X &gt; m + n | X &gt; m) &amp; = \frac{P(X&gt;m+n)}{P(X&gt;m)} = \frac{(1-p)^{m+n}}{(1-p)^m} \\ &amp; = (1 - p)^n = P(X &gt; n) \end{align*}P(X&gt;m+n∣X&gt;m)​=P(X&gt;m)P(X&gt;m+n)​=(1−p)m(1−p)m+n​=(1−p)n=P(X&gt;n)​数学期望设随机变量X XX服从几何分布G e ( p ) Ge(p)Ge(p)，令q = 1 − p q=1-pq=1−p，利用逐项微分可得X XX的数学期望为E ( X ) = ∑ k = 1 + ∞ k p q k − 1 = p ∑ k = 1 + ∞ k q k − 1 = p ∑ k = 1 + ∞ d q k d q = p d d q ( ∑ k = 0 + ∞ q k ) = p d d q ( 1 1 − q ) = p ( 1 − q ) 2 = 1 p \begin{align*} E(X) &amp; = \sum_{k=1}^{+\infty} kpq^{k-1} = p\sum_{k=1}^{+\infty}kq^{k-1} = p\sum_{k=1}^{+\infty}\frac{\mathrm dq^k}{\mathrm dq} \\ &amp; = p\frac{\mathrm d}{\mathrm dq}\Big( \sum_{k=0}^{+\infty}q^k \Big) = p \frac{\mathrm d}{\mathrm dq}\left( \frac1{1-q} \right) = \frac p{(1-q)^2} = \frac1p \end{align*}E(X)​=k=1∑+∞​kpqk−1=pk=1∑+∞​kqk−1=pk=1∑+∞​dqdqk​=pdqd​(k=0∑+∞​qk)=pdqd​(1−q1​)=(1−q)2p​=p1​​方差E ( X 2 ) = ∑ k = 1 + ∞ k 2 p q k − 1 = p [ ∑ k = 1 + ∞ k ( k − 1 ) q k − 1 + ∑ k = 1 + ∞ k q k − 1 ] = p q ∑ k = 1 + ∞ k ( k − 1 ) q k − 2 + 1 p = p q ∑ k = 1 + ∞ d 2 d q 2 q k + 1 p = p q d 2 d q 2 ( ∑ k = 1 + ∞ q k ) + 1 p = p q d 2 d q 2 ( 1 1 − q ) + 1 p = p q 2 ( 1 − q ) 3 + 1 p = 2 q p 2 + 1 p \begin{align*} E(X^2) &amp; = \sum_{k=1}^{+\infty} k^2pq^{k-1} = p \bigg[ \sum_{k=1}^{+\infty} k(k-1)q^{k-1} + \sum_{k=1}^{+\infty} kq^{k-1} \bigg] \\ &amp; = pq\sum_{k=1}^{+\infty} k(k-1)q^{k-2} + \frac1p = pq \sum_{k=1}^{+\infty}\frac{\mathrm d^2}{\mathrm dq^2}q^k + \frac1p \\ &amp; = pq\frac{\mathrm d^2}{\mathrm dq^2}\Big(\sum_{k=1}^{+\infty}q^k\big) + \frac1p = pq \frac{\mathrm d^2}{\mathrm dq^2}\left( \frac1{1-q}\right) + \frac1p \\ &amp; = pq\frac2{(1-q)^3} + \frac1p = \frac{2q}{p^2} + \frac1p \end{align*}E(X2)​=k=1∑+∞​k2pqk−1=p[k=1∑+∞​k(k−1)qk−1+k=1∑+∞​kqk−1]=pqk=1∑+∞​k(k−1)qk−2+p1​=pqk=1∑+∞​dq2d2​qk+p1​=pqdq2d2​(k=1∑+∞​qk)+p1​=pqdq2d2​(1−q1​)+p1​=pq(1−q)32​+p1​=p22q​+p1​​由此得X XX的方差为V a r ( X ) = E ( X 2 ) − [ E ( X ) ] 2 = 2 q p 2 + 1 p − 1 p 2 = 1 − p p 2 \mathrm{Var}(X) = E(X^2) - [E(X)]^2 = \frac{2q}{p^2} + \frac1p - \frac1{p^2} = \frac{1-p}{p^2}Var(X)=E(X2)−[E(X)]2=p22q​+p1​−p21​=p21−p​负二项分布作为几何分布的一种延伸，我们注意下面的负二项分布，巴斯卡分布：在伯努利试验序列中，记每次试验中事件A AA发生的概率为p pp，如果X XX为事件A AA第r rr次出现时的试验次数，则X XX的可能取值为r , r + 1 , ⋯ , r + m , ⋯ r,r+1,\cdots,r+m,\cdotsr,r+1,⋯,r+m,⋯. 称X XX服从负二项分布或巴斯卡分布，其分布列为P ( X = k ) = ( k − 1 r − 1 ) p r ( 1 − p ) k − r , k = r , r + 1 , ⋯ P(X = k) = \binom{k-1}{r-1} p^r(1-p)^{k-r},\; k=r,r+1,\cdotsP(X=k)=(r−1k−1​)pr(1−p)k−r,k=r,r+1,⋯记为X ∼ N b ( r , p ) X\sim Nb(r,p)X∼Nb(r,p)。当r = 1 r=1r=1时，即为几何分布。这是因为在次伯努利试验中，最后一次一定是A AA，而前k − 1 k-1k−1次中A AA应出现r − 1 r-1r−1次，由二项分布知其概率为( k − 1 r − 1 ) p r − 1 ( 1 − p ) k − r \binom{k-1}{r-1}p^{r-1}(1-p)^{k-r}(r−1k−1​)pr−1(1−p)k−r，再乘以最后一次出现A AA的概率p pp，即得。可以算得负二项分布的数学期望为r / p r/pr/p，方差为r ( 1 − p ) / p 2 r(1-p)/p^2r(1−p)/p2。从直观上看这是合理的，因为首次出现A AA的平均试验次数是1 / p 1/p1/p，那么第r rr个A AA出现所需的平均试验次数是r / p r/pr/p。如果将第一个A AA出现的试验次数记为X 1 X_1X1​，第二个A AA出现的试验次数（从第一个A AA出现之后算起）记为X 2 X_2X2​，第r rr个A AA出现的试验次数（从第r − 1 r-1r−1个A AA出现之后算起）记为X r X_rXr​，则X i X_iXi​独立同分布，且X i ∼ G e ( p ) X_i\sim Ge(p)Xi​∼Ge(p).此时有X = X 1 + X 2 + ⋯ + X r ∼ N b ( r , p ) X=X_1+X_2+\cdots+X_r\sim Nb(r,p)X=X1​+X2​+⋯+Xr​∼Nb(r,p)，即负二项分布的随机变量可以表示成r rr个独立同分布的几何分布随机变量之和。http://www.ppmy.cn/news/1540667.html相关文章笔试练习day7目录 OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码 NC109 岛屿数量题目解析解法代码(dfs)dfs的实现 拼三角题目解析解法(枚举)代码 感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接 &amp;#x1f412;&amp;#x1f412;&amp;#x1f412; 
个人主页 &amp;…阅读更多...DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:38 +0000</pubDate>
    </item>
    <item>
      <title>笔试练习day7</title>
      <link>https://www.ppmy.cn/news/1540666.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维笔试练习day7news/2025/10/31 21:29:36/目录OR59 字符串中找出连续最长的数字串题目解析解法(双指针遍历)代码NC109 岛屿数量题目解析解法代码(dfs)dfs的实现拼三角题目解析解法(枚举)代码感谢各位大佬对我的支持,如果我的文章对你有用,欢迎点击以下链接🐒🐒🐒 
个人主页🥸🥸🥸 
C语言🐿️🐿️🐿️ 
C语言例题🐣🐣🐣 
python🐓🐓🐓 
数据结构C语言🐔🐔🐔 
C++🐿️🐿️🐿️ 
文章链接目录🏀🏀🏀 
笔试练习题OR59 字符串中找出连续最长的数字串OR59 字符串中找出连续最长的数字串题目解析这道题是找出最长连续的数字,并将这串数字以字符串的形式输出,解题的思路就是用两个指针(i和j)遍历这个字符串当i指针第一次遇到数字字符时就将位置给到j指针此时j往后开始去查找这个连续的数字字符串有多长,当j遇到不是数字字符的时候就表示这个连续的数字字符串已经找完了,要计算他的长度.这个长度的计算我们可以直接用两个变量去记录这个数字字符串的起始位置和长度然后i变到j的下一个位置继续重复上面操作当遇到字符串长度比之前的len要大的时候就更新begin和len解法(双指针遍历)代码intmain(){string s;cin&gt;&gt;s;intbegin=-1,len=0;for(inti=0;i&lt;s.size();i++){if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'){intj=i;while(j&lt;s.size()&amp;&amp;s[j]&gt;='0'&amp;&amp;s[j]&lt;='9'){j++;}if(j-i&gt;len){len=j-i;begin=i;}i=j+1;}}cout&lt;&lt;s.substr(begin,len)&lt;&lt;endl;return0;}NC109 岛屿数量NC109 岛屿数量题目解析根据题目描述下面的这个例子有3个岛屿其中绿色圆圈圈起的数字虽然没有上下左右之间的关系,但是也是相连的岛屿解法这道题解法就是通过bfs/dfs搜索去寻找连通的岛屿并标记已经找到的岛屿代码(dfs)classSolution{public:intm,n;intdx[4]={0,0,1,-1};intdy[4]={1,-1,0,0};boolvis[210][210]={0};intsolve(vector&lt;vector&lt;char&gt;&gt;&amp;grid){m=grid.size(),n=grid[0].size();intret=0;for(inti=0;i&lt;m;i++){for(intj=0;j&lt;n;j++){if(grid[i][j]=='1'&amp;&amp;!vis[i][j]){ret++;dfs(grid,i,j);}}}returnret;}};因为这个岛屿需要上下左右的搜索,所以需要方向数组(之前的题也有类似的)在搜索时需要进行标记已经搜索过的岛屿,所以要用一个bool类型的数组vis,因为岛屿矩阵的范围是200200,所以vis数组的范围我们应该选择大于200200的范围二维数组的长和宽我们用m和n进行表示,ret来记录有多少个岛屿通过两层for循环去遍历这个二维数组然后用条件判断当grid[i][j]==1的时候表示这里有岛屿,且我们还要看这个岛屿是否之前已经被搜索过了,所以!vis[i][j]条件符合时就让ret++记录这个岛屿,并且用dfs去标记周围连通的岛屿dfs的实现voiddfs(vector&lt;vector&lt;char&gt;&gt;&amp;grid,inti,intj){vis[i][j]=true;for(intk=0;k&lt;4;k++){intx=i+dx[k],y=j+dy[k];if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;grid[x][y]=='1'&amp;&amp;!vis[x][y]){dfs(grid,x,y);}}}进入dfs时grid[i][j]是有岛屿的,所以要进行标记然后利用方向数组对grid[i][j]的周围进行搜索,并且要判断是否越界,当满足grid[x][y] == '1’和vis[x][y]没有被标记时就继续进入dfs(grid, x, y)拼三角拼三角题目解析题目意思就是给了6个棍子,但是这6个棍子的长度是不一样的,需要在选出3根来组成一个三角形的同时剩下的3根也能组成解法(枚举)因为这道题只给了6根棍子,所以搭配的方式比较少,我们可以把所有情况列出来由排列组合可得所以的情况只有654/322=10种具体我们可以用三重for循环去枚举,第一个for循环选第一根棍子,第二跟for循环选第二跟棍子,第三个for循环就选第三根棍子,在循环内部再检查是否能组成三角形第二个方法就是用dfs去枚举第三个方法就是优化后的枚举我们知道三角形的判断条件如下我们假设三个棍子长度分别为a b c如果我们将这三个棍子长度进行排序,那么我们判断条件就会简单许多假如a&lt;b&lt;c那么我们就会发现判断条件就会少两个所以我们对开始的6根棍子进行排序,排序过后就需要枚举以下的10种情况当我们在枚举0 1 2和3 4 5的时候如果他们的条件成立就不需要再枚举后面的情况(因为已经满足条件了)而如果枚举0 1 2和3 4 5的时候发现不满足条件那么他后面的几种情况就不需要再考虑(因为0+1&lt;2那么0+1也同时&lt;3)所以根据上面的思路我们只需要枚举4种情况就可以了代码#include&lt;iostream&gt;#include&lt;algorithm&gt;usingnamespacestd;intt;intarr[6];intmain(){cin&gt;&gt;t;while(t--){for(inti=0;i&lt;6;i++)cin&gt;&gt;arr[i];sort(arr,arr+6);if(arr[0]+arr[1]&gt;arr[2]&amp;&amp;arr[3]+arr[4]&gt;arr[5]||arr[0]+arr[2]&gt;arr[3]&amp;&amp;arr[1]+arr[4]&gt;arr[5]||arr[0]+arr[3]&gt;arr[4]&amp;&amp;arr[1]+arr[2]&gt;arr[5]||arr[0]+arr[4]&gt;arr[5]&amp;&amp;arr[1]+arr[2]&gt;arr[3])cout&lt;&lt;"Yes"&lt;&lt;endl;elsecout&lt;&lt;"No"&lt;&lt;endl;}return0;}http://www.ppmy.cn/news/1540666.html相关文章DBSwitch和Seatunel一、DBSwitch 
什么是DBSwitch?它主要用在什么场景&amp;#xff1f; 通过步骤分析可以看到这个是通过配置数据源&amp;#xff0c;采用一次性或定时方案&amp;#xff0c;同步到数据仓库的指定表&amp;#xff0c;并且指定映射关系的工具。有点类似于flinkcdc的增量同步。 
参考&amp;#xff1a; 
dbs…阅读更多...webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:36 +0000</pubDate>
    </item>
    <item>
      <title>DBSwitch和Seatunel</title>
      <link>https://www.ppmy.cn/news/1540665.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维DBSwitch和Seatunelnews/2025/10/31 21:29:35/一、DBSwitch什么是DBSwitch?它主要用在什么场景？通过步骤分析可以看到这个是通过配置数据源，采用一次性或定时方案，同步到数据仓库的指定表，并且指定映射关系的工具。有点类似于flinkcdc的增量同步。参考：dbswitch: 异构数据库迁移同步工具dbswitch工具提供源端数据库向目的端数据库的批量迁移同步功能，支持数据的全量和增量方式同步。包括：结构迁移支持字段类型、主键信息、建表语句等的转换，并生成建表SQL语句。支持基于正则表达式转换的表名与字段名映射转换。数据同步。基于JDBC的分批次读取源端数据库数据，并基于insert/copy方式将数据分批次写入目的数据库。支持有主键表的增量变更同步（变化数据计算Change Data Calculate）功能(千万级以上数据量的性能尚需在生产环境验证)dbswitch实现的功能是:异构数据库迁移同步工具,dbswitch提供源端数据库向目的端数据的全量与增量迁移同步功能,其实大概功能和datax类似，只是效率和稳定性没有datax好，因为datax毕竟是阿里巴巴开源，并且也是目前国内认为开源中最好的离线数据同步工具。但是datax不支持表结构的同步二、Seatunel什么是Seatunel?它主要用在什么场景？SeaTunnel 是一个简单易用的数据集成框架，在企业中，由于开发时间或开发部门不通用，往往有多个异构的、运行在不同的软硬件平台上的信息系统同时运行。数据集成是把不同来源、格式、特点性质的数据在逻辑上或物理上有机地集中， 从而为企业提供全面的数据共享。 SeaTunnel 支持海量数据的实时同步。它每天可以稳定高效地同步数百亿数据。 并已用于近 100 家公司的生产。SeaTunnel 在做什么？本质上，SeaTunnel 不是对 Saprk 和 Flink 的内部修改，而是在 Spark 和 Flink 的基础上 做了一层包装。它主要运用了控制反转的设计模式，这也是 SeaTunnel 实现的基本思想。SeaTunnel 的日常使用，就是编辑配置文件。编辑好的配置文件由 SeaTunnel 转换为具 体的 Spark 或 Flink 任务。目前 SeaTunnel 的优势是他有丰富的连接器， 又因为它以 Spark 和 Flink 为引擎。所以可以很好地进行分布式的海量数据同步。 通常 SeaTunnel 会被用来做出仓入仓工具， 或者被用来进行数据集成。参考：https://seatunnel.apache.org/zh-CN/docs/2.3.6/seatunnel-engine/rest-api/SeaTunnel有一个用于监控的API，可用于查询运行作业的状态和统计信息，以及最近完成的作业。监控API是RESTful风格的，它接受HTTP请求并使用JSON数据格式进行响应。也是和datax在进行比较http://www.ppmy.cn/news/1540665.html相关文章webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）一、排他操作 
1.排他思想 如果有同一组元素&amp;#xff0c;我们想要某一个元素实现某种样式&amp;#xff0c;需要用到循环的排他思想算法&amp;#xff1a; 1.所有的元素全部清除样式 2.给当前的元素设置样式 注意顺序能不能颠倒&amp;#xff0c;首先清除全部样式&amp;#xff0c;再设置自己当前的…阅读更多...Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:35 +0000</pubDate>
    </item>
    <item>
      <title>webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）</title>
      <link>https://www.ppmy.cn/news/1540664.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维webAPI中的排他思想、自定义属性操作、节点操作（配大量案例练习）news/2025/10/31 21:29:33/一、排他操作1.排他思想如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：1.所有的元素全部清除样式2.给当前的元素设置样式注意顺序能不能颠倒，首先清除全部样式，再设置自己当前的样式&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;01排他思想&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;buttonclass="btn"&gt;按钮1&lt;/button&gt;&lt;buttonclass="btn"&gt;按钮2&lt;/button&gt;&lt;buttonclass="btn"&gt;按钮3&lt;/button&gt;&lt;buttonclass="btn"&gt;按钮4&lt;/button&gt;&lt;buttonclass="btn"&gt;按钮5&lt;/button&gt;&lt;script&gt;//1.获取到所有的元素varbtns=document.getElementsByClassName('btn');//console.log(btns);//2.遍历  btns是一个数组（有length和根据索引获取元素，但是不具备数据中push等方法）for(vari=0;i&lt;btns.length;i++){//给所有的button都注册点击事件btns[i].onclick=function(){//alert('ok');//1)清除所有按钮的样式(重新再遍历一遍所有的btns)for(varj=0;j&lt;btns.length;j++){btns[j].style.backgroundColor='';}//2)添加样式this.style.backgroundColor='pink';}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.案例案例一百度换肤&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;02百度换肤&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}body{background:url(images/1.jpg)no-repeat center top;}li{list-style:none;}.baidu{overflow:hidden;margin:100px auto;background-color:#fff;width:410px;padding-top:3px;}.baidu li{float:left;}.baidu img{width:100px;}.baidu:hover{cursor:pointer;/*手的形状*/}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ulclass="baidu"id="baidu"&gt;&lt;li&gt;&lt;img src="images/1.jpg"alt=""&gt;&lt;/li&gt;&lt;li&gt;&lt;img src="images/2.jpg"alt=""&gt;&lt;/li&gt;&lt;li&gt;&lt;img src="images/3.jpg"alt=""&gt;&lt;/li&gt;&lt;li&gt;&lt;img src="images/4.jpg"alt=""&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//1.获取元素//1-1 获取到ul (通过id获取，就是只获取了一个对象)varulObj=document.getElementById('baidu');//1-2 通过ul对象，找ul中的imgvarimgs=ulObj.getElementsByTagName('img')//console.log(imgs);//2.循环imgsfor(vari=0;i&lt;imgs.length;i++){//给每一个都注册事件imgs[i].onclick=function(){//console.log(this.src);document.body.style.backgroundImage='url('+this.src+')'}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;案例二：隔行变色&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;03隔行变色&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}table{width:800px;margin:100px auto;text-align:center;border-collapse:collapse;font-size:14px;}thead tr{height:30px;background-color:skyblue;}tbody tr{height:30px;}tbody tr td{border-bottom:1px solid #d7d7d7;font-size:12px;color:blue;}.bg{background-color:#999;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table id="mytable"&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;代码&lt;/th&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;最近公布净产值&lt;/th&gt;&lt;th&gt;净产值增长率&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0121213&lt;/td&gt;&lt;td&gt;农银金穗3个月订气开放债券&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;td&gt;1.09&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script&gt;//1.获取到所有的tr（每一个tr就是一行）varmytable=document.getElementById('mytable');vartrs=mytable.getElementsByTagName('tr');//console.log(trs);//2.遍历trfor(vari=0;i&lt;trs.length;i++){//隔行变色// if(i != 0 &amp;&amp; i % 2 ==0){ //偶数//     trs[i].style.backgroundColor ='pink'// }if(i==0){continue}//鼠标放在tr上，有一个背景颜色,给每个tr都注册一个鼠标放上去的事件trs[i].onmouseover=function(){this.className='bg';}//鼠标移开，移除背景样式trs[i].onmouseout=function(){this.className=''}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;案例三：全选全不选&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;04全选和全部选&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}.wrap{width:300px;margin:100px auto;}table{border-spacing:0;border:1px solid #c0c0c0;}th,td{border:1px solid #d0d0d0;color:#404040;padding:10px;}th{background-color:#09c;font:bold16px"微软雅黑";color:#fff;}td{font:14px"微软雅黑";}tbody tr{background-color:#f0f0f0;}tbody tr:hover{cursor:pointer;background-color:#fafafa;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;tableclass="wrap"&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;input type="checkbox"id="j_chAll"/&gt;&lt;/th&gt;&lt;th&gt;商品&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;Iphone16&lt;/td&gt;&lt;td&gt;8000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;华为mate70&lt;/td&gt;&lt;td&gt;9000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;小米17&lt;/td&gt;&lt;td&gt;5000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;vivo&lt;/td&gt;&lt;td&gt;4000&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script&gt;//1.获取元素//1-1 全选复选框varall=document.getElementById('j_chAll');//1-2 所有的其它复选框varothers=document.getElementsByClassName('other');//通过复选框对象.checked可以获取到复选框的状态，true是勾选状态，false取消勾选的状态//通过复选框对象.checked = true/false 可以设置复选框的状态//给全选和全部选复选框注册点击事件all.onclick=function(){varflag=all.checked;//复选框的状态console.log(flag);//2.遍历所有的其它复选框for(vari=0;i&lt;others.length;i++){others[i].checked=flag;//设置复选框的状态}}// //看看all复选框，点击的时候发生了什么// var flag = all.checked;// console.log(flag);// all.onclick = function(){//     var flag = all.checked;//     console.log(flag);// }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;升级&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;05全选和全部选升级&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}.wrap{width:300px;margin:100px auto;}table{border-spacing:0;border:1px solid #c0c0c0;}th,td{border:1px solid #d0d0d0;color:#404040;padding:10px;}th{background-color:#09c;font:bold16px"微软雅黑";color:#fff;}td{font:14px"微软雅黑";}tbody tr{background-color:#f0f0f0;}tbody tr:hover{cursor:pointer;background-color:#fafafa;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;tableclass="wrap"&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;input type="checkbox"id="j_chAll"/&gt;&lt;/th&gt;&lt;th&gt;商品&lt;/th&gt;&lt;th&gt;价格&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;Iphone16&lt;/td&gt;&lt;td&gt;8000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;华为mate70&lt;/td&gt;&lt;td&gt;9000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;小米17&lt;/td&gt;&lt;td&gt;5000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="checkbox"class="other"/&gt;&lt;/td&gt;&lt;td&gt;vivo&lt;/td&gt;&lt;td&gt;4000&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script&gt;//1.获取元素//1-1 全选复选框varall=document.getElementById('j_chAll');//1-2 所有的其它复选框varothers=document.getElementsByClassName('other');//通过复选框对象.checked可以获取到复选框的状态，true是勾选状态，false取消勾选的状态//通过复选框对象.checked = true/false 可以设置复选框的状态//给全选和全部选复选框注册点击事件all.onclick=function(){varflag=all.checked;//复选框的状态console.log(flag);//2.遍历所有的其它复选框for(vari=0;i&lt;others.length;i++){others[i].checked=flag;//设置复选框的状态}}//2.遍历所有的其它复选框for(vari=0;i&lt;others.length;i++){others[i].onclick=function(){varch=checkCheckbox(others);//会返回一个truefalse//console.log(ch);all.checked=ch;//给全选或全部选复选框设置值}}//检查其它的复选框的状态，如果全选就返回true，只要有一个不选就返回falsefunctioncheckCheckbox(chks){varch=true;// 遍历for(vari=0;i&lt;chks.length;i++){//检查每一个的状态if(chks[i].checked==false){ch=false;break}}returnch;}// //看看all复选框，点击的时候发生了什么// var flag = all.checked;// console.log(flag);// all.onclick = function(){//     var flag = all.checked;//     console.log(flag);// }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;二、自定义属性操作1.获取属性值有两种方式：element.属性，就可以获取到该元素属性的值element.getAttribute(‘属性’)区别：element.属性， 获取内置属性值 （元素本身自带的属性）element.getAttribute(‘属性’)；主要是获取自定义属性（我们程序自定义的属性）2.设置属性的值有两种方式：element.属性 = 值element.setAttribute(‘属性名’,'属性值);区别：element.属性 = 值 设置内置属性的值element.setAttribute(‘属性名’,'属性值);主要设置自定义属性的值3.移除属性element.removeAttribute(‘属性’);4.案例案例一：讲课案例&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;06.获取属性值&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="demo"index="1"class="nav"&gt;123&lt;/div&gt;&lt;script&gt;//1.获取到div对象。根据id获取是获取到一个对象vardiv=document.getElementById('demo');console.log(div.id);//获取div对象中id属性的值console.log(div.getAttribute('id'));//获取div这个对象中id这个属性的值console.log(div.index);//***获取失败，对象.属性名只能获取本身自有属性，不能获取自定义属性console.log(div.getAttribute('index'));//获取div这个对象中index这个属性的值//2.设置对象的属性值值//2-1 element.属性 = '值'div.id='test'console.log(div.id);div.className='navs'console.log(div.className);//2-2 element.setAttribute('属性名','值').主要针对的是自定义属性div.setAttribute('index',222)console.log(div.getAttribute('index'));div.setAttribute('class','abded')console.log(div.className);//3.移除自定义属性    removeAttribute('属性名')div.removeAttribute('index')div.removeAttribute('class');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;案例二：tab栏&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;07tab&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}ul li{list-style:none;}.tab{width:978px;margin:100px auto;}.tab_list{height:39px;border:1px solid #ccc;background-color:#f1f1f1;}.tab_list li{float:left;height:39px;line-height:39px;padding:0px20px;text-align:center;cursor:pointer;}.tab_list.current{background-color:#c81623;color:#fff;}.item{display:none;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;divclass="tab"&gt;&lt;divclass="tab_list"id="tab_list"&gt;&lt;ul&gt;&lt;liclass="current"&gt;商品介绍&lt;/li&gt;&lt;li&gt;规格与包装&lt;/li&gt;&lt;li&gt;售后保障&lt;/li&gt;&lt;li&gt;商品评价（50000）&lt;/li&gt;&lt;li&gt;手机社区&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;divclass="tab_con"&gt;&lt;divclass="item"style="display: block;"&gt;商品介绍模块&lt;/div&gt;&lt;divclass="item"&gt;规格与包装模块内容&lt;/div&gt;&lt;divclass="item"&gt;售后保障内容：京东商城向您保证所售商品均为正品行货，京东自营商品开具机打发票或电子发票。&lt;/div&gt;&lt;divclass="item"&gt;手机收到了。特别特别棒，货比三家才买的，店主人很好，回答问题很有耐心，也很详细，有需要还会再来的&lt;/div&gt;&lt;divclass="item"&gt;手机社区：心中疑惑就问问买过此商品的同学吧~我要提问&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;//1.获取元素vartab_list=document.getElementById('tab_list');varlis=tab_list.getElementsByTagName('li');varitems=document.getElementsByClassName('item');//console.log(lis);//2.利用for循环给li绑定点击事件for(vari=0;i&lt;lis.length;i++){//给每个li设置一个索引号lis[i].setAttribute('index',i);//注册事件lis[i].onclick=function(){//2-1 li点击有红色样式//其它要干掉for(varj=0;j&lt;lis.length;j++){lis[j].className='';}//给当前点击的红色样式this.className='current'//2-2 点击li下面显示的内容模块变化varindex=this.getAttribute('index');console.log(index);//其它的要隐藏for(vark=0;k&lt;items.length;k++){items[k].style.display='none'}items[index].style.display='block'}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;5.H5自定义属性自定义属性目的：是为了保存并使用数据。有些数据可以保存在页面中而不用保存在数据库中自定义一属性获取是通过getAttribute(‘属性名’) 获取但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。h5给我们新增了自定义属性设置自定义属性h5规定自定义属性data-开头作为属性名并赋值如：设置：element.setAttribute(‘data-index’,1);获取自定义属性兼容属性获取：element.getAttribute(‘data-index’);h5新增了获取方式：element.dataset.index 或者 element.dataset(‘index’)&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;08.H5自定义属性&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="my"getTime="20"data-index="2"data-list-name="admin"&gt;&lt;/div&gt;&lt;script&gt;//1.获取元素vardiv=document.getElementById('my');console.log(div.getAttribute('getTime'));//设置一个h5属性div.setAttribute('data-time',20);console.log(div.getAttribute('data-time'));//h5新增的自定义属性的方法(  只能是data-  开头)//dataset：是一个集合里面存放了所有以data开头的自定义属性console.log(div.dataset);console.log(div.dataset.index);//2console.log(div.dataset['index']);//2//如果自定义属性里面有多个链接的单词，我们获得时候采用驼峰写法console.log(div.dataset.listName);console.log(div.dataset['listName']);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;三、节点操作1.节点概述节点：网页中所有的内容都是节点 （标签、属性、文本、注释等等），在DOM中，节点使用node表示html DOM 树种所有的节点都可以通过javaScript来进行访问，所有的HTML元素（节点）均可被修改，也可以创建或删除一般地：节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;09节点概述&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;ul&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;/ul&gt;&lt;div id="box"&gt;&lt;spanclass="erweima"&gt;我是二维码&lt;/span&gt;&lt;/div&gt;&lt;script&gt;varbox=document.getElementById('box');console.dir(box);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;元素节点 nodeType 为 1元素节点 nodeType 为 2元素节点 nodeType 为 3 (文本节点内包含文字、空格、换行等等)我们实际开发种，节点操作主要是操作元素节点2.父节点node.parentNode属性可以返回某节点的父节点，注意是最近的一个父节点如果指定的节点没有父节点，返回null&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;10父节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;ul&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;/ul&gt;&lt;div id="box"&gt;&lt;spanclass="erweima"id="erweima"&gt;我是二维码&lt;/span&gt;&lt;/div&gt;&lt;script&gt;//获取到二维码对象varerweima=document.getElementById('erweima');//node.parentNode 得到的是离元素最近的父节点，如果找不到父节点就返回nullconsole.dir(erweima.parentNode);//div#box&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.子节点所有的子节点：​ parentNode.childNodes​ 返回的是包含指定节点的子节点的集合，该集合即时更新的集合**注意：**返回值里面包含了所有的子节点，包括元素节点、文本节点等如果只需要获取到里面的元素节点，则需要专门的处理，所以我们一般不提倡使用childNodesparentNode.children是一个只读属性，返回的是所有的子元素节点，它只返回子元素节点，其它节点不返回（终点掌握这个）&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;11子节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;ul id="ul"&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;li&gt;我是li&lt;/li&gt;&lt;/ul&gt;&lt;div id="box"&gt;&lt;spanclass="erweima"id="erweima"&gt;我是二维码&lt;/span&gt;&lt;/div&gt;&lt;script&gt;//获取ulvarul=document.getElementById('ul');//获取ul中所有的li//var lis = ul.getElementsByTagName('li');varlis=ul.childrenconsole.log(lis);//1.字节点console.log(ul.childNodes);console.log(ul.childNodes[0].nodeType);//3console.log(ul.childNodes[1].nodeType);//1console.log(ul.children);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.1 获取子节点第一个节点和最后一个parentNode.firstNode ;返回第一个子节点，找不到就返回null，通过也页包含所有的节点parentNode.firstElementNode: 返回一个子元素节点，找不到就是nullparentNode.lastChild :最后一个子节点parentNode.lastElementChild: 返回最后一个子元素节点，找不到就是null&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;13.新浪下拉菜单&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}li{list-style:none;}a{text-decoration:none;font-size:14px;}#nav{margin:100px;}#nav&gt;li{position:relative;float:left;width:80px;height:40px;text-align:center;}#nav li a{display:block;width:100%;height:100%;line-height:40px;color:#333;}#nav ul{display:none;}#nav&gt;li&gt;a:hover{background-color:#eee;}#nav ul li a:hover{background-color:#fff5da;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="nav"&gt;&lt;li&gt;&lt;a href="#"&gt;微博&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;微博&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;微博&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;微博&lt;/a&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="#"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//1.获取元素varnav=document.getElementById('nav');//2.获取livarlis=nav.children;console.log(lis);//3.循环注册事件for(vari=0;i&lt;lis.length;i++){lis[i].onmouseover=function(){//this.children[1] 表示当前这个li种的ulthis.children[1].style.display='block'}lis[i].onmouseout=function(){this.children[1].style.display='none'}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;3.2 兄弟节点下一个兄弟 : nextElementSibling上一个兄弟 : previousElementSibling&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;我是h2&lt;/h2&gt;&lt;div id="div"&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;script&gt;vardiv=document.getElementById('div');//1.nextSibling   下一个兄弟节点，包含了元素节点或者是文本节点等等  (了解)console.log(div.nextSibling);//下一个console.log(div.previousSibling);//上一个//2.nextElementSibling 下一个兄弟  previousElementSibling 上一个兄弟  [掌握]div.nextElementSibling.style.backgroundColor='pink'console.log(div.nextElementSibling);//下一个console.log(div.previousElementSibling);//上一个div.previousElementSibling.style.backgroundColor='red'&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;4.创建添加节点创建节点：docuemnt.createElement(tagName’);java添加节点：node.appendChild(child);&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id="ul"&gt;&lt;li&gt;123&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//1.创建节点varli=document.createElement('li');//2.添加节点到父节点varul=document.getElementById('ul');//加入到父节点里子元素的最后ul.appendChild(li);//ul.children[1].innerHTML = '456'//添加节点varli2=document.createElement('li');//用insertBefore(参数一是创建的新元素，参数二添加的位置)ul.insertBefore(li2,ul.children[0]);//将新的节点，加入到ul的第一个孩子的位置console.log(li);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;5.案例发布留言&lt;!DOCTYPEhtml&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;meta name="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;16.留言板&lt;/title&gt;&lt;style&gt;*{margin:0;padding:0;}body{padding:100px;}textarea{width:200px;height:100px;border:1px solid pink;outline:none;resize:none;/*不让修改大小*/}ul{width:300px;padding:5px;background-color:rgb(245,209,243);color:#fff;font-size:14px;margin:15px0;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea name=""id="comment"&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;button id="btn"&gt;发布&lt;/button&gt;&lt;ul id="ul"&gt;&lt;/ul&gt;&lt;script&gt;//1.获取元素varbtn=document.getElementById('btn');varcomment=document.getElementById('comment');varul=document.getElementById('ul');//2.注册事件btn.onclick=function(){//判断是否有输入内容if(comment.value==''){alert('请输入内容');returnfalse;}else{//2-1 创建元素varli=document.createElement('li');//设置内容li.innerHTML=comment.value//2-2 添加元素//ul.appendChild(li); //添加到后面ul.insertBefore(li,ul.children[0]);//添加完成后清除输入框种的内容comment.value=''}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;http://www.ppmy.cn/news/1540664.html相关文章Debian12离线部署docker详细教程1、转至  https://download.docker.com/linux/debian/dists/ 
2、在列表中选择您的 Debian 版本。 
cat /etc/os-release
# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构&amp;#xff08;amd64、 armhf、arm64或s390x&amp;#xff09; 
4、在deb网址下&amp;#xff0c;下载Doc…阅读更多...知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:34 +0000</pubDate>
    </item>
    <item>
      <title>Debian12离线部署docker详细教程</title>
      <link>https://www.ppmy.cn/news/1540663.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Debian12离线部署docker详细教程news/2025/10/31 21:29:32/1、转至  https://download.docker.com/linux/debian/dists/2、在列表中选择您的 Debian 版本。cat/etc/os-release# 我的版本号是bookworm3、转到pool/stable/并选择适用的架构（amd64、 armhf、arm64或s390x）4、在deb网址下，下载Docker Engine、CLI、containerd 和 Docker Compose 软件包的以下文件：containerd.io_1.6.26-1_amd64.deb
docker-ce_24.0.7-1~debian.12~bookworm_amd64.deb
docker-ce-cli_24.0.7-1~debian.12~bookworm_amd64.deb
docker-buildx-plugin_0.11.2-1~debian.12~bookworm_amd64.deb docker-compose-plugin_2.21.0-1~debian.12~bookworm_amd64.deb5、安装.deb软件包。将以下示例中的路径更新为您下载 Docker 软件包的位置。安装命令如下：sudodpkg -i   containerd.io_1.6.26-1_amd64.deb  docker-ce_24.0.7-1~debian.12~bookworm_amd64.deb docker-ce-cli_24.0.7-1~debian.12~bookworm_amd64.deb docker-buildx-plugin_0.11.2-1~debian.12~bookworm_amd64.deb docker-compose-plugin_2.21.0-1~debian.12~bookworm_amd64.deb文章参考：https://docs.docker.com/engine/install/debian/#install-from-a-packagehttp://www.ppmy.cn/news/1540663.html相关文章知识点：代理设计模式1.场景设定和问题复现 1 准备项目 pom.xml &lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependen…阅读更多...兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:32 +0000</pubDate>
    </item>
    <item>
      <title>知识点：代理设计模式</title>
      <link>https://www.ppmy.cn/news/1540662.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维知识点：代理设计模式news/2025/10/31 21:29:31/1.场景设定和问题复现1准备项目pom.xml&lt;dependency&gt;&lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;&lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;&lt;version&gt;5.3.1&lt;/version&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;2.声明功能接口/***功能接口*/public interfaceGongNeng{//吃饭voidchifan();//谈小目标voidtanxiaomb();}3.声明老总目标类实现功能接口/***老总:目标对象类，实现功能接口*/public classLaoZongimplementsGongNeng{@Overridepublic voidchifan() {//核心功能System.out.println("老总吃饭...");}@Overridepublic voidtanxiaomb() {//核心功能System.out.println("老总谈一个亿的小目标...");}}4.声明带预约和联系方式附加功能实现新需求： 需要在每个方法中，添加控制台输出，输出预约和输出留个联系方式，方便下次联系！/***老总:目标对象类*需要在每个方法中，添加控制台输出，输出预约和输出留个联系方式，方便下次联系！*/public classLaoZongimplementsGongNeng{@Overridepublic voidchifan() {System.out.println("预约....");//核心功能System.out.println("老总吃饭...");System.out.println("留个联系方式，方便下次联系....");}@Overridepublic voidtanxiaomb() {System.out.println("预约....");//核心功能System.out.println("老总谈一个亿的小目标...");System.out.println("留个联系方式，方便下次联系....");}}5.代码问题分析1. 代码缺陷- 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力- 附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！2. 解决思路核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。将重复的代码统一提取，并且[[动态插入]]到每个业务方法！3. 技术困难解决问题的困难：提取重复附加功能代码到一个类中，可以实现但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！6.解决技术代理模式1. 代理模式二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。2. 无代理场景3. 有代理场景4. 生活中的代理- 广告商找大明星拍广告需要经过经纪人- 合作伙伴找大老板谈合作要约见面时间需要经过秘书- 房产中介是买卖双方的代理- 太监是大臣和皇上之间的代理5. 相关术语- 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)动词：指做代理这个动作，或这项工作名词：扮演代理这个角色的类、对象、方法- 目标：**被代理**“套用”了核心逻辑代码的类、对象、方法。(房东)代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]6.静态代理实现1. 主动创建代理类/***秘书：静态代理类*/public classXiaoMiimplementsGongNeng{//将被代理的目标对象：老总LaoZonglaoZong;publicXiaoMi(LaoZonglaoZong) {this.laoZong= laoZong;}@Overridepublic voidchifan() {//附加功能由代理类中的代理方法来实现：核心业务前执行的操作System.out.println("预约....");//调用目标对象老总的吃饭方法laoZong.chifan();//附加功能由代理类中的代理方法来实现：核心业务后执行的操作System.out.println("留个联系方式，方便下次联系....");}@Overridepublic voidtanxiaomb() {//附加System.out.println("预约....");laoZong.tanxiaomb();//附加System.out.println("留个联系方式，方便下次联系....");}}测试代码@Testpublic voidtestStaticProxy(){//创建老总对象：马云LaoZong yunyun=newLaoZong();//创建云云的秘书XiaoMi xm=newXiaoMi(yunyun);//吃饭xm.chifan();System.out.println("--------------");xm.tanxiaomb();}静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。7.动态代理1. 动态代理技术分类动态代理是一种在运行时动态生成代理对象的技术。它是一种设计模式，用于在不修改原始对象的情况下，通过代理对象来间接访问原始对象，并在访问前后执行额外的操作。JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须实现接口！他会根据目标类的接口动态生成一个代理对象！代理对象和目对象有标相同的接口！（拜把子）cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）2.基于jdk代理技术实现1.声明功能接口/***功能接口*/public interfaceGongNeng{//吃饭voidchifan();//谈小目标voidtanxiaomb();}2.声明老总目标类实现功能接口/***老总:目标对象类，实现功能接口*/public classLaoZongimplementsGongNeng{@Overridepublic voidchifan() {//核心功能System.out.println("老总吃饭...");}@Overridepublic voidtanxiaomb() {//核心功能System.out.println("老总谈一个亿的小目标...");}}3.定义jdk动态代理工厂类，生成动态代理对象和目标对象实现同一个接口，并调用代理方法invoke/*** jdk动态代理工厂类，生成小秘动态代理对象*/public classJdkProxyHandlerimplementsInvocationHandler{//代理的目标对象LaoZonglaoZong;publicJdkProxyHandler(LaoZonglaoZong) {this.laoZong= laoZong;}/*** invoke()设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法* proxy：代理对象* method：代理对象需要实现的方法，即其中需要重写的方法* args：method所对应方法的参数*/@OverridepublicObjectinvoke(Objectproxy,Methodmethod,Object[] args)throwsThrowable{System.out.println("预约....");//调用目标对象的方法Object obj=method.invoke(laoZong,args);System.out.println("留下联系方式,方便下次联系....");returnobj;}}4. 测试代码/*** JDK动态代理*/@Testpublic voidtestJdkProxy(){//创建老总对象LaoZong yunyun=newLaoZong();/***创建代理对象，通过jdk动态代理生成代理对象的方法* Proxy.newProxyInstance()：创建一个代理实例*其中有三个参数：* 1、classLoader：加载动态生成的代理类的类加载器* 2、interfaces：目标对象实现的所有接口的class对象所组成的数组* 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法*/GongNeng xm=(GongNeng)Proxy.newProxyInstance(TestProxy.class.getClassLoader(),newClass[]{GongNeng.class},newJdkProxyHandler(yunyun));//通过代理对象调用目标对象的方法，从而扩展附加功能xm.chifan();System.out.println("--------------");xm.tanxiaomb();}3. 基于cglib代理技术，生成动态代理对象1.引入cglib坐标&lt;dependency&gt;&lt;groupId&gt;cglib&lt;/groupId&gt;&lt;artifactId&gt;cglib&lt;/artifactId&gt;&lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;2.定义目标对象的类 (不要实现接口)/***老总:目标对象类*/public classLaoZong{public voidchifan() {//核心功能System.out.println("老总吃饭...");}public voidtanxiaomb() {//核心功能System.out.println("老总谈一个亿的小目标...");}}3.定义cglib动态代理工厂类，生成动态代理对象,是目标对象的子类。并调用代理方法invoke/*** cglib动态代理工厂类，生成日志动态代理对象*/public classCglibInterceptorimplementsMethodInterceptor{/*** intercept设置代理对象实现目标对象方法的过程，即代理类中如何重写目标中的方法* o :目标对象* method：目标对象的方法* MethodProxy：代理对象的方法* objects：method所对应方法的参数*/@OverridepublicObjectintercept(Objecto,Methodmethod,Object[] objects,MethodProxymethodProxy)throwsThrowable{System.out.println("预约....");//调用目标对象的方法Object obj=methodProxy.invokeSuper(o,objects);System.out.println("留下联系方式,方便下次联系....");returnobj;}}3. 测试代码/*** Cglib动态代理*/@Testpublic voidtestCglibProxy(){//创建代理对象,是目标对象的子类Enhancer e=newEnhancer();//1.指定父类：目标对象e.setSuperclass(LaoZong.class);//2.指定callback，指定代理对象调用一个对象的代理方法e.setCallback(newCglibInterceptor());LaoZong xm=(LaoZong)e.create();//通过代理对象调用目标对象的方法，从而扩展附加功能xm.chifan();System.out.println("--------------");xm.tanxiaomb();}注意：运行时会出现异常，原因由于jdk8之后的版本的反射相关功能被限制，导致了异常。解决方案：编辑配置时手动添加两个参数实现jdk的兼容，选择开启不被允许的反射功能。--add-opens java.base/java.lang=ALL-UNNAMED8.代理总结**代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！**他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！需要自己编写代理工厂等！但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring AOP]框架，他会简化动态代理的实现！！！http://www.ppmy.cn/news/1540662.html相关文章兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展兰迪舍克曼&amp;#xff08;Randy Schekman&amp;#xff09;作为生命银行链&amp;#xff08;Life Bank Chain, LBC&amp;#xff09;的顾问参与其中&amp;#xff0c;这无疑是个令人兴奋的消息&amp;#xff01;他在生理医学和基因研究方面拥有深厚的专业知识&amp;#xff0c;必将对LBC的使命&amp;#xff0c;即安全…阅读更多...10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:31 +0000</pubDate>
    </item>
    <item>
      <title>兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展</title>
      <link>https://www.ppmy.cn/news/1540661.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维兰迪·舍克曼担任生命银行链（LBC）顾问，赋能基因数据区块链技术发展news/2025/10/31 21:29:29/兰迪·舍克曼（Randy Schekman）作为生命银行链（Life Bank Chain, LBC）的顾问参与其中，这无疑是个令人兴奋的消息！他在生理医学和基因研究方面拥有深厚的专业知识，必将对LBC的使命，即安全存储和协作基因及干细胞数据，提供重要支持。LBC与其既有使命X Genomics的关联也将积极推动他们在研究和创新方面的发展，目前LBC在这一领域发挥着重要作用。LBC是一个安全存储和协作基因及干细胞数据的平台，基于个人和机构节点的系统。该平台旨在构建可扩展的跨链服务，支持各种基因及干细胞区块链应用的功能和实现框架。LBC的CEO瑞安·克里斯（Ryan Chris）表示：“我们将专注于开发分析和利用基因及细胞数据的应用场景，通过此举，我们希望能够为人类生命科学的进步作出贡献，并通过区块链技术管理生物医学数据，同时计划对贡献个人给予奖励。”http://www.ppmy.cn/news/1540661.html相关文章10-14到10-16学习笔记mybatis-plus设置逻辑删除 
1.配置全局的逻辑删除规则&amp;#xff08;高版本可以省略&amp;#xff09; 2.配置逻辑删除的组件bean(高版本可以省略) 
3.给实体类的属性加上逻辑删除TableLogic注解 Element-ui的Dialog 对话框使用 
&lt;el-dialog :title"title" :visible.sync…阅读更多...FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:30 +0000</pubDate>
    </item>
    <item>
      <title>10-14到10-16学习笔记</title>
      <link>https://www.ppmy.cn/news/1540660.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维10-14到10-16学习笔记news/2025/10/31 21:29:28/mybatis-plus设置逻辑删除1.配置全局的逻辑删除规则（高版本可以省略）2.配置逻辑删除的组件bean(高版本可以省略)3.给实体类的属性加上逻辑删除@TableLogic注解Element-ui的Dialog 对话框使用&lt;el-dialog :title="title" :visible.sync="dialogVisible" width="30%"&gt;&lt;el-form :model="category"&gt;&lt;el-form-item label="分类名称"&gt;&lt;el-input v-model="category.name" autocomplete="off"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item label="图标"&gt;&lt;el-input v-model="category.icon" autocomplete="off"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item label="计量单位"&gt;&lt;el-input v-model="category.productUnit" autocomplete="off"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;/el-form&gt;&lt;div slot="footer" class="dialog-footer"&gt;&lt;el-button @click="dialogFormVisible = false"&gt;取 消&lt;/el-button&gt;&lt;el-button type="primary" @click="submitData"&gt;确 定&lt;/el-button&gt;&lt;/div&gt;&lt;/el-dialog&gt;基本用法要使用Dialog，首先确保已经引入 Element UI。在 Vue 组件中，使用以下基本结构&lt;template&gt;&lt;div&gt;&lt;el-button type="text" @click="dialogVisible = true"&gt;打开对话框&lt;/el-button&gt;&lt;el-dialogtitle="对话框标题":visible.sync="dialogVisible"@close="handleClose"&gt;&lt;p&gt;对话框内容&lt;/p&gt;&lt;span slot="footer" class="dialog-footer"&gt;&lt;el-button @click="dialogVisible = false"&gt;取 消&lt;/el-button&gt;&lt;el-button type="primary" @click="handleConfirm"&gt;确 定&lt;/el-button&gt;&lt;/span&gt;&lt;/el-dialog&gt;&lt;/div&gt;
&lt;/template&gt;&lt;script&gt;
export default {data() {return {dialogVisible: false, // 控制对话框显示};},methods: {handleClose() {console.log('对话框已关闭');},handleConfirm() {console.log('确认操作');this.dialogVisible = false; // 关闭对话框},},
};
&lt;/script&gt;主要属性title：对话框的标题。visible.sync：控制对话框的显示状态，使用.sync修饰符可以双向绑定。width：设置对话框的宽度，默认值为30%。modal：是否显示遮罩，默认值为true。close-on-click-modal：点击遮罩时是否关闭对话框，默认为true。事件@close：对话框关闭时触发。@open：对话框打开时触发。插槽slot="footer"：自定义对话框底部内容，常用于放置按钮。进阶用法在对话框中使用表单，可以如下实现：&lt;el-dialogtitle="填写信息":visible.sync="dialogVisible"
&gt;&lt;el-form :model="form"&gt;&lt;el-form-item label="姓名"&gt;&lt;el-input v-model="form.name"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;el-form-item label="邮箱"&gt;&lt;el-input v-model="form.email"&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;&lt;/el-form&gt;&lt;span slot="footer" class="dialog-footer"&gt;&lt;el-button @click="dialogVisible = false"&gt;取 消&lt;/el-button&gt;&lt;el-button type="primary" @click="handleSubmit"&gt;确 定&lt;/el-button&gt;&lt;/span&gt;
&lt;/el-dialog&gt;在data中添加表单模型：data() {return {dialogVisible: false,form: {name: '',email: '',},};
},http://www.ppmy.cn/news/1540660.html相关文章FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！SPI接口详解 
SPI&amp;#xff08;Serial Peripheral Interface&amp;#xff09;是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备&amp;#xff0c;如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点&amp;#xff1a; 
全双工通信&amp;#xff1a;支持同时发送和接收数…阅读更多...【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径读《代码大全2》读后感3revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:28 +0000</pubDate>
    </item>
    <item>
      <title>FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！</title>
      <link>https://www.ppmy.cn/news/1540659.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维FPGA实现SPI接口，用verilog实现，SPI接口使用例程！！！news/2025/10/31 21:29:27/SPI接口详解SPI（Serial Peripheral Interface）是一种高速、全双工、同步的通信总线。它常用于连接微控制器和各种外围设备，如EEPROM、FLASH、AD转换器等。SPI接口主要具有以下优点：全双工通信：支持同时发送和接收数据。高速传输：支持100MHz以上的数据传输速率。灵活的字长：可根据应用需求选择消息字长，不限于8位。简单的硬件连接：仅占用四根线（SCK、MOSI、MISO、SS/CS），节省芯片管脚和PCB空间。然而，SPI接口也存在一些缺点：无寻址机制：通过片选信号选择不同设备，无法像IIC那样通过地址选择。无从设备ACK：主设备无法确认发送的数据是否被从设备成功接收。单主控支持：典型应用中仅支持一个主设备。传输距离短：相比RS232、RS485和CAN总线，SPI的传输距离较短。SPI接口的信号定义如下：SCK（Serial Clock）：串行时钟信号，由主设备提供。MOSI（Master Output, Slave Input）：主设备发送，从设备接收的信号。MISO（Master Input, Slave Output）：主设备接收，从设备发送的信号。SS/CS（Slave Select/Chip Select）：片选信号，用于选择从设备。SPI的传输模式可以通过设置控制寄存器中的CPOL和CPHA位来配置：CPOL（Clock Polarity）：决定时钟空闲时的电平。CPOL=1时，时钟低电平有效；CPOL=0时，时钟高电平有效。CPHA（Clock Phase）：定义数据采样的时钟边沿。CPHA=1时，数据采样发生在时钟偶数边沿；CPHA=0时，数据采样发生在时钟奇数边沿。常见的SPI传输模式有四种：Mode 0（CPOL=0, CPHA=0）、Mode 1（CPOL=0, CPHA=1）、Mode 2（CPOL=1, CPHA=0）和Mode 3（CPOL=1, CPHA=1）。其中，Mode 0和Mode 3最为常见。SPI接口的Verilog实现以下是一个简单的SPI接口Verilog实现，包括发送和接收功能。该实现以Mode 0为例。module spi_master(  input clk,             // 系统时钟  input rst,             // 复位信号  input [23:0] data_out, // 要发送的数据  input wr_en,           // 写使能信号  output reg sck,        // 串行时钟信号  output reg mosi,       // 主设备输出/从设备输入信号  output reg csn,        // 片选信号  input [23:0] data_in   // 从设备发送的数据（仿真时使用）  
);  // 状态定义  
typedef enum logic [3:0] {  IDLE,  START,  SEND,  RECV,  STOP  
} state_t;  state_t state, next_state;  
reg [3:0] bit_cnt;        // 位计数器  
reg [23:0] shift_reg;     // 移位寄存器  // 状态转移逻辑  
always @(posedge clk or posedge rst) begin  if (rst) begin  state &lt;= IDLE;  end else begin  state &lt;= next_state;  end  
end  // 下一个状态逻辑  
always @(*) begin  case (state)  IDLE: begin  if (wr_en) begin  next_state = START;  end else begin  next_state = IDLE;  end  end  START: begin  next_state = SEND;  end  SEND: begin  if (bit_cnt == 4'd23) begin  next_state = RECV;  end else begin  next_state = SEND;  end  end  RECV: begin  next_state = STOP;  end  STOP: begin  next_state = IDLE;  end  default: begin  next_state = IDLE;  end  endcase  
end  // 时钟和片选信号生成  
always @(posedge clk or posedge rst) begin  if (rst) begin  sck &lt;= 0;  csn &lt;= 1;  end else begin  case (state)  IDLE, STOP: begin  sck &lt;= 0;  csn &lt;= 1;  end  START, SEND, RECV: begin  sck &lt;= ~sck; // 时钟翻转  if (state == START) begin  csn &lt;= 0; // 拉低片选信号  end  end  endcase  end  
end  // 数据发送和接收逻辑  
always @(posedge clk or posedge rst) begin  if (rst) begin  bit_cnt &lt;= 0;  shift_reg &lt;= 0;  end else begin  case (state)  IDLE: begin  shift_reg &lt;= data_out; // 加载要发送的数据  end  SEND: begin  if (bit_cnt &lt; 4'd23) begin  mosi &lt;= shift_reg[23]; // 发送最高位  shift_reg &lt;= {shift_reg[22:0], 1'b0}; // 左移一位，并补0  bit_cnt &lt;= bit_cnt + 1;  end  end  RECV: begin  // 在此处添加接收逻辑（仿真时使用data_in）  // 实际硬件中，MISO信号应由从设备提供  end  STOP: begin  // 可以在此处添加接收完成后的处理逻辑  end  endcase  end  
end  // 仿真时使用的接收数据寄存器（实际硬件中不需要）  
reg [23:0] recv_data;  
always @(posedge clk or posedge rst) begin  if (rst) begin  recv_data &lt;= 0;  end else if (state == STOP) begin  // 在此示例中，recv_data仅用于仿真，接收的数据通过data_in提供  // 实际硬件中，应根据MISO信号接收数据  recv_data &lt;= {23'b0, mosi}; // 示例：仅接收最后一位（不正确，仅用于说明）  // 注意：实际接收逻辑应基于完整的MISO信号时序  end  
end  endmodule注意：上述代码中的接收逻辑部分仅用于仿真示例，并不完整。在实际硬件中，接收逻辑应根据MISO信号的时序来编写。仿真Testbench代码以下是一个简单的Testbench代码，用于仿真上述SPI接口模块。module spi_master_tb;  // 输入信号  
reg clk;  
reg rst;  
reg [23:0] data_out;  
reg wr_en;  // 输出信号  
wire sck;  
wire mosi;  
wire csn;  
wire [23:0] recv_data; // 用于仿真接收的数据（实际硬件中不需要）  // 实例化SPI接口模块  
spi_master spi_inst(  .clk(clk),  .rst(rst),  .data_out(data_out),  .wr_en(wr_en),  .sck(sck),  .mosi(mosi), // 在仿真中，mosi信号由spi_master模块提供  .csn(csn),  .data_in(24'hABCDEF12) // 仿真时提供的接收数据  
);  // 时钟生成  
initial begin  clk = 0;  forever #5 clk = ~clk; // 100MHz时钟（5ns周期）  
end  // 仿真流程  
initial begin  // 初始化信号  rst = 1;  data_out = 0;  wr_en = 0;  // 等待一段时间以初始化  #20;  // 复位信号拉低  rst = 0;  // 发送数据  data_out = 24'h12345678;  wr_en = 1;  #100; // 等待发送完成  wr_en = 0;  // 等待一段时间以观察接收数据  #100;  // 打印接收数据（用于验证）  $display("Received data: %h", recv_data);  // 结束仿真  $finish;  
end  endmodulehttp://www.ppmy.cn/news/1540659.html相关文章【Java并发编程】线程池的四种拒绝策略（饱和策略）引入 
线程池的拒绝策略是当线程池出现以下情况时&amp;#xff0c;由于线程池达到其容量上限而无法接受新任务时的处理机制&amp;#xff1a; 
线程池已满&amp;#xff1a;当线程池中的所有线程都在执行任务时&amp;#xff0c;新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最…阅读更多...卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:27 +0000</pubDate>
    </item>
    <item>
      <title>【Java并发编程】线程池的四种拒绝策略（饱和策略）</title>
      <link>https://www.ppmy.cn/news/1540658.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Java并发编程】线程池的四种拒绝策略（饱和策略）news/2025/10/31 21:29:26/引入线程池的拒绝策略是当线程池出现以下情况时，由于线程池达到其容量上限而无法接受新任务时的处理机制：线程池已满：当线程池中的所有线程都在执行任务时，新提交的任务无法立即执行。这种情况发生在当前线程池的核心线程和最大线程数都已被占用时。任务队列已满：当线程池的任务队列（如LinkedBlockingQueue）已满，新的任务无法被放入队列中等待执行。在 Java 的并发包（java.util.concurrent）中，ThreadPoolExecutor提供了四种内置的线程池拒绝策略 （RejectedExecutionHandler）来应对线程池达到其容量限制时，采取适当的策略来处理这些额外的任务。四种内置拒绝策略适用场景如下，在挑选拒绝策略时需要根据具体的需求选择合适的策略：策略说明适用场景AbortPolicy抛出RejectedExecutionException任务执行必须完成，不能丢失任务的场景，如实时数据处理系统。CallerRunsPolicy调用execute()方法在调用线程中运行任务任务提交者自己执行任务，适用于负载较低时避免任务丢失的场景。DiscardPolicy忽略被拒绝的任务，不做任何处理任务丢失可以接受，优先处理重要任务的场景，如缓存更新。DiscardOldestPolicy丢弃队列中最旧的任务并尝试提交新任务需要保留最新任务，但可以丢弃较旧任务的场景，如短时间内的数据采集。线程池的四种拒绝策略1. AbortPolicy默认的拒绝策略。如果线程池和队列都满了，并且无法接受新任务时，AbortPolicy策略会直接终止任务提交并抛出RejectedExecutionException异常。newThreadPoolExecutor.AbortPolicy();使用这种策略时，调用者需要处理异常，确保程序不会因为任务被拒绝而崩溃。适用于任务提交者可以控制和处理异常的场景。示例：ThreadPoolExecutorexecutor=newThreadPoolExecutor(2,2,60,TimeUnit.SECONDS,newLinkedBlockingQueue&lt;&gt;(2),newThreadPoolExecutor.AbortPolicy());2. CallerRunsPolicy当任务被拒绝时，CallerRunsPolicy策略会由任务提交者线程来执行被拒绝的任务，而不是由线程池中的线程来执行。newThreadPoolExecutor.CallerRunsPolicy();这种策略可以减缓任务提交的速度，避免过度负荷线程池。适用于希望通过降低提交速率来缓解线程池压力的场景。示例：ThreadPoolExecutorexecutor=newThreadPoolExecutor(2,2,60,TimeUnit.SECONDS,newLinkedBlockingQueue&lt;&gt;(2),newThreadPoolExecutor.CallerRunsPolicy());3. DiscardPolicy当任务被拒绝时，DiscardPolicy策略会将被拒绝的任务丢弃，没有任何通知或异常抛出。newThreadPoolExecutor.DiscardPolicy();这种策略采取丢弃任务的方式可能会导致任务丢失，但有助于防止线程池崩溃或性能严重下降，适用于对丢弃任务没有特别要求的场景。示例：ThreadPoolExecutorexecutor=newThreadPoolExecutor(2,2,60,TimeUnit.MILLISECONDS,newLinkedBlockingQueue&lt;&gt;(2),newThreadPoolExecutor.DiscardPolicy());4. DiscardOldestPolicy如果线程池和队列都满了，DiscardOldestPolicy会丢弃任务队列中最旧的任务，然后尝试提交新的任务。newThreadPoolExecutor.DiscardOldestPolicy();这种策略可以确保新的任务被处理，但会丢弃最早的任务，可能会丢失一些重要任务。适用于希望保留最新任务的场景。示例：ThreadPoolExecutorexecutor=newThreadPoolExecutor(2,2,0L,TimeUnit.MILLISECONDS,newLinkedBlockingQueue&lt;&gt;(2),newThreadPoolExecutor.DiscardOldestPolicy());自定义拒绝策略除了内置的策略，我们可以通过实现自定义的RejectedExecutionHandler接口来创建自定义拒绝策略。publicclassCustomRejectedExecutionHandlerimplementsRejectedExecutionHandler{@OverridepublicvoidrejectedExecution(Runnabler,ThreadPoolExecutorexecutor){// 自定义处理逻辑，比如记录日志、重新排队等System.out.println("任务被拒绝: "+r.toString());}}例如，我们可以实现一个自定义的拒绝策略，当任务被拒绝时会尝试重试提交任务：publicclassRequeueRejectedExecutionHandlerimplementsRejectedExecutionHandler{@OverridepublicvoidrejectedExecution(Runnabler,ThreadPoolExecutorexecutor){// 将被拒绝的任务重新排队System.out.println("任务被拒绝，正在重新排队: "+r.toString());// 尝试将任务重新提交到线程池if(!executor.isShutdown()){try{Thread.sleep(1000);// 直接调用execute方法进行重新排队executor.execute(r);}catch(Exceptione){System.err.println("重新提交任务失败: "+e.getMessage());}}}}但是在实际应用中，我们应避免任务被无限重试，应该确保在达到最大重试次数后，任务能够被丢弃或者按照某种策略处理。http://www.ppmy.cn/news/1540658.html相关文章卷积神经网络（CNN）-Padding介绍在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。 
什么是填充 
Padding是一种技术，用于在对特征…阅读更多...C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:26 +0000</pubDate>
    </item>
    <item>
      <title>卷积神经网络（CNN）-Padding介绍</title>
      <link>https://www.ppmy.cn/news/1540657.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维卷积神经网络（CNN）-Padding介绍news/2025/10/31 21:29:25/在卷积过程中，输出特征图的大小由输入特征图的大小、内核的大小和步幅决定。如果我们简单地在输入特征图上应用内核，那么输出特征图将小于输入。这可能会导致输入特征图边界处的信息丢失。为了保留边框信息，我们使用padding。什么是填充Padding是一种技术，用于在对特征图进行卷积操作后保留输入图像的空间维度。Padding 涉及在卷积之前在输入特征图的边界周围添加额外的像素。可以通过两种方式完成：Valid Padding：在有效 padding 中，输入特征图没有添加 padding，并且输出特征图小于输入特征图。当我们想要减小特征图的空间维度时，这很有用。Same Padding：在相同的 padding：在相同的 padding 中，将 padding 添加到输入特征图中，使得输出特征图的大小与输入特征图的大小相同。当我们想要保留特征图的空间维度时，这很有用。要添加的像素数可以根据内核的大小和特征图大小的所需输出来计算。最常见的填充值是零填充，它涉及向输入特征图的边界添加零。Padding 有助于减少输入特http://www.ppmy.cn/news/1540657.html相关文章C++ 类的基础用法与详细说明：简单易懂的入门指南什么是类&amp;#xff1f; 
C类_百度百科 
类是C中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型&amp;#xff0c;它可以包含数据&amp;#xff08;成员变量&amp;#xff09;和操作这些数据的函数&amp;#xff08;成员函数&amp;#xff09;。 
创建一个简单的类 
让我们通过一个…阅读更多...【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:25 +0000</pubDate>
    </item>
    <item>
      <title>C++ 类的基础用法与详细说明：简单易懂的入门指南</title>
      <link>https://www.ppmy.cn/news/1540656.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C++ 类的基础用法与详细说明：简单易懂的入门指南news/2025/10/31 21:29:23/什么是类？C++类_百度百科类是C++中一种用于封装数据和功能的基本结构。你可以将类视为一种自定义的数据类型，它可以包含数据（成员变量）和操作这些数据的函数（成员函数）。创建一个简单的类让我们通过一个简单的例子来演示如何定义和使用一个类。我们将创建一个表示**“学生”**的类。1. 定义类首先，我们需要定义一个类。以下是一个名为Student的类的示例。#include &lt;iostream&gt;
#include &lt;string&gt;class Student {
public:// 成员变量std::string name; // 学生姓名int age;          // 学生年龄int id;           // 学生ID// 成员函数：设置学生信息void setInfo(std::string studentName, int studentAge, int studentId) {name = studentName; // 设置姓名age = studentAge;   // 设置年龄id = studentId;     // 设置ID}// 成员函数：打印学生信息void printInfo() {std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; ", ID: " &lt;&lt; id &lt;&lt; std::endl;}
};2. 类的结构解释class Student { ... };：这行代码定义了一个名为Student的类。public:：这是一个访问修饰符，表示后面定义的成员可以被类外部访问。成员变量：std::string name;：存储学生的姓名。int age;：存储学生的年龄。int id;：存储学生的ID。成员函数：void setInfo(...)：用于设置学生的姓名、年龄和ID。void printInfo()：用于打印学生的详细信息3. 创建对象接下来，我们需要使用这个类来创建对象。对象是类的实例。int main() {// 创建一个Student类的对象Student student1;// 设置学生信息student1.setInfo("Alice", 20, 1001);// 打印学生信息student1.printInfo();// 创建另一个Student类的对象Student student2;// 设置另一个学生的信息student2.setInfo("Bob", 22, 1002);// 打印另一个学生的信息student2.printInfo();return 0;
}4. 代码解释Student student1;：创建一个名为student1的对象，该对象是Student类的实例。student1.setInfo("Alice", 20, 1001);：调用setInfo函数来设置student1的姓名、年龄和ID。student1.printInfo();：调用printInfo函数来打印学生的信息。5.代码与输出结果C++输⼊&amp;&amp;输出&amp;&amp;换行_c++输出时换行-CSDN博客若不理解可查看using namespace std;
#include &lt;string&gt;class Student {
public:// 成员变量std::string name; // 学生姓名int age;          // 学生年龄int id;           // 学生ID// 成员函数：设置学生信息void setInfo(std::string studentName, int studentAge, int studentId) {name = studentName; // 设置姓名age = studentAge;   // 设置年龄id = studentId;     // 设置ID}// 成员函数：打印学生信息void printInfo() {std::cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; ", ID: " &lt;&lt; id &lt;&lt; std::endl;}
};int main() {// 创建一个Student类的对象Student student1;// 设置学生信息student1.setInfo("Alice", 20, 1001);// 打印学生信息student1.printInfo();// 创建另一个Student类的对象Student student2;// 设置另一个学生的信息student2.setInfo("Bob", 22, 1002);// 打印另一个学生的信息student2.printInfo();return 0;
}总结类是数据和功能的封装。成员变量是类中存储数据的变量。成员函数是类中定义的可以对数据进行操作的函数。对象是类的实例，你可以创建多个对象来使用同一个类。共勉 💪同为未来的it人让我们在共同进步吧。我很喜欢雷军的一段话：我们就悄悄的干，就算失败了咱也不丢人。http://www.ppmy.cn/news/1540656.html相关文章【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！文章目录 起因二、得记住的知识点1. make()切片&amp;#xff0c;初始化了吗&amp;#xff1f;2. make()切片不同长度容量&amp;#xff0c;append时的差别3. 切片是指向数组的指针吗&amp;#xff1f;4. 切片扩容时&amp;#xff0c;重新分配内存&amp;#xff0c;原切片的数据怎么办&amp;#xff1f; 三、咳咳&amp;a…阅读更多...CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:24 +0000</pubDate>
    </item>
    <item>
      <title>【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！</title>
      <link>https://www.ppmy.cn/news/1540655.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Golang】踩坑记录：make()创建引用类型，初始值是不是nil！！news/2025/10/31 21:29:22/文章目录起因二、得记住的知识点1. make()切片，初始化了吗？2. make()切片不同长度容量，append时的差别3. 切片是指向数组的指针吗？4. 切片扩容时，重新分配内存，原切片的数据怎么办？三、咳咳，总结一下起因序列化的时候居然给我空指针报错，哪nil啦？？？猛一顿查，查到了创建的结构体数组事情是这样的(举例啊）：有一个结构体AtypeAstruct{firint32sec[]int32}还有另一个结构体BtypeBstruct{a[]*A}然后我判断B.a是否为nil，若为nil就为a创建切片分配内存，并且为切片赋值上默认值，如此不就规避nil异常了嘛ifB.a==nil{B.a=make([]*A,5,5)}后面我就直接调用了，然后就出现了开头说的报错。怎么样，你们能看出来是什么问题吗？先说答案：\qquad因为a 是一个长度为 5 的 *A（指向 A的指针）切片。由于使用 make 函数创建了这个切片，并且没有对其进行初始化，因为它们是指针类型的切片元素，但没有被分配实际的 A 实例，所以每个元素的初始值是 nil。在这个过程中，我逐渐理清了make创建过程，以及各种引用类型的创建之后的值，来记录一下咯二、得记住的知识点1. make()切片，初始化了吗？在 Go 中，使用 make() 函数创建切片时，切片本身是被初始化的，但切片中的元素可能没有被初始化为非零值。具体来说：make([]T, length, capacity)创建了一个类型为 []T 的切片，长度为 length，容量为 capacity。切片本身是一个引用类型，make()会为切片分配底层数组的内存，并返回一个指向该数组的切片。切片中的每个元素会被初始化为其类型的零值。例如：a:=make([]int,5)// 创建一个长度为5的int切片在这个例子中，a是一个长度为 5 的int切片，其中每个元素都被初始化为 0，因为int类型的零值是 0。如果你创建一个指针类型的切片：b:=make([]*MyStruct,5)// 创建一个长度为5的*MyStruct切片在这个例子中，b是一个长度为 5 的*MyStruct切片，其中每个元素都被初始化为nil，因为指针类型的零值是nil。在Go中，使用make()函数创建的结果总是初始化的，但初始化的内容取决于类型：切片：make([]T, length, capacity)创建的切片本身是初始化的，切片中的每个元素被初始化为其类型的零值。如果 T 是指针类型，那么这些元素会是 nil。映射：make(map[K]V)创建的映射是初始化的，但映射中的键值对需要显式添加。通道：make(chan T)创建的通道是初始化的，可以立即使用。2. make()切片不同长度容量，append时的差别make([]int,0,5)make([]int,0)make([]int,5,5)这三个切片在append时的差别:Go中，make([]int, length, capacity)用于创建切片，length是切片的初始长度，capacity是切片的容量。append操作会根据切片的容量来决定是否需要分配新的内存。以下是这三个切片在 append 操作时的差别：make([]int, 0, 5)：创建一个长度为 0，容量为 5 的切片。可以在不分配新内存的情况下 append 最多 5 个元素。当 append 超过 5 个元素时，底层数组会自动扩容，分配新的内存，切片指向新数组。make([]int, 0)：创建一个长度为 0，容量为 0 的切片。任何 append 操作都会导致切片扩容，因为初始容量为 0。每次 append 操作可能会导致内存重新分配，底层数组会自动扩容，分配新的内存，切片指向新数组。make([]int, 5, 5)：创建一个长度为 5，容量为 5 的切片。切片初始时已经有 5 个元素，全部被初始化为零值。可以直接访问和修改这 5 个元素。append 操作会从第 6 个元素开始，底层数组会自动扩容，分配新的内存，切片指向新数组。3. 切片是指向数组的指针吗？切片并不是直接指向数组的指针，但它确实包含了一个指向底层数组的指针。在 Go 中，切片的底层结构可以用一个结构体来表示，尽管在实际实现中它是由编译器处理的。切片的结构通常包含以下三个字段：指针（Pointer）：指向底层数组的起始位置。长度（Length）：切片中元素的数量。容量（Capacity）：从切片的起始位置到底层数组末尾的元素数量。这种设计使得切片可以灵活地表示数组的一部分，并且可以动态调整大小。切片的这种结构使得它们在内存管理和性能上都非常高效。typeSliceHeaderstruct{Datauintptr// 底层数组的指针Lenint// 切片的长度Capint// 切片的容量}在实际使用中，切片是一个引用类型，SliceHeader是一个抽象的表示，帮助理解切片的工作原理。切片的操作（如append、copy等）会根据这些字段来管理内存和数据。需要注意的是，SliceHeader是一个概念上的结构，Go 语言中并没有直接暴露这个结构给用户。切片的实际实现和管理是由Go 运行时负责的。4. 切片扩容时，重新分配内存，原切片的数据怎么办？在Go中，当切片需要扩容时，会进行以下操作：分配新内存：Go会分配一个更大的底层数组，以容纳更多的元素。新数组的容量通常是现有容量的两倍，但具体增长策略可能会根据实现有所不同。复制数据：现有切片的数据会被复制到新分配的数组中。这是一个浅拷贝操作，意味着只复制数据本身，而不是数据的引用。更新切片：切片的内部指针会更新为指向新数组的起始位置，长度和容量也会相应更新。原切片的数据在扩容后仍然保持不变，且新切片会包含原切片的数据。旧的底层数组会被垃圾回收机制回收（如果没有其他引用指向它）。例如：s:=make([]int,2,2)s[0]=1s[1]=2s=append(s,3)// 触发扩容在这个例子中，s的初始容量是 2。当append第三个元素时，Go 会分配一个新的数组（容量可能为 4），将原来的数据 [1, 2] 复制到新数组中，然后将 3 添加到新数组中。s的指针会更新为指向新数组。三、咳咳，总结一下创建切片时的内存分配：使用make([]T, length, capacity)创建切片时，会根据指定的容量分配底层数组的内存。即使容量为 0，make仍然会创建一个切片结构，但底层数组的内存不会被分配，因为没有元素需要存储。发散问题：“容量为 0，make 仍然会创建一个切片结构，只是没有分配底层数组的内存。”意思是 切片指向数组的指针为nil?\qquad在Go中，当你使用make([]T, 0)创建一个切片时，切片的内部结构确实被初始化，但它的底层数组指针并不是nil。相反，它指向一个特殊的、零长度的数组。具体来说：切片的长度和容量都是 0。切片的底层数组指针指向一个零长度的数组，而不是 nil。"切片的底层数组指针指向一个零长度的数组，而不是 nil"如何做到？这是Go 语言设计的一部分，确保切片即使在容量为 0 时也能安全地使用。零长度数组：Go 运行时会为切片分配一个零长度的数组。这是一个特殊的内存区域，专门用于处理这种情况。这个数组的地址是有效的，但它不占用实际的内存空间，因为没有元素需要存储。切片结构：切片的内部结构（如 SliceHeader）会被初始化，指针字段指向这个零长度数组。长度和容量字段都设置为 0。安全性：这种设计确保了即使切片的容量为 0，切片的指针字段仍然是一个有效的地址。这意味着你可以安全地对切片进行操作（如 append），而不会导致空指针异常。扩容机制：当你对一个容量为 0 的切片进行 append 操作时，Go 会自动分配一个新的底层数组，并将数据复制到新数组中。切片的指针、长度和容量会相应更新。元素初始化：底层数组的元素会被初始化为其类型的零值。对于指针类型的切片，元素的零值是nil。扩容时的行为：当切片需要扩容时，Go 会分配一个更大的底层数组。原数组的元素会被复制到新数组中，这个过程是浅拷贝。切片的内部指针会更新为指向新数组，长度和容量也会相应更新。http://www.ppmy.cn/news/1540655.html相关文章CLion和Qt 联合开发环境配置教程（Windows和Linux版）需要安装的工具CLion 和Qt 
CLion下载链接 :https://www.jetbrains.com.cn/clion/ 这个软件属于直接默认安装就行&amp;#xff0c;很简单&amp;#xff0c;不多做介绍了 
Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/ 
window 直接点exe Linux 先c…阅读更多...http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:22 +0000</pubDate>
    </item>
    <item>
      <title>CLion和Qt 联合开发环境配置教程（Windows和Linux版）</title>
      <link>https://www.ppmy.cn/news/1540654.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维CLion和Qt 联合开发环境配置教程（Windows和Linux版）news/2025/10/31 21:29:21/需要安装的工具CLion 和QtCLion下载链接 :https://www.jetbrains.com.cn/clion/这个软件属于直接默认安装就行，很简单，不多做介绍了Qt:https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/window 直接点exeLinux 先chmod +x xxxx.run赋予可执行权限，然后./xxx.run运行安装，另外ubuntu需要执行sudo apt install libglx-dev libgl1-mesa-dev项目创建Windows(标红的地方注意一下)Linux(标红的地方注意一下）项目运行正常创建完是可以直接运行的。如下图所示：Qt Designer 和Qt UIC 配置注：windows需要配置Qt Designer ， Qt UIC ,Linux 只需要配置 Qt DesignerFile-&gt; settings -&gt; External ToolsQt Designer 配置，标红的地方改成自己的路径Qt UIC 配置，标红的地方改成自己的路径http://www.ppmy.cn/news/1540654.html相关文章http大数据post与put请求大数据请求情况下出现post请求提交出错而put请求提交不出错 
一、http方法特性差异 
1、请求语义和用途不同 post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下&amp;#xff0c;服务器可能对put请求的处理更加…阅读更多...大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:21 +0000</pubDate>
    </item>
    <item>
      <title>http大数据post与put请求</title>
      <link>https://www.ppmy.cn/news/1540653.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维http大数据post与put请求news/2025/10/31 21:29:19/大数据请求情况下出现post请求提交出错而put请求提交不出错一、http方法特性差异1、请求语义和用途不同post通常用于 创建新资源Put一般用于更新现有资源服务器对于不同的HTTP方法可能有不同的处理逻辑和优化策略。在某些情况下，服务器可能对put请求的处理更加高效，尤其是在处理大数据量的更新操作时。2、缓存行为差异浏览器和中间服务器通常对post请求的响应进行较少的缓存，因为post请求通常会改变服务器的状态，其结果不具有可重复性。而put请求在某些情况下可能被缓存，具体取决于缓存策略的设置。如果在请求过程中有中间缓存服务器参与，可能会影响请求的处理方式和结果。在大数据量情况下，如果中间缓存服务器对put请求进行了缓存优化，可能会减少请求到达后端服务器的次数，从而降低出错的概率。二、服务器端处理机制差异1、数据验证和处理流程不同服务器对post和put请求可能有不同的数据验证和处理流程。在处理大量数据时，这些差异可能导致不同的结果。对于post请求，服务器可能会更严格的输入验证（数据格式，大小限制等）。而对于put请求，由于是更新操作，服务器可能已经对数据的格式和结构有了一定的预期，验证过程相对宽松一些。这种差异可能导致大数据量的post请求在验证阶段出错，而put请求能够顺利通过。2、资源分配和管理差异服务器在处理不同的HTTP方法时，可能会分配不同的资源来处理请求。对于大数据量的请求，资源的分配和管理方式可能会对请求的成功与否产生影响。服务器可能为put请求分配更多的内存资源或采用更高效的磁盘I/O策略来处理大数据量的更新操作。而对于post请求，由于创建新资源的过程中设计更多的不确定性和复杂性，资源分配可能不够优化，导致在处理大数据量时出现错误。三、前端发送请求的方式差异1、请求参数的编码方式post与put请求在发送大数据量时，可能采用不同的编码方式。由于编码方式的差异可能会影响服务器请求的解析和处理。post 数据编码：application/x-www-form-urlencoded 或 JSON 编码（application/json）。put  数据编码：multipart/form-data 编码如果服务器对不同的编码方式支持程度不同，可能导致put请求更适合大数据量传输。2、请求都设置差异前端发送post或put请求时，可能会设置不同的请求头。不同的请求头可能会影响服务器对请求的处理方式。注：HTTP中，POST和PUT的主要区别在于他们被设计用来完成不同的任务。POST：请求通常用于创建新资源或提交数据给服务器进行修改，PUT：请求用于更新或替换服务器上的资源。post:用于创建新资源put：用户更新资源服务器在接收数据的时候对post提交的数据验证更加严格，put对数据格式有一定的预期，验证相对宽松。前端发送请求不同，其对参数的编码方式也有不同，不同请求头可能会影响服务器对请求的处理方式。http://www.ppmy.cn/news/1540653.html相关文章大厂面试提问：Flash Attention 是怎么做到又快又省显存的？最近已有不少大厂都在秋招宣讲了&amp;#xff0c;也有一些在 Offer 发放阶段。 
节前&amp;#xff0c;我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。 
针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了…阅读更多...Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:19 +0000</pubDate>
    </item>
    <item>
      <title>大厂面试提问：Flash Attention 是怎么做到又快又省显存的？</title>
      <link>https://www.ppmy.cn/news/1540652.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大厂面试提问：Flash Attention 是怎么做到又快又省显存的？news/2025/10/31 21:29:17/最近已有不少大厂都在秋招宣讲了，也有一些在 Offer 发放阶段。节前，我们邀请了一些互联网大厂朋友、今年参加社招和校招面试的同学。针对新手如何入门算法岗、该如何准备面试攻略、面试常考点、大模型技术趋势、算法项目落地经验分享等热门话题进行了深入的讨论。总结链接如下：《大模型面试宝典》(2024版) 正式发布喜欢本文记得收藏、关注、点赞Flash Attention 并没有减少 Attention 的计算量，也不影响精度，但是却比标准的Attention运算快 2~4 倍的运行速度，减少了 5~20 倍的内存使用量。究竟是怎么实现的呢？Attention 为什么慢？此处的“快慢”是相对而言的。严格意义上来说，相比于传统的 RNN，Transformer中的Attention可以并行地处理序列所有位置的信息（RNN 只能串行处理），因此计算效率并不低，但是仍然有可以进一步改进的空间。众所周知，科学计算通常分为计算密集型 (compute-bound) 和内存密集型 (memory-bound) 两类。其中，计算密集型运算的时间瓶颈主要在于算数计算，比如大型矩阵的相乘等，而内存密集型运算的时间瓶颈主要在于内存的读写时间，比如批归一化、层归一化等等。时间复杂度：Attention 需要对矩阵 Q 和矩阵 K 的转置做乘法来得到注意力权重矩阵。不考虑 batch 维度，假设矩阵QK 的尺寸都为，那么两个维度为的矩阵相乘的时间复杂度是序列长度n的平方级；在计算完注意力权重矩阵后，还需要对其进行softmax操作，这个算法需要分成三次迭代来执行空间复杂度：Attention的计算过程需要存储和这两个尺寸均为的矩阵为了对 Attention 的内存读取时间有更清晰的感知，这里简单介绍 GPU 的内存层级。GPU 的内存可以分为 HBM 和 SRAM 两部分。例如，A100 GPU具有40-80 GB的高带宽内存（上图中的 HBM，即我们平时说的“显存”），带宽为 1.5TB/s，并且108个流式多核处理器都有 192 KB 的片上 SRAM，带宽约为 19 TB/s。片上 SRAM 比 HBM 快一个数量级，但容量要小很多个数量级。在 GPU 运算之前，数据和模型先从 CPU 的内存（上图中的DRAM）移动到 GPU 的 HBM，然后再从 HBM 移动到 GPU 的 SRAM，CUDA kernel 在 SRAM 中对这些数据进行运算，运算完毕后将运算结果再从 SRAM 移动到 HBM。所以提高Attention运算效率，需要从降低attention的时间和空间复杂度入手。时间复杂度在的计算过程中，理论上尝试的方法主要可以分为稀疏 (sparse) 估计和低秩 (low-rank) 估计。但是在实际应用中仍然存在一些缺陷：性能比不上原始 attention。不论是稀疏估计、低秩估计还是其他，这些方法都采用了某种近似算法来估算注意力权重矩阵，难免会丢失信息。目前主流的还是原始的attention无法减少内存读取的时间消耗。这些方法只能降低 attention 的计算复杂度，但是无法对 attention 运算过程中的空间复杂度等进行控制，无法减少内存读写带来的时间损耗所以在时间复杂度方向的优化主要在softmax的计算过程中：softmax 有个问题，那就是很容易溢出。比如float16的最大值为65504，所以只要 的话softmax就溢出了。好在 exp 有这么一个性质，那就是，根据这个性质，可以在分子分母上同时除以一个数，这样可以将的范围都缩放到范围内，保证计算 softmax 时的数值稳定性。这个算法可以分成三次迭代来执行：遍历所有数，求 x 中的最大值m计算 softmax 分母，并根据m对其进行缩放求对应位置的 softmax分析以上步骤可以发现，如果是不做任何优化的话，至少要进行和 GPU 进行6次通信（3次写入，3次写出），如果对每一步的for循环进行一些并行切分的的话，还要加上 reduce_sum 和 reduce_max 之类的通信成本。所以2018年 Nvidia 提出了《Online normalizer calculation for softmax》，核心改进是去掉第二步中对的依赖，设（这里的全局最大值变成了当前最大值），这个式子有如下的性质：这个式子依赖于，，。那么就可以将softmax前两步合并到一起：求 x 的最大值 m, 计算 softmax 的分母求对应位置的 softmax以上的算法优化可以将3步合并变成2步，将softmax的时间复杂度降为。空间复杂度在将3步合成2步的同时：借助GPU的share memory来存储中间结果，将上面的两步只用一个 kernel 实现，这样就只需要与 global memory 通信两次（一次写入数据，一次读取结果）还可以减少 Reduce_max 和 Reduce_sum 之类的通信成本空间复杂度方面优化的基本思路是降低Attention对于显存的需求，减少HBM和SRAM之间的换入换出，充分利用 GPU 的并行优势，进而减少Attention运算的时间消耗。总结Flash Attention的动机是尽可能避免大尺寸的注意力权重矩阵在 HBM 和 SRAM 之间的换入换出。论文中具体方法包含两个部分：tiling 和 recomputation。tiling 的基本思路：不直接对整个输入序列计算注意力，而是将其分为多个较小的块，逐个对这些块进行计算，增量式地进行 softmax 的规约。规约过程中只需要更新某些中间变量，不需要计算整个注意力权重矩阵，就是以上介绍的将三步合并成两步的过程。recomputation 的基本思路：基于 tiling 技巧，在反向传播过程中不保留整个注意力权重矩阵，而是只保留前向过程中 tiling 的某些中间变量，然后在反向传播过程中重新计算注意力权重矩阵。recomputation 可以看作是一种基于 tiling 的特殊的 gradient checkpointing，想进一步了解 recomputation 的读者可以翻阅Flash Attention原文。得益于上述技巧，Flash Attention 可以同时做到又快（运算速度快）又省（节省显存）。http://www.ppmy.cn/news/1540652.html相关文章Scala中的reduce作用&amp;#xff1a;reduce是一种集合操作&amp;#xff0c;用于对集合中的元素进行聚合操作&amp;#xff0c;返回一个单一的结果。它通过指定的二元操作&amp;#xff08;即取两个元素进行操作&amp;#xff09;对集合中所有的元素进行递归处理&amp;#xff0c;并最终将其合并为一个值。 
语法&amp;#xff1…阅读更多...在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:17 +0000</pubDate>
    </item>
    <item>
      <title>Scala中的reduce</title>
      <link>https://www.ppmy.cn/news/1540651.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Scala中的reducenews/2025/10/31 21:29:16/作用：reduce是一种集合操作，用于对集合中的元素进行聚合操作，返回一个单一的结果。它通过指定的二元操作（即取两个元素进行操作）对集合中所有的元素进行递归处理，并最终将其合并为一个值。语法：def reduce[B&gt;:A](op:(B,B)=&gt;B):Bdef main(args: Array[String]): Unit = {//定义一个数组Array(1,2,3,4,5)//求和 (1,2,3,4,5) ===&gt; 一个值val res=Array(1,2,3,4,5).reduce((x,y)=&gt; x+y)println(res)}http://www.ppmy.cn/news/1540651.html相关文章在合规的地方怎么用EACO地球链兑换交换价值？地球链EACO&amp;#xff08;EarthChain&amp;#xff0c;简称$E&amp;#xff09;是一种虚拟数字资产。 
目前在中国大陆&amp;#xff0c;虚拟资产相关业务活动属于金融活动&amp;#xff0c;包括虚拟资产的交易、兑换等操作&amp;#xff0c;因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动&amp;…阅读更多...LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:16 +0000</pubDate>
    </item>
    <item>
      <title>在合规的地方怎么用EACO地球链兑换交换价值？</title>
      <link>https://www.ppmy.cn/news/1540650.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维在合规的地方怎么用EACO地球链兑换交换价值？news/2025/10/31 21:29:15/地球链EACO（EarthChain，简称$E）是一种虚拟数字资产。目前在中国大陆，虚拟资产相关业务活动属于金融活动，包括虚拟资产的交易、兑换等操作，因此应该谨慎去寻求如何用它来交换价值。 虚拟资产交易炒作活动，可能会产生扰乱经济金融秩序，滋生赌博、非法集资、诈骗、传销、洗钱等违法犯罪活动，严重危害人民群众财产安全。为了保障自身的合法权益和金融安全，应远谨慎这类虚拟货币交易操作，部分网友认为。扬长避短，注意避免缺点，发挥优点。怎么把这些负面能量转化为正能量呢？在中东东南亚欧美等合规的地方怎么用EACO地球链兑换交换价值？即使在一些对加密资产监管相对宽松的地区，使用EACO地球链或其他虚拟资产进行价值兑换和交易也存在诸多风险和不确定性，并且操作流程较为复杂且逐渐被广泛认可。以下是一些可能的途径，但建议进行认真仔细谨慎此类操作：1. **加密资产交易所**：在部分地区有一些加密资产交易所允许交易EACO。你需要在符合当地法规的交易所上注册账户、完成身份验证等一系列流程，然后将你持有的EACO挂单出售或与其他支持的加密资产、稳定币进行兑换交易。例如，一些交易所可能提供EACO与USDT（泰达币，一种与美元挂钩的稳定币）等的交易对。不过，加密资产交易所的市场波动较大，价格不稳定，且交易所可能存在安全风险和监管方面的不确定性。2. **P2P交易**：在一些地区可能存在点对点（P2P）的虚拟资产交易平台或社区。你可以在这些平台上寻找愿意与你进行EACO交易的对手方，直接进行交易。但这种方式缺乏监管，容易出现欺诈、洗钱等违法违规行为，交易安全难以保障。3. **与接受虚拟资产的商家或个人进行交易**：极个别商家或个人可能愿意接受EACO作为支付方式来交换商品或服务，但这种情况非常罕见。你需要找到这样的交易对象，并与他们协商确定交易的价值和方式。需要强调的是，虚拟资产市场具有高度的投机性和风险性，并且在全球范围内，虚拟资产的监管政策仍在不断完善和变化。在中国，虚拟资产相关业务活动属于金融活动，建议谨慎参与虚拟货币的交易和兑换。在其他国家和地区，也应该谨慎对待虚拟货币的投资和交易，充分了解当地的法律法规和市场风险。http://www.ppmy.cn/news/1540650.html相关文章LeetCode 203 - 移除链表元素题目描述 
给你一个链表的头节点 head 和一个整数 val &amp;#xff0c;请你删除链表中所有满足 Node.val  val 的节点&amp;#xff0c;并返回 新的头节点 。 解题思路 
创建一个虚拟头节点dummyHead&amp;#xff0c;并将其next指向给定的头节点head&amp;#xff0c;这样可以避免处理头节点的特…阅读更多...Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:15 +0000</pubDate>
    </item>
    <item>
      <title>LeetCode 203 - 移除链表元素</title>
      <link>https://www.ppmy.cn/news/1540649.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维LeetCode 203 - 移除链表元素news/2025/10/31 21:29:14/题目描述给你一个链表的头节点head和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回 新的头节点 。解题思路创建一个虚拟头节点dummyHead，并将其next指向给定的头节点head，这样可以避免处理头节点的特殊情况。使用指针cur来遍历链表，当cur的下一个节点不为空时，进行如下操作：1.如果cur的下一个节点的值等于给定的数值val，则将其下一个节点（即要移除的节点）保存在临时指针tmp中，然后将cur的next指针指向下下个节点，同时删除tmp指向的节点，完成移除操作。2.如果cur的下一个节点的值不等于给定的数值val，则将cur指针指向下一个节点，即保持链表的连续性。3.最后，将head指向dummyHead的下一个节点，即新的头节点，然后删除dummyHead节点释放内存，最终返回新的头节点。算法实现C++实现/*** Definition for singly-linked list.* struct ListNode {*     int val;*     ListNode *next;*     ListNode() : val(0), next(nullptr) {}*     ListNode(int x) : val(x), next(nullptr) {}*     ListNode(int x, ListNode *next) : val(x), next(next) {}* };*/
class Solution {
public:ListNode* removeElements(ListNode* head, int val) {ListNode*dummyHead=new ListNode(0);dummyHead-&gt;next=head;ListNode*cur=dummyHead;while(cur-&gt;next!=NULL){if(cur-&gt;next-&gt;val==val){ListNode*tmp=cur-&gt;next;cur-&gt;next=cur-&gt;next-&gt;next;delete tmp;}else{cur=cur-&gt;next;}}head=dummyHead-&gt;next;delete dummyHead;return head;}
};复杂度分析时间复杂度：O(n)，其中n是链表的长度。需要遍历整个链表一次。空间复杂度：O(1)，只使用了常数级别的额外空间。总结=这种方法的时间复杂度和空间复杂度都很低，适用于处理大规模的链表数据。希望本篇博客能给大家提供一些帮助，也欢迎大家多多交流，共同进步！以上就是对LeetCode203移除链表元素的解题思路、算法实现、复杂度分析和总结，希望对你有所帮助！http://www.ppmy.cn/news/1540649.html相关文章Android 禁止App字体随系统大小而更改运营反馈&amp;#xff0c;老年用户的手机多设置为大字体&amp;#xff0c;在使用我们app过程中&amp;#xff0c;由于字体被放大&amp;#xff0c;导致布局错乱&amp;#xff0c;部分功能按键遮挡&amp;#xff0c;无法正常使用。   收到问题&amp;#xff0c;着手解决&amp;#xff0c;除了对界面布局进行改写&amp;#…阅读更多...Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:14 +0000</pubDate>
    </item>
    <item>
      <title>Android 禁止App字体随系统大小而更改</title>
      <link>https://www.ppmy.cn/news/1540648.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Android 禁止App字体随系统大小而更改news/2025/10/31 21:29:12/运营反馈，老年用户的手机多设置为大字体，在使用我们app过程中，由于字体被放大，导致布局错乱，部分功能按键遮挡，无法正常使用。收到问题，着手解决，除了对界面布局进行改写，改为约束布局，对app字体大小也进行统一管理，然而这不是主要的，最主要的是避免系统更改app字体的大小。Android提供了相关的方法用来实现public class DisplayUtil {/*** 保持字体大小不随系统设置变化（用在界面加载之前）* 要重写Activity的attachBaseContext()*/public static Context attachBaseContext(Context context, float fontScale) {Configuration config = context.getResources().getConfiguration();//正确写法config.fontScale = fontScale;return context.createConfigurationContext(config);}/*** 保持字体大小不随系统设置变化（用在界面加载之前）* 要重写Activity的getResources()*/public static Resources getResources(Context context, Resources resources, float fontScale) {Configuration config = resources.getConfiguration();if(config.fontScale != fontScale) {config.fontScale = fontScale;return context.createConfigurationContext(config).getResources();} else {return resources;}}/*** 保存字体大小，后通知界面重建，它会触发attachBaseContext，来改变字号*/public static void recreate(Activity activity) {activity.recreate();}
}在BaseActivity中复写相关的方法：static float fontScale = 1f;@Overridepublic Resources getResources() {Resources resources = super.getResources();return DisplayUtil.getResources(this,resources,fontScale);}@Overrideprotected void attachBaseContext(Context newBase) {super.attachBaseContext(DisplayUtil.attachBaseContext(newBase,fontScale));}public void setFontScale(float fontScale) {this.fontScale = fontScale;DisplayUtil.recreate(this);}经测试，在设置中把字体调整为最大，打开app,app中字体均保持不变，测试华为，vivo，小米机型均生效，于是交付测试。http://www.ppmy.cn/news/1540648.html相关文章Javascript与前端路由相关webAPI与路由相关的浏览器Web API主要涉及前端路由的管理&amp;#xff0c;这在单页应用&amp;#xff08;SPA&amp;#xff09;中尤为重要。以下是对这些API的详细解释&amp;#xff1a; 
一、前端路由的基本概念 
前端路由是指在不重新加载页面的情况下&amp;#xff0c;通过改变URL来更新页面内容的一种技术…阅读更多...Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:12 +0000</pubDate>
    </item>
    <item>
      <title>Javascript与前端路由相关webAPI</title>
      <link>https://www.ppmy.cn/news/1540647.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Javascript与前端路由相关webAPInews/2025/10/31 21:29:11/与路由相关的浏览器Web API主要涉及前端路由的管理，这在单页应用（SPA）中尤为重要。以下是对这些API的详细解释：一、前端路由的基本概念前端路由是指在不重新加载页面的情况下，通过改变URL来更新页面内容的一种技术。它允许开发者在客户端维护一个路由表，根据用户的操作（如点击按钮、输入地址等）来动态地显示不同的页面或组件。二、与路由相关的Web APIHistory APIHistory API提供了一组方法和属性，用于操作浏览器的会话历史（即浏览器标签页的历史记录）。其中，history.pushState()和history.replaceState()是与前端路由密切相关的两个方法。history.pushState(state, title, url)：将一个新的历史记录条目添加到会话历史堆栈中。这个方法不会立即导致页面跳转，但会改变当前的URL，并且会在用户点击浏览器的后退或前进按钮时触发popstate事件。history.replaceState(state, title, url)：修改当前的历史记录条目，而不是添加一个新的条目。这个方法同样不会立即导致页面跳转，但会更新URL和状态对象。通过这两个方法，开发者可以在不重新加载页面的情况下，动态地更新URL和页面内容，从而实现前端路由。window.locationwindow.location对象包含了有关当前文档位置的信息，并且允许JavaScript修改浏览器的URL。虽然它本身不是专门为前端路由设计的，但开发者可以利用它来读取或设置URL，从而在一定程度上实现路由的功能。window.location.href：获取或设置整个URL。window.location.pathname：获取或设置URL的路径部分。window.location.search：获取或设置URL的查询字符串部分。window.location.hash：获取或设置URL的哈希部分（即URL中#符号后面的部分）。通过修改window.location对象的属性，开发者可以实现页面的跳转或更新URL的特定部分。然而，这种方法通常会导致页面的重新加载，因此在单页应用中，开发者更倾向于使用History API来实现前端路由。三、前端路由的实现原理前端路由的实现原理主要基于以下几点：监听URL的变化：通过监听popstate事件或hashchange事件（对于基于哈希的路由）来检测URL的变化。匹配路由：根据URL的变化，在客户端的路由表中查找对应的页面或组件。渲染页面：根据匹配到的页面或组件，动态地更新DOM树，从而显示不同的内容。四、前端路由的框架和库为了简化前端路由的实现，开发者通常会使用一些框架和库，如React Router、Vue Router等。这些框架和库提供了丰富的API和配置选项，使得前端路由的实现更加简单和高效。综上所述，与路由相关的浏览器Web API主要包括History API和window.location对象。通过这些API，开发者可以在不重新加载页面的情况下，动态地更新URL和页面内容，从而实现前端路由。同时，为了简化实现过程，开发者还可以借助一些前端路由的框架和库。下面是一个结合History API和window.location使用的示例。在这个示例中，我们将展示如何使用history.pushState()和history.replaceState()来改变浏览器的历史记录，并监听popstate事件来处理用户点击浏览器后退或前进按钮时的行为。同时，我们也将使用window.location来读取当前的URL。&lt;!DOCTYPE html&gt;  
&lt;html lang="en"&gt;  
&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;History API and window.location Example&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  &lt;h1&gt;History API and window.location Example&lt;/h1&gt;  &lt;button id="pushStateBtn"&gt;Push State&lt;/button&gt;  &lt;button id="replaceStateBtn"&gt;Replace State&lt;/button&gt;  &lt;p id="urlDisplay"&gt;Current URL: &lt;span&gt;&lt;/span&gt;&lt;/p&gt;  &lt;script&gt;  // 获取按钮和显示URL的元素  const pushStateBtn = document.getElementById('pushStateBtn');  const replaceStateBtn = document.getElementById('replaceStateBtn');  const urlDisplaySpan = document.querySelector('#urlDisplay span');  // 更新当前显示的URL  function updateUrlDisplay() {  urlDisplaySpan.textContent = window.location.href;  }  // 监听popstate事件  window.addEventListener('popstate', function(event) {  console.log('Popstate event triggered:', event.state);  updateUrlDisplay();  // 根据event.state的值来更新页面的其他内容（这里只是简单打印到控制台）  });  // Push State按钮的点击事件处理函数  pushStateBtn.addEventListener('click', function() {  const state = { page: 'newState1', data: 'Some data for new state 1' };  const title = ''; // 大多数浏览器忽略此参数  const url = '/new-page-1'; // 新的历史记录条目的URL（相对于当前页面）  // 将新的历史记录条目添加到会话历史堆栈中  history.pushState(state, title, url);  // 更新当前显示的URL  updateUrlDisplay();  // 可以在这里添加其他逻辑来处理新状态的加载，比如通过AJAX获取数据并更新页面内容  });  // Replace State按钮的点击事件处理函数  replaceStateBtn.addEventListener('click', function() {  const state = { page: 'newState2', data: 'Some data for new state 2' };  const title = ''; // 大多数浏览器忽略此参数  const url = '/new-page-2'; // 要替换的当前历史记录条目的新URL（相对于当前页面）  // 修改当前的历史记录条目  history.replaceState(state, title, url);  // 更新当前显示的URL  updateUrlDisplay();  // 可以在这里添加其他逻辑来处理新状态的加载，比如通过AJAX获取数据并更新页面内容  });  // 初始化时显示当前URL  updateUrlDisplay();  &lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;在这个示例中，有两个按钮：“Push State”和“Replace State”。点击“Push State”按钮时，会使用history.pushState()方法向浏览器的历史记录中添加一个新的条目，并更新当前显示的URL。点击“Replace State”按钮时，会使用history.replaceState()方法替换当前的历史记录条目，并更新URL。同时，我们监听popstate事件来处理用户点击浏览器后退或前进按钮时的行为。当用户导航到新状态时（无论是通过点击按钮还是使用浏览器的后退/前进按钮），都会在控制台中打印出触发popstate事件时的状态对象，并更新页面上显示的当前URL。请注意，由于安全限制，history.pushState()和history.replaceState()方法中的url参数必须是与当前页面同源的URL。如果尝试使用不同的URL，将会抛出一个异常。在这个示例中，我们使用了相对于当前页面的URL（如/new-page-1），但在实际应用中，你可能需要根据你的应用结构和路由配置来调整这些URL。五、利用WebAPI手动实现一个路由在JavaScript中实现一个简单的路由功能，可以使用前端路由技术，这通常用于单页面应用（SPA）。前端路由通过在浏览器历史记录中添加和监听不同的路径来实现页面的无刷新切换。以下是一个使用纯JavaScript实现简单路由功能的示例：HTML首先，我们需要一些基本的HTML结构来容纳我们的视图（页面）：&lt;!DOCTYPE html&gt;  
&lt;html lang="en"&gt;  
&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;Simple Routing&lt;/title&gt;  
&lt;/head&gt;  
&lt;body&gt;  &lt;nav&gt;  &lt;a href="/home" class="router-link"&gt;Home&lt;/a&gt;  &lt;a href="/about" class="router-link"&gt;About&lt;/a&gt;  &lt;a href="/contact" class="router-link"&gt;Contact&lt;/a&gt;  &lt;/nav&gt;  &lt;div id="app"&gt;&lt;/div&gt;  &lt;script src="router.js"&gt;&lt;/script&gt;  
&lt;/body&gt;  
&lt;/html&gt;JavaScript (router.js)接下来，我们在router.js文件中实现路由功能：// 创建一个简单的路由类  
class Router {  constructor() {  this.routes = {};  this.currentRoute = null;  this.appElement = document.getElementById('app');  // 监听点击事件，阻止默认行为并处理路由  document.querySelectorAll('.router-link').forEach(link =&gt; {  link.addEventListener('click', (e) =&gt; {  e.preventDefault();  this.navigateTo(e.target.getAttribute('href'));  });  });  // 监听 popstate 事件以处理浏览器前进/后退按钮  window.addEventListener('popstate', (e) =&gt; {  this.navigateTo(document.location.pathname);  });  // 初始化路由，处理页面加载时的路由  this.init();  }  init() {  this.navigateTo(document.location.pathname);  }  defineRoute(path, component) {  this.routes[path] = component;  }  navigateTo(path) {  // 规范化路径，确保路径以 '/' 开头  if (!path.startsWith('/')) {  path = '/' + path;  }  // 更新浏览器历史记录  history.pushState({}, '', path);  // 渲染相应的组件  if (this.routes[path]) {  this.currentRoute = path;  this.appElement.innerHTML = ''; // 清空之前的视图  this.appElement.appendChild(this.routes[path]());  } else {  // 处理 404 页面  this.appElement.innerHTML = '&lt;h1&gt;404 - Page Not Found&lt;/h1&gt;';  }  }  
}  // 定义一些简单的组件  
function HomeComponent() {  const div = document.createElement('div');  div.innerHTML = '&lt;h1&gt;Home Page&lt;/h1&gt;&lt;p&gt;Welcome to the home page!&lt;/p&gt;';  return div;  
}  function AboutComponent() {  const div = document.createElement('div');  div.innerHTML = '&lt;h1&gt;About Page&lt;/h1&gt;&lt;p&gt;This is the about page.&lt;/p&gt;';  return div;  
}  function ContactComponent() {  const div = document.createElement('div');  div.innerHTML = '&lt;h1&gt;Contact Page&lt;/h1&gt;&lt;p&gt;Contact us at example@example.com.&lt;/p&gt;';  return div;  
}  // 初始化路由并定义路由规则  
const router = new Router();  
router.defineRoute('/home', HomeComponent);  
router.defineRoute('/about', AboutComponent);  
router.defineRoute('/contact', ContactComponent);一个导航栏，每个链接都带有router-link类，这些链接用于触发路由。#app元素是我们放置不同页面组件的地方。JavaScript路由：Router类：管理路由定义、导航和视图渲染。constructor：初始化路由，监听链接点击和浏览器前进/后退按钮。init方法：在页面加载时初始化路由。defineRoute方法：定义路径和对应的组件。navigateTo方法：处理路径导航，更新浏览器历史记录，并渲染相应的组件。HomeComponent、AboutComponent和ContactComponent：简单的组件函数，返回包含HTML内容的div元素。通过这种方式，你可以实现一个简单的前端路由系统，用于单页面应用。http://www.ppmy.cn/news/1540647.html相关文章Spring Boot与图书管理：进销存系统的新发展4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:11 +0000</pubDate>
    </item>
    <item>
      <title>Spring Boot与图书管理：进销存系统的新发展</title>
      <link>https://www.ppmy.cn/news/1540646.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Spring Boot与图书管理：进销存系统的新发展news/2025/10/31 21:29:10/4系统概要设计4.1概述本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式，是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示：图4-1系统工作原理图4.2系统结构本系统是基于B/S架构的网站系统，设计的功能结构图如下图所示：图4-2功能结构图4.3.数据库设计4.3.1数据库实体概念设计的目标是设计出反映某个组织部门信息需求的数据库系统概念模式，数据库系统的概念模式独立于数据库系统的逻辑结构、独立于数据库管理系统（DBMS）、独立于计算机系统。概念模式的设计方法是在需求分析的基础上，用概念数据模型（例如E-R模型）表示数据及数据之间的相互联系，设计出反映用户信息需求和处理需求的数据库系统概念模式。概念设计的目标是准确描述应用领域的信息模式，支持用户的各种应用，这样既容易转换为数据库系统逻辑模式，又容易为用户理解。数据库系统概念模式是面向现实世界的数据模型，不能直接用于数据库系统的实现。在此阶段，用户可以参与和评价数据库系统的设计，从而有利于保证数据库系统的设计与用户的需求相吻合。在概念模式的设计中，E-R模型法是最常见的设计方法。本系统的E-R图如下图所示：（1）图书类型信息的实体属性图如下：图4.12 图书类型信息实体属性图（2）收入金额信息实体属性图如图4.13所示：图4.13 收入金额信息实体属性图（3）管理员信息实体属性图如图4.14所示：图4.14 管理员信息实体属性图4.3.2数据库设计表图书进销存管理系统需要后台数据库，下面介绍数据库中的各个表的详细信息：表4.1 图书信息评论表字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间refid bigint(20) 否 关联表iduserid bigint(20) 否 用户idnickname varchar(200) 是 NULL 用户名content longtext 否 评论内容reply longtext 是 NULL 回复内容表4.2 供应商字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间gongyingshangbianhao varchar(200) 是 NULL 供应商编号gongyingshangmingcheng varchar(200) 是 NULL 供应商名称gongyingshangleixing varchar(200) 是 NULL 供应商类型zhugongshangpin varchar(200) 是 NULL 主供商品fuzeren varchar(200) 是 NULL 负责人lianxidianhua varchar(200) 是 NULL 联系电话lianxidizhi varchar(200) 是 NULL 联系地址xiangqingbeizhu longtext 是 NULL 详情备注表4.3 进货订单字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间dingdanbianhao varchar(200) 否 订单编号gongyingshangbianhao varchar(200) 是 NULL 供应商编号gongyingshangmingcheng varchar(200) 是 NULL 供应商名称tushubianhao varchar(200) 是 NULL 图书编号tushumingcheng varchar(200) 是 NULL 图书名称tushuleixing varchar(200) 是 NULL 图书类型tushuzuozhe varchar(200) 是 NULL 图书作者chubanshe varchar(200) 是 NULL 出版社tupian varchar(200) 是 NULL 图片tushudanjia varchar(200) 是 NULL 图书单价shuliang varchar(200) 是 NULL 数量dingdanjine varchar(200) 是 NULL 订单金额jinhuoshijian datetime 是 NULL 进货时间shenheren varchar(200) 是 NULL 审核人表4.4 客户信息字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间kehubianhao varchar(200) 是 NULL 客户编号kehumingcheng varchar(200) 否 客户名称fuzeren varchar(200) 否 负责人lianxidianhua varchar(200) 是 NULL 联系电话dizhi varchar(200) 是 NULL 地址beizhu longtext 是 NULL 备注tupian varchar(200) 是 NULL 图片表4.5 库存分析字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间tushubianhao varchar(200) 是 NULL 图书编号tushumingcheng varchar(200) 是 NULL 图书名称riqi varchar(200) 是 NULL 日期dangqiankucun varchar(200) 是 NULL 当前库存表4.6 批销订单字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间dingdanbianhao varchar(200) 否 订单编号gongyingshangbianhao varchar(200) 是 NULL 供应商编号gongyingshangmingcheng varchar(200) 是 NULL 供应商名称tushubianhao varchar(200) 是 NULL 图书编号tushumingcheng varchar(200) 是 NULL 图书名称tushuleixing varchar(200) 是 NULL 图书类型tushuzuozhe int(11) 是 NULL 图书作者chubanshe varchar(200) 是 NULL 出版社tupian varchar(200) 是 NULL 图片tushudanjia longtext 是 NULL 图书单价shuliang varchar(200) 是 NULL 数量dingdanjine varchar(200) 是 NULL 订单金额jinhuoshijian datetime 是 NULL 进货时间shenheren varchar(200) 是 NULL 审核人表4.7 商品退货字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间gongyingshangbianhao varchar(200) 是 NULL 供应商编号gongyingshangmingcheng varchar(200) 是 NULL 供应商名称caigoubianhao varchar(200) 是 NULL 采购编号tushubianhao varchar(200) 是 NULL 图书编号tushumingcheng varchar(200) 是 NULL 图书名称tushuzuozhe varchar(200) 是 NULL 图书作者chubanshe varchar(200) 是 NULL 出版社shuliang varchar(200) 是 NULL 数量caigoujiage varchar(200) 是 NULL 采购价格tuihuojine varchar(200) 是 NULL 退货金额tuihuoyuanyin varchar(200) 是 NULL 退货原因tuihuoriqi date 是 NULL 退货日期表4.8 收入金额字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间riqi varchar(200) 是 NULL 日期tushushuliang varchar(200) 是 NULL 图书数量shourujine varchar(200) 是 NULL 收入金额beizhu longtext 是 NULL 备注表4.9 收藏表字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间userid bigint(20) 否 用户idrefid bigint(20) 是 NULL 收藏idtablename varchar(200) 是 NULL 表名name varchar(200) 否 收藏名称picture varchar(200) 否 收藏图片表4.10 图书类型字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间tushuleixing varchar(200) 是 NULL 图书类型表4.11 图书信息字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间tushubianhao varchar(200) 是 NULL 图书编号tushumingcheng varchar(200) 是 NULL 图书名称tushuleixing varchar(200) 是 NULL 图书类型tushuzhuangtai varchar(200) 是 NULL 图书状态tushuzuozhe varchar(200) 是 NULL 图书作者tushugaiyao longtext 是 NULL 图书概要tushufengmian varchar(200) 是 NULL 图书封面thumbsupnum int(11) 是 0 赞crazilynum int(11) 是 0 踩表4.12 管理员表字段 类型 空 默认 注释id (主键) bigint(20) 否 主键username varchar(100) 否 用户名password varchar(100) 否 密码role varchar(100) 是 管理员 角色addtime timestamp 否 CURRENT_TIMESTAMP 新增时间表4.13 应收金额字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间riqi varchar(200) 是 NULL 日期tushushuliang varchar(200) 是 NULL 图书数量yingshoujine varchar(200) 是 NULL 应收金额beizhu longtext 是 NULL 备注表4.14 用户字段 类型 空 默认 注释id (主键) bigint(20) 否 主键addtime timestamp 否 CURRENT_TIMESTAMP 创建时间zhanghao varchar(200) 否 账号mima varchar(200) 否 密码xingming varchar(200) 是 NULL 姓名xingbie varchar(200) 是 NULL 性别shouji varchar(200) 是 NULL 手机youxiang varchar(200) 是 NULL 邮箱tupian varchar(200) 是 NULL 图片sfsh varchar(200) 是 否 是否审核shhf longtext 是 NULL 审核回复6系统测试6.1概念和意义测试的定义：程序测试是为了发现错误而执行程序的过程。测试(Testing)的任务与目的可以描述为：目的：发现程序的错误；任务：通过在计算机上执行程序，暴露程序中潜在的错误。另一个预测是相关的术语叫纠错(Debugging)。它的目的与任务可以规定为：目的：定位和纠正错误；任务：消除软件故障，保证程序的可靠运行。测试与纠错的关系，可以用图6-1的数据流图来说明。图中表明，每一次测试都要准备好若干必要的测试数据，与被测试程序一道送入计算机执行。通常把一次程序执行需要的测试数据，称为一个“测试用例(Test Case)。每一个测试用例产生一个相应的“测试结果”。如果它与“期望结果”不想符合，便说明程序中存在错误，需要用纠错来改正。图6.1测试与纠错信息流程6.2特性（1）挑剔性测试是为了证明程序有错，而不是证明程序无错。因此，对于被测程序就是要“纯毛求疵”，就是要“鸡蛋里挑骨头”。（2）复杂性测试仪程序则比较容易，这其实是一个误区。设计测试用力是一项需要细致和高度技巧的高能工作，稍有不慎就会顾此失彼，发生不应用得数楼。（3）不彻底性实际测试都是不彻底的，当然不能够保证测试后的程序不存在遗漏的错误。（4）经济性通场这种测试称为“选择测试（Selective Testing）”。为了降低测试成本，选择测试用力是应注意遵守“经济性”的原则。6.3重要性软件测试在软件生命周期中占据重要的地位，在传统的瀑布模型中，软件测试学仅处于运行维护阶段之前，是软件产品交付用户使用之前保证软件质量的重要手段。近来，软件工程界趋向于一种新的观点，即认为软件生命周期每一阶段中都应包含测试，从而检验本阶段的成果是否接近预期的目标，尽可能早的发现错误并加以修正，如果不在早期阶段进行测试，错误的延时扩散常常会导致最后成品测试的巨大困难。6.4测试方法首先我们来说界面测试，界面测试是为了使程序在不同的的操作平台上能够运行界面，并且能够保持原来的风格。我把完整程序拷贝到Windows 7环境下，似的程序运行正常，运行界面上的字体图片等设置都能够保持得非常好。不出现字体变形等情况！其次进行功能测试。该系统测试采用的是单元测试，集成测试，完善性测试等多种方式进行测试。经过测试，所有功能都能得以实现，没有任何变形。至此，在功能的测试上也已经比较圆满的完成了。由于经验不足，写代码时出现了一些考虑不周的系统缺陷，写代码的时候会出现与设想不一致，比如说代码不规范导致接口与接口之间出现问题，功能与客户的要求不符合，这样导致产品不能过关，无法交付。所以产品在上线前必须反复测试，经过反复测试，修改，再测试，再修改，产品才能够不断完善。在整个系统测试中，根据需求文档和设计文档，逐一对功能进行检测并写好测试用例，有效避免残片缺陷，因为产品出现缺陷不仅影响功能，而且可以导致数据的不准确，导致产品质量的降低，经过测试，才能使得产品的稳定性和成熟度得到极大的提升，产品质量也才有保证。6.5 功能测试功能测试主要包括五项内容：适用性、准确性、可操作性、依从性、安全性。本系统功能测试如表6.1所示：表6.1 系统功能测试测试内容 测试结果适用性 好准确性 好可操作性 好依从性 好安全性 好6.6可用性测试可用性测试用于检测系统的可操作性、可理解性、可学习性等方面内容。具体测试方面如表6.2所示。表6.2 系统可用性测试测试项 测试人员的评价窗口移动、大小改变、关闭等操作是否正常 是操作模块是否友好 是模块、提示内容等文字描述是否正确 是模块布局是否协调、合理 是模块的状态是否正确（对选中项能否发生对应切换） 是鼠标、键盘操作是否支持 是所需数据项是否正确显示 是操作流程是否合理 是是否提供帮助信息 是6.7性能测试性能测试主要通过模拟系统运行环境，测试系统性能是否符合客户需求。性能测试的重要技术指标就是：系统运行速度、网络响应时间和支持并发节点数。1）系统运行速度：通过在不同计算机上试运行本系统，没有发现有任何迟滞、停顿现象。2）网络响应时间：网络响应时间主要包括网络最小响应时间、平均响应时间、最大响应时间三个参数。经过测试，在网络运营良好状态下，NBA局域网内响应时间三参数为：1/2/6s，NBA外网响应时间三参数为3/7/12s，符合客户需求，属于用户心理可承受范围。3）支持并发节点数：经过模拟环境测试，本系统在并发节点达46个时，网络运营速度会发生较大波动，延迟时间10秒左右，符合客户需求。6.8测试分析本网站设计时借鉴了国内外优秀网站的优点，从界面到系统设计都保证了用户能够方便操作。系统的主要特点和优点归纳如下：（1）本系统用的移置性和针对性都比较高，因为针对性高可以提供更好的服务而移置性可以在多个系统上运行，更给客户带来了极大的方便。（2）该完整内容全面，管理方便可以及时的全面的处理各种错误，异常，这样避免了很多因用户的马虎操作而出现的失误，其操作方便，用户界面友好，能够上网的人都可以很好的进行操作。6.9测试结果分析经过对上述测试结果分析，本系统符合用户需求。所有基本功能点实现，操作简单，操作流程简单合理，产品运行性能良好，是一款值得推广的图书进销存管理系统。http://www.ppmy.cn/news/1540646.html相关文章Git 总结文章目录 1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令 2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更 3、移动提交记录1_整理提交记录2_交互式 rebase 4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git D…阅读更多...Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:10 +0000</pubDate>
    </item>
    <item>
      <title>Git 总结</title>
      <link>https://www.ppmy.cn/news/1540644.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Git 总结news/2025/10/31 21:29:07/文章目录1、基础操作1_提交命令2_创建分支命令3_切换分支4_分支合并5_其他关键命令2、高级操作1_查看 HEAD 指向2_分离Head3_查看提交记录的hash值4_相对引用5_撤销变更3、移动提交记录1_整理提交记录2_交互式 rebase4、经验之谈1_提交技巧12_提交的技巧23_Git Tags4_Git Describe5、Push &amp; Pull —— Git 远程仓库！1_git clone2_远程分支3_Git Fetch4_Git Pull5_Git Push6_偏离的工作7_远程服务器拒绝!(Remote Rejected)8_远程跟踪分支9_Git Push 的参数10_Git fetch 的参数11_古怪的`&lt;source&gt;`12_Git pull 参数6、总结1、基础操作Git主要命令，本文中的主分支命名采用main而不是传统的master。1_提交命令Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有parent节点的原因 —— 对于项目组的成员来说，维护提交历史对大家都有好处。gitcommit2_创建分支命令Git的分支也非常轻量。它们只是简单地指向某个提交纪录—— 仅此而已。所以许多 Git 爱好者传颂：早建分支！多用分支！这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。gitbranch&lt;分支名&gt;#新版支持 git switch3_切换分支gitcheckout&lt;分支名&gt;4_分支合并第一种方法在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个 parent 节点。翻译成自然语言相当于：“我要把这两个 parent 节点本身及它们所有的祖先都包含进来。”# 在 main 分支上对 bugFix合并gitcheckout maingitmerge bugFix第二种合并分支的方法是实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。R e b a s e RebaseRebase的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用Rebase的话，代码库的提交历史将会变得异常清晰。# 把 bugFix 分支里的工作直接移到 main 分支上。# 移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。# 并且原 bugFix 分支上的提交记录依然存在，作为副本gitcheckout bugFixgitrebash main如果是继承关系的合并，Git 只会简单的把父分支的引用向前移动了一下而已。5_其他关键命令# 初始化本地Git仓库, 创建新仓库。gitinit‌# 添加文件到暂存区。gitadd# 查看仓库当前状态。gitstatus# 比较文件差异。gitdiff#删除文件。gitrm#移动或重命名文件。gitmv#配置Git设置。gitconfig#显示分支和提交信息。gitshow-branch#检查仓库完整性。gitfsck#清理仓库和优化存储。gitgc2、高级操作在接触 Git 更高级功能之前，我们有必要先学习在你项目的提交树上前后移动的几种方法。1_查看 HEAD 指向HEAD是一个对当前所在分支的符号引用—— 也就是指向你正在其基础上进行工作的提交记录。HEAD总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。HEAD通常情况下是指向分支名的（如bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。cat.git/HEAD如果 HEAD 指向的是一个引用，还可以查看它的指向gitsymbolic-ref HEAD2_分离Head分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。# 通过哈希值指定提交记录。gitcheckout c2hashvalue# 既不是 bugFix也不是main分支，而是提交记录3_查看提交记录的hash值Git 对哈希的处理很智能。其实你只需要提供能够唯一标识提交记录的前几个字符即可。gitlog4_相对引用通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。使用相对引用的话，你就可以从一个易于记忆的地方（比如bugFix分支或HEAD）开始计算。使用^向上移动 1 个提交记录# main^ 相当于“main 的 parent 节点”。main^^ 是 main 的第二个 parent 节点gitcheckout main^# 也可以将 HEAD 作为相对引用的参照。一直向上移动gitcheckout c3gitcheckout HEAD^但是，如果你想在提交树中向上移动很多步的话，敲那么多^貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符~。该操作符后面可以跟一个数字（可选，不跟数字时与^相同，向上移动一次）。使用~&lt;num&gt;向上移动多个提交记录，如~3gitcheckout main~3我使用相对引用最多的就是移动分支。可以直接使用-f选项让分支指向另一个提交。例如:gitbranch -f main HEAD~3上面的命令会将main分支强制指向HEAD的第 3 级parent提交。5_撤销变更在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们里主要关注的是后者。主要有两种方法用来撤销变更：git reset通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset向上移动分支，原来指向的提交记录就跟从来没有提交过一样。# 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。gitreset HEAD~1虽然在你的本地分支中使用git reset很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的！为了撤销更改并分享给别人，我们需要使用git revert。# 在我们要撤销的C2提交记录后面会多了一个新提交！这是因为新提交记录 C2' 引入了更改# 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。gitrevert HEAD3、移动提交记录自由修改提交树。1_整理提交记录开发人员有时会说“我想要把这个提交放到这里，那个提交放到刚才那个提交的后面”，而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。如果你想将一些提交复制到当前所在的位置（HEAD）下面的话，C h e r r y − p i c k Cherry-pickCherry−pick是最直接的方式了。我个人非常喜欢cherry-pick，因为它特别简单。gitcherry-pick&lt;提交号&gt;# git cherry-pick c2 c4我们只需要提交记录 C2 和 C4，所以 Git 就将被它们抓过来放到当前分支下了。c0	-&gt;c1	-&gt;c5	-&gt;c2`-&gt;c4`(*)|-&gt;c2	-&gt;c3	-&gt;c42_交互式 rebase当你知道你所需要的提交记录（并且还知道这些提交记录的哈希值）时，用cherry-pick再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点，我们可以利用交互式的 rebase—— 如果你想从一系列的提交记录中找到想要的记录，这就是最好的方法了。交互式rebase指的是使用带参数--interactive的 rebase 命令，简写为-i。如果你在命令后增加了这个选项，Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。当rebase UI界面打开时，你能做3件事:调整提交记录的顺序删除你不想要的提交（通过切换 pick 的状态来完成）合并提交。 它允许你把多个提交记录合并成一个。会出现一个交互对话框。对提交记录做个排序（当然你也可以删除某些提交），点击确定看结果，Git 严格按照你在对话框中指定的方式进行了复制。gitrebase -i HEAD~44、经验之谈来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！最后就差把bugFix分支里的工作合并回main分支了。你可以选择通过fast-forward快速合并到main分支上，但这样的话main分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让Git复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用gitrebase -igitcherry-pick来达到目的。1_提交技巧1接下来这种情况也是很常见的：你之前在newImage分支上进行了一次提交，然后又基于它创建了caption分支，然后又提交了一次。此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下newImage中图片的分辨率，尽管那个提交记录并不是最新的了。我们可以通过下面的方法来克服困难：1. 先用gitrebase -i 将提交重新排序, 然后把我们想要修改的提交记录挪到最前2. 然后用gitcommit --amend 来进行一些小修改3. 接着再用gitrebase -i 来将他们调回原来的顺序4. 最后我们把 main 移到修改的最前端(用你自己喜欢的方法), 就大功告成啦！2_提交的技巧2正如你在上面所见到的，我们可以使用rebase -i对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用--amend修改它，然后把它们重新排成我们想要的顺序。但这样做就唯一的问题就是要进行两次排序，而这有可能造成由rebase而导致的冲突。所以最好还是使用git cherry-pick。3_Git Tags相信通过前面的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？当然有了！Git的tag就是干这个用的，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。咱们来看看标签到底是什么样。# 先建立一个标签, 指向提交记录 C1, 表示这是我们 1.0 版本。gittag v1 c1# 不能直接在v1 上面做 commit。所以会进到分离 HEAD 的状态gitcheckout v14_Git Describe由于标签在代码库中起着“锚点”的作用，Git还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是git describe！Git Describe能帮你在提交历史中移动了多次以后找到方向；当你用git bisect（一个查找产生Bug的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时，可能会用到这个命令。git describe的​​语法是：gitdescribe&lt;ref&gt;&lt;ref&gt;可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会使用你目前所在的位置（HEAD）。它输出的结果是这样的：&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;tag表示的是离ref最近的标签，numCommits是表示这个ref与tag相差有多少个提交记录，hash表示的是你所给定的ref所表示的提交记录哈希值的前几位。当ref提交记录上有某个标签时，则只输出标签名称c0[v1]-&gt;c1 -&gt;c3[v2]-&gt;c4(side*)|-&gt;c2(main)gitdescribe main# 会输出：v1_2_gC2gitdescribe side# 会输出：v2_1_gC45、Push &amp; Pull —— Git 远程仓库！远程仓库并不复杂，在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西，但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录。话虽如此，远程仓库却有一系列强大的特性：首先也是最重要的的点，远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力，但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据，你仍可以通过远程仓库拿回你丢失的数据。还有就是，远程让代码社交化了! 既然你的项目被托管到别的地方了，你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)现在用网站来对远程仓库进行可视化操作变得越发流行了(像GitHub)，但远程仓库永远是这些工具的顶梁柱，因此理解其概念非常的重要!1_git clone直到现在，本文都聚焦于本地仓库的操作（branch、merge、rebase等等）。但我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令，它就是git clone。 从技术上来讲，git clone命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从github.com）。gitclone[远程仓库地址]2_远程分支既然你已经看过git clone命令了，咱们深入地看一下发生了什么。你可能注意到的第一个事就是在我们的本地仓库多了一个名为o/main的分支，这种类型的分支就叫远程分支。由于远程分支的特性导致其拥有一些特殊属性。远程分支反映了远程仓库(在你上次和它通信时)的状态。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.远程分支有一个特别的属性，在你切换到远程分支时，自动进入分离 HEAD 状态。Git这么做是出于不能直接在这些分支上进行操作的原因，你必须在别的地方完成你的工作，（更新了远程分支之后）再用远程分享你的工作成果。为什么有o/？你可能想问这些远程分支的前面的o/是什么意思呢？好吧，远程分支有一个命名规范 —— 它们的格式是:&lt;remotename&gt;/&lt;branchname&gt;因此，如果你看到一个名为o/main的分支，那么这个分支就叫main，远程仓库的名称就是o。大多数的开发人员会将它们主要的远程仓库命名为origin，并不是o。这是因为当你用git clone某个仓库时，Git已经帮你把远程仓库的名称设置为origin了不过origin还是太长了，因此简写成o😃 但是要记住，当你使用真正的Git时，你的远程仓库默认为origin!#如果切换到远程分支会怎么样呢？gitcheckout o/main;gitcommit#Git 会变成了分离 HEAD 状态, 当添加新的提交时 o/main 也不会更新（这里只会本地提交）。这是因为 o/main 只有在远程仓库中相应的分支更新了以后才会更新。3_Git FetchGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被Git管理的更新（因此可以分享代码、文件、想法、情书等等）。接下来我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是git fetch。你会看到当我们从远程仓库获取数据时，远程分支也会更新以反映最新的远程仓库。我们已经提及过这一点了。# 这里假设我们有一个远程仓库, 它有两个我们本地仓库中没有的提交。gitfetch[远程仓库地址]# git fetch 后，这两次没有的提交记录会被下载到本地。同时远程分支 o/main 也被更新git fetch完成了仅有的但是很重要的两步:从远程仓库下载本地仓库中缺失的提交记录。更新远程分支指针(如o/main)。git fetch实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。前面说过，远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解git fetch与远程分支之间的关系了吧。git fetch通常通过互联网（使用http://或git://协议) 与远程仓库通信。git fetch 不会做的事git fetch并不会改变你本地仓库的状态。它不会更新你的main分支，也不会修改你磁盘上的文件。理解这一点很重要，因为许多开发人员误以为执行了git fetch以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。不过有能完成该操作的命令:D。所以，你可以将git fetch的理解为单纯的下载操作。4_Git Pull既然我们已经知道了如何用git fetch获取远程的数据，现在我们学习如何将这些变化更新到我们的工作当中。其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:gitcherry-pick o/maingitrebase o/maingitmerge o/main## 等等实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此Git提供了一个专门的命令来完成这两个操作。它就是我们要讲的git pull。# git fetch; git merge o/maingitpull[远程仓库地址]5_Git PushOK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享我的成果呢？嗯，上传自己分享内容与下载他人的分享刚好相反，那与git pull相反的命令是什么呢？git push！git push负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦git push完成，你的朋友们就可以从这个远程仓库下载你分享的成果了！你可以将git push想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……注意 ——git push不带任何参数时的行为与Git的一个名为push.default的配置有关。它的默认值取决于你正使用的Git的版本，但是我使用的是upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。gitpush[远程仓库地址]远程仓库接收了最新的提交，远程仓库中的main分支也被更新到指向C2了，我们的远程分支(o/main)也同样被更新了。所有的分支都同步了！6_偏离的工作现在我们已经知道了如何从其它地方pull提交记录，以及如何push我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？困难来自于远程库提交历史的偏离。在讨论这个问题的细节前，我们先来看一个例子……假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。这种情况下，git push就不知道该如何操作了。如果你执行git push，Git应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？因为这情况（历史偏离）有许多的不确定性，Git是不会允许你push变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。假设此时执行git push，则什么都不会改变，因为命令失败了！git push失败是因为你最新提交的C3基于远程分支中的C1。而远程仓库中该分支已经更新到C2了，所以 Git 拒绝了你的推送请求。那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。有许多方法做到这一点呢，不过最直接的方法就是通过rebase调整你的工作。咱们继续，看看怎么rebase！如果我们在push之前做rebase呢？gitfetch;gitrebase o/main;gitpush我们用git fetch更新了本地仓库中的远程分支，然后用r e b a s e rebaserebase将我们的工作移动到最新的提交记录下，最后再用git push推送到远程仓库。还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用merge尽管git merge不会移动你的工作（它会创建新的合并提交），但是它会告诉Git你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。gitfetch;gitmerge o/main;gitpush我们用git fetch更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用git push把工作推送到远程仓库。很好！但是要敲那么多命令，有没有更简单一点的？当然 —— 前面已经介绍过git pull就是fetch和merge的简写，类似的git pull --rebase就是fetch和rebase的简写！# 跟之前结果一样,但是命令更短了。gitpull --rebase;gitpush# 还可以使用以下常规的,只不过远程和merge一样会产生分叉,不像rebase就一直一条路gitpull;gitpush在开发社区里，有许多关于merge与rebase的讨论。以下是关于rebase的优缺点：优点缺点Rebase 使你的提交树变得很干净，所有的提交都在一条线上Rebase 修改了提交树的历史比如，提交C1可以被rebase到C3之后。这看起来C1中的工作是在C3之后进行的，但实际上是在C3之前。一些开发人员喜欢保留提交历史，因此更偏爱merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱rebase。仁者见仁，智者见智。 😄7_远程服务器拒绝!(Remote Rejected)如果你是在一个大的合作团队中工作，很可能是main被锁定了，需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main，然后试图推送(push)修改，你将会收到这样类似的信息:![远程服务器拒绝]main -&gt;main(TF402455: 不允许推送(push)这个分支;你必须使用pull request来更新这个分支.)为什么会被拒绝?远程服务器拒绝直接推送(push)提交到main，因为策略配置要求pull requests来提交更新.你应该按照流程，新建一个分支，推送(push)这个分支并申请pull request，但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.解决办法新建一个分支feature，推送到远程服务器. 然后reset你的main分支和远程服务器保持一致，否则下次你pull并且他人的提交和你冲突的时候就会有问题.# 创建新分支gitbranch feature# 切换到创建的分支gitcheckout feature# 推送到远程服务器gitpush# 由于推送后主分支会自动跟新分支合并, 需要同步和远程一致gitcheckout maingitreset o/main# 开始操作新分支gitcheckout feature8_远程跟踪分支在前面中有件事儿挺神奇的，Git好像知道main与o/main是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支main和本地的main分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：pull操作时，提交记录会被先下载到o/main上，之后再合并到本地的main分支。隐含的合并目标由这个关联确定的。push操作时，我们把工作从main推到远程仓库中的main分支(同时会更新远程分支o/main) 。这个推送的目的地也是由这种关联确定的！直接了当地讲，main和o/main的关联关系就是由分支的“remote tracking”属性决定的。main被设定为跟踪o/main—— 这意味着为main分支指定了推送的目的地以及拉取后合并的目标。你可能想知道main分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧，当你克隆仓库的时候，Git就自动帮你把这个属性设置好了。当你克隆时，Git会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如o/main）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为main。克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。这也解释了为什么会在克隆的时候会看到下面的输出：localbranch"main"setto track remote branch"o/main"我能自己指定这个属性吗？当然可以啦！你可以让任意分支跟踪o/main，然后该分支会像main分支一样得到隐含的push目的地以及merge的目标。 这意味着你可以在分支totallyNotMain上执行git push，将工作推送到远程仓库的main分支上。有两种方法设置这个属性，第一种就是通过远程分支切换到一个新的分支，执行:gitcheckout -b totallyNotMain o/main就可以创建一个名为totallyNotMain的分支，它跟踪远程分支o/main。另一种设置远程追踪分支的方法就是使用：git branch -u命令，执行：gitbranch -u o/main foo这样foo就会跟踪o/main了。如果当前就在foo分支上，还可以省略foo：gitbranch -u o/main9_Git Push 的参数很好! 既然你知道了远程跟踪分支，我们可以开始揭开git push、fetch和pull的神秘面纱了。我们会逐个介绍这几个命令，它们在理念上是非常相似的。首先来看git push。在远程跟踪中，你已经学到了Git是通过当前所在分支的属性来确定远程仓库以及要push的目的地的。这是未指定参数时的行为，我们可以为push指定参数，语法是：gitpush&lt;remote&gt;&lt;place&gt;&lt;place&gt;参数是什么意思呢？我们稍后会深入其中的细节，先看看例子，这个命令是:gitpush origin main把这个命令翻译过来就是：切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。我们通过“place”参数来告诉Git提交记录来自于main，要推送到远程仓库中的main。它实际就是要同步的两个仓库的位置。需要注意的是，因为我们通过指定参数告诉了Git所有它需要的信息，所以它就忽略了我们所切换分支的属性！同时，如果HEAD处于分离状态，不指定&lt;place&gt;参数会提交失败。&lt;place&gt;参数详解还记得之前说的吧，当为git push指定place参数为main时，我们同时指定了提交记录的来源和去向。你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的foo分支推送到远程仓库中的bar分支。哎，很遗憾Git做不到…… 开个玩笑，别当真！当然是可以的啦 😃Git拥有超强的灵活性（有点过于灵活了）接下来咱们看看是怎么做的……要同时为源和目的地指定&lt;place&gt;的话，只需要用冒号:将二者连起来就可以了：gitpush origin&lt;source&gt;:&lt;destination&gt;这个参数实际的值是个refspec，“refspec”是一个自造的词，意思是Git能识别的位置（比如分支foo或者HEAD~1）一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了，让我们看看演示！记住，source可以是任何Git能识别的位置：gitpush origin foo^:main这是个令人困惑的命令，但是它确实是可以运行的 ——Git将foo^解析为一个位置，上传所有未被包含到远程仓库里main分支中的提交记录。如果你要推送到的目的分支不存在会怎么样呢？没问题！Git会在远程仓库中根据你提供的名称帮你创建这个分支！gitpush origin main:newBranch很赞吧！它是不是很聪明？！ 😛10_Git fetch 的参数我们刚学习了git push的参数，很酷的&lt;place&gt;参数，还有用冒号分隔的refspecs（&lt;source&gt;:&lt;destination&gt;）。 这些参数可以用于git fetch吗？你猜中了！git fetch的参数和git push极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）&lt;place&gt;参数如果你像如下命令这样为git fetch设置 的话：gitfetch origin fooGit会到远程仓库的foo分支上，然后获取所有本地不存在的提交，放到本地的o/foo上。你可能会好奇 —— 为何Git会将新提交放到o/foo而不是放到我本地的foo分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？这里需要Git做一些特殊处理，因为你可能在foo分支上的工作还未完成，你也不想弄乱它。还记得在git fetch里我们讲到的吗 —— 它不会更新你的本地的非远程分支，只是下载提交记录（这样，你就可以对远程分支进行检查或者合并了）。“如果我们指定&lt;source&gt;:&lt;destination&gt;会发生什么呢？”如果你觉得直接更新本地分支很爽，那你就用冒号分隔的refspec吧。不过，你不能在当前切换的分支上干这个事，但是其它分支是可以的。这里有一点是需要注意的 ——source现在指的是远程仓库中的位置，而&lt;destination&gt;才是要放置提交的本地仓库的位置。它与git push刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明fetch和push的相似性，只是方向相反罢了。# Git 将 C2 解析成一个 origin 仓库的位置，然后将那些提交记录下载到了本地的 bar 分支（一个本地分支）上。gitfetch origin C2:bar# 如果执行命令前目标分支不存在跟 git push 一样，Git 会在 fetch 前自己创建立本地分支#如果 git fetch 没有参数，它会下载所有的提交记录到各个远程分支……11_古怪的&lt;source&gt;Git有两种关于&lt;source&gt;的用法是比较诡异的，即你可以在git push或git fetch时不指定任何source，方法就是仅保留冒号和destination部分，source部分留空。gitpush origin :sidegitfetch origin :bugFix我们分别来看一下这两条命令的作用……如果push传空值source到远程仓库会如何呢？它会删除远程仓库中的分支！如果fetch空 到本地，会在本地创建一个新分支。很神奇吧！但无论怎么说，这就是Git！12_Git pull 参数既然你已经掌握关于git fetch和git push参数的方方面面了，关于git pull几乎没有什么可以讲的了 😃因为git pull到头来就是fetch后跟merge的缩写。你可以理解为用同样的参数执行git fetch，然后再merge你所抓取到的提交记录。还可以和其它更复杂的参数一起使用，来看一些例子:以下命令在Git中是等效的:gitpull origin foo#相当于：gitfetch origin foo;gitmerge o/foo还有…gitpull origin bar:bugFix#相当于：gitfetch origin bar:bugFix;gitmerge bugFix看到了? git pull实际上就是fetch + merge的缩写，git pull唯一关注的是提交最终合并到哪里（也就是为git fetch所提供的destination参数）6、总结希望本文可以更好的帮助你在工作中更加有效的使用Git。另外附上一张包含常用 Git 命令大全的表格（来源Chat，不一定完全准确）。命令名称描述用法示例其他相关信息git init初始化一个新的 Git 仓库git init在当前目录创建一个新仓库git clone克隆一个远程仓库到本地git clone https://github.com/user/repo.git可指定目录：git clone &lt;url&gt; &lt;directory&gt;git add将文件添加到暂存区git add filename添加所有更改：git add .git commit提交暂存区中的更改到仓库git commit -m "commit message"添加 -a 参数可以跳过暂存区直接提交所有更改git status显示工作目录和暂存区的状态git status简短输出：git status -sgit log显示提交历史git log查看某一特定提交：git log &lt;commit&gt;git diff显示工作目录和暂存区之间的差异git diff比较暂存区和仓库：git diff --cachedgit branch列出、创建或删除分支git branch创建新分支：git branch new_branchgit checkout切换分支或恢复工作目录文件git checkout branch_name创建并切换新分支：git checkout -b new_branchgit merge将指定分支的更改合并到当前分支git merge branch_name解决冲突后需要再次提交git pull从远程仓库拉取更改并合并到当前分支git pull origin branch_name相当于git fetch+git mergegit push将本地分支的更改推送到远程仓库git push origin branch_name强制推送：git push -f origin branch_namegit remote管理远程仓库git remote -v查看远程仓库：git remote -vgit fetch从远程仓库获取最新的更改，但不合并git fetch origin不会影响当前工作目录git tag列出、创建或删除标签git tag创建新标签：git tag v1.0git stash临时保存当前工作目录的更改git stash恢复更改：git stash popgit reset重置当前 HEAD 到指定的状态git reset --hard HEAD~1软重置：git reset --soft HEAD~1git rebase将当前分支的更改移动到另一个分支上git rebase master交互式：git rebase -i &lt;commit&gt;git cherry-pick将指定的提交应用到当前分支git cherry-pick &lt;commit&gt;处理冲突后需要解决git revert创建一个新的提交来撤销指定的提交git revert &lt;commit&gt;不改变历史记录git reflog显示所有引用日志git reflog用于恢复丢失的提交git submodule管理子模块git submodule add &lt;url&gt; &lt;path&gt;初始化：git submodule initgit config配置 Git 的全局或仓库特定设置git config --global user.name "Your Name"查看配置：git config --listgit blame显示文件的每一行最后修改的提交记录git blame filename显示详细信息：git blame -L 1,10 filenamegit gc清理不必要的文件和优化本地仓库git gc自动运行：git gc --autogit archive创建一个包含指定提交的归档文件git archive --format=zip HEAD &gt; archive.zip支持多种格式：tar, zipgit grep在仓库中搜索指定字符串git grep "search string"搜索特定提交：git grep "search string" &lt;commit&gt;git bisect通过二分查找来定位引入错误的提交git bisect start标记坏提交：git bisect badgit filter-branch重写 Git 仓库的历史git filter-branch --tree-filter 'rm -f password.txt' HEAD小心使用，可能影响历史记录git clean清理未跟踪的文件git clean -f交互式清理：git clean -igit rev-parse解析引用名称或其他字符串为提交的 SHA-1 哈希值git rev-parse HEAD解析分支：git rev-parse --abbrev-ref HEADgit shortlog显示提交日志摘要git shortlog按作者分组：git shortlog -s -n这个表格包含了大部分常用的 Git 命令及其用法示例。如果你有具体的命令需求或需要更多详细信息，请查阅 Git 官方文档。http://www.ppmy.cn/news/1540644.html相关文章Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具关于Damn-Vulnerable-Drone 
Damn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具&amp;#xff0c;广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。 Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构&amp;#xff0c;其中故意留下了各种…阅读更多...施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:07 +0000</pubDate>
    </item>
    <item>
      <title>Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具</title>
      <link>https://www.ppmy.cn/news/1540643.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Damn-Vulnerable-Drone：一款针对无人机安全研究与分析的靶机工具news/2025/10/31 21:29:06/关于Damn-Vulnerable-DroneDamn-Vulnerable-Drone是一款针对无人机安全研究与分析的靶机工具，广大研究人员可以利用该环境工具轻松学习、研究和分析针对无人机安全态势。Damn Vulnerable Drone 基于流行的 ArduPilot/MAVLink 架构，其中故意留下了各种安全缺陷以供网络安全研究人员分析和研究，并以此来提升无人机领域的网络安全态势。与飞行员利用飞行模拟器进行训练类似，我们可以使用 Damn Vulnerable Drone 模拟器深入了解现实世界的无人机系统，了解它们的弱点，并学习有效的方法来更好地提升无人机安全。功能介绍1、基于Docker 的环境：在完全虚拟化的基于 docker 的设置中运行，使其可访问且安全地进行无人机安全实验。2、模拟无线网络：模拟 Wifi（802.11）接口，用于练习无线无人机安全测试。3、机载摄像机流媒体和万向节：通过万向节和配套计算机集成，模拟 RTSP 无人机机载摄像机流媒体。4、配套计算机 Web 界面：通过 Web 界面和模拟串行连接与飞行控制器进行配套计算机配置管理。5、QGroundControl/MAVProxy 集成：一键启动 QGroundControl UI（仅支持 x86 架构）并集成 MAVProxy GCS。6、MAVLink 路由器集成：通过配套计算机 Web 界面上的 MAVLink 路由器进行遥测转发。7、动态飞行记录：完全动态的 Ardupilot 飞行箱日志存储在模拟 SD 卡上。8、管理 Web 控制台：易于使用的模拟器管理 Web 控制台，用于触发场景和无人机飞行状态。9、全面的安全测试场景：非常适合练习各种无人机安全测试技术，从基本的侦察到高级测试。工具架构工具安装步骤 1.添加 docker apt 源：printf '%s\n' "deb https://download.docker.com/linux/debian bullseye stable" | sudo tee /etc/apt/sources.list.d/docker-ce.list步骤 2.导入 GPG 密钥：curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/docker-ce-archive-keyring.gpg步骤 3.更新 apt 存储库：sudo apt update -y步骤 4.安装 Docker 和 Docker Composesudo apt install docker-ce docker-ce-cli containerd.io -y步骤 5.启动 Docker 服务：sudo systemctl enable docker --now步骤 6.为用户添加 docker 权限：sudo usermod -aG docker $USER克隆存储库：git clone https://github.com/nicholasaleks/Damn-Vulnerable-Drone.git &amp;&amp; cd Damn-Vulnerable-Drone工具使用sudo ./start.sh -hUsage: sudo ./start.sh [OPTION]Start the Damn Vulnerable Drone simulator.Options:--wifi      使用虚拟无人机Wi-Fi网络开始模拟--no-wifi   启动模拟，立即访问无人机网络（默认）-h, --help  现实工具帮助信息和退出Example:sudo ./start.sh --wifi      # 使用虚拟Wi-Fi启动sudo ./start.sh --no-wifi   # 不使用虚拟Wi-Fi启动工具使用演示工具演示视频演示视频：【点我观看】许可证协议本项目的开发与发布遵循MIT开源许可协议。项目地址Damn-Vulnerable-Drone：【GitHub传送门】参考资料ArduPilot - Versatile, Trusted, OpenIntroduction · MAVLink Developer Guidehttp://www.ppmy.cn/news/1540643.html相关文章施磊C++ | 进阶学习笔记 | 5.设计模式五、设计模式 这里贴出常用的23中设计模式。视频课程仅包含部分&amp;#xff0c;剩余部分需要找其他课程或者资料进行自学。 
1.设计模式三大类型概述 
C设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践&amp;#xff0c;它们可以帮助开发者编写更加清晰、可维护和可扩展…阅读更多...【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:06 +0000</pubDate>
    </item>
    <item>
      <title>施磊C++ | 进阶学习笔记 | 5.设计模式</title>
      <link>https://www.ppmy.cn/news/1540642.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维施磊C++ | 进阶学习笔记 | 5.设计模式news/2025/10/31 21:29:04/五、设计模式这里贴出常用的23中设计模式。视频课程仅包含部分，剩余部分需要找其他课程或者资料进行自学。1.设计模式三大类型概述C++设计模式是一套被广泛认可的用于解决常见软件设计问题的最佳实践，它们可以帮助开发者编写更加清晰、可维护和可扩展的代码。根据解决的问题类型，设计模式通常被分为三大类：创建型、结构型和行为型。以下是对每一大类的概述及其特点：一、创建型设计模式创建型设计模式主要关注于对象的创建机制，帮助使系统独立于如何创建、组合和表示对象。特点：将对象的创建和使用分离，增加代码的灵活性和可维护性。通过定义创建对象的接口或方法，使得子类或具体实现类可以决定实例化哪个类。常见模式：单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。工厂方法模式（Factory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。建造者模式（Builder）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。原型模式（Prototype）：通过复制现有的实例来创建新的实例，而不是通过新建类。二、结构型设计模式结构型设计模式关注于类和对象的组合，用于形成更大的结构，以解决如何将对象和类组合成较大的结构，同时保持结构的灵活和高效。特点：通过组合和继承等方式，将对象或类组合成更大的结构。强调对象之间的静态关系，以及如何通过不同的组合方式获得更加灵活的程序结构。常见模式：适配器模式（Adapter）：将一个类的接口转换成客户期望的另一个接口。桥接模式（Bridge）：将抽象部分与实现部分分离，使它们可以独立变化。组合模式（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构。装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。外观模式（Facade）：提供一个统一的接口，用来访问子系统中的一群接口。享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。三、行为型设计模式行为型设计模式特别关注对象之间的通信，以及如何通过对象之间的协作来实现特定的功能。特点：强调对象之间的动态关系，以及如何通过对象之间的交互来实现特定的行为。通过定义对象之间的交互规则和通信方式，使得系统更加灵活和可扩展。常见模式：责任链模式（Chain of Responsibility）：为请求创建一个接收者对象的链。命令模式（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化。解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露其内部的表示。中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。备忘录模式（Memento）：在不破坏封装的前提下，捕获并保存一个对象的内部状态，以便在将来的时间点上恢复对象到这个状态。观察者模式（Observer）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。策略模式（Strategy）：定义一系列的算法，把它们一个个封装起来，并使它们可相互替换。模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。综上所述，C++中的创建型、结构型和行为型设计模式各具特点，分别关注于对象的创建、组合以及对象之间的通信和协作。这些设计模式在软件开发中具有重要的应用价值，可以帮助开发者编写更加清晰、可维护和可扩展的代码。2.设计模式三大原则设计模式的三大原则通常指的是开闭原则（Open/Closed Principle）、里氏替换原则（Liskov Substitution Principle）和依赖倒置原则（Dependency Inversion Principle），它们是面向对象设计的基本原则，旨在提高代码的灵活性、可维护性和可扩展性。以下是这三个原则的清晰简洁解释：开闭原则（Open/Closed Principle）解释：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着当需要添加新功能时，应该通过扩展现有代码（例如添加新类、新接口等）来实现，而不是修改已有代码。目的：提高代码的灵活性和可维护性，减少因修改已有代码而引入的潜在错误。里氏替换原则（Liskov Substitution Principle）解释：子类必须能够替换它们的基类而不会导致程序出错。这要求子类必须完全遵守基类所定义的接口契约，即子类在替换基类时，其行为应该与基类保持一致。目的：确保系统的稳定性和可靠性，避免子类破坏基类的行为预期。依赖倒置原则（Dependency Inversion Principle）解释：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这意味着在设计中，应该通过接口或抽象类来定义高层模块和低层模块之间的交互，而不是直接依赖于具体的实现类。目的：降低模块之间的耦合度，提高系统的可扩展性和可维护性。通过依赖抽象而不是具体实现，可以更容易地在不改变高层模块的情况下替换低层模块的实现。这三大原则共同构成了面向对象设计的基础，它们指导我们如何设计更加灵活、可维护和可扩展的软件系统。遵循这些原则，可以帮助我们避免常见的设计问题，提高代码的质量和可维护性。3.单例模式单例模式：一个类不管创建多少次对象，永远只能得到该类型的一个对象的实例常用到的，比如日志模块，数据库模块需要注意的五个点：1、需要将构造函数私有化，这样保证使用者无法通过构造函数创建新的单例对象2、需要定义一个唯一的static实例对象3、需要提供对外的接口返回这个唯一的实例对象4、需要删除拷贝构造函数和赋值运算符重载函数，保证使用者不能通过者二者构造新的对象5、在类内声明了static对象，还需要在类外进行定义分为两类：饿汉式单例模式：还没有获取实例对象，实例对象就已经产生了懒汉式单例模式：唯一的实例对象，直到第一次获取它的时候，才产生（初始化)1.饿汉单例模式饿汉单例模式 一定是线程安全的汉式单例模式在类加载时就创建实例。这种方式的特点是线程安全，因为实例在类加载时就已经被初始化，而类加载是线程安全的（由类加载器保证）。此外，饿汉式单例模式的实现相对简单。然而，它的缺点是即使实例没有被使用，它也会在类加载时被创建，这可能会导致内存浪费。创建步骤：1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;list&gt;#include&lt;mutex&gt;#include&lt;atomic&gt;#include&lt;queue&gt;#include&lt;condition_variable&gt;usingnamespacestd;classSingleton{public:staticSingleton*getInstance()//3.定义接口让用户有办法获取类的唯一实例化对象的方法{return&amp;instance;}private:staticSingleton instance;//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）Singleton(){}// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例Singleton(constSingleton&amp;)=delete;Singleton&amp;operator=(constSingleton&amp;)=delete;};Singleton Singleton::instance;intmain(){//打印出来的p1 p2 p3 都是同一块地址Singleton*p1=Singleton::getInstance();Singleton*p2=Singleton::getInstance();Singleton*p3=Singleton::getInstance();cout&lt;&lt;p1&lt;&lt;" "&lt;&lt;p2&lt;&lt;" "&lt;&lt;p3&lt;&lt;endl;return0;}2.懒汉单例模式懒汉式单例模式在首次使用时才创建实例。这种方式的特点是实现了延迟加载，即只有在需要实例时才创建它，从而节省了内存。把静态变量设置为指针，通过初始化为空的方式不去分配内存，直到使用时（调用get）才去分配内存。创建步骤：1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）3.定义接口让用户有办法获取类的唯一实例化对象的方法，通常返回的都是指针类型#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
using namespace std;class Singleton
{
public:static Singleton* getInstance()//3.定义接口让用户有办法获取类的唯一实例化对象的方法{if (instance == nullptr){instance = new Singleton();}return instance;}
private:static Singleton *instance;//2.定义一个唯一的类的实例对象（既然已经让用户难以调用构造函数，那么类应该提供这个唯一的实例化对象）Singleton(){}// 1.构造函数私有化 使得用户不能随意调用构造函数，没有那么轻易的创建对象的实例Singleton(const Singleton&amp;) = delete;Singleton&amp; operator = (const Singleton&amp;) = delete;
};Singleton* Singleton::instance = nullptr;int main()
{Singleton* p1 = Singleton::getInstance();Singleton* p2 = Singleton::getInstance();Singleton* p3 = Singleton::getInstance();cout &lt;&lt; p1 &lt;&lt; " " &lt;&lt; p2 &lt;&lt; " " &lt;&lt; p3 &lt;&lt; endl;return 0;
}然而，懒汉式单例模式在多线程环境下可能会出现线程安全问题，即多个线程可能会同时创建实例，导致违反单例原则。为了解决这个问题，可以在创建实例的方法上加上同步关键字（synchronized），但这会降低性能。为了解决懒汉式单例模式在多线程环境下的线程安全问题和性能问题，可以采用双重检查锁定（Double-Checked Locking）和volatile关键字。双重检查锁定可以确保在创建实例时只进行一次同步操作，而volatile关键字可以确保变量的可见性和禁止指令重排序，从而避免在创建实例时出现线程安全问题。4.线程安全的懒汉单例模式可重入函数：这个函数还没执行完，可不可以再被调用一次在单线程中不可能发生（除了递归），在多线程中可能，线程1还没运行完，线程2就来运行了如果这个函数可以在多线程环境下直接运行而且不发生竞态条件，那就是可重入函数而懒汉单例模式中，getIntance并不是线程安全的线程1进去了，还没给instance赋值，时间片到了给了线程2，那线程2就给instance赋值了，所以不是可重入函数，所以懒汉单例模式并不是线程安全的1.锁+双重判断#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
using namespace std;mutex mtx;
//锁+双重判断
class Singleton
{
public:static Singleton* getInstance(){//锁的粒度太大了 在单线程环境中也要不停地加锁解锁//lock_guard&lt;mutex&gt; guard(mtx);if (instance == nullptr){//放到if里面，只要创建过，后面就不会进来iflock_guard&lt;mutex&gt; guard(mtx);if (instance == nullptr){instance = new Singleton();/*1.开辟内存2.构造对象3.给instance赋值*/}}return instance;}
private://不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了//注意在下面初始化的时候也要加上volatile关键字static Singleton * volatile instance;Singleton(){}Singleton(const Singleton&amp;) = delete;Singleton&amp; operator = (const Singleton&amp;) = delete;
};Singleton* volatile Singleton::instance = nullptr;int main()
{Singleton* p1 = Singleton::getInstance();Singleton* p2 = Singleton::getInstance();Singleton* p3 = Singleton::getInstance();cout &lt;&lt; p1 &lt;&lt; " " &lt;&lt; p2 &lt;&lt; " " &lt;&lt; p3 &lt;&lt; endl;return 0;
}注意：1.不加volatile的默认情况下，线程会对代码数据段拷贝一份副本，自己看自己的副本，加上以后不拷贝副本，只要instance发生改变，所有线程都能立马看到它改变了2.在下面初始化的时候也要加上volatile关键字3.new具体步骤补充开辟内存：new操作符首先为对象分配足够的内存空间。这是通过调用底层的内存分配函数（如malloc，尽管在 C++ 中更常见的是使用operator new）来完成的。这个步骤确保了对象有足够的空间来存储其数据成员。构造对象：一旦内存被分配，new操作符就会在该内存位置上调用类的构造函数来初始化对象。这是对象实际被“创建”或“构造”的时刻，它的数据成员被赋予初始值（如果有的话）。给instance赋值：最后，new操作符返回指向新构造对象的指针，这个指针随后被赋值给静态成员变量instance。这一步是将新创建的对象与类的静态成员变量关联起来的关键。2.简洁的线程安全懒汉单例模式class Singleton
{
public:static Singleton* getInstance(){static Singleton instance;return &amp;instance;}
private:Singleton(){}Singleton(const Singleton&amp;) = delete;Singleton&amp; operator = (const Singleton&amp;) = delete;
};在C++中，类的静态局部变量的内存确实在程序启动时就已经为其预留，但是变量的初始化会延迟到第一次执行到它所在的代码块，所以这也是一种懒汉单例模式而函数静态局部变量的初始化，在汇编指令上已经自动添加线程互斥指令了，因此不用担心线程安全的问题#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
using namespace std;class Singleton
{
public:static Singleton* getInstance(){static Singleton instance;return &amp;instance;}
private:Singleton(){}Singleton(const Singleton&amp;) = delete;Singleton&amp; operator = (const Singleton&amp;) = delete;
};int main()
{Singleton* p1 = Singleton::getInstance();Singleton* p2 = Singleton::getInstance();Singleton* p3 = Singleton::getInstance();cout &lt;&lt; p1 &lt;&lt; " " &lt;&lt; p2 &lt;&lt; " " &lt;&lt; p3 &lt;&lt; endl;return 0;
}5.简单工厂(Simple Factor)、工厂方法(Factory Method)工厂模式：主要是封装了对象的创建操作1.简单工厂#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;class Car
{
public:Car(string name):_name(name){}virtual void show() = 0;string _name;
};class BMW :public Car
{
public:BMW(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆宝马汽车" &lt;&lt; _name &lt;&lt; endl;}
};class Audi :public Car
{
public:Audi(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆奥迪汽车" &lt;&lt; _name &lt;&lt;endl;}
};enum CarType
{Bmw, AUDI
};class SimpleFactory
{
public:Car* createCar(CarType ct){switch (ct){case Bmw:return new BMW("X1");case AUDI:return new Audi("A6");default:cerr &lt;&lt; "传入工厂的参数不正确:" &lt;&lt; ct &lt;&lt; endl;break;}return nullptr;}
};int main()
{/*1.原来是这样的，但是对于用户来说根本不需要知道什么X1，X6什么的Car* p1 = new BMW("X1");Car* p2 = new Audi("A6");*//*2.SimpleFactory* factory = new SimpleFactory();Car* p1 = factory-&gt;createCar(Bmw);Car* p2 = factory-&gt;createCar(AUDI);p1-&gt;show();p2-&gt;show();*///3.使用智能指针管理资源unique_ptr&lt;SimpleFactory&gt; factory(new SimpleFactory());unique_ptr&lt;Car&gt; p1(factory-&gt;createCar(Bmw));unique_ptr&lt;Car&gt; p2(factory-&gt;createCar(AUDI));p1-&gt;show();p2-&gt;show();return 0;
}该例子中使用SimpleFactory类封装两个汽车类的创建操作一共2种使用方法，即代码中的2种，直接用或者通过智能指针间接用简单工厂模式（Simple Factory）的缺点主要包括以下几个方面：违反开闭原则开闭原则要求软件实体（类、模块、函数等）应该是可扩展的，但不可修改的。然而，在简单工厂模式中，每当需要增加新的产品时，都需要修改工厂类中的判断逻辑，从而违反了开闭原则。高内聚问题简单工厂模式中的工厂类通常负责所有产品的创建，这导致工厂类的职责过重，不符合高内聚的原则。高内聚要求一个模块或类应该只负责一个功能或一个紧密相关的功能集合。不利于扩展和维护由于简单工厂模式中的工厂类集中了所有产品的创建逻辑，随着产品种类的增加，工厂类的逻辑将变得越来越复杂，不利于系统的扩展和维护。当需要添加新产品时，需要修改工厂类的代码，这增加了代码的维护成本。测试困难在简单工厂模式中，由于工厂类与具体产品类之间存在紧密的耦合关系，这增加了单元测试的难度。为了测试某个具体产品类，可能需要先实例化工厂类，并调用其创建方法，这可能会引入不必要的依赖和复杂性。缺乏灵活性简单工厂模式通常使用静态方法或全局方法来创建对象，这限制了对象的创建方式和灵活性。例如，在某些情况下，可能需要使用不同的创建策略或根据不同的上下文创建不同的对象实例，但简单工厂模式无法提供这种灵活性。所以有了工厂方法和抽象工厂2.工厂方法#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;class Car
{
public:Car(string name):_name(name){}virtual void show() = 0;string _name;
};class BMW :public Car
{
public:BMW(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆宝马汽车" &lt;&lt; _name &lt;&lt; endl;}
};class Audi :public Car
{
public:Audi(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆奥迪汽车" &lt;&lt; _name &lt;&lt;endl;}
};class Factory
{
public:virtual Car* createCar(string name) = 0;//这个就是所谓的工厂方法
};class BMWFactory :public Factory
{
public:Car* createCar(string name){return new BMW(name);}
};class AudiFactory :public Factory
{
public:Car* createCar(string name){return new Audi(name);}
};int main()
{unique_ptr&lt;Factory&gt; bmwfty(new BMWFactory());unique_ptr&lt;Factory&gt; audifty(new AudiFactory());unique_ptr&lt;Car&gt; p1(bmwfty-&gt;createCar("X6"));unique_ptr&lt;Car&gt; p2(audifty-&gt;createCar("A8"));p1-&gt;show();p2-&gt;show();return 0;
}Factory的纯虚函数就是工厂方法其实就是对每个类有又单独创建了一个创建它的对象的类，就相当于封装了1.完成了对对象的封装操作2.贴合了软件的开闭原则（对原来已有的功能封闭，对扩展新功能开放）一个工厂对应了一个类的创建，如果类很多的话会导致工厂也很多缺点：灵活性受限工厂方法模式通常用于创建单个产品对象，如果需要创建多个相关或依赖的产品对象，可能需要使用其他模式（如抽象工厂模式）来替代。6.抽象工厂(Abstract Factory)对有一组关联关系的产品簇提供产品对象的统一创建#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;class Car
{
public:Car(string name):_name(name){}virtual void show() = 0;string _name;
};class BMW :public Car
{
public:BMW(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆宝马汽车" &lt;&lt; _name &lt;&lt; endl;}
};class Audi :public Car
{
public:Audi(string name) :Car(name) {}void show(){cout &lt;&lt; "获得了一辆奥迪汽车" &lt;&lt; _name &lt;&lt;endl;}
};//车的相关系列产品 车灯
class Light
{
public:virtual void show() = 0;
};class BmwLight :public Light
{
public:void show() { cout &lt;&lt; " BMW Light" &lt;&lt; endl; }
};class AudiLight :public Light
{
public:void show() { cout &lt;&lt; " Audi Light" &lt;&lt; endl; }
};//抽象工厂 对有一组关联关系的产品簇提供产品对象的统一创建
class AbstractFactory
{
public://这个就是所谓的工厂方法virtual Car* createCar(string name) = 0;//工厂方法 创建车virtual Light* createCarLight() = 0;//工厂方法 创建汽车关联的产品车灯
};class BMWFactory :public AbstractFactory
{
public:Car* createCar(string name){return new BMW(name);}Light* createCarLight(){return new BmwLight();}
};class AudiFactory :public AbstractFactory
{
public:Car* createCar(string name){return new Audi(name);}Light* createCarLight(){return new AudiLight();}
};int main()
{unique_ptr&lt;AbstractFactory&gt; bmwfty(new BMWFactory());unique_ptr&lt;AbstractFactory&gt; audifty(new AudiFactory());unique_ptr&lt;Car&gt; p1(bmwfty-&gt;createCar("X6"));unique_ptr&lt;Car&gt; p2(audifty-&gt;createCar("A8"));unique_ptr&lt;Light&gt; l1(bmwfty-&gt;createCarLight());unique_ptr&lt;Light&gt; l2(audifty-&gt;createCarLight());p1-&gt;show();p2-&gt;show();l1-&gt;show();l2-&gt;show();return 0;
}缺点：不支持单一产品的变化抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。其他的类甚至也要重写AbstractFactory里面新加的这个产品，不然自己的类会变成虚函数，但是实际上其他类本身也不提供这个产品（比如宝马课程生产一个螺丝奥迪可能就没有，这个时候就挺尴尬）小结：简单工厂 Simple Factory :优点：把对象的创建封装在一个接口函数里面,通过传入不同的标识,返回创建的对象客户不用自己负责new对象,不用了解对象创建的详细过程缺点：提供创建对象实例的接口函数不闭合,不能对修改关闭工厂方法 Factory Method优点：Factory基类,提供了一个纯虚函数(创建产品)，定义派生类(具体产品的工厂)负责创建对应的产品,可以做到不同的产品,在不同的工厂里面创建,能够对现有工厂,以及产品的修改关闭缺点：实际上,很多产品是有关联关系的,属于一个产品簇,不应该放在不同的工厂里面去创建,这样一是不符合实际的产品对象创建逻辑,二是工厂类太多了,不好维护抽象工厂 Abstract Factory优点：把有关联关系的,属于一个产品簇的所有产品创建的接口函数,放在一个抽象工厂里面AbstractFactroy，派生类(具体产品的工厂)应该负责创建该产品簇里面所有的产品缺点：抽象工厂模式适用于一组相关产品的创建，但如果只有一个产品发生变化，那么整个工厂都需要进行修改，可能不够灵活。7.代理模式（Proxy）通过代理类，来控制实际对象的访问权限代理模式（Proxy Pattern）是一种结构型设计模式，它提供一个对象的代理，以控制对这个对象的访问。代理对象作为客户端和目标对象之间的中介，客户端通过代理对象间接地访问目标对象。代理模式常用于延迟加载、访问控制、缓存等功能。优点隐藏实现细节：客户端通过代理对象访问目标对象，不需要知道目标对象的具体实现。增强目标对象：可以在不修改目标对象代码的情况下，为目标对象添加额外的功能。控制访问：可以对目标对象的访问进行权限控制。减少系统开销：例如，通过代理实现延迟加载，减少系统资源的消耗。缺点性能损耗：代理对象会增加一层调用开销，虽然这个开销通常很小，但在高性能要求的场景下可能会成为瓶颈。代码复杂度增加：引入代理模式后，系统的代码复杂度会增加。步骤：1.抽象公共类2.委托类（继承自公共类）3.代理类（继承自公共类）4.以组合的方式使用代理对象5.客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;//客户   助理proxy   老板 委托类class VideoSite//1.抽象类
{
public:virtual void freeMovie() = 0;//免费看电影virtual void vipMovie() = 0;//vip看virtual void ticketMovie() = 0;//用券才能看
};class FixBugVideoSite:public VideoSite//2.委托类
{
public:virtual void freeMovie(){cout &lt;&lt; "观看免费电影" &lt;&lt; endl;}virtual void vipMovie(){cout &lt;&lt; "观看vip电影" &lt;&lt; endl;}virtual void ticketMovie(){cout &lt;&lt; "用券观看电影" &lt;&lt; endl;}
};//3.代理类
class FreeVideoSiteProxy :public VideoSite
{
public:FreeVideoSiteProxy() { pVideo = new FixBugVideoSite(); }~FreeVideoSiteProxy() { delete pVideo; }virtual void freeMovie(){pVideo-&gt;freeMovie();//通过代理对象的freemovie访问委托类真正的freemovie}virtual void vipMovie(){cout &lt;&lt; "您目前只是普通用户，需要升级VIP才能观看VIP电影" &lt;&lt; endl;}virtual void ticketMovie(){cout &lt;&lt; "您目前没有券，需要购买电影券才能观看该电影" &lt;&lt; endl;}
private:VideoSite* pVideo;//4.以组合的方式使用代理对象//或者去掉构造和析构，直接调用委托类也行 //FixBugVideoSite Video
};class VipVideoSiteProxy :public VideoSite
{
public:VipVideoSiteProxy() { pVideo = new FixBugVideoSite(); }~VipVideoSiteProxy() { delete pVideo; }virtual void freeMovie(){pVideo-&gt;freeMovie();//通过代理对象的freemovie访问委托类真正的freemovie}virtual void vipMovie(){pVideo-&gt;vipMovie();}virtual void ticketMovie(){cout &lt;&lt; "您目前没有券，需要购买电影券才能观看该电影" &lt;&lt; endl;}
private:VideoSite* pVideo;
};//这些都是通用的API接口，使用的都是基类的指针或者引用 通过多态访问虚函数就是了
void watchMovice(unique_ptr&lt;VideoSite&gt; &amp;ptr)
{ptr-&gt;freeMovie();ptr-&gt;vipMovie();ptr-&gt;ticketMovie();
}int main()
{/*1.只有委托类，没有代理类同一个用户p1看的时候可能就还得对这些调用加if else判断来判断身份从而控制访问权限，什么电影能看，什么不能看，很麻烦，不灵活*/VideoSite* p1 = new FixBugVideoSite();p1-&gt;freeMovie();p1-&gt;vipMovie();p1-&gt;ticketMovie();/*2.通过代理，不同身份的用户可以对不同类型的电影具有不同的访问权限*///第五步，客户直接访问代理对象 相当于客户只能访问助理，不能直接访问老板//游客unique_ptr&lt;VideoSite&gt; p2(new FreeVideoSiteProxy());watchMovice(p2);//VIPunique_ptr&lt;VideoSite&gt; p3(new VipVideoSiteProxy());watchMovice(p3);return 0;
}类和接口的说明：VideoSite：这是一个抽象基类，定义了三个纯虚函数freeMovie、vipMovie和ticketMovie，分别代表观看免费电影、VIP电影和用券观看电影的功能。这个类作为所有视频站点（包括代理和委托）的接口。FixBugVideoSite：这是VideoSite的一个具体实现，即委托类。它实现了所有三个虚函数，分别输出相应的观看信息。这个类代表了一个实际的视频站点，提供了观看电影的具体功能。FreeVideoSiteProxy和VipVideoSiteProxy：这两个类都是VideoSite的代理类。它们各自持有一个指向VideoSite（实际上是FixBugVideoSite）的指针，用于在需要时调用委托类的功能。代理类通过重写虚函数来控制对委托类功能的访问，例如，普通用户（FreeVideoSiteProxy）不能观看VIP电影或用券观看电影，而VIP用户（VipVideoSiteProxy）则可以观看VIP电影，但仍然不能用券观看（在这个例子中，VIP用户是否能用券观看取决于代理类的实现，这里简单地限制了）。委托类和代理类的虚函数都是一样的，都是抽象类里面的函数代理类经过检查发现不合法，没有权限，就不会调用委托类对象8.装饰器模式装饰器模式：主要是增加现有类的功能为了增强现有类的功能，通过实现子类的方式，重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式通过创建一个包装对象（即装饰器）来包裹原始对象，从而可以在运行时动态地给对象添加职责。优点灵活性：可以在不修改原有类的情况下增加新的功能。扩展性：通过组合而非继承来扩展功能，避免了继承带来的高耦合和代码膨胀问题。复用性：装饰器和具体组件可以独立变化，互不干扰。缺点装饰链复杂：如果装饰链太长，调试和维护会变得复杂。性能：因为每次调用都会通过多个装饰器，可能会有一定的性能开销。#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;class Car
{
public:virtual void show() = 0;
};class Bmw :public Car
{
public:void show(){cout &lt;&lt; "这是一辆宝马汽车，配置有：基类配置";}
};class Audi :public Car
{
public:void show(){cout &lt;&lt; "这是一辆奥迪汽车，配置有：基类配置";}
};class Benz :public Car
{
public:void show(){cout &lt;&lt; "这是一辆奔驰汽车，配置有：基类配置";}
};//装饰器的基类 装饰器可以让增加的功能互相组合
class CarDecorator :public Car
{
public:CarDecorator(Car* p) :pCar(p) {}private:Car* pCar;
};//装饰器1 定速巡航
class ConcreteDecorator01 :public Car
{
public:ConcreteDecorator01(Car *p):pCar(p){}void show(){pCar-&gt;show();cout &lt;&lt; ",定速巡航";}
private:Car* pCar;
};//装饰器2 定速巡航
class ConcreteDecorator02 :public Car
{
public:ConcreteDecorator02(Car* p) :pCar(p) {}void show(){pCar-&gt;show();cout &lt;&lt; ",自动刹车";}
private:Car* pCar;
};//装饰器3 车道偏离
class ConcreteDecorator03 :public Car
{
public:ConcreteDecorator03(Car* p) :pCar(p) {}void show(){pCar-&gt;show();cout &lt;&lt; ",车道偏离";}
private:Car* pCar;
};int main()
{Car* p1 = new ConcreteDecorator01(new Bmw());//功能组合p1 = new ConcreteDecorator02(p1);p1 = new ConcreteDecorator03(p1);p1-&gt;show();cout &lt;&lt; endl;Car* p2 = new ConcreteDecorator02(new Audi());p2-&gt;show();cout &lt;&lt; endl;Car* p3 = new ConcreteDecorator03(new Benz());p3-&gt;show();cout &lt;&lt; endl;return 0;
}9.代理和装饰的区别C++中的装饰器模式（Decorator Pattern）和代理模式（Proxy Pattern）都是结构型设计模式，但它们在目的、功能扩展方式、结构修改以及关注点等方面存在显著的区别。一、目的装饰器模式：主要用于动态地为对象添加额外的职责，而不改变其结构。它允许在不改变现有对象代码的情况下，通过创建一系列的装饰器类来增加、扩展或修改对象的功能。代理模式：主要用于控制对其他对象的访问。它在客户端和实际对象之间引入了一个代理对象，客户端通过代理对象访问实际对象。代理对象可以用于控制访问权限、延迟加载、远程访问等。二、功能扩展方式装饰器模式：通过组合多个装饰器类来实现功能扩展。每个装饰器类都实现了与被装饰对象相同的接口，并可以在调用接口方法之前或之后添加额外的行为。代理模式：主要通过代理对象来控制访问，实际功能一般是由被代理对象提供的。代理对象可以在访问实际对象之前或之后添加额外的逻辑，如权限检查、日志记录等。三、结构修改装饰器模式：通常不改变对象的结构，只是在其上添加装饰器。装饰器与被装饰对象具有相同的接口，因此可以替换或组合使用。代理模式：虽然也引入了新的代理对象，但代理对象通常包含了额外的逻辑，这些逻辑在访问实际对象之前或之后执行。此外，代理模式可能会改变客户端与实际对象之间的交互方式。四、关注点装饰器模式：关注于对象的功能增强。它允许在不修改现有代码的情况下，动态地为对象添加新的行为或功能。代理模式：关注于对象的访问控制和管理。它提供了对实际对象访问的间接层，以便在访问过程中添加额外的逻辑或控制。五、应用场景装饰器模式：组件扩展：在大型项目中，随着业务的增加，需要添加新的功能时，装饰器可以避免修改原有的基础组件。API增强：当提供API给第三方调用时，装饰器可以用于添加额外的功能，如日志记录、安全校验等。权限管理：装饰器可以用来控制对原有特定接口的访问权限。缓存机制：在网络请求或数据库查询等操作中，装饰器可以用来添加额外的缓存、重试、超时处理等功能。代理模式：延迟加载：可以在需要时才创建实际对象，节省资源。远程代理：用于控制对远程对象的访问，通常用于网络编程中。保护代理：用于控制对对象的访问权限，增强安全性。缓存/缓冲代理：用于缓存频繁访问的数据，以减少计算或网络请求的开销。智能引用代理：用于管理对象的生命周期，确保对象在不再需要时被正确释放。10.适配器模式适配器模式：让不兼容的接口可以在一起工作适配器模式（Adapter Pattern）是一种结构型设计模式，它允许接口不兼容的类一起工作。适配器模式将类的接口转换成客户端所期望的另一种接口形式，使得原本不兼容的类可以合作无间。优点提高灵活性：通过适配器，客户端可以透明地访问不兼容的接口，提高了系统的灵活性。复用性：适配器使得已有的类可以被复用，而无需修改它们的源代码。解耦：适配器模式有助于将接口和实现解耦，使得系统更加模块化。缺点代码复杂度增加：引入适配器会增加系统的代码量和复杂度。性能损耗：在某些情况下，适配器可能会导致性能上的损耗，因为它需要在客户端和适配对象之间进行额外的转换。#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
using namespace std;//VGA接口的电脑 TV投影仪也是VGA接口
class VGA
{
public:virtual void play() = 0;
};//TV01表示支持VGA接口的投影仪
class TV01 :public VGA
{
public:void play(){cout &lt;&lt; "通过VGA接口连接投影仪，进行视频播放" &lt;&lt; endl;}
};//实现一个电脑类，只支持VGA接口
class Computer
{
public://由于电脑只支持VGA接口，所以该方法的参数也只能支持VGA接口的指针和引用void playVideo(VGA* pVGA){pVGA-&gt;play();}
};//进了一批新的投影仪，都只支持HDMT接口，根本都插不到电脑上
class HDMI
{
public:virtual void play() = 0;
};class TV02 :public HDMI
{
public:void play(){cout &lt;&lt; "通过HDMI接口连接投影仪，进行视频播放" &lt;&lt; endl;}
};//由于电脑(VGA接口)和投影仪(HDMI接口)无法直接相连，所以需要添加适配器类
class VGAToHDMTAdapter :public VGA
{
public:VGAToHDMTAdapter(HDMI *p):pHdmi(p){}//该方法相当于就是转换头，做不同接口的信号转换的void play(){pHdmi-&gt;play();}
private:HDMI* pHdmi;
};int main()
{Computer computer;//电脑本身就支持VGA，通过VGA投影到投影仪上computer.playVideo(new TV01());/*TV02只支持HDMI，不支持AGVcomputer.playVideo(new TV02());表现为VGA*不接受一个TV02指针类型的参数方法1：换一个支持HDMI接口的电脑，这个就叫代码重构方法2：买一个转换头（适配器），能够把VGA信号转成HDMI信号，这是添加适配器类*///通过转换头，可以通过HDMI接口投影仪播放视频computer.playVideo(new VGAToHDMTAdapter(new TV02()));return 0;
}下面是对代码中各个部分的详细讲解：抽象接口定义VGA和HDMI是两个抽象基类，分别定义了具有play()方法的接口。这两个接口代表两种不同的视频输出标准。具体实现类TV01继承自VGA，表示一个支持VGA接口的投影仪，其play()方法实现了通过VGA接口播放视频的功能。TV02继承自HDMI，表示一个支持HDMI接口的投影仪，其play()方法实现了通过HDMI接口播放视频的功能。电脑类Computer类有一个方法playVideo(VGA* pVGA)，这个方法接受一个VGA接口的指针作为参数，并调用该指针的play()方法。这表示电脑只能通过VGA接口播放视频。适配器类VGAToHDMTAdapter类继承自VGA，但它内部持有一个HDMI接口的指针。这个适配器类实现了VGA接口的play()方法，但在这个方法内部，它调用的是内部HDMI接口指针的play()方法。这样，VGAToHDMTAdapter就起到了将HDMI接口转换为VGA接口的作用。11.观察者模式也称为监听者模式或发布-订阅模式它属于行为型模式，而行为型主要关注的是对象之间的通信观察者模式主要关注的是对象的一对多的关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其他对象都能接收到相应的通知观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。优点松耦合：观察者和被观察者之间通过抽象接口进行交互，降低了它们之间的耦合度。灵活性：观察者可以在任何时候增加或删除，而不会影响被观察者的行为。扩展性强：可以在不修改被观察者代码的情况下增加新的观察者。缺点性能开销：如果被观察者状态频繁变化，并且有很多观察者，那么通知所有观察者可能会带来较大的性能开销。内存泄漏风险：如果没有正确管理观察者的生命周期，可能会导致内存泄漏。循环依赖：观察者之间可能相互依赖，导致复杂的依赖关系网。例如：一组数据（数据对象），通过这一组数据生成 曲线图（对象1）/ 柱状图（对象2）/ 圆饼图（对象3）当数据对象改变时，对象1,2,3应该及时收到相应的通知Subject主题有更改的时候，应该及时通知相应的观察者，去处理相应的事件#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;list&gt;
#include&lt;mutex&gt;
#include&lt;atomic&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;memory&gt;
#include&lt;unordered_map&gt;
#include&lt;list&gt;
using namespace std;//观察者抽象类
class Observer
{
public:virtual void handle(int msgid) = 0;
};//第一个观察者实例
class Observer1 :public Observer
{
public:void handle(int msgid){switch (msgid){case 1:cout &lt;&lt; "Observer1 recv 1 msg" &lt;&lt; endl;break;case 2:cout &lt;&lt; "Observer1 recv 2 msg" &lt;&lt; endl;break;default:cout &lt;&lt; "Observer1 recv unkown msg" &lt;&lt; endl;break;}}
};//第二个观察者实例
class Observer2 :public Observer
{
public:void handle(int msgid){switch (msgid){case 2:cout &lt;&lt; "Observer2 recv 2 msg" &lt;&lt; endl;break;default:cout &lt;&lt; "Observer2 recv unkown msg" &lt;&lt; endl;break;}}
};//第三个观察者实例
class Observer3 :public Observer
{
public:void handle(int msgid){switch (msgid){case 1:cout &lt;&lt; "Observer3 recv 1 msg" &lt;&lt; endl;break;case 3:cout &lt;&lt; "Observer3 recv 3 msg" &lt;&lt; endl;break;default:cout &lt;&lt; "Observer3 recv unkown msg" &lt;&lt; endl;break;}}
};//主题类
class Subject
{
public://给主题增加观察者对象void adObserver(Observer* obser, int msgid){_subMap[msgid].push_back(obser);}//主题检测发生改变，通知相应的观察者对象处理事件void dispatch(int msgid){auto it = _subMap.find(msgid);//没找着说明没人对这件事情感兴趣if (it != _subMap.end()){for (Observer* pObser : it-&gt;second){pObser-&gt;handle(msgid);}}}
private:unordered_map&lt;int, list&lt;Observer*&gt;&gt; _subMap;
};int main()
{Subject subject;Observer* p1 = new Observer1();Observer* p2 = new Observer2();Observer* p3 = new Observer3();subject.adObserver(p1, 1);subject.adObserver(p1, 2);subject.adObserver(p2, 2);subject.adObserver(p3, 1);subject.adObserver(p3, 3);int msgid = 0;for (;;){cout &lt;&lt; "输入消息id:" ;cin &gt;&gt; msgid;if (msgid == -1)break;subject.dispatch(msgid);}return 0;
}当主题改变的时候，对消息关注的对象会收到通知http://www.ppmy.cn/news/1540642.html相关文章【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作C语言教程 
嵌入式编程 
1. 介绍与前提条件 
1.1 课程目标 
本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程&amp;#xff0c;学员将掌握高级C语言技巧&amp;#xff0c;能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论&amp;#xff0c;还强调实践&amp;a…阅读更多...【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:05 +0000</pubDate>
    </item>
    <item>
      <title>【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作</title>
      <link>https://www.ppmy.cn/news/1540641.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【C语言教程】【嵌入式编程】（一）介绍与前提条件（二）嵌入式编程基础（三）硬件基础知识（四）硬件寄存器操作news/2025/10/31 21:29:03/C语言教程嵌入式编程1. 介绍与前提条件1.1 课程目标本课程旨在帮助学员深入理解C语言在嵌入式系统开发中的高级用法。通过这一课程，学员将掌握高级C语言技巧，能够在嵌入式环境下开发高效、稳定的系统。课程不仅紧扣理论，还强调实践，帮助学员应对实际开发中的常见挑战。目的：提升对C语言的深入理解，特别是在嵌入式开发中的应用。学习如何有效使用C语言进行硬件编程，涉及硬件交互和设备驱动。实现从概念到实践的转变，通过项目动手实验巩固所学知识。预期成果：获得高级C编程技巧，特别是在内存管理和并发控制方面。能够独立设计和开发嵌入式系统项目。具备调试复杂系统和优化代码性能的能力。1.2 前提条件为了顺利参与本课程，学员应具备以下基础知识与技能：必备知识：熟悉C语言基础语法，理解变量、数据类型、控制结构、指针、数组及结构体等内容。基本的编程能力，能够独立编写简单的C程序。理解计算机基本工作原理，了解多态、动态分配等概念。推荐技能：具备一定的数学和物理知识，这将有助于理解嵌入式硬件交互。了解电子电路基础，能够读懂基本的电路图。具备基本的计算机科学知识，如操作系统和编译原理。1.3 工具与资源为了确保学习的顺利进行，我们建议使用以下集成开发环境（IDE）和硬件设备：软件工具：IDE推荐：Keil、IAR Embedded Workbench、Arduino IDE等。选择一款熟悉的IDE将有助于提高编程效率。调试工具：GNU Debugger (GDB) 或者其他适用于选择的开发板的调试工具。硬件设备：开发板：如STMicroelectronics的STM32系列、Microchip的PIC单片机或Arduino系列等。辅助设备：基础的电子工具箱，包括面包板、跳线、示波器和万用表，以便进行硬件测试与验证。通过以上内容的详细了解和准备，学员将能够顺利进入课程的深入学习阶段。2. 嵌入式编程基础2.1 嵌入式系统概述嵌入式系统是一种专门为特定功能或特定应用而设计的计算机系统，通常是计算机硬件和软件结合在一个单一的设备上。它不同于通用计算机，因为它是针对特定任务的优化，通常功能单一且效率高。应用场景：家用电器：如微波炉、洗衣机、冰箱，这些设备中嵌入式系统用于控制设备的基本功能。工业控制：在工厂自动化设备中，嵌入式系统用于过程控制、数据采集和实时监控。消费电子：智能手机、智能手表等设备中，嵌入式系统管理显示、通信和应用程序。汽车电子：车内计算机用于引擎控制、导航、娱乐系统等。2.2 常见单片机单片机是嵌入式系统的核心组件之一，它是一种集成了CPU、内存（RAM、ROM）、输入输出接口等于一体的芯片。在项目开发过程中，选择合适的单片机是非常重要的。AVR单片机：由Atmel公司开发，如ATmega系列。特点：支持C语言开发，体积小，功耗低，常用于简单的消费电子项目。PIC单片机：由Microchip公司生产，种类丰富。特点：有多种系列支持不同的复杂性，应用于家电控制、传感器接口等。ARM Cortex-M系列：业界广泛使用，由ARM公司授权不同厂商生产。特点：处理能力强，功耗低，适合复杂的嵌入式应用，如物联网设备及医疗设备。2.3 嵌入式开发环境选择一个合适的嵌入式开发环境（IDE）对于顺利进行开发至关重要，它提供了代码编辑、调试、编译等多种功能。以下是几个常用的开发环境：Keil MDK-ARM：特点：支持多种ARM处理器，集成度高，适合ARM Cortex-M系列开发。安装与配置：安装后需要正确配置项目选项以匹配目标处理器。IAR Embedded Workbench：特点：兼容多种架构，优化的编译器，适合商业化项目。安装与配置：提供模板项目，用户可以快速开始开发。Arduino IDE：特点：开源项目，支持Arduino及其他简单的MCU开发，易于学习。安装与配置：界面友好，支持插件安装，可以通过简单配置连接Arduino开发板。使用这些开发环境时，通常需要：获取并安装目标平台的支持包；配置编译器、调试器参数；下载并安装驱动程序以正确连接硬件设备。这些步骤确保开发环境正确识别、编译、下载程序到单片机中，并进行调试验证。通过合理选择工具和配置，开发者能够有效地进行嵌入式项目的开发和维护。3. 硬件基础知识3.1 硬件基础概述在进行嵌入式系统开发时，了解基本的电路原理是必不可少的。以下是一些关键的电路基础知识：电压（Voltage）：电压是电荷通过电路移动的潜在能量差异，通常用伏特（Volt, V）表示。在一条电路上，电压决定了电流的方向和大小。电流（Current）：电流是电荷在电路中流动的速率，通常用安培（Ampere, A）表示。根据欧姆定律，电流与电压和电阻成反比关系：I = V/R。电阻（Resistance）：电阻对电流流动的阻碍程度，通常用欧姆（Ohm, Ω）表示。电阻越大，电流越小。3.2 常用电子元件了解常用电子元件及其功能对于硬件开发至关重要：电阻（Resistor）：限制电流流通的元件，常用于电路分压和限流。电容（Capacitor）：储存电荷的器件，可用于滤波、去耦和能量存储。二极管（Diode）：允许电流单方向流动的元件，常用于整流和保护电路中。晶体管（Transistor）：用于放大和开关信号的基本半导体器件，尤其在信号处理和功率控制中常见。3.3 原理图与PCB设计简介阅读原理图：原理图或电路图是电路设计的基础表达，显示电气元件及其连接方式。关键步骤：熟悉常用符号：了解各电子元件符号如电阻、电容、二极管等。解读信号流：通过识别电气连接线，判断信号流的路径。识别电源和接地：找出电源连接及地线，以便了解电路的整体功能。PCB设计工具简介：PCB（印制电路板）设计是实现电气原理的物理布局，以下介绍一种常用工具：KiCad：一款开源且免费的PCB设计软件，适合从基础到复杂的电路板设计。主要功能包括：原理图捕获（创建和编辑电路原理图）PCB布局设计（将原理图转化为实际的电路板设计）强大的3D渲染功能（帮助设计者直观地查看板子的3D视图）上述内容给出了关于硬件基础知识的概述，包括电路基本理论、常见电子元件与其功能、原理图的阅读方法以及介绍了一种简单易用的PCB设计工具KiCad，提供了从理论到实践的基本指导。4. 硬件寄存器操作硬件寄存器是嵌入式系统中与微处理器相关的一个重要概念。它们位于芯片内部，由多个位构成，用于控制芯片的不同功能模块。4.1 寄存器基础寄存器是用于处理器与外围设备之间数据交换的重要通道。通过访问寄存器，程序可以配置和控制硬件。作用：寄存器是系统中最基本的存储元件，用于存储控制信息、状态信息及数据。访问方法：直接访问：通过指针访问寄存器地址。通过寄存器定义：使用头文件中定义的寄存器符号进行访问。#defineREG_ADDRESS0x40021018// 假设寄存器地址voidexample_register_access(){volatileunsignedint*reg_pointer=(unsignedint*)REG_ADDRESS;// 设置指针*reg_pointer=0x01;// 设置寄存器}4.2 GPIO（通用输入输出）操作GPIO用于通过微控制器与外部环境进行简单的交互，例如开关和LED灯。配置GPIO寄存器：设置GPIO模式（输入/输出/复用/模拟）。配置输出类型（推挽/开漏）。设置上下拉模式（无/上拉/下拉）。实例：LED控制与电平检测#defineGPIO_PORT0x40010800// 假设的GPIO端口地址#defineGPIO_MODER_OFFSET0x00#defineGPIO_ODR_OFFSET0x14voidgpio_led_control(){volatileunsignedint*moder=(unsignedint*)(GPIO_PORT+GPIO_MODER_OFFSET);volatileunsignedint*odr=(unsignedint*)(GPIO_PORT+GPIO_ODR_OFFSET);*moder&amp;=~(0x3&lt;&lt;(2*5));// 清除旧设置*moder|=(0x1&lt;&lt;(2*5));// 设置为输出模式*odr|=(1&lt;&lt;5);// 设置第5位为1，点亮LED}4.3 定时器与计数器定时器用于测量时间间隔，生成定时中断或PWM信号。配置定时器寄存器：设置自动重装值。选取时钟源及分频器。配置中断及事件生成。实例：定时器中断与PWM生成#defineTIMER_BASE0x40012C00#defineTIMER_CR1_OFFSET0x00#defineTIMER_ARR_OFFSET0x2Cvoidtimer_init(){volatileunsignedint*timer_cr1=(unsignedint*)(TIMER_BASE+TIMER_CR1_OFFSET);volatileunsignedint*timer_arr=(unsignedint*)(TIMER_BASE+TIMER_ARR_OFFSET);*timer_arr=1000;// 设置自动重装值*timer_cr1|=0x01;// 启动定时器}4.4 通信接口常见的通信接口包括UART、SPI、I2C等，通过寄存器控制这些接口实现数据交换。UART寄存器配置：设置波特率。配置数据格式（数据位、停止位、校验位）。启用发送/接收。SPI/I2C寄存器配置：设置时钟速度。配置主从模式。启用相关功能。实例：传感器数据读取与显示#defineUART_BASE0x40011000#defineUART_DR_OFFSET0x04voiduart_send_data(uint8_tdata){volatileunsignedint*uart_dr=(unsignedint*)(UART_BASE+UART_DR_OFFSET);*uart_dr=data;// 发送数据}voidread_sensor_data(){uint8_tsensor_data=0x55;// 假设读取到的数据uart_send_data(sensor_data);// 通过UART发送数据}http://www.ppmy.cn/news/1540641.html相关文章【面试11】嵌入式之模电/数电一、基尔霍尔定律 
1.基本概念 &amp;#xff08;1&amp;#xff09;请简述基尔霍夫电流定律&amp;#xff08;KCL&amp;#xff09;的内容。 KEY&amp;#xff1a;对任一节点&amp;#xff0c;在任一时刻&amp;#xff0c;经过&amp;#xff08;流入、流出&amp;#xff09;该节点的所有电流的代数和为零。强调电流的方向性以…阅读更多...100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:03 +0000</pubDate>
    </item>
    <item>
      <title>【面试11】嵌入式之模电/数电</title>
      <link>https://www.ppmy.cn/news/1540640.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【面试11】嵌入式之模电/数电news/2025/10/31 21:29:01/一、基尔霍尔定律1.基本概念（1）请简述基尔霍夫电流定律（KCL）的内容。KEY：对任一节点，在任一时刻，经过（流入、流出）该节点的所有电流的代数和为零。强调电流的方向性以及代数和的概念。（2）请简述基尔霍夫电压定律（KVL）的含义。KEY：对于任一回路，在任一时刻，沿该回路的所有电压的代数和为零。说明电压降的概念，即顺着回路绕行方向，元件上的电压为正，反之则为负。2.实际应用（1）如果电路中有非线性元件，基尔霍夫定律是否仍然适用？KEY：基尔霍夫定律依旧适用。因为基尔霍夫定律是基于电荷守恒和能量守恒等基本原理，与元件的线性或非线性性质无关。但在分析含有非线性元件的电路时，可能需要结合其他特殊方法来求解方程。（2）基尔霍夫定律在电路设计中起到哪些重要作用？KEY：在电路设计过程中，基尔霍夫定律可以帮助设计师确定电路的结构和参数，确保电路能够正常工作。例如，通过 KCL 和 KVL 可以验证电路的连接是否正确，计算电源的容量和电阻的取值，以满足电路的性能要求。同时，在电路的故障诊断和优化方面，基尔霍夫定律也提供了重要的理论依据。二、低通、高通、带通、阻通1.理论知识方面（1）请简述低通滤波器的工作原理。KEY：低通滤波器允许低频信号通过，而对高频信号进行衰减。可以从电路结构（如 RC 低通滤波器）出发，解释电容的阻抗随频率变化的特性，以及如何实现对不同频率信号的不同处理。（2）高通滤波器的特点是什么？KEY：高通滤波器允许高频信号通过，阻止低频信号。说明电阻和电容在高通滤波器中的作用，以及如何根据频率特性曲线来理解高通滤波器的性能。（3）带通滤波器的定义和作用是什么？KEY：带通滤波器允许一定频率范围内的信号通过，而将频率在此范围之外的信号进行衰减。解释带通滤波器的中心频率、带宽等概念，以及在通信、音频处理等领域的应用。（4）带阻滤波器是如何工作的？KEY：带阻滤波器阻止特定频率范围内的信号通过，而让其他频率的信号通过。可以举例说明带阻滤波器在消除特定频率干扰方面的应用。2.实际应用（1）滤波器的主要性能指标有哪些？KEY：包括截止频率、通带增益、阻带衰减、带宽等。解释每个性能指标的含义和重要性，以及如何根据实际需求来选择合适的性能指标。（2）信号处理：KEY：在模拟信号处理中，低通滤波器可用于去除信号中的高频噪声，保留低频有用信号。例如，在音频信号处理中，低通滤波器可以去除高频噪声，使声音更加清晰、柔和。在传感器信号处理中，低通滤波器可以滤除传感器输出信号中的高频干扰，提高信号的准确性。（3）电机控制：KEY：在电机控制系统中，低通滤波器可以用于平滑电机的速度和电流信号，减少噪声和脉动。例如，在直流电机调速系统中，低通滤波器可以滤除速度反馈信号中的高频噪声，提高速度控制的精度。在交流电机变频调速系统中，低通滤波器可以用于平滑电流指令信号，减少电流脉动，提高电机的运行效率和稳定性。三、三极管1.稳压电路（1）简单稳压电路利用三极管的反向击穿特性，可以制作简单的稳压电路。例如，将一个三极管的基极和发射极之间连接一个稳压二极管，当输入电压变化时，三极管的集电极和发射极之间的电压能够保持相对稳定，从而实现对输出电压的稳压作用。这种简单的稳压电路常用于一些对电压稳定性要求不高的电子设备中。（2）串联型稳压电路在串联型稳压电路中，三极管作为调整元件，根据输出电压的变化来调整自身的导通程度，从而保持输出电压的稳定。这种稳压电路具有较高的稳压精度和较好的负载调整能力，广泛应用于各种电子设备的电源电路中。2.放大作用工作原理：三极管是一种电流控制型器件，具有三个电极，分别为基极（b）、集电极（c）和发射极（e）。其核心原理是通过基极电流的微小变化，来控制集电极电流的较大变化，从而实现电流的放大。例如，对于 NPN 型三极管，当基极与发射极之间的电压大于 PN 结的导通电压（硅管约为 0.7V）时，基极有电流流入发射极，此时三极管开始导通。由于三极管内部的特殊结构和载流子的运动，使得集电极电流会随着基极电流的变化而变化，并且集电极电流的变化量是基极电流变化量的 β 倍（β 为三极管的电流放大倍数，通常远大于 1，比如几十、几百甚至更高）。3.振荡电路（1）LC 振荡电路由电感（L）、电容（C）和三极管组成的 LC 振荡电路，可以产生一定频率的交流信号。三极管在电路中起到放大和反馈的作用，使电路能够持续振荡。这种振荡电路常用于无线电通信、信号发生器等设备中，例如收音机的本机振荡器就是一种 LC 振荡电路，用于产生接收信号所需的本振频率。（2）石英晶体振荡电路石英晶体具有非常稳定的谐振频率，将石英晶体与三极管等元件组成的振荡电路，可以产生高度稳定的频率信号。这种振荡电路广泛应用于电子钟表、计算机时钟、频率合成器等对频率稳定性要求较高的设备中。四、放大电路三极管放大电路。五、AD-DC电路数模转换。六、反馈类型反馈类型可根据不同的标准进行分类，主要有以下几种：（1）按反馈的极性分正反馈：反馈的结果使净输入量增加，从而使输出量的变化增大。正反馈电路多应用在电子振荡电路上，例如正弦波振荡器中就需要正反馈来维持振荡。在一些特殊的放大电路中，如果出现正反馈，可能会使电路产生自激现象，影响电路的正常工作，但在振荡器中，自激现象是期望的结果。负反馈：反馈的结果使净输入量减小，从而使输出量的变化减小。负反馈电路在各种高低频放大电路中应用广泛，其可以改善放大器的性能，如提高放大器的稳定性、减小失真、扩展带宽等。（2）按反馈信号和输出信号的关系分电压反馈：反馈信号取自输出电压，即反馈量与输出电压成正比。如果将电路的输出端对地短路，反馈信号消失，则该反馈为电压反馈。电压反馈的作用是稳定输出电压，当负载变化时，通过反馈使输出电压基本保持不变345。电流反馈：反馈信号取自输出电流，即反馈量与输出电流成正比。如果将电路的输出端对地短路，反馈信号依然存在，则该反馈为电流反馈。电流反馈的作用是稳定输出电流，当负载变化时，输出电流基本保持不变，而负载上的电压可能会变化345。（3）按反馈信号和输入信号的关系分串联反馈：反馈信号与输入信号在输入回路中以电压的形式叠加。也就是说，反馈信号与输入信号串联连接到放大器的输入端。在串联反馈中，输入信号和反馈信号在相位上会相互影响，常用于需要提高输入电阻、改善信号传输质量的电路中。并联反馈：反馈信号与输入信号在输入回路中以电流的形式叠加。反馈信号与输入信号并联连接到放大器的输入端。并联反馈会降低输入电阻，常用于需要增加输入信号的电流、提高电路的功率增益的电路中。（4）按反馈信号是交流或直流分交流反馈：反馈信号中只有交流成分，直流成分被隔断。交流反馈主要影响电路的交流性能，如放大倍数、频率响应等。在交流放大电路中，通常需要引入交流反馈来改善电路的性能。直流反馈：反馈信号中只有直流成分，交流成分被隔断。直流反馈主要用于稳定电路的静态工作点，例如在三极管放大电路中，通过引入直流负反馈，可以稳定三极管的基极电流、集电极电流等，从而保证电路在不同的工作条件下都能正常工作。交、直流反馈：反馈信号中既有交流成分又有直流成分。这种反馈方式既可以稳定电路的静态工作点，又可以改善电路的交流性能，在一些对电路性能要求较高的场合经常使用。http://www.ppmy.cn/news/1540640.html相关文章100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合还在为你的菜单项和链接寻找动画效果而感到疲惫吗&amp;#xff1f; 
不用再找了&amp;#xff01;这里列出了 100 多种不同的动画。从简单的到更复杂的&amp;#xff0c;你肯定能找到自己想要的。 
无需 SVG&amp;#xff08;可缩放矢量图形&amp;#xff09;&amp;#xff0c;无需 JavaScript&amp;#xff08;脚…阅读更多...6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:02 +0000</pubDate>
    </item>
    <item>
      <title>100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合</title>
      <link>https://www.ppmy.cn/news/1540639.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维100 种下划线 / 覆盖层动画 | 终极 CSS（层叠样式表）集合news/2025/10/31 21:29:00/还在为你的菜单项和链接寻找动画效果而感到疲惫吗？不用再找了！这里列出了 100 多种不同的动画。从简单的到更复杂的，你肯定能找到自己想要的。无需 SVG（可缩放矢量图形），无需 JavaScript（脚本语言），无需额外标签，无需伪元素，无需关键帧……所有这些动画都是利用背景、过渡效果并且只通过一个元素来实现的。只需添加一个类，就可以享受（这些动画效果）了。不依赖伪元素，所以你可以轻松地将它们用于诸如输入框（我们无法在其中使用伪元素）之类的元素上。关键字：css 特效 动画 样式 纯 css主要效果1.基础效果2.持续效果3.双重效果4.分阶段动画5.突现效果6.圆弧效果7.消融效果8.无限效果9.全方位效果10.厚重11.滑动12.华丽13.倒转14.三维一、基础用法这部分主要介绍了一些基础的动画效果实现方式。通过对一系列类名为basic - *的元素设置不同的背景渐变样式，并利用 CSS 变量和过渡效果，实现了在鼠标悬停时下划线样式的变化。这些效果从简单的单边下划线到复杂的位置变化下划线都有涵盖，为后续更复杂的动画效果奠定了基础。&lt;div class="basic-0"&gt;0. Hover me&lt;/div&gt;
&lt;div class="basic-1"&gt;1. Hover me&lt;/div&gt;
&lt;div class="basic-2"&gt;2. Hover me&lt;/div&gt;
&lt;div class="basic-3"&gt;3. Hover me&lt;/div&gt;
&lt;div class="basic-4"&gt;4. Hover me&lt;/div&gt;
&lt;div class="basic-5"&gt;5. Hover me&lt;/div&gt;
&lt;div class="basic-6"&gt;6. Hover me&lt;/div&gt;.basic-0{background:linear-gradient(currentColor 0 0)0 100% /var(--d,0)3pxno-repeat;}.basic-0:hover{--d:100%;}.basic-1{background:linear-gradient(currentColor 0 0)0 100% /var(--d,0)3pxno-repeat;transition:0.5s;}.basic-1:hover{--d:100%;}.basic-2{background:linear-gradient(currentColor 0 0)100% 100% /var(--d,0)3pxno-repeat;transition:0.5s;}.basic-2:hover{--d:100%;}.basic-3{background:linear-gradient(currentColor 0 0)bottom /var(--d,0)3pxno-repeat;transition:0.5s;}.basic-3:hover{--d:100%;}.basic-4{background:linear-gradient(currentColor 0 0)var(--p,0)100% /var(--d,0)3pxno-repeat;transition:0.3s,background-position 0s 0.3s;}.basic-4:hover{--d:100%;--p:100%;}.basic-5{background:linear-gradient(currentColor 0 0)var(--p,100%)100% /var(--d,0)3px no-repeat;transition:0.3s,background-position 0s 0.3s;}.basic-5:hover{--d:100%;--p:0%;}.basic-6{background:linear-gradient(currentColor 0 0)bottom /var(--d,20%)3pxno-repeat;transition:0.5s;}.basic-6:hover{--d:80%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding-bottom:5px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}查看效果二、边框效果此部分着重展示了围绕元素四周的边框动画效果。通过设置多个线性渐变背景，并结合 CSS 变量和过渡效果，在鼠标悬停时使边框从无到有或发生其他样式变化。这些效果可以用于强调元素的边界，为页面元素添加独特的视觉效果，提升用户对元素的关注度。html:&lt;div class="allsides-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="allsides-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="allsides-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="allsides-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="allsides-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="allsides-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="allsides-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="allsides-8"&gt;8. Hover me &lt;/div&gt;css:.allsides-1{background:linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-1:hover{--d:100%;}.allsides-2{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-2:hover{--d:100%;}.allsides-3{background:linear-gradient(currentColor 0 0)top,linear-gradient(currentColor 0 0)left,linear-gradient(currentColor 0 0)bottom,linear-gradient(currentColor 0 0)right;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-3:hover{--d:100%;}.allsides-4{background:linear-gradient(currentColor 0 0)var(--p,100%)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--d,0)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-4:hover{--d:100%;--p:0%;}.allsides-5{background:linear-gradient(currentColor 0 0)var(--d,0)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--p,100%)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-5:hover{--d:100%;--p:0%;}.allsides-6{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-6:hover{--d:20px;}.allsides-7{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--p,50%)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-7:hover{--d:100%;--p:0%;}.allsides-8{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0;background-size:20px 3px,3px 20px;background-repeat:no-repeat;transition:0.5s;}.allsides-8:hover{background-position:100% 100%,0 0,0 0,100% 100%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}查看效果三、持续效果这部分的动画效果强调了一种持续性的视觉变化。在鼠标悬停相关元素时，通过背景渐变和 CSS 变量的控制，实现了元素边框或下划线等样式的持续改变，给用户一种连贯、流畅的视觉感受，可用于创建具有动态感和交互性的页面元素。查看效果html:&lt;div class="allsides-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="allsides-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="allsides-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="allsides-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="allsides-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="allsides-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="allsides-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="allsides-8"&gt;8. Hover me &lt;/div&gt;css:.allsides-1{background:linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-1:hover{--d:100%;}.allsides-2{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-2:hover{--d:100%;}.allsides-3{background:linear-gradient(currentColor 0 0)top,linear-gradient(currentColor 0 0)left,linear-gradient(currentColor 0 0)bottom,linear-gradient(currentColor 0 0)right;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-3:hover{--d:100%;}.allsides-4{background:linear-gradient(currentColor 0 0)var(--p,100%)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--d,0)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-4:hover{--d:100%;--p:0%;}.allsides-5{background:linear-gradient(currentColor 0 0)var(--d,0)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--p,100%)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-5:hover{--d:100%;--p:0%;}.allsides-6{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-6:hover{--d:20px;}.allsides-7{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--p,50%)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-7:hover{--d:100%;--p:0%;}.allsides-8{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0;background-size:20px 3px,3px 20px;background-repeat:no-repeat;transition:0.5s;}.allsides-8:hover{background-position:100% 100%,0 0,0 0,100% 100%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}四、分段效果主要介绍了分阶段的动画效果。通过设置不同的背景渐变组合以及复杂的过渡效果，在鼠标悬停时，元素的样式会按照设定的阶段逐步发生变化。这种效果可以为用户提供更丰富的交互体验，使元素的动态效果更具层次感和逻辑性。查看效果html:&lt;div class="two-steps-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="two-steps-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="two-steps-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="two-steps-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="two-steps-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="two-steps-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="two-steps-7"&gt;7. Hover me &lt;/div&gt;css:.two-steps-1{background:linear-gradient(currentColor 0 0)var(--p,-100%)100% /50% 3pxno-repeat,linear-gradient(currentColor 0 0)0 100% /var(--d,0)3pxno-repeat;transition:0.3s,background-position 0.3s 0.2s;}.two-steps-1:hover{--d:100%;--p:0%;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-2{background:linear-gradient(currentColor 0 0)var(--p,200%)100% /50% 3pxno-repeat,linear-gradient(currentColor 0 0)100% 100% /var(--d,0)3pxno-repeat;transition:0.3s,background-position 0.3s 0.2s;}.two-steps-2:hover{--d:100%;--p:100%;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-3{background:linear-gradient(currentColor 0 0)var(--p,201%)100% /50% 3pxno-repeat,linear-gradient(90deg,currentColor 50%,transparent 0)bottom /var(--d,0)3px no-repeat;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-3:hover{--d:100%;--p:100%;transition:0.3s,background-position 0.3s 0.2s;}.two-steps-4{background:linear-gradient(currentColor 0 0)var(--p,-100%)100% /50% 3pxno-repeat,linear-gradient(-90deg,currentColor 50%,transparent 0)bottom /var(--d,0)3px no-repeat;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-4:hover{--d:100%;--p:0%;transition:0.3s,background-position 0.3s 0.2s;}.two-steps-5{background:linear-gradient(currentColor 0 0)var(--p,201%)100% /50% 3pxno-repeat,linear-gradient(-90deg,currentColor 50%,transparent 0)bottom /var(--d,0)3px no-repeat;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-5:hover{--d:100%;--p:0%;transition:0.3s,background-position 0.3s 0.2s;}.two-steps-6{background:linear-gradient(currentColor 0 0)var(--p,-101%)100% /50% 3pxno-repeat,linear-gradient(90deg,currentColor 50%,transparent 0)bottom /var(--d,0)3px no-repeat;transition:0.3s,background-size 0.3s 0.3s;}.two-steps-6:hover{--d:100%;--p:100%;transition:0.3s,background-position 0.3s 0.3s;}.two-steps-7{background:linear-gradient(currentColor 0 0)100% 100% /var(--p,0%)3pxno-repeat,linear-gradient(currentColor 0 0)var(--d,-101%)100% /50% 3pxno-repeat;transition:0.3s,background-size 0.3s 0.2s;}.two-steps-7:hover{--d:0%;--p:50%;transition:0.3s,background-position 0.3s 0.2s;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding-bottom:5px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}五、 突现效果此部分聚焦于突现的动画效果。通过对元素背景设置不同的线性或径向渐变，并利用 CSS 变量和特定的过渡效果，在鼠标悬停时使元素的下划线或边框等样式突然出现或发生显著变化，能够快速吸引用户的注意力，增强页面的视觉冲击力。查看效果html:&lt;div class="unexpected-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="unexpected-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="unexpected-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="unexpected-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="unexpected-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="unexpected-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="unexpected-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="unexpected-8"&gt;8. Hover me &lt;/div&gt;css:.unexpected-1{background:linear-gradient(currentColor 0 0)var(--p,50%)100% /var(--d,10%)3px no-repeat;transition:0.3s,background-position 0.3s 0.3s;}.unexpected-1:hover{--d:100%;--p:0%;transition:0.3s,background-size 0.3s 0.3s;}.unexpected-3{background:linear-gradient(currentColor 0 0)leftvar(--p,50%)bottom 0 /var(--d,10%)3px no-repeat,linear-gradient(currentColor 0 0)rightvar(--p,50%)bottom 0 /var(--d,10%)3px no-repeat;transition:0.3s,background-position 0.3s 0.3s;}.unexpected-3:hover{--d:100%;--p:100%;transition:0.3s,background-size 0.3s 0.3s;}.unexpected-2{background:linear-gradient(currentColor 0 0)leftvar(--p,50%)bottom 0 /var(--d,10%)3px no-repeat,linear-gradient(currentColor 0 0)rightvar(--p,50%)bottom 0 /var(--d,10%)3px no-repeat;transition:0.3s,background-position 0.3s 0.3s;}.unexpected-2:hover{--d:50%;--p:50.1%;transition:cubic-bezier(0,500,1,500)0.3s,background-size 0.3s 0.3s;}.unexpected-4{background:linear-gradient(currentColor 0 0)var(--p,50%)100% /var(--d,10%)3px no-repeat;transition:0.3s,background-position 0s;}.unexpected-4:hover{--d:100%;--p:0%;transition:0.3s,background-size 0.3s 0.3s;}.unexpected-5{background:linear-gradient(currentColor 0 0)calc(50% + 10px)100% /20px 3pxno-repeat,linear-gradient(90deg,transparentcalc(100% - 20px),currentColor 0)0 100% /var(--d,50%)3px no-repeat;transition:0.3s;}.unexpected-5:hover{--d:0%;background-position:calc(50% + 0px)100%,0 100%;transition:0.3scubic-bezier(0,-5,1,-5),background-size 0.3s 0.3s;}.unexpected-6{background:linear-gradient(currentColor 0 0)leftvar(--p,50%)bottom 0 /var(--d,20px)3px no-repeat,linear-gradient(currentColor 0 0)rightvar(--p,50%)bottom 0 /var(--d,20px)3px no-repeat;transition:0.3s,background-position 0s;}.unexpected-6:hover{--d:100%;--p:100%;transition:0.3s,background-size 0.3s 0.3s;}.unexpected-7{background:linear-gradient(currentColor 0 0)-20% 100% /var(--p,10%)3px no-repeat;transition:0.5s 0.3scubic-bezier(0,1.25,1,1.8),background-size 0.3s;}.unexpected-7:hover{background-position:50% 100%;--p:50%;transition:0.5scubic-bezier(0,1.25,1,1.8),background-size 0.2s 0.7s;}.unexpected-8{background:linear-gradient(currentColor 0 0)bottom/var(--p,10%)3pxno-repeat;transition:0s;}.unexpected-8:hover{--p:10.1%;transition:0.5scubic-bezier(0,800,1,800);}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding-bottom:5px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}六、圆弧效果这部分展示了基于圆弧的动画效果。通过设置径向渐变背景，并结合 CSS 变量和过渡效果，在鼠标悬停时，元素的下划线或背景装饰呈现出圆弧形状的变化。这些效果可以为页面增添一种圆润、柔和的视觉感受，适用于一些需要营造温馨或优雅氛围的页面设计。查看效果html:&lt;div class="rounded-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="rounded-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="rounded-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="rounded-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="rounded-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="rounded-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="rounded-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="rounded-8"&gt;8. Hover me &lt;/div&gt;css:.rounded-1{background:radial-gradient(circle closest-side,currentColor 90%,transparent)bottom /var(--d,80%)12px repeat-x;transition:0.5s;}.rounded-1:hover{--d:12px;}.rounded-2{background:radial-gradient(circle closest-side,currentColor 90%,transparent)bottom /var(--d,3px)12px repeat-x;transition:0.5s;}.rounded-2:hover{--d:12px;}.rounded-3{background:radial-gradient(circle 7px,currentColor 90%,transparent)bottomvar(--d,-14px)left 50%/12px 14px repeat-x;transition:0.5s;}.rounded-3:hover{--d:-7px;}.rounded-4{background:radial-gradient(circle closest-side,currentColor 80%,transparent)bottomvar(--p1,0px)left 50% /100%var(--p,12px)no-repeat,linear-gradient(currentColor 0 0)bottom 4px left 50% /var(--d,0%)3px no-repeat;transition:0.5s;}.rounded-4:hover{--d:100%;--p:3px;--p1:4px;}.rounded-5{padding-bottom:8px;background:radial-gradient(circle closest-side,currentColor 80%,transparent)bottom 0 leftcalc(50% -var(--d,0px)/ 2)/ 100% 12px no-repeat,radial-gradient(circle closest-side,currentColor 80%,transparent)bottom 0 leftcalc(50% +var(--d,0px)/ 2)/ 100% 12px no-repeat,linear-gradient(currentColor 0 0)bottom /var(--d,0%)12px no-repeat;transition:0.5s;}.rounded-5:hover{--d:50px;}.rounded-6{padding-bottom:8px;background:radial-gradient(circle closest-side,currentColor 80%,transparent)bottom / 12px 12px no-repeat,radial-gradient(circle closest-side,currentColor 80%,transparent)bottom / 12px 12px no-repeat,linear-gradient(currentColor 0 0)bottom left /var(--d,0%)12px no-repeat,linear-gradient(currentColor 0 0)bottom right/var(--d,0%)12px no-repeat;transition:0.3s,background-position 0.3s 0.3s;}.rounded-6:hover{--d:100%;background-position:bottom left,bottom right;transition:0.3s,background-size 0.3s 0.3s;}.rounded-7{padding-bottom:8px;background:radial-gradient(circle closest-side,currentColor 80%,transparent)-12px 100% /12px 12px no-repeat,linear-gradient(currentColor 0 0)bottomleft /var(--d,0)12px no-repeat;transition:0.3s linear;}.rounded-7:hover{--d:50%;background-position:50% 100%,bottom left;}.rounded-8{background:radial-gradient(circle closest-side,currentColor 80%,transparent)var(--d,50%)100% /12px 12px no-repeat;}.rounded-8:hover{--d:50.1%;transition:0.3scubic-bezier(0.5,-900,0.5,900);}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding-bottom:10px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}七、消融效果此部分介绍的是消融类的动画效果。通过设置不同类型的线性和径向渐变背景，结合过渡效果，在鼠标悬停时，元素的下划线或背景装饰呈现出逐渐消失或融合的效果。这种效果可以传达一种动态的、变化的视觉感受，常用于一些需要表现元素的动态性或临时性的场景。查看效果html:&lt;div class="fading-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="fading-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="fading-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="fading-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="fading-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="fading-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="fading-7"&gt;7. Hover me &lt;/div&gt;css:.fading-1{background:linear-gradient(90deg,transparent,black,transparent)bottom /var(--d,0)3px no-repeat;transition:0.5s;}.fading-1:hover{--d:100%;}.fading-2{background:linear-gradient(transparent,black)bottom / 100%var(--d,0)no-repeat;transition:0.5s;}.fading-2:hover{--d:12px;}.fading-3{background:linear-gradient(-45deg,transparentcalc(100% / 3),rgba(0,0,0,0.5),transparentcalc(200% / 3))bottom right/350% 100% no-repeat;transition:0.5s linear;}.fading-3:hover{background-position:bottom left;}.fading-4{background:radial-gradient(transparent 50%,rgba(0,0,0,0.5))center/200% 200%no-repeat;transition:0.5s;}.fading-4:hover{background-size:100% 100%;}.fading-5{background:linear-gradient(-45deg,transparentcalc(100% / 3),rgba(0,0,0,0.5),transparentcalc(200% / 3))bottom right/350% 100% no-repeat;transition:0.5s linear,background-size 0s 0.5s;}.fading-5:hover{background-position:bottom left;background-size:0 0;}.fading-6{background:linear-gradient(90deg,rgba(0,0,0,0.5),transparent 30% 70%,rgba(0,0,0,0.5))center/300% 100% no-repeat;transition:0.5s;}.fading-6:hover{background-size:100% 100%;}.fading-7{background:radial-gradient(farthest-side at bottom,black,transparent)bottom/calc(2 *var(--d,0%))var(--d,0)no-repeat;transition:0.5s;}.fading-7:hover{--d:50%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}body{text-align:center;}八、无限效果这部分着重展示了具有无限循环特点的动画效果。通过设置重复的线性渐变背景，并利用极长的过渡时间和特定的位置变化设置，在鼠标悬停时，元素的下划线或背景装饰呈现出无限循环移动的视觉效果。这种效果可以为页面增添一种动态的、持续的活力感，适用于一些需要强调连续性或重复性的设计场景。查看效果html:&lt;div class="infinite-1"&gt;1. Hover me &lt;/div&gt;&lt;div class="infinite-2"&gt;2. Hover me &lt;/div&gt;&lt;div class="infinite-3"&gt;3. Hover me &lt;/div&gt;&lt;div class="infinite-4"&gt;4. Hover me &lt;/div&gt;&lt;div class="infinite-5"&gt;5. Hover me &lt;/div&gt;&lt;div class="infinite-6"&gt;6. Hover me &lt;/div&gt;&lt;div class="infinite-7"&gt;7. Hover me &lt;/div&gt;&lt;div class="infinite-8"&gt;8. Hover me &lt;/div&gt;css:.infinite-1{background:repeating-linear-gradient(90deg,currentColor 0 15px,transparent 0 30px)bottom left / 2000% 3px no-repeat;transition:99999s linear;}.infinite-1:hover{background-position:bottom right;transition:40s linear;}.infinite-2{background:repeating-linear-gradient(90deg,currentColor 0 15px,transparent 0 30px)bottom right / 2000% 3px no-repeat;transition:99999s linear;}.infinite-2:hover{background-position:bottom left;transition:40s linear;}.infinite-3{background:repeating-linear-gradient(90deg,currentColor 0 15px,transparent 0 30px),repeating-linear-gradient(90deg,currentColor 0 15px,transparent 0 30px);background-position:center bottom;background-size:2000% 3px;background-repeat:no-repeat;transition:99999s linear;}.infinite-3:hover{background-position:bottom left,bottom right;transition:40s linear;}.infinite-4{background:linear-gradient(90deg,currentColor 50%,transparent 0)0 100%/200%3px repeat-x;transition:99999s linear;}.infinite-4:hover{background-position:-8000px 100%;transition:30s;}.infinite-5{background:linear-gradient(90deg,currentColor 50%,transparent 0)0 100%/200%3px repeat-x;transition:99999s linear;}.infinite-5:hover{background-position:8000px 100%;transition:30s;}.infinite-6{background:linear-gradient(90deg,currentColor 30px,transparent 0calc(100% - 30px),currentColor 0),linear-gradient(90deg,currentColor 30px,transparent 0calc(100% - 30px),currentColor0);background-size:200% 3px;background-position:0 100%,0px 100%;background-repeat:repeat-x;transition:99999s linear;}.infinite-6:hover{background-position:10000px 100%,-10000px 100%;transition:30s linear;}.infinite-7{background:linear-gradient(90deg,currentColor 15px,transparent 0calc(100% - 15px),currentColor 0),linear-gradient(90deg,currentColor 15px,transparent 0calc(100% - 15px),currentColor0);background-size:100% 3px;background-position:0 100%,0px 100%;background-repeat:repeat-x;transition:99999s linear;}.infinite-7:hover{background-position:10000px 100%,-10000px 100%;transition:30s linear;}.infinite-8{background:linear-gradient(90deg,transparentcalc(25% - 15px),currentColor 0calc(25% + 15px),transparent 0)0 100%/200% 3px repeat-x;transition:99999s linear;}.infinite-8:hover{background-position:10000px 100%,-10000px 100%;transition:30s linear;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding-bottom:8px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}九、全方位效果此部分再次展示了围绕元素四周的全方位动画效果。通过设置多个线性渐变背景，并结合 CSS 变量和过渡效果，在鼠标悬停时使元素的边框或下划线等样式从各个方向发生变化。这种全方位的效果可以为元素提供一种强烈的视觉强调，使其在页面中更加突出。查看效果html:&lt;div class="allsides-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="allsides-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="allsides-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="allsides-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="allsides-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="allsides-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="allsides-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="allsides-8"&gt;8. Hover me &lt;/div&gt;css:.allsides-1{background:linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-1:hover{--d:100%;}.allsides-2{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-2:hover{--d:100%;}.allsides-3{background:linear-gradient(currentColor 0 0)top,linear-gradient(currentColor 0 0)left,linear-gradient(currentColor 0 0)bottom,linear-gradient(currentColor 0 0)right;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-3:hover{--d:100%;}.allsides-4{background:linear-gradient(currentColor 0 0)var(--p,100%)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--d,0)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-4:hover{--d:100%;--p:0%;}.allsides-5{background:linear-gradient(currentColor 0 0)var(--d,0)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--p,100%)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-5:hover{--d:100%;--p:0%;}.allsides-6{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-6:hover{--d:20px;}.allsides-7{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--p,50%)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-7:hover{--d:100%;--p:0%;}.allsides-8{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0;background-size:20px 3px,3px 20px;background-repeat:no-repeat;transition:0.5s;}.allsides-8:hover{background-position:100% 100%,0 0,0 0,100% 100%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}十、厚重这部分介绍的是厚重感的动画效果。通过设置不同的线性渐变背景和过渡效果，在鼠标悬停时，元素的下划线或背景装饰呈现出一种厚重、实在的视觉效果。这种效果可以为页面元素增添一种沉稳、可靠的感觉，适用于一些需要传达专业或重要信息的页面设计。查看效果html:&lt;div class="thick-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="thick-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="thick-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="thick-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="thick-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="thick-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="thick-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="thick-8"&gt;8. Hover me &lt;/div&gt;css:.thick-1{background:linear-gradient(currentColor 0 0)bottom / 100%var(--d,0px)no-repeat;transition:0.5s;}.thick-1:hover{--d:10px;}.thick-2{background:linear-gradient(#000 0 0)50%calc(-3px - 100%)/var(--d,0%)200% no-repeat;transition:0.3s,background-size 0.3s 0.3s;}.thick-2:hover{--d:100%;background-position:50% 0%;color:#fff;transition:0.3s,background-position 0.3s 0.3s,color 0.3s 0.3s;}.thick-3{background:linear-gradient(#000 0 0)0%calc(-3px - 100%)/var(--d,0%)200%no-repeat;transition:0.3s,background-size 0.3s 0.3s;}.thick-3:hover{--d:100%;background-position:50% 0%;color:#fff;transition:0.3s,background-position 0.3s 0.3s,color 0.3s 0.3s;}.thick-4{background:linear-gradient(#000 0 0)left /var(--d,0%)100% no-repeat,linear-gradient(#000 0 0)right /var(--d,0%)100% no-repeat;transition:0.5s;}.thick-4:hover{--d:100%;color:#fff;}.thick-5{background:linear-gradient(#000 0 0)top / 100%var(--d,0%)no-repeat,linear-gradient(#000 0 0)bottom / 100%var(--d,0%)no-repeat;transition:0.5s;}.thick-5:hover{--d:100%;color:#fff;}.thick-6{background:linear-gradient(#000 0 0)left / 100%var(--d,0%)no-repeat;transition:0.5s;}.thick-6:hover{--d:100%;color:#fff;}.thick-7{background:linear-gradient(#000 0 0)left /var(--d,0%)100% no-repeat;transition:0.5s;}.thick-7:hover{--d:100%;color:#fff;}.thick-8{background:linear-gradient(#000 0 0)top / 100%var(--d,0%)no-repeat;transition:0.5s;}.thick-8:hover{--d:100%;color:#fff;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}body{text-align:center;}十一、滑动此部分主要介绍了滑动类的动画效果。这些效果需要考虑元素的宽度，适用于等宽字体。通过设置文本阴影、缩进以及背景渐变，并结合 CSS 变量和过渡效果，在鼠标悬停时，文本或元素呈现出滑动的视觉效果。这种效果可以为页面增添一种动态的交互感，使元素更加生动有趣。下面（的操作）需要我们知道元素的宽度，所以它更适用于等宽字体，在这种情况下我们可以使用 “ch” 单位。查看效果html:&lt;div class="sliding-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="sliding-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="sliding-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="sliding-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="sliding-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="sliding-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="sliding-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="sliding-8"&gt;8. Hover me &lt;/div&gt;css:.sliding-1{text-shadow:var(--t,0ch)0 #fff;text-indent:calc(-2 *var(--t,0ch));background:linear-gradient(currentColor 0 0)right/var(--d,0)100% no-repeat;transition:0.5s linear;}.sliding-1:hover{--d:100%;--t:11ch;}.sliding-2{white-space:nowrap;overflow:hidden;text-shadow:calc(-1 *var(--t,0ch))0 #fff;text-indent:var(--t,0ch);background:linear-gradient(currentColor 0 0)left/var(--d,0)100% no-repeat;transition:0.5s linear;}.sliding-2:hover{--d:100%;--t:11ch;}.sliding-3{height:1.2em;white-space:nowrap;overflow:hidden;text-shadow:0 -1.2em #fff;line-height:var(--t,1.2em);background:linear-gradient(currentColor 0 0)top/100%var(--d,0)no-repeat;transition:0.5s linear;}.sliding-3:hover{--d:100%;--t:3.6em;}.sliding-4{height:1.2em;white-space:nowrap;overflow:hidden;text-shadow:0calc(-0.5 *var(--t,0em))#fff;line-height:calc(1.2em +var(--t,0em));background:linear-gradient(currentColor 0 0)top/100%var(--d,0)no-repeat;transition:0.5s linear;}.sliding-4:hover{--d:100%;--t:2.4em;}.sliding-5{height:1.2em;color:#fff;text-shadow:0 -1.2em black;line-height:var(--t,3.6em);background:linear-gradient(black 0 0)bottom/100%var(--d,0%)no-repeat;transition:0.5s linear;}.sliding-5:hover{--d:100%;--t:1.2em;}.sliding-6{height:1.2em;color:#fff;text-shadow:0calc(-0.5 *var(--t,2.4em))black;line-height:calc(1.2em +var(--t,2.4em));background:linear-gradient(black 0 0)bottom/100%var(--d,0)no-repeat;transition:0.5s linear;}.sliding-6:hover{--d:100%;--t:0em;}.sliding-7{text-shadow:11ch 0 #fff;text-indent:calc(-2 *var(--t,0px));background:linear-gradient(currentColor 0 0)right/var(--d,0)100% no-repeat;transition:0.5s linear;}.sliding-7:hover{--d:100%;--t:11ch;}.sliding-8{text-shadow:-11ch 0 #fff;text-indent:var(--t,0);background:linear-gradient(currentColor 0 0)left/var(--d,0)100% no-repeat;transition:0.5s linear;}.sliding-8:hover{--d:100%;--t:11ch;}/**/div[class]{display:inline-block;font-size:40px;font-family:monospace;white-space:nowrap;overflow:hidden;margin:25px;width:11ch;cursor:pointer;}body{text-align:center;}十二、华丽这部分再次展示了围绕元素四周的华丽动画效果。通过设置多个线性渐变背景，并结合 CSS 变量和过渡效果，在鼠标悬停时使元素的边框或下划线等样式发生华丽的变化。这些效果可以为页面增添一种奢华、精致的视觉感受，提升页面的整体美观度。查看效果html:&lt;div class="allsides-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="allsides-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="allsides-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="allsides-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="allsides-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="allsides-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="allsides-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="allsides-8"&gt;8. Hover me &lt;/div&gt;css:.allsides-1{background:linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-1:hover{--d:100%;}.allsides-2{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-2:hover{--d:100%;}.allsides-3{background:linear-gradient(currentColor 0 0)top,linear-gradient(currentColor 0 0)left,linear-gradient(currentColor 0 0)bottom,linear-gradient(currentColor 0 0)right;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-3:hover{--d:100%;}.allsides-4{background:linear-gradient(currentColor 0 0)var(--p,100%)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--d,0)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-4:hover{--d:100%;--p:0%;}.allsides-5{background:linear-gradient(currentColor 0 0)var(--d,0)0,linear-gradient(currentColor 0 0)0var(--d,0),linear-gradient(currentColor 0 0)var(--p,100%)100%,linear-gradient(currentColor 0 0)100%var(--p,100%);background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s,background-position 0s 0.5s;}.allsides-5:hover{--d:100%;--p:0%;}.allsides-6{background:linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 0,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--d,0)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-6:hover{--d:20px;}.allsides-7{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 100%,linear-gradient(currentColor 0 0)100% 100%;background-size:var(--p,50%)3px,3pxvar(--d,0);background-repeat:no-repeat;transition:0.5s;}.allsides-7:hover{--d:100%;--p:0%;}.allsides-8{background:linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)0 100%,linear-gradient(currentColor 0 0)100% 0,linear-gradient(currentColor 0 0)100% 0;background-size:20px 3px,3px 20px;background-repeat:no-repeat;transition:0.5s;}.allsides-8:hover{background-position:100% 100%,0 0,0 0,100% 100%;}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}div[class]:nth-child(odd){color:darkblue;}body{text-align:center;}十三、倒转此部分介绍的是倒转类的动画效果。通过设置不同的线性和径向渐变背景，并利用背景裁剪属性以及 CSS 变量和过渡效果，在鼠标悬停时，元素的文本或背景装饰呈现出倒转的视觉效果。这种效果可以为页面增添一种独特的视觉体验，吸引用户的注意力。查看效果html:&lt;div class="inverted-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="inverted-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="inverted-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="inverted-4"&gt;4. Hover me &lt;/div&gt;
&lt;div class="inverted-5"&gt;5. Hover me &lt;/div&gt;
&lt;div class="inverted-6"&gt;6. Hover me &lt;/div&gt;
&lt;div class="inverted-7"&gt;7. Hover me &lt;/div&gt;
&lt;div class="inverted-8"&gt;8. Hover me &lt;/div&gt;css:.inverted-1{background:linear-gradient(black 50%,#fff 0)0var(--_d,0)/ 100% 200% no-repeat,linear-gradient(#0000 50%,#000 0)0var(--_d,0)/ 100% 200% no-repeat;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;transition:0.8s;}.inverted-1:hover{--_d:50%;}.inverted-2{background:linear-gradient(90deg,#000 50%,#fff 0),linear-gradient(-90deg,#000 50%,#fff 0),linear-gradient(90deg,#0000 50%,#000 0),linear-gradient(-90deg,#000050%,#000 0);background-repeat:no-repeat;background-size:200% 51%;background-position:top left,bottom right;-webkit-background-clip:text,text,padding-box,padding-box;background-clip:text,text,padding-box,padding-box;transition:0.8s;}.inverted-2:hover{background-position:top right,bottom left;}.inverted-3{background:linear-gradient(-135deg,#000 50%,#fff 0)var(--_d,100%)/ 250% no-repeat,linear-gradient(-135deg,#0000 50%,#000 0)var(--_d,100%)/ 250% no-repeat;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;transition:0.8s;}.inverted-3:hover{--_d:50%;}.inverted-4{background:linear-gradient(to bottom right,#000 50%,#fff 50.1%)left/300% 300%no-repeat,linear-gradient(to bottom right,#0000 50%,#000 50.1%)left/300%300% no-repeat;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;transition:0.8s;}.inverted-4:hover{background-position:center;}.inverted-5{background:linear-gradient(#000,40%,#fff 0 60%,#000 0)left/var(--_p,0%)no-repeat,linear-gradient(#0000 40%,#000 0 60%,#0000 0)left/var(--_p,0%)no-repeat,#000;-webkit-background-clip:text,padding-box,text;background-clip:text,padding-box,text;transition:0.8s;}.inverted-5:hover{--_p:100%;}.inverted-6{--_g1:conic-gradient(from 90deg at 50% 75%,#000 90deg,#fff 0)no-repeat;--_g2:conic-gradient(from 90deg at 50% 75%,#0000 90deg,#000 0)no-repeat;background:var(--_g1)0calc(134% -var(--_p,0%)),var(--_g2)0calc(134% -var(--_p,0%)),var(--_g1)100%calc(200% -var(--_p,0%)),var(--_g2)100%calc(200% -var(--_p,0%)),#000;background-size:50.2% 400%;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;transition:0.8s;}.inverted-6:hover{--_p:134%;}.inverted-7{background:linear-gradient(-45deg,#000 40%,#fff 0 60%,#000 0)right/300% 100%no-repeat,linear-gradient(-45deg,#0000 40%,#000 0 60%,#0000 0)right/300%100% no-repeat;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;transition:0.8s;}.inverted-7:hover{background-position:left;}.inverted-8{background:linear-gradient(-45deg,#000 40%,#fff 0 60%,#000 0)right/300% 100%no-repeat,linear-gradient(-45deg,#0000 40%,#000 0 60%,#0000 0)right/300%100% no-repeat;-webkit-background-clip:text,padding-box;background-clip:text,padding-box;}.inverted-8:hover{background-position:left;transition:0.8s;}/**/div[class]{color:#0000;font-weight:bold;display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}body{text-align:center;}十四、三维这部分展示了具有三维效果的动画。通过使用一些高级 CSS 技术并借助 CSS 变量进行控制，在鼠标悬停时，元素呈现出类似三维立方体的视觉效果，包括边框和内部填充的变化。这种效果可以为页面增添一种强烈的立体感和空间感，适用于一些需要营造现代、科技感的页面设计。注意：下面（内容）使用了一些高级 CSS（技术），不过我考虑到（使用）CSS 变量，以便于控制。html:&lt;div class="d-1"&gt;1. Hover me &lt;/div&gt;
&lt;div class="d-2"&gt;2. Hover me &lt;/div&gt;
&lt;div class="d-3"&gt;3. Hover me &lt;/div&gt;
&lt;div class="d-4"&gt;4. Hover me &lt;/div&gt;css:.d-1{--b:4px;/* border length*/--c:20px;/* the cube perspective */--g:calc(var(--c)* 0.707);/* 0.707 = cos(45deg) = sin(45deg) */transition:0.5s;border:solid transparent;border-width:var(--b)var(--b)calc(var(--c)+var(--b))calc(var(--c)+var(--b));background:linear-gradient(-45deg,transparentvar(--g),rgba(255,255,255,0.6)0)left /var(--c)100%,linear-gradient(135deg,transparentvar(--g),rgba(255,255,255,0.3)0)bottom / 100%var(--c),conic-gradient(from -90deg at topvar(--b)rightvar(--b),currentColor 270deg,transparent 0),conic-gradient(from 90deg at bottomcalc(var(--c)+var(--b))leftcalc(var(--c)+var(--b)),currentColor 270deg,transparent 0);background-repeat:no-repeat;background-origin:border-box;transform:translate(calc(var(--c)/ -1),calc(var(--c)/ 1));clip-path:polygon(var(--c)0%,var(--c)0%,100% 0%,100%calc(100% -var(--c)),100%calc(100% -var(--c)),var(--c)calc(100% -var(--c)),var(--c)calc(100% -var(--c)));}.d-1:hover{transform:translate(0,0);clip-path:polygon(0%var(--c),var(--c)0%,100% 0%,100%calc(100% -var(--c)),calc(100% -var(--c))100%,0% 100%,0% 100%);}.d-2{--b:4px;/* border length*/--c:20px;/* the cube perspective */--g:calc(var(--c)* 0.707);/* 0.707 = cos(45deg) = sin(45deg) */color:blue;transition:0.5s;border:solid transparent;border-width:var(--b)calc(var(--c)+var(--b))calc(var(--c)+var(--b))var(--b);background:linear-gradient(45deg,transparentvar(--g),rgba(255,255,255,0.6)0)right /var(--c)100%,linear-gradient(-135deg,transparentvar(--g),rgba(255,255,255,0.3)0)bottom / 100%var(--c),conic-gradient(from -180deg at topvar(--b)leftvar(--b),currentColor 270deg,transparent 0),conic-gradient(from 0deg at bottomcalc(var(--c)+var(--b))rightcalc(var(--c)+var(--b)),currentColor 270deg,transparent 0);background-repeat:no-repeat;background-origin:border-box;transform:translate(calc(var(--c)/ 1),calc(var(--c)/ 1));clip-path:polygon(calc(100% -var(--c))0%,calc(100% -var(--c))0%,0% 0%,0%calc(100% -var(--c)),0%calc(100% -var(--c)),calc(100% -var(--c))calc(100% -var(--c)),calc(100% -var(--c))calc(100% -var(--c)));}.d-2:hover{transform:translate(0,0);clip-path:polygon(100%var(--c),calc(100% -var(--c))0%,0% 0%,0%calc(100% -var(--c)),var(--c)100%,100% 100%,100% 100%);}.d-3{--c:20px;/* the cube perspective */--g:calc(var(--c)* 0.707);/* 0.707 = cos(45deg) = sin(45deg) */border:solid transparent;border-width:0var(--c)var(--c)0;background:linear-gradient(45deg,transparentvar(--g),rgba(255,255,255,0.6)0)right /var(--c)100%,linear-gradient(-135deg,transparentvar(--g),rgba(255,255,255,0.3)0)bottom / 100%var(--c);background-repeat:no-repeat;background-origin:border-box;transition:0.3s,background-color 0.3s 0.3s,color 0.3s 0.3s;transform:translate(calc(var(--c)/ 1),calc(var(--c)/ 1));clip-path:polygon(calc(100% -var(--c))0%,calc(100% -var(--c))0%,0% 0%,0%calc(100% -var(--c)),0%calc(100% -var(--c)),calc(100% -var(--c))calc(100% -var(--c)),calc(100% -var(--c))calc(100% -var(--c)));}.d-3:hover{transition:0.3s 0.3s,background-color 0.3s,color 0.3s;background-color:black;color:#fff;transform:translate(0,0);clip-path:polygon(100%var(--c),calc(100% -var(--c))0%,0% 0%,0%calc(100% -var(--c)),var(--c)100%,100% 100%,100% 100%);}.d-4{--c:20px;/* the cube perspective */--g:calc(var(--c)* 0.707);/* 0.707 = cos(45deg) = sin(45deg) */border:solid transparent;border-width:0 0var(--c)var(--c);background:linear-gradient(-45deg,transparentvar(--g),rgba(255,255,255,0.6)0)left /var(--c)100%,linear-gradient(135deg,transparentvar(--g),rgba(255,255,255,0.3)0)bottom / 100%var(--c);background-repeat:no-repeat;background-origin:border-box;transition:0.3s,background-color 0.3s 0.3s,color 0.3s 0.3s;transform:translate(calc(var(--c)/ -1),calc(var(--c)/ 1));clip-path:polygon(var(--c)0%,var(--c)0%,100% 0%,100%calc(100% -var(--c)),100%calc(100% -var(--c)),var(--c)calc(100% -var(--c)),var(--c)calc(100% -var(--c)));}.d-4:hover{transition:0.3s 0.3s,background-color 0.3s,color 0.3s;background-color:blue;color:#fff;transform:translate(0,0);clip-path:polygon(0%var(--c),var(--c)0%,100% 0%,100%calc(100% -var(--c)),calc(100% -var(--c))100%,0% 100%,0% 100%);}/**/div[class]{display:inline-block;font-size:40px;font-family:sans-serif;margin:25px;padding:8px;cursor:pointer;}body{text-align:center;}查看效果http://www.ppmy.cn/news/1540639.html相关文章6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】6、基于Python爬虫LDA决策树的《富士山下》评论数据情感分析【开题源程序论文】 1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载 1、论文目录 
第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解…阅读更多...WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:29:00 +0000</pubDate>
    </item>
    <item>
      <title>6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】</title>
      <link>https://www.ppmy.cn/news/1540638.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】news/2025/10/31 21:28:58/6、基于Python+爬虫+LDA+决策树的《富士山下》评论数据情感分析【开题+源程序+论文】1、论文目录2、项目研究背景及意义3、爬虫代码4、采集数据展示5、分析可视化代码6、下载1、论文目录第一章 绪论
1.1 项目研究背景及意义
1.2 国内外发展现状及存在的问题
1.3 主要研究内容及解决问题
1.4 本文组织结构
第二章 《富士山下》评论数据采集与处理
2.1 《富士山下》评论数据采集
2.2 《富士山下》评论数据预处理
2.2.1 数据去重
2.2.2 数据清洗
2.2.3 分词与词性标注
2.2.4 去除标点符号与停用词
2.2.5 词云图生成
2.3 本章小结
第三章 《富士山下》评论数据探索性分析
3.1 不同情感的文本频率
3.2 共现语义网络分析
3.3 评论与时间关系	
3.4 不同评论设备与情感关系
3.5 本章小结
第四章 模型构建
4.1 基于决策树的情感分类
4.1.1 构造特征空间与标签
4.1.2 训练集与测试集划分
4.1.3 词向量化与特征表示
4.1.4 构建决策树分类器
4.1.5 决策树的可视化
4.2 情感分析
4.2.1导入情感词典
4.2.2 扩展情感词汇
4.2.3合并词库与评论数据
4.2.4 修正情感倾向
4.2.5 计算每条评论的情感值
4.2.6 查看情感分析效果
4.2.7 生成词云图	
4.3 基于 LDA 模型的主题分析
4.3.1 建立词典与语料库
4.3.2 主题数的优化
4.3.3 LDA 主题分析的结果
第五章 总结与展望
5.1 总结
5.2 展望
致谢2、项目研究背景及意义在当今信息化社会中，在线社交平台和音乐平台已成为用户情感表达和观点交流的重要途径。网易云音乐作为中国领先的音乐平台之一，吸引了大量用户通过评论区表达对音乐作品的情感反馈。用户的评论不仅反映了他们对歌曲的态度和感受，也揭示了更广泛的社会情绪。《富士山下》作为粤语经典歌曲之一，在网易云音乐平台上拥有数以万计的评论，这些评论为情感分析提供了丰富的语料。通过分析这些评论数据，研究者能够洞察歌曲引发的情感共鸣，探索用户的情感倾向，并揭示不同群体的情感差异。情感分析作为自然语言处理领域的重要方向，已经在产品评价、社交媒体分析等多个场景中得到广泛应用。通过对文本情感的识别，能够帮助企业优化产品、预测用户行为，甚至分析社会事件的公众情绪。然而，音乐评论的情感分析，尤其是中文环境下的分析，还面临着词汇多样性和语境依赖性等挑战。本研究基于网易云音乐《富士山下》评论数据，旨在通过情感分析和可视化手段，揭示用户在不同维度下的情感变化。研究不仅在音乐情感分析领域具有实践意义，还能够为自然语言处理和情感计算的相关研究提供数据和方法支持。3、爬虫代码4、采集数据展示5、分析可视化代码6、下载1、下方二维码2、wechat/vx：python812146如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “👍点赞” “✍️评论” “💙收藏” 一键三连哦！👇🏻👇🏻👇🏻关注我| 获取更多源码 | 定制源码，大学生毕设模板、期末大作业模板 、Echarts大数据可视化、爬虫逆向等! 「一起探讨 ，互相学习」！以上内容技术相关问题😈欢迎一起交流学习👇🏻👇🏻👇🏻🔥http://www.ppmy.cn/news/1540638.html相关文章WSL2配置代理解决git网络不通畅的问题简述 
书接上文&amp;#xff0c;在WSL2下使用CrossSim&amp;#xff0c;git的时候网络很差&amp;#xff0c;通过代理解决这个问题。 旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口&amp;#xff0c;这样有时候并不能访问&amp;#xff0c;并且一般会出现该问题&amp;#xff1a;ws…阅读更多...【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:58 +0000</pubDate>
    </item>
    <item>
      <title>WSL2配置代理解决git网络不通畅的问题</title>
      <link>https://www.ppmy.cn/news/1540637.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维WSL2配置代理解决git网络不通畅的问题news/2025/10/31 21:28:56/简述书接上文，在WSL2下使用CrossSim，git的时候网络很差，通过代理解决这个问题。旧版的解决方案一般是通过cat /etc/resolv.conf获取IP然后配置主机的端口，这样有时候并不能访问，并且一般会出现该问题：wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。解决在win11下，wsl更新后可以通过手动写.wslconfig强制wsl走win的代理。在C:\Users\&lt;your_username&gt;路径下新建一个.wslconfig文件，记得打开文件后缀，把txt后缀删除，然后在文件中输入以下内容：[experimental]networkingMode=mirroreddnsTunneling=truefirewall=trueautoProxy=true保存文件后，重启wsl即可。wsl --shutdown
wsl这样在wsl下也可以走windows开启的代理了。http://www.ppmy.cn/news/1540637.html相关文章【C语言】TCP接收已知长度的数据在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤： 1. 创建套接字（socket）。 2. 绑定套接字到指定的IP和端口。 3. 监听连接请求。 4. 接受连接请求。 5. 接收数据。 下例展示了一个简单的TCP服务器，用于接收已知长度的数据： 
#include &lt;stdio.h&gt;
#includ…阅读更多...机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:56 +0000</pubDate>
    </item>
    <item>
      <title>【C语言】TCP接收已知长度的数据</title>
      <link>https://www.ppmy.cn/news/1540636.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【C语言】TCP接收已知长度的数据news/2025/10/31 21:28:54/在C语言中，通过TCP接收已知长度的数据通常涉及以下几个步骤：1. 创建套接字（socket）。2. 绑定套接字到指定的IP和端口。3. 监听连接请求。4. 接受连接请求。5. 接收数据。下例展示了一个简单的TCP服务器，用于接收已知长度的数据：#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;#define PORT 8080
#define BUFF_SIZE 1024void error_handling(char *message) {
    perror(message);
    exit(1);
}int main() {
    int server_sock, client_sock;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_size;
    char buffer[BUFF_SIZE];
    int recv_len, total_recv_len = 0;
    int data_length = 1024; // 已知数据长度    server_sock = socket(PF_INET, SOCK_STREAM, 0);
    ifhttp://www.ppmy.cn/news/1540636.html相关文章机器学习中的优化算法-2-随机优化技术随机优化技术 
随机优化技术将随机性引入搜索过程&amp;#xff0c;这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。 
模拟退火&amp;#xff1a;受冶金学退火过程的启发&amp;#xff0c;该技术从高温&amp;#xff08;高随机性&amp;#xff09;开始&amp;#xff0c;允许广泛探索搜索空间。随…阅读更多...深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:54 +0000</pubDate>
    </item>
    <item>
      <title>机器学习中的优化算法-2-随机优化技术</title>
      <link>https://www.ppmy.cn/news/1540635.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维机器学习中的优化算法-2-随机优化技术news/2025/10/31 21:28:52/随机优化技术随机优化技术将随机性引入搜索过程，这对于解决传统方法可能难以解决的复杂非凸优化问题可能有利。模拟退火：受冶金学退火过程的启发，该技术从高温（高随机性）开始，允许广泛探索搜索空间。随着时间的推移，温度降低（随机性降低），模仿金属的冷却，这有助于算法收敛到更好的解决方案，同时避免局部最小值。随机搜索：这种简单的方法在搜索空间中随机选择点，然后对它们进行评估。尽管它可能看起来很幼稚，但随机搜索实际上非常有效，特别是对于高维或知之甚少的优化环境。这种方法易于实现，而且能够作为更复杂算法的基准，因此很有吸引力。此外，随机搜索也可能成为使用其他优化方法的更广泛策略的一部分。使用随机优化算法时，必须考虑以下实际方面：重复评估：随机优化算法通常需要对目标函数进行重复评估，这可能非常耗时。因此，平衡评估数量与可用计算资源至关重要。问题结构：随机优化算法的选择取决于问题的结构。例如，模拟退火适用于具有多个局部最优值的问题，而随机搜索对高维优化景观有效。1.3进化算法进化算法受到自然选择的启发，包括遗传算法和差分进化等技术。它们通常用于解决使用传统方法难以或无法解决的复杂优化问题。关键组件：总体：优化问题的一组候选解决方案。Fitness Function：评估每个候选解决方案质量的函数。选择：一种用于选择要复制的最适候选者的机制。Genetic Operators：修改所选候选者以创建新的后代的运算符，例如交叉和突变。终止：停止算法的条件，例如达到最大代数或令人满意的适应度。1.3.1遗传算法这些算法使用 crossover 和 mutation 运算符来进化种群。通常用于通过依赖生物启发的运算符（如 mutation、crossover 和 selection）为优化和搜索问题生成高质量的解决方案。import numpy as np# Define the gradient function for f(x) = x^2
def gradient(x):return 2 * x# Gradient descent optimization function
def gradient_descent(gradient, start, learn_rate, n_iter=50, tolerance=1e-06):vector = startfor _ in range(n_iter):diff = -learn_rate * gradient(vector)if np.all(np.abs(diff) &lt;= tolerance):breakvector += diffreturn vector# Initial point
start = 5.0
# Learning rate
learn_rate = 0.1
# Number of iterations
n_iter = 50
# Tolerance for convergence
tolerance = 1e-6# Gradient descent optimization
result = gradient_descent(gradient, start, learn_rate, n_iter, tolerance)
print(result)http://www.ppmy.cn/news/1540635.html相关文章深入理解 KMP 算法《深入理解 KMP 算法》 
在计算机科学中&amp;#xff0c;字符串匹配是一个常见且重要的问题&amp;#xff0c;而 KMP&amp;#xff08;Knuth - Morris - Pratt&amp;#xff09;算法则是一种高效的字符串匹配算法。 
一、KMP 算法的背景 
在传统的字符串匹配算法中&amp;#xff0c;当遇到不匹配的字符时…阅读更多...第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...vLLM 大模型推理引擎调研文档文章目录 介绍vLLM 速度很快vLLM 灵活且易于使用 使用和部署离线批量推理在线推理服务 分布式推理服务如何确定分布式推理策略?多节点推理和服务-Ray集群 量化支持模型量化KV Cache 量化 性能调优PagedAttentionAutomatic prefix cachingBatching 策略PreemptionChunked Prefi…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:53 +0000</pubDate>
    </item>
    <item>
      <title>深入理解 KMP 算法</title>
      <link>https://www.ppmy.cn/news/1540634.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深入理解 KMP 算法news/2025/10/31 21:28:51/《深入理解 KMP 算法》在计算机科学中，字符串匹配是一个常见且重要的问题，而 KMP（Knuth - Morris - Pratt）算法则是一种高效的字符串匹配算法。一、KMP 算法的背景在传统的字符串匹配算法中，当遇到不匹配的字符时，模式串会回溯到起始位置重新开始匹配。然而，这种回溯方式在某些情况下会导致大量的不必要计算。KMP 算法的出现正是为了避免这种无效的回溯，提高字符串匹配的效率。二、KMP 算法的核心思想KMP 算法的关键在于利用模式串本身的特征，提前计算出一个“部分匹配表”（也称为“next 数组”）。这个部分匹配表记录了模式串中每个位置之前的子串的最长前缀和最长后缀相等的长度。当在主串中进行匹配时，如果遇到不匹配的字符，根据部分匹配表，模式串可以直接向前移动一定的位置，而不是回溯到开头。这样就大大减少了比较的次数。三、部分匹配表（next 数组）的计算初始化对于模式串的第一个字符，其部分匹配值为 0。迭代计算从模式串的第二个字符开始，依次计算每个字符的部分匹配值。假设当前位置为 i，通过比较当前字符之前的子串的前缀和后缀，找到最长的相等前缀和后缀，其长度就是 i 位置的部分匹配值。例如，对于模式串“ABABCABAA”：位置 1：部分匹配值为 0。位置 2：“A”与“AB”的前缀和后缀都不相等，部分匹配值为 0。位置 3：“AB”与“ABA”的前缀“AB”和后缀“AB”相等，部分匹配值为 2。以此类推，可以计算出整个模式串的部分匹配表。四、KMP 算法的匹配过程首先，将模式串与主串的起始位置对齐。逐个字符进行比较，如果字符匹配，则继续比较下一个字符。如果遇到不匹配的字符，根据部分匹配表，将模式串向右移动相应的位置，然后继续比较。重复这个过程，直到找到匹配的位置或者遍历完主串。五、KMP 算法的优势与传统的字符串匹配算法相比，KMP 算法在最坏情况下的时间复杂度为 O(n + m)，其中 n 是主串的长度，m 是模式串的长度。它避免了大量的回溯操作，大大提高了匹配效率，尤其在处理长字符串和复杂模式串时，优势更加明显。六、KMP 算法的应用KMP 算法在许多领域都有广泛的应用，比如文本编辑器中的查找替换功能、搜索引擎中的字符串匹配、生物信息学中的序列比对等。总之，KMP 算法是一种非常重要的字符串匹配算法，它的核心思想和实现方法对于理解计算机科学中的字符串处理和算法设计具有重要的意义。通过深入学习和掌握 KMP 算法，我们可以更好地解决实际中的字符串匹配问题，提高程序的性能和效率。推荐几款学习编程的免费平台免费在线开发平台（https://docs.ltpp.vip/LTPP/）探索编程世界的新天地，为学生和开发者精心打造的编程平台，现已盛大开启！这个平台汇集了近4000道精心设计的编程题目，覆盖了C、C++、JavaScript、TypeScript、Go、Rust、PHP、Java、Ruby、Python3以及C#等众多编程语言，为您的编程学习之旅提供了一个全面而丰富的实践环境。在这里，您不仅可以查看自己的代码记录，还能轻松地在云端保存和运行代码，让编程变得更加便捷。平台还提供了私聊和群聊功能，让您可以与同行们无障碍交流，分享文件，共同进步。不仅如此，您还可以通过阅读文章、参与问答板块和在线商店，进一步拓展您的知识边界。为了提升您的编程技能，平台还设有每日一题、精选题单以及激动人心的编程竞赛，这些都是备考编程考试的绝佳资源。更令人兴奋的是，您还可以自定义系统UI，选择视频或图片作为背景，打造一个完全个性化的编码环境，让您的编程之旅既有趣又充满挑战。免费公益服务器（https://docs.ltpp.vip/LTPP-SHARE/linux.html）作为开发者或学生，您是否经常因为搭建和维护编程环境而感到头疼？现在，您不必再为此烦恼，因为一款全新的免费公共服务器已经为您解决了所有问题。这款服务器内置了多种编程语言的编程环境，并且配备了功能强大的在线版VS Code，让您可以随时随地在线编写代码，无需进行任何复杂的配置。随时随地，云端编码无论您身在何处，只要有网络连接，就可以通过浏览器访问这款公共服务器，开始您的编程之旅。这种云端编码的便利性，让您的学习或开发工作不再受限于特定的设备或环境。丰富的编程语言支持服务器支持包括C、C++、JavaScript、TypeScript、Go、Rust、PHP、Java、Ruby、Python3以及C#等在内的多种主流编程语言，满足不同开发者和学生的需求。无论您是初学者还是资深开发者，都能找到适合自己的编程环境。在线版VS Code，高效开发内置的在线版VS Code提供了与本地VS Code相似的编辑体验，包括代码高亮、智能提示、代码调试等功能，让您即使在云端也能享受到高效的开发体验。数据隐私和安全提醒虽然服务器是免费的，但为了保护您的数据隐私和安全，我们建议您不要上传任何敏感或重要的数据。这款服务器更适合用于学习和实验，而非存储重要信息。免费公益MYSQL（https://docs.ltpp.vip/LTPP-SHARE/mysql.html）作为一名开发者或学生，数据库环境的搭建和维护往往是一个复杂且耗时的过程。但不用担心，现在有一款免费的MySQL服务器，专为解决您的烦恼而设计，让数据库的使用变得简单而高效。性能卓越，满足需求虽然它是免费的，但性能绝不打折。服务器提供了稳定且高效的数据库服务，能够满足大多数开发和学习场景的需求。在线phpMyAdmin，管理更便捷内置的在线phpMyAdmin管理面板，提供了一个直观且功能强大的用户界面，让您可以轻松地查看、编辑和管理数据库。数据隐私提醒，安全第一正如您所知，这是一项公共资源，因此我们强烈建议不要上传任何敏感或重要的数据。请将此服务器仅用于学习和实验目的，以确保您的数据安全。免费在线WEB代码编辑器（https://docs.ltpp.vip/LTPP-WEB-IDE/）无论你是开发者还是学生，编程环境的搭建和管理可能会占用你宝贵的时间和精力。现在，有一款强大的免费在线代码编辑器，支持多种编程语言，让您可以随时随地编写和运行代码，提升编程效率，专注于创意和开发。多语言支持，无缝切换这款在线代码编辑器支持包括C、C++、JavaScript、TypeScript、Go、Rust、PHP、Java、Ruby、Python3以及C#在内的多种编程语言，无论您的项目需要哪种语言，都能在这里找到支持。在线运行，快速定位问题您可以在编写代码的同时，即时运行并查看结果，快速定位并解决问题，提高开发效率。代码高亮与智能提示编辑器提供代码高亮和智能提示功能，帮助您更快地编写代码，减少错误，提升编码质量。免费二维码生成器（https://docs.ltpp.vip/LTPP-QRCODE/）二维码（QR Code）是一种二维条码，能够存储更多信息，并且可以通过智能手机等设备快速扫描识别。它广泛应用于各种场景，如：企业宣传企业可以通过二维码分享公司网站、产品信息、服务介绍等。活动推广活动组织者可以创建二维码，参与者扫描后可以直接访问活动详情、报名链接或获取电子门票。个人信息分享个人可以生成包含联系方式、社交媒体链接、个人简历等信息的二维码。电子商务商家使用二维码进行商品追踪、促销活动、在线支付等。教育教师可以创建二维码，学生扫描后可以直接访问学习资料或在线课程。交通出行二维码用于公共交通的票务系统，乘客扫描二维码即可进出站或支付车费。        功能强大的二维码生成器通常具备用户界面友好，操作简单，即使是初学者也能快速上手和生成的二维码可以在各种设备和操作系统上扫描识别的特点。http://www.ppmy.cn/news/1540634.html相关文章第十七周周报：YOLO-v2、YOLO-v3目录 
摘要 
Abstract 
一、YOLO-v2 
1.1 总体结构 
1.2 改进 
二、YOLO-v3 
2.1 总体结构 
2.2 改进 
2.3 代码 
总结 摘要 
本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型&amp;#xff0c;同时也是YOLO系列的巅峰之作&amp;#xff0c;在后期作者依然对YOLO进行不断地优化&amp;#xff…阅读更多...OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...vLLM 大模型推理引擎调研文档文章目录 介绍vLLM 速度很快vLLM 灵活且易于使用 使用和部署离线批量推理在线推理服务 分布式推理服务如何确定分布式推理策略?多节点推理和服务-Ray集群 量化支持模型量化KV Cache 量化 性能调优PagedAttentionAutomatic prefix cachingBatching 策略PreemptionChunked Prefi…阅读更多...SpringBoot构建的智能健康生活助手4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:51 +0000</pubDate>
    </item>
    <item>
      <title>第十七周周报：YOLO-v2、YOLO-v3</title>
      <link>https://www.ppmy.cn/news/1540633.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维第十七周周报：YOLO-v2、YOLO-v3news/2025/10/31 21:28:48/目录摘要Abstract一、YOLO-v21.1 总体结构1.2 改进二、YOLO-v32.1 总体结构2.2 改进2.3 代码总结摘要本周主要学习了YOLO-v2、YOLO-v3两个目标检测模型，同时也是YOLO系列的巅峰之作，在后期作者依然对YOLO进行不断地优化，使其仍然是目前最优秀的目标检测网络之一。本篇博客主要介绍YOLO-v2和YOLO-v3做了哪些改进使该模型拥有更好的效果。最后，复现了YOLO-v3的PyTorch代码，实现了对图片的目标检测任务。AbstractThis week, I mainly studied two object detection models, YOLO-v2 and YOLO-v3, which are also the pinnacle of the YOLO series. In the later stage, the author continued to optimize YOLO, making it still one of the best object detection networks currently available. This blog mainly introduces the improvements made by YOLO-v2 and YOLO-v3 to improve the performance of the model. Finally, the PyTorch code of YOLO-v3 was replicated to achieve object detection tasks on images.一、YOLO-v2上一篇博客中写到的YOLO-v1，作者也说了因为是通过全连接层直接预测真实框坐标的方式，所以在预测框的精度上存在不少问题。于是，今天我们来看看YOLO-v2对v1做了哪些改进，得到了多大的提升吧。1.1 总体结构YOLO-v2模型采用 448x448 大小的图像作为输入，在输入模型时将大小缩放为 416x416 。因为在19次卷积之后，正好为 13x13 大小的特征图，因为这样为奇数，在特征图像上会有唯一一个中心点。后面会解释为什么奇数更好。然后，通过一个全新的分类网络DarkNet-19进行特征提取，最后得到 13x13x1024 的特征图，在经过一次全连接之后，将特征图转化为 13x13x125 。就可以进行框预测和类别预测。1.2 改进为什么要改为 416x416 的输入改为 416 之后，下采样32倍会产生 13x13 的特征图像，中心会有唯一一个通道去预测边框和类别，因为YOLO-v2还是会让真实框中心点所在的grid box去预测真实框的位置，这样如果有目标在图像中间就不会像右图一样同时有4个grid box去预测。DarkNet-19DarkNet-19网络结构图如上所示，相较于YOLO-v1使用的VGG-16而言，在精度上提升不大，但是处DarkNet-19理一张图片仅需要55.8亿次运算，相比于VGG306.9亿次，速度提高了近6倍。同样YOLO-v2中使用的该模型预先在ImageNet上进行预训练后，在进行联合训练。联合训练YOLO9000，即YOLO-v2。为什么该模型能够识别9000种类别呢？因为该模型使用WorldTree来混合来自不同资源的训练数据，并使用联合优化技术同时在ImageNet和COCO数据集上进行训练，能够实时地检测超过9000种物体。也就是在ImageNet上训练的分类网络，依然能够检测在COCO数据集上没有的类别。Batch NormalizationBN对数据进行预处理（统一格式、均衡化、去噪等）能够大大提高训练速度，提升训练效果。基于此，YOLO-v2 对每一层输入的数据都进行批量标准化，这样网络就不需要每层都去学数据的分布，收敛会变得更快。Anchor本节开篇提到YOLO-v1直接通过全连接层预测目标框的位置，导致了准确率低和召回率不高的问题。在加上YOLO-v1没有类似R-CNN系列的推荐区域（RPN），所以网络在前期训练时非常困难，很难收敛。于是，自YOLOv2开始，重新引入了 Anchors box 机制，希望通过提前筛选得到的具有代表性先验框Anchors，使得网络在训练时更容易收敛。但是YOLO的Anchors box机制有别于Faster R-CNN中的RPN。在Faster R-CNN中，是通过预测预测框和真实框直接的偏移，再去拟合预测框。但是这样的预测框是不受位置限制的，它可能会停在图像中的任何一个位置，导致了模型的不稳定。于是，YOLO-v2将其改进为预测边界框中心点相对于该网格左上角坐标（ Cx , Cy ）的相对偏移量，同时为了将预测框的中心点约束在当前网格中，使用 sigmoid 函数将归一化处理，将值约束在0-1，这使得模型训练更稳定，如下图所示：如上约束就能满足每个网格预测目标中心在自身网格中心的物体。在本节开篇提到经过DarkNet提取特征之后，会产生大小为 13x13x125 的特征图像。由此可见，图像被分为了 13x13 个网格，每个网格会有5个anchor去预测。每个网格对应了125维度的特征，即125=5*（4+1+20），其中4为（x,y,w,h），1为置信度（类似于YOLO-v1中的confidence），20为类别数。为什么每个网格的anchor数量为5呢？在Faster R-CNN 中 Anchor Box 的大小和比例是按经验设定的，不具有很好的代表性。若一开始就选择了更好的、更有代表性的先验框Anchor Boxes，那么网络就更容易学到准确的预测位置了。YOLO-v2 使用 K-means 聚类方法得到 Anchor Box 的大小，选择具有代表性的尺寸的Anchor Box进行一开始的初始化。传统的K-means聚类方法使用标准的欧氏距离作为距离度量，这意味着大的box会比小的box产生更多的错误。因此这里使用其他的距离度量公式。到聚类中心的距离越小越好，但IOU值是越大越好，所以使用 1 - IOU。这样就保证距离越小，IOU值越大。经过准确度和花销的权衡之下，选择了anchor为5，如下图所示：细粒度特征YOLO-v2是通过一个直通层实现将高分辨率的特征与低分辨率的特征串联起来的。将DarkNet-19最后一个max pooling层的输入，即 26x26x512 的特征图分为两路：一路，做正常卷积走完DarkNet-19剩下的路，得到 13x13x1024 的特征图；另一路，将 26x26x512 的特征图拆分为4块，即 4x13x13x512 的特征图，如下图所示：然后将上述特征图进行通道维度上的拼接，得到 13x13x3072 的特征图像。这样就拥有了高维度和低维度的特征，以便于后续预测各种尺寸的目标。二、YOLO-v32.1 总体结构YOLO-v3仍然采用 416x416x3 的输入，通过DarkNet-53提取特征，但是在对于不同尺度下的预测方式与YOLO-v2有所不同，具体请看下文。图片引用于这篇博客。2.2 改进DarkNet-53相比于 YOLO-v2 的骨干网络DarkNet-19，YOLO-v3 进行了较大的改进。DarkNet-53由 1×1 和 3×3 的卷积层组成，每个卷积层之后包含一个批量归一化层和一个ReLU，加入这两个部分的目的是为了防止过拟合，以及采用残差连接。卷积层、批量归一化层，以及ReLU共同组成DarkNet-53中的基本卷积单元DBL。多尺寸预测YOLO-v3中共有3个尺度特征输出，和YOLO-v2中的跨尺度连接输出一个尺度特征有所不同。在每一种尺度输出之前还有一个分支就是和下一路进行拼接（残差连接），在拼接之前该层先进行上采样到下一路相同维度。这样加入残差思想，保留各种维度特征(底层像素+高层语义)，三个尺度就可以预测各种不同大小的物体了。详细可见 2.1 的总体结构图。通过上述方式，模型分别输出了 13x13x255、26x26x255、52x52x255 三个尺度的特征图像。YOLO-v3为每个尺度都分配了3种比例的anchor，即共有9种比例的anchor分别预测不同尺度的目标。在每个尺度下的每一个anchor都需要进行边框预测和类别预测，即每个尺度的特征图都有种结果。其中 NxN 为该尺度下网格的数量，3为每个网格分配的anchor数量，4为（x,y,w,h）坐标值，1为置信度，80为类别数量。这样每一个尺度下的anchor就可以预测不同大小的目标，同时也增加了anchor的数量，使模型的预测框召回率更高。多标签分类将YOLO-v2中用于分类的softmax层修改为逻辑分类器。在YOLOv2中，算法认定一个目标只从属于一个类别，根据网络输出类别的得分最大值，将其归为某一类。然而在一些复杂的场景中，单一目标可能从属于多个类别。为实现多标签分类就需要用逻辑分类器来对每个类别都进行二分类。逻辑分类器主要用到了sigmoid函数，它可以把输出约束在 0 到 1 ，如果某一特征图的输出经过该函数处理后的值大于设定阈值，那么就认定该目标框所对应的目标属于该类。二分类、多分类与多标签问题的区别请看这篇博客。2.3 代码采用VOC2012数据集微调YOLO-v3模型，DarkNet-53在ImageNet上预训练。import datetime
import argparseimport yaml
import torch.optim as optim
import torch.optim.lr_scheduler as lr_scheduler
from torch.utils.tensorboard import SummaryWriterfrom models import *
from build_utils.datasets import *
from build_utils.utils import *
from train_utils import train_eval_utils as train_util
from train_utils import get_coco_api_from_datasetdef train(hyp):device = torch.device(opt.device if torch.cuda.is_available() else "cpu")print("Using {} device training.".format(device.type))wdir = "weights" + os.sep  # weights dirbest = wdir + "best.pt"results_file = "results{}.txt".format(datetime.datetime.now().strftime("%Y%m%d-%H%M%S"))cfg = opt.cfgdata = opt.dataepochs = opt.epochsbatch_size = opt.batch_sizeaccumulate = max(round(64 / batch_size), 1)  # accumulate n times before optimizer update (bs 64)weights = opt.weights  # initial training weightsimgsz_train = opt.img_sizeimgsz_test = opt.img_size  # test image sizesmulti_scale = opt.multi_scale# Image sizes# 图像要设置成32的倍数gs = 32  # (pixels) grid sizeassert math.fmod(imgsz_test, gs) == 0, "--img-size %g must be a %g-multiple" % (imgsz_test, gs)grid_min, grid_max = imgsz_test // gs, imgsz_test // gsif multi_scale:imgsz_min = opt.img_size // 1.5imgsz_max = opt.img_size // 0.667# 将给定的最大，最小输入尺寸向下调整到32的整数倍grid_min, grid_max = imgsz_min // gs, imgsz_max // gsimgsz_min, imgsz_max = int(grid_min * gs), int(grid_max * gs)imgsz_train = imgsz_max  # initialize with max sizeprint("Using multi_scale training, image range[{}, {}]".format(imgsz_min, imgsz_max))# configure run# init_seeds()  # 初始化随机种子，保证结果可复现data_dict = parse_data_cfg(data)train_path = data_dict["train"]test_path = data_dict["valid"]nc = 1 if opt.single_cls else int(data_dict["classes"])  # number of classeshyp["cls"] *= nc / 80  # update coco-tuned hyp['cls'] to current datasethyp["obj"] *= imgsz_test / 320# Remove previous resultsfor f in glob.glob(results_file):os.remove(f)# Initialize modelmodel = Darknet(cfg).to(device)# 是否冻结权重，只训练predictor的权重if opt.freeze_layers:# 索引减一对应的是predictor的索引，YOLOLayer并不是predictoroutput_layer_indices = [idx - 1 for idx, module in enumerate(model.module_list) ifisinstance(module, YOLOLayer)]# 冻结除predictor和YOLOLayer外的所有层freeze_layer_indeces = [x for x in range(len(model.module_list)) if(x not in output_layer_indices) and(x - 1 not in output_layer_indices)]# Freeze non-output layers# 总共训练3x2=6个parametersfor idx in freeze_layer_indeces:for parameter in model.module_list[idx].parameters():parameter.requires_grad_(False)else:# 如果freeze_layer为False，默认仅训练除darknet53之后的部分# 若要训练全部权重，删除以下代码darknet_end_layer = 74  # only yolov3spp cfg# Freeze darknet53 layers# 总共训练21x3+3x2=69个parametersfor idx in range(darknet_end_layer + 1):  # [0, 74]for parameter in model.module_list[idx].parameters():parameter.requires_grad_(False)# optimizerpg = [p for p in model.parameters() if p.requires_grad]optimizer = optim.SGD(pg, lr=hyp["lr0"], momentum=hyp["momentum"],weight_decay=hyp["weight_decay"], nesterov=True)scaler = torch.cuda.amp.GradScaler() if opt.amp else Nonestart_epoch = 0best_map = 0.0if weights.endswith(".pt") or weights.endswith(".pth"):ckpt = torch.load(weights, map_location=device)# load modeltry:ckpt["model"] = {k: v for k, v in ckpt["model"].items() if model.state_dict()[k].numel() == v.numel()}model.load_state_dict(ckpt["model"], strict=False)except KeyError as e:s = "%s is not compatible with %s. Specify --weights '' or specify a --cfg compatible with %s. " \"See https://github.com/ultralytics/yolov3/issues/657" % (opt.weights, opt.cfg, opt.weights)raise KeyError(s) from e# load optimizerif ckpt["optimizer"] is not None:optimizer.load_state_dict(ckpt["optimizer"])if "best_map" in ckpt.keys():best_map = ckpt["best_map"]# load resultsif ckpt.get("training_results") is not None:with open(results_file, "w") as file:file.write(ckpt["training_results"])  # write results.txt# epochsstart_epoch = ckpt["epoch"] + 1if epochs &lt; start_epoch:print('%s has been trained for %g epochs. Fine-tuning for %g additional epochs.' %(opt.weights, ckpt['epoch'], epochs))epochs += ckpt['epoch']  # finetune additional epochsif opt.amp and "scaler" in ckpt:scaler.load_state_dict(ckpt["scaler"])del ckpt# Scheduler https://arxiv.org/pdf/1812.01187.pdflf = lambda x: ((1 + math.cos(x * math.pi / epochs)) / 2) * (1 - hyp["lrf"]) + hyp["lrf"]  # cosinescheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lf)scheduler.last_epoch = start_epoch  # 指定从哪个epoch开始# Plot lr schedule# y = []# for _ in range(epochs):#     scheduler.step()#     y.append(optimizer.param_groups[0]['lr'])# plt.plot(y, '.-', label='LambdaLR')# plt.xlabel('epoch')# plt.ylabel('LR')# plt.tight_layout()# plt.savefig('LR.png', dpi=300)# model.yolo_layers = model.module.yolo_layers# dataset# 训练集的图像尺寸指定为multi_scale_range中最大的尺寸train_dataset = LoadImagesAndLabels(train_path, imgsz_train, batch_size,augment=True,hyp=hyp,  # augmentation hyperparametersrect=opt.rect,  # rectangular trainingcache_images=opt.cache_images,single_cls=opt.single_cls)# 验证集的图像尺寸指定为img_size(512)val_dataset = LoadImagesAndLabels(test_path, imgsz_test, batch_size,hyp=hyp,rect=True,  # 将每个batch的图像调整到合适大小，可减少运算量(并不是512x512标准尺寸)cache_images=opt.cache_images,single_cls=opt.single_cls)# dataloadernw = min([os.cpu_count(), batch_size if batch_size &gt; 1 else 0, 8])  # number of workerstrain_dataloader = torch.utils.data.DataLoader(train_dataset,batch_size=batch_size,num_workers=nw,# Shuffle=True unless rectangular training is usedshuffle=not opt.rect,pin_memory=True,collate_fn=train_dataset.collate_fn)val_datasetloader = torch.utils.data.DataLoader(val_dataset,batch_size=batch_size,num_workers=nw,pin_memory=True,collate_fn=val_dataset.collate_fn)# Model parametersmodel.nc = nc  # attach number of classes to modelmodel.hyp = hyp  # attach hyperparameters to modelmodel.gr = 1.0  # giou loss ratio (obj_loss = 1.0 or giou)# 计算每个类别的目标个数，并计算每个类别的比重# model.class_weights = labels_to_class_weights(train_dataset.labels, nc).to(device)  # attach class weights# start training# caching val_data when you have plenty of memory(RAM)# coco = Nonecoco = get_coco_api_from_dataset(val_dataset)print("starting traning for %g epochs..." % epochs)print('Using %g dataloader workers' % nw)for epoch in range(start_epoch, epochs):mloss, lr = train_util.train_one_epoch(model, optimizer, train_dataloader,device, epoch,accumulate=accumulate,  # 迭代多少batch才训练完64张图片img_size=imgsz_train,  # 输入图像的大小multi_scale=multi_scale,grid_min=grid_min,  # grid的最小尺寸grid_max=grid_max,  # grid的最大尺寸gs=gs,  # grid step: 32print_freq=100,  # 每训练多少个step打印一次信息warmup=True,scaler=scaler)# update schedulerscheduler.step()if opt.notest is False or epoch == epochs - 1:# evaluate on the test datasetresult_info = train_util.evaluate(model, val_datasetloader,coco=coco, device=device)coco_mAP = result_info[0]voc_mAP = result_info[1]coco_mAR = result_info[8]# write into tensorboardif tb_writer:tags = ['train/giou_loss', 'train/obj_loss', 'train/cls_loss', 'train/loss', "learning_rate","mAP@[IoU=0.50:0.95]", "mAP@[IoU=0.5]", "mAR@[IoU=0.50:0.95]"]for x, tag in zip(mloss.tolist() + [lr, coco_mAP, voc_mAP, coco_mAR], tags):tb_writer.add_scalar(tag, x, epoch)# write into txtwith open(results_file, "a") as f:# 记录coco的12个指标加上训练总损失和lrresult_info = [str(round(i, 4)) for i in result_info + [mloss.tolist()[-1]]] + [str(round(lr, 6))]txt = "epoch:{} {}".format(epoch, '  '.join(result_info))f.write(txt + "\n")# update best mAP(IoU=0.50:0.95)if coco_mAP &gt; best_map:best_map = coco_mAPif opt.savebest is False:# save weights every epochwith open(results_file, 'r') as f:save_files = {'model': model.state_dict(),'optimizer': optimizer.state_dict(),'training_results': f.read(),'epoch': epoch,'best_map': best_map}if opt.amp:save_files["scaler"] = scaler.state_dict()torch.save(save_files, "./weights/yolov3spp-{}.pt".format(epoch))else:# only save best weightsif best_map == coco_mAP:with open(results_file, 'r') as f:save_files = {'model': model.state_dict(),'optimizer': optimizer.state_dict(),'training_results': f.read(),'epoch': epoch,'best_map': best_map}if opt.amp:save_files["scaler"] = scaler.state_dict()torch.save(save_files, best.format(epoch))if __name__ == '__main__':parser = argparse.ArgumentParser()parser.add_argument('--epochs', type=int, default=10)parser.add_argument('--batch-size', type=int, default=4)parser.add_argument('--cfg', type=str, default='./cfg/my_yolov3.cfg', help="*.cfg path")parser.add_argument('--data', type=str, default='./data/my_data.data', help='*.data path')parser.add_argument('--hyp', type=str, default='./cfg/hyp.yaml', help='hyperparameters path')parser.add_argument('--multi-scale', type=bool, default=True, help='adjust (67%% - 150%%) img_size every 10 batches')parser.add_argument('--img-size', type=int, default=512, help='test size')parser.add_argument('--rect', action='store_true', help='rectangular training')parser.add_argument('--savebest', type=bool, default=False, help='only save best checkpoint')parser.add_argument('--notest', action='store_true', help='only test final epoch')parser.add_argument('--cache-images', action='store_true', help='cache images for faster training')parser.add_argument('--weights', type=str, default='./weights/yolov3-spp-ultralytics-512.pt',help='initial weights path')parser.add_argument('--name', default='', help='renames results.txt to results_name.txt if supplied')parser.add_argument('--device', default='cuda:0', help='device id (i.e. 0 or 0,1 or cpu)')parser.add_argument('--single-cls', action='store_true', help='train as single-class dataset')parser.add_argument('--freeze-layers', type=bool, default=False, help='Freeze non-output layers')# 是否使用混合精度训练(需要GPU支持混合精度)parser.add_argument("--amp", default=False, help="Use torch.cuda.amp for mixed precision training")opt = parser.parse_args()# 检查文件是否存在opt.cfg = check_file(opt.cfg)opt.data = check_file(opt.data)opt.hyp = check_file(opt.hyp)print(opt)with open(opt.hyp) as f:hyp = yaml.load(f, Loader=yaml.FullLoader)print('Start Tensorboard with "tensorboard --logdir=runs", view at http://localhost:6006/')tb_writer = SummaryWriter(comment=opt.name)train(hyp)共训练10个epoch，如下图所示：需要注意的是需要将VOC2012数据集格式转为YOLO格式，脚本如下：import os
from tqdm import tqdm
from lxml import etree
import json
import shutil# voc数据集根目录以及版本
voc_root = "./data/VOCdevkit"
voc_version = "VOC2012"# 转换的训练集以及验证集对应txt文件
train_txt = "train.txt"
val_txt = "val.txt"# 转换后的文件保存目录
save_file_root = "./data/my_yolo_dataset"# label标签对应json文件
label_json_path = './data/pascal_voc_classes.json'# 拼接出voc的images目录，xml目录，txt目录
voc_images_path = os.path.join(voc_root, voc_version, "JPEGImages")
voc_xml_path = os.path.join(voc_root, voc_version, "Annotations")
train_txt_path = os.path.join(voc_root, voc_version, "ImageSets", "Main", train_txt)
val_txt_path = os.path.join(voc_root, voc_version, "ImageSets", "Main", val_txt)# 检查文件/文件夹都是否存在
assert os.path.exists(voc_images_path), "VOC images path not exist..."
assert os.path.exists(voc_xml_path), "VOC xml path not exist..."
assert os.path.exists(train_txt_path), "VOC train txt file not exist..."
assert os.path.exists(val_txt_path), "VOC val txt file not exist..."
assert os.path.exists(label_json_path), "label_json_path does not exist..."
if os.path.exists(save_file_root) is False:os.makedirs(save_file_root)def parse_xml_to_dict(xml):"""将xml文件解析成字典形式，参考tensorflow的recursive_parse_xml_to_dictArgs：xml: xml tree obtained by parsing XML file contents using lxml.etreeReturns:Python dictionary holding XML contents."""if len(xml) == 0:  # 遍历到底层，直接返回tag对应的信息return {xml.tag: xml.text}result = {}for child in xml:child_result = parse_xml_to_dict(child)  # 递归遍历标签信息if child.tag != 'object':result[child.tag] = child_result[child.tag]else:if child.tag not in result:  # 因为object可能有多个，所以需要放入列表里result[child.tag] = []result[child.tag].append(child_result[child.tag])return {xml.tag: result}def translate_info(file_names: list, save_root: str, class_dict: dict, train_val='train'):"""将对应xml文件信息转为yolo中使用的txt文件信息:param file_names::param save_root::param class_dict::param train_val::return:"""save_txt_path = os.path.join(save_root, train_val, "labels")if os.path.exists(save_txt_path) is False:os.makedirs(save_txt_path)save_images_path = os.path.join(save_root, train_val, "images")if os.path.exists(save_images_path) is False:os.makedirs(save_images_path)for file in tqdm(file_names, desc="translate {} file...".format(train_val)):# 检查下图像文件是否存在img_path = os.path.join(voc_images_path, file + ".jpg")assert os.path.exists(img_path), "file:{} not exist...".format(img_path)# 检查xml文件是否存在xml_path = os.path.join(voc_xml_path, file + ".xml")assert os.path.exists(xml_path), "file:{} not exist...".format(xml_path)# read xmlwith open(xml_path) as fid:xml_str = fid.read()xml = etree.fromstring(xml_str)data = parse_xml_to_dict(xml)["annotation"]img_height = int(data["size"]["height"])img_width = int(data["size"]["width"])# write object info into txtassert "object" in data.keys(), "file: '{}' lack of object key.".format(xml_path)if len(data["object"]) == 0:# 如果xml文件中没有目标就直接忽略该样本print("Warning: in '{}' xml, there are no objects.".format(xml_path))continuewith open(os.path.join(save_txt_path, file + ".txt"), "w") as f:for index, obj in enumerate(data["object"]):# 获取每个object的box信息xmin = float(obj["bndbox"]["xmin"])xmax = float(obj["bndbox"]["xmax"])ymin = float(obj["bndbox"]["ymin"])ymax = float(obj["bndbox"]["ymax"])class_name = obj["name"]class_index = class_dict[class_name] - 1  # 目标id从0开始# 进一步检查数据，有的标注信息中可能有w或h为0的情况，这样的数据会导致计算回归loss为nanif xmax &lt;= xmin or ymax &lt;= ymin:print("Warning: in '{}' xml, there are some bbox w/h &lt;=0".format(xml_path))continue# 将box信息转换到yolo格式xcenter = xmin + (xmax - xmin) / 2ycenter = ymin + (ymax - ymin) / 2w = xmax - xminh = ymax - ymin# 绝对坐标转相对坐标，保存6位小数xcenter = round(xcenter / img_width, 6)ycenter = round(ycenter / img_height, 6)w = round(w / img_width, 6)h = round(h / img_height, 6)info = [str(i) for i in [class_index, xcenter, ycenter, w, h]]if index == 0:f.write(" ".join(info))else:f.write("\n" + " ".join(info))# copy image into save_images_pathpath_copy_to = os.path.join(save_images_path, img_path.split(os.sep)[-1])if os.path.exists(path_copy_to) is False:shutil.copyfile(img_path, path_copy_to)def create_class_names(class_dict: dict):keys = class_dict.keys()with open("./data/my_data_label.names", "w") as w:for index, k in enumerate(keys):if index + 1 == len(keys):w.write(k)else:w.write(k + "\n")def main():# read class_indictjson_file = open(label_json_path, 'r')class_dict = json.load(json_file)# 读取train.txt中的所有行信息，删除空行with open(train_txt_path, "r") as r:train_file_names = [i for i in r.read().splitlines() if len(i.strip()) &gt; 0]# voc信息转yolo，并将图像文件复制到相应文件夹translate_info(train_file_names, save_file_root, class_dict, "train")# 读取val.txt中的所有行信息，删除空行with open(val_txt_path, "r") as r:val_file_names = [i for i in r.read().splitlines() if len(i.strip()) &gt; 0]# voc信息转yolo，并将图像文件复制到相应文件夹translate_info(val_file_names, save_file_root, class_dict, "val")# 创建my_data_label.names文件create_class_names(class_dict)if __name__ == "__main__":main()将上述训练好的yolov3spp-9.pt模型权重引入YOLO-v3预测代码中进行图像目标检测，代码如下所示：import os
import json
import timeimport torch
import cv2
import numpy as np
from matplotlib import pyplot as plt
from PIL import Imagefrom build_utils import img_utils, torch_utils, utils
from models import Darknet
from draw_box_utils import draw_objsdef main():img_size = 512  # 必须是32的整数倍 [416, 512, 608]cfg = "cfg/my_yolov3.cfg"  # 改成生成的.cfg文件weights_path = "./weights/yolov3spp-9.pt"  # 改成自己训练好的权重文件json_path = "./data/pascal_voc_classes.json"  # json标签文件img_path = "./data/street.jpg"assert os.path.exists(cfg), "cfg file {} dose not exist.".format(cfg)assert os.path.exists(weights_path), "weights file {} dose not exist.".format(weights_path)assert os.path.exists(json_path), "json file {} dose not exist.".format(json_path)assert os.path.exists(img_path), "image file {} dose not exist.".format(img_path)with open(json_path, 'r') as f:class_dict = json.load(f)category_index = {str(v): str(k) for k, v in class_dict.items()}input_size = (img_size, img_size)device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")model = Darknet(cfg, img_size)weights_dict = torch.load(weights_path, map_location='cpu')weights_dict = weights_dict["model"] if "model" in weights_dict else weights_dictmodel.load_state_dict(weights_dict)model.to(device)model.eval()with torch.no_grad():# initimg = torch.zeros((1, 3, img_size, img_size), device=device)model(img)img_o = cv2.imread(img_path)  # BGRassert img_o is not None, "Image Not Found " + img_pathimg = img_utils.letterbox(img_o, new_shape=input_size, auto=True, color=(0, 0, 0))[0]# Convertimg = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416img = np.ascontiguousarray(img)img = torch.from_numpy(img).to(device).float()img /= 255.0  # scale (0, 255) to (0, 1)img = img.unsqueeze(0)  # add batch dimensiont1 = torch_utils.time_synchronized()pred = model(img)[0]  # only get inference resultt2 = torch_utils.time_synchronized()print(t2 - t1)pred = utils.non_max_suppression(pred, conf_thres=0.1, iou_thres=0.6, multi_label=True)[0]t3 = time.time()print(t3 - t2)if pred is None:print("No target detected.")exit(0)# process detectionspred[:, :4] = utils.scale_coords(img.shape[2:], pred[:, :4], img_o.shape).round()print(pred.shape)bboxes = pred[:, :4].detach().cpu().numpy()scores = pred[:, 4].detach().cpu().numpy()classes = pred[:, 5].detach().cpu().numpy().astype(np.int) + 1pil_img = Image.fromarray(img_o[:, :, ::-1])plot_img = draw_objs(pil_img,bboxes,classes,scores,category_index=category_index,box_thresh=0.2,line_thickness=3,font='arial.ttf',font_size=20)plt.imshow(plot_img)plt.show()# 保存预测的图片结果plot_img.save("test_result.jpg")if __name__ == "__main__":main()输入图像如下：YOLO-v3检测结果如下图所示：由此可见检测结果还是非常准确的，预测框的召回率也较高。总结本周的学习到此结束，下周将会学习CenterNet，以及复习之前学习的内容。如有错误，请各位大佬指出，谢谢！http://www.ppmy.cn/news/1540633.html相关文章OceanBase 的写盘与传统数据库有什么不同？背景 
在数据库开发过程中&amp;#xff0c;“写盘”是一项核心操作&amp;#xff0c;即将内存中暂存的数据安全地转储到磁盘上。在诸如MySQL这样的传统数据库管理系统中&amp;#xff0c;写盘主要有以下几步&amp;#xff1a;首先将数据写入缓存池&amp;#xff1b;其次&amp;#xff0c;为了确保数据的完整性…阅读更多...飞腾X100适配Ubuntu说明【写在前面】 飞腾开发者平台是基于飞腾自身强大的技术基础和开放能力&amp;#xff0c;聚合行业内优秀资源而打造的。该平台覆盖了操作系统、算法、数据库、安全、平台工具、虚拟化、存储、网络、固件等多个前沿技术领域&amp;#xff0c;包含了应用使能套件、软件仓库、软件支持、软件适…阅读更多...mqtt客户端订阅一直重复连接？文章 前言错误场景问题分析解决方案后言 前言 ✨✨ 他们是天生勇敢的开发者&amp;#xff0c;我们创造bug&amp;#xff0c;传播bug&amp;#xff0c;毫不留情地消灭bug&amp;#xff0c;在这个过程中我们创造了很多bug以供娱乐。 前端bug这里是博主总结的一些前端的bug以及解决方案&amp;#xff0c;感兴…阅读更多...树的遍历笔记前序遍历&amp;#xff08;根左右&amp;#xff09; 
①根 
②左子树 
③右子树 
中序遍历&amp;#xff08;左根右&amp;#xff09; 
①左子树 
②根 
③右子树 
后序遍历&amp;#xff08;左右根&amp;#xff09; 
①左子树 
②右子树 
③根 
中序代码为例&amp;#xff1a; 
​
void find(根节点下标&amp;#xff…阅读更多...高效的多进程编程：使用 Python `multiprocessing` 库进行进程管理高效的多进程编程：使用 Python multiprocessing 库进行进程管理 
在现代计算机硬件上，CPU 核心的数量日益增多，单线程程序难以充分利用这些资源。因此，了解如何使用 Python 的 multiprocessing 库管理多个进程，充分利用多核 CPU 来提高程序的并行执行能力，成为了一个非常…阅读更多...vLLM 大模型推理引擎调研文档文章目录 介绍vLLM 速度很快vLLM 灵活且易于使用 使用和部署离线批量推理在线推理服务 分布式推理服务如何确定分布式推理策略?多节点推理和服务-Ray集群 量化支持模型量化KV Cache 量化 性能调优PagedAttentionAutomatic prefix cachingBatching 策略PreemptionChunked Prefi…阅读更多...SpringBoot构建的智能健康生活助手4系统概要设计 4.1概述 本系统采用B/S结构(Browser/Server,浏览器/服务器结构)和基于Web服务两种模式&amp;#xff0c;是一个适用于Internet环境下的模型结构。只要用户能连上Internet,便可以在任何时间、任何地点使用。系统工作原理图如图4-1所示&amp;#xff1a;  
图4-1系统工作原理…阅读更多...极速体验：实用的前端性能优化技巧本文将深入探讨一系列实用的前端性能优化方案&amp;#xff0c;从基础知识到高级技巧&amp;#xff0c;我们将揭示如何让你的网站在瞬息万变的互联网中脱颖而出&amp;#xff0c;无论你是经验丰富的开发者还是刚入行的新手&amp;#xff0c;这篇文章都将为你提供宝贵的见解和实践建议。 目录 
&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览DW1000芯片帧组成解析实验课收获2025.10.30Revit Api打印当前项目的所有的可打印视图概率递推1microsoft edge webview离线安装包程序员修炼之道：从小工到专家sunpinyin online的简单例子Ubuntu server配置Docker Daemon.json 顽固不生效Ai元人文：价值权衡元能力的培育路径与开源生态构建revit api 事务和事务组Skill Discovery | RGSD：基于高质量参考轨迹，预训练 skill spacerevit api 过滤器获取元素revit 设置参数revit 设置参数和获取参数值《代码大全2》读书笔记2[Vulhub]Sickos靶机渗透revit api共享参数一件有关山寨iPod shuffle 2的往事revit api  加载族文件+放置族实例 创建门图元【AI说】HTML从零基础到精通路径revit api楼梯创建《代码大全2》初读有感代码大全2{2}revit api  几何图元连接读《代码大全2》读后感2公众号排版工具实测报告：为什么有一云AI编辑器成为全能高效的“排版专家”？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 13:28:49 +0000</pubDate>
    </item>
  </channel>
</rss>
