<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>PPMY RSS</title>
    <link>https://www.ppmy.cn/news</link>
    <description>PPMY 网站文章 RSS</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 03 Nov 2025 16:21:18 +0000</lastBuildDate>
    <item>
      <title>CSS3文本阴影、文本换行、文本溢出、文本修饰、文本描边的使用</title>
      <link>https://www.ppmy.cn/news/1541532.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维CSS3文本阴影、文本换行、文本溢出、文本修饰、文本描边的使用news/2025/11/4 0:22:39/1.文本阴影：text-shadow2.文本换行：white-space：pre（可以理解为按原文显示）white-space：pre-wrap（不会超出父容器）3.文本溢出text-overflow：ellipsis一般配合文本换行使用：white-space：nowrap4.文本修饰5.文本描边http://www.ppmy.cn/news/1541532.html相关文章React04 - react ajax、axios、路由和antd UI文章目录 react与ajaxreact与axiosreact中跨域解决方法使用axios携带参数发送请求父子组件间的传值&amp;#xff08;props&amp;#xff09;根据请求结果展示不同的页面效果兄弟组件间通信&amp;#xff08;消息订阅与发布&amp;#xff09;fetch发送请求 路由前端路由和后端路由路由原理与基本使用…阅读更多...stm32 单片机使用 rt-thread 的syswatch 系统守护软件包一、系统看守(syswatch)组件 介绍 
系统看守(syswatch)组件 主要功能是保障实时操作系统正常运行&amp;#xff0c;防止系统死机以及各种异常引起的线程阻塞&amp;#xff0c;保障整个系统长期正常运行。 系统看守具备以下几种行为模式&amp;#xff1a; 1、系统崩溃或硬件异常导致系统失去调度…阅读更多...zookeeper的作用--有无zookeeper的区别如果光了解zookeeper的作用可能有些抽象&amp;#xff0c;本文从对比有无zookeeper的情况来更直观凸显其作用。 
ZooKeeper在分布式系统中提供了多种关键功能&amp;#xff0c;包括配置管理、命名服务、分布式锁、集群管理等。下面通过一些具体场景来对比有ZooKeeper和没有ZooKeeper的情况…阅读更多...开发板+freertos+lvgl学习1#目的 最近找到了一块开发板&amp;#xff0c;并且买了一个手表屏幕&amp;#xff0c;准备学习下lvglfreerots #详细实验步骤 ##整体配置如下 首先是连接硬件并通过cubemx对主板进行配置  大体分类几类功能&amp;#xff1a; 其中spi1lcd开头的引脚用来控制手表lcd屏幕 其中i2ctouch开头的引脚…阅读更多...create-vite my-vite-uniapp-project搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目&amp;#xff0c;你可以遵循以下步骤&amp;#xff1a; 
安装 Node.js 和 npm。 
使用以下命令全局安装 Vue CLI&amp;#xff1a; 
npm install -g vue/cli创建一个新的 Vue 3项目&amp;#xff0c;并选择 TypeScr…阅读更多...15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:39 +0000</pubDate>
    </item>
    <item>
      <title>React04 - react ajax、axios、路由和antd UI</title>
      <link>https://www.ppmy.cn/news/1541531.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维React04 - react ajax、axios、路由和antd UInews/2025/11/4 0:22:38/文章目录react与ajaxreact与axiosreact中跨域解决方法使用axios携带参数发送请求父子组件间的传值（props）根据请求结果展示不同的页面效果兄弟组件间通信（消息订阅与发布）fetch发送请求路由前端路由和后端路由路由原理与基本使用react-router-dom@5BrowserRouter和HashRouterNavLinkSwitch路由的模糊匹配和严格匹配Redirect重定向嵌套路由（二级路由）向路由组件传递参数编程式路由导航withRouterantd UIreact与ajaxreact不包含发送ajax请求的代码，需要集成第三方ajax库或者自己封装。常用的ajax请求库：jQuery、axios。对比axios，jQuery会更多的直接操作DOM，不适用react框架，更倾向于选择axios作为react的ajax请求库。react与axiosaxios是一个轻量级的ajax请求库，有promise风格，可以用在浏览器和node服务器两个端口。react中跨域解决方法在项目目录终端中输入npm add axios，引入第三方库。// App.jsimportReact,{Component}from'react'importaxiosfrom'axios'exportdefaultclassAppextendsComponent{getStudentData=()=&gt;{axios.get('http://localhost:5000/student').then(response=&gt;{console.log('success',response.data)},error=&gt;{console.log('fail',error)})}render(){return(&lt;div&gt;&lt;button onClick={this.getStudentData}&gt;点击获取数据&lt;/button&gt;&lt;/div&gt;)}}使用nodejs创建一个服务器，向端口5000发送请求。constexpress=require('express')constapp=express()app.use((req,res,next)=&gt;{console.log('请求服务器了')next()})app.get('/student',(req,res)=&gt;{conststudents=[{id:'001',name:'tom',age:18}.{id:'002',name:'jery',age:18}.{id:'003',name:'tony',age:18}.]res.send(students)})app.listen(5000,err=&gt;{if(!err)console.log('服务器启动成功，请求地址http://localhost:5000/students')})前端项目运行在3000端口，点击按钮，会发生跨域问题，无法返回数据。解决跨域配置代理方法一，在package.json文件内加入proxy属性，规定跨域地址。"proxy":http://localhost:5000在组件请求方法中修改请求路径：getStudentData=()=&gt;{axios.get('http://localhost:3000/student').then(response=&gt;{console.log('success',response.data)},error=&gt;{console.log('fail',error)})}这样当3000端口发送请求时，先查看当前端口是否有请求资源，若有，直接返回数据，若没有，会向5000端口请求资源，然后返回。解决跨域配置代理方法二，在src文件夹下新建一个名为setupProxy.js的文件，react在编译的时候会把他交给webpack，然后转为node去做处理。在这个文件里，要使用commonjs编写，commonjs是前端模块化的一种规范，node使用的也是commonjs编写的。该方法适用于要从多个服务器获取资源。// setupProxy.jsconstproxy=require('http-proxy-middleware')moudle.exports=function(app){app.use(proxy('/api1',{// 请求前缀，请求路径中有该前缀则触发此代理配置target:'http://localhost:5000',// 请求转发路径changeOrigin:true,// 控制服务器收到的请求头中Host值，相当于欺骗服务器，该请求来自本服务器。前端请求为localhost:3000,但当前端发起请求时，5000端口的服务器会知道是请求头localhost:5000的请求。不写这一行代码时，5000端口的服务器会知道是请求头localhost:3000的请求。pathRewrite:{'^/api1':''}// 重写请求路径，将请求路径中的/api1字段替换为空字符串，避免服务器收到/api1开头的路径，导致请求返回404}),proxy('/api2',{target:'http://localhost:5001',changeOrigin:true,pathRewrite:{'^/api2':''}}),)}以上代码中规定了不同服务器请求路径的前缀（api1/api2），组件中的请求方法也要对应修改。getStudentData=()=&gt;{axios.get('http://localhost:3000/api1/student').then(response=&gt;{console.log('success',response.data)},error=&gt;{console.log('fail',error)})}使用axios携带参数发送请求constvalue=10;axios.get('http://localhost:3000/search/users?q=${value}').then(res=&gt;{console.log('success',res.data);},err=&gt;{console.log('fail',err)})父子组件间的传值（props）案例：App包含Search和List两个子组件，在Search组件中输入数据，点击按钮请求数据，将请求返回的数据给List组件，用于展示列表。// 父组件中exportdefaultclassAppextendsComponent{state={users:[]}// 获取子组件Search返回的数据，保存在state中saveUsers=users=&gt;{this.setState({users})}render(){return(&lt;div&gt;&lt;Searrch saveUsers={this.saveUsers}/&gt;&lt;List list={this.state.users}/&gt;&lt;/div&gt;)// 使用props传递函数和值给子组件}}// 子组件Search中exportdefaultclassSearchextendsComponent{search=()=&gt;{// 使用ref获取输入框的值constvalue=this.inputValue.value;axios.get('http://localhost:3000/search/users?q=${value}').then(res=&gt;{// 将接口返回的数据通过props传递给父组件this.props.saveUsers(res.data)},err=&gt;{console.log('ereoe',err)})}render(){return(&lt;div&gt;&lt;input ref={c=&gt;this.inputValue=c}type="text"/&gt;&lt;button onClick={this.search}&gt;点击获取数据&lt;/button&gt;&lt;/div&gt;)}}// 子组件Lisr中exportdefaultclassListectends Component{render(){return(&lt;div&gt;this.props.list.map(item=&gt;{return(&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)})&lt;/div&gt;)// 使用props获取父组件传递的数据}}根据请求结果展示不同的页面效果发送请求前的页面，发送请求时的页面，请求成功的页面，请求失败的页面。// jsx使用嵌套三元表达式beforeSend?&lt;h1&gt;Welcome&lt;/h1&gt;:loading?&lt;h1&gt;wait loading&lt;/h1&gt;:err?&lt;h1&gt;something wrong&lt;/h1&gt;:&lt;h1&gt;response data&lt;/h1&gt;兄弟组件间通信（消息订阅与发布）消息发布：把消息给别的兄弟组件，消息订阅：可以接收别的兄弟组件发布的消息，注意要在组件的componentWillUnmount中取消订阅importPubSubfrom'pubsub-js'// 订阅,在接收消息的组件中使用this.token=PubSub.subscribe('MY TOPIC',(msg,data)=&gt;{console.log(msg,data);// msg是消息订阅名称，data是发布传送的数据});// 取消订阅，在接收消息的组件中适用componentWillUnmount(){PubSub.unsubscribe(this.token)}// 发布，在发送消息的组件中使用PubSub.publish('MY TOPIC','hello');fetch发送请求原生xhr对象=&gt;jQuery（回调地狱）=&gt;axios（promise）fetch是windows对象自带的方法，也能发送请求，也有promise风格，适用IE8+浏览器。// 原生xhr对象发送请求varxhr=newXMLHttpRequest();xhr.open('GET',url);xhr.resonseType='json';xhr.onload=function(){console.log(xhr.response);}xhr.onerror=function(){console.log('error');}xhr.send();// fetch发送请求fetch(url).then(//进行服务器连接response=&gt;{console.log('联系服务器成功');returnresponse.json();// 返回成功，值是一个promise对象},error=&gt;{console.log('联系服务器失败',error);returnnewPromise(()=&gt;{});// 设置空promise对象，以防联系服务器失败依旧走下面的then，显示获取数据成功，undefined}).then(// 前一个then中成功的回调返回的promise对象，继续操作response=&gt;{console.log('获取数据成功',response)},// response是数据error=&gt;{console.log('获取数据失败',error)})// 优化写法fetch(url).then(response=&gt;{console.log('联系服务器成功');returnresponse.json();}).then(response=&gt;{console.log('获取数据成功',response)}).catch(error=&gt;{console.log('请求出错',error)})// 优化写法 await跟promise对象搭配使用,await适用外部要包含async函数async()=&gt;{try{constresponse=awaitfetch(url);constdata=awaitresponse.json();console.log(data)}catch(error){console.log('请求出错',error)}}路由单页面web应用（SPA）整个应用只有一个完整页面，点击页面中的链接不会刷新整个页面，只会局部更新页面，数据都需要通过ajax请求获取，并在前端异步展现。前端路由和后端路由一个路由是一个映射关系（key: value），key是路径，value可以是function（后端路由）或component（前端路由）。// node后端路由，根据请求路径调用函数来请求处理返回数据router.get("/search/users",function(req,res){axios.get(url).then(res=&gt;{},err=&gt;{})}// 前端路由，根据请求路径返回组件更新页面内容&lt;Route path="/users"component={User}&gt;路由原理与基本使用前端路由是基于浏览器的History工作的，在BOM中的History对象管理页面的访问路径历史记录等。history对象使用栈存储页面路径，更改路径但是不跳转页面。锚点跳转也可以更新路径，但不跳转页面。// 引用history.jslethistory=History.createBrowserHistory()// 方法一，直接使用H5推出的history对象的API// let history = History.createHashHistory() // 方法一，hash值（锚点）history.push(path)history.replace(path)history.goBack()history.goForward()react-router包含三个方面的库：web、native（native）、anywhere（能适用任何地方）。主要学习react-router-dom库（web应用）。react-router-dom@5npm add react-router-dom@5  // 下载版本5的路由库分析页面，找页面的导航区，展示区，不同的展示区就是不同的页面。要实现点击导航区链接改变路径，被路由器检测到路径改变，进行匹配组件，进而更新页面。导航区写路由组件链接，展示区注册路由。&lt;body&gt;&lt;!--原生结构--&gt;&lt;div&gt;&lt;span&gt;&lt;a href="./about.html"&gt;About&lt;/a&gt;&lt;/span&gt;&lt;span&gt;AboutPage&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;// App.jsx中，使用Link路由组件，类似原生中的a标签 &lt;a href="./about.html"&gt;About&lt;/a&gt;import{Link,BrowserRouter}from'react-router-dom'importAboutfrom'./pages/About'&lt;div&gt;&lt;BrowserRouter&gt;&lt;span&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;// （导航区使用路由链接）在react中使用路由链接实现组件切换，Link组件外必须有Router标签&lt;/span&gt;&lt;span&gt;&lt;Route path="/about"component={About}&gt;// （内容展示区注册路由）注册路由&lt;/span&gt;&lt;/BrowserRouter&gt;&lt;/div&gt;// 路由组件About.jsxexportdefaultclassAboutextendsComponent{render(){return&lt;span&gt;AboutPage&lt;/span&gt;}}BrowserRouter和HashRouterRouter包含BrowserRouter和HashRouter，BrowserRouter适用于请求服务器的情况，路径中没有#，HashRouter适用于不请求服务器的情况，路径中带有#。BrowserRouter使用的是H5的history API，不兼容IE9以下版本，HashRouter使用的是URL的哈希值。页面刷新后，BrowserRouter没有任何影响，因为state会保存在history对象中，HashRouter会发生路由state参数丢失。在使用路由组件时，必须用Router将路由组件包含起来，注册路由也需要使用同一个Router，因此需要包含在同一个Router里。// App组件的index.js里，将整个App组件使用同一个Router包裹，所有的组件都使用一个Router管理ReactDom.render(&lt;BrowserRouter&gt;&lt;App/&gt;&lt;/BrowserRouter&gt;,document.getElementById('root'))// 在App.jsx中只需要写Link和Route&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;Route path="/about"component={About}&gt;路由组件和一般组件的最大区别在于，自带了props属性：history, location, match。NavLink使用NavLink可以实现路由链接的高亮，通过activeClassName指定自定义样式名。&lt;NavLink activeClassName="active"to="/abput"&gt;About&lt;/NavLink&gt;SwitchSwitch组件，避免多个相同路径的路由一直匹配渲染。// 多个路径相同的组件会一直匹配，About和Detail两个组件的内容都会显示在页面上&lt;Route path="/about"component={About}&gt;&lt;Route path="/about"component={Detail}&gt;// 引入Switch组件后匹配到第一个就停止匹配import{Switch}from'react-router-dom'&lt;Switch&gt;// 使用&lt;Switch&gt;包裹所有路由&lt;Route path="/about"component={About}&gt;// 匹配到About组件就停止，页面只显示About组件的内容&lt;Route path="/about"component={Detail}&gt;&lt;/Switch&gt;路由的模糊匹配和严格匹配// 无法显示页面&lt;Link to="/home"&gt;Home&lt;/Link&gt;&lt;Route path="/home/a/b"component={Home}/&gt;// 可以显示页面，模糊匹配，最左逐个匹配home a b，匹配到了home&lt;link to="/home/a/b"&gt;Home&lt;/Link&gt;&lt;Route path="/home"component={Home}/&gt;// 无法显示页面，严格匹配&lt;Link to="/home/a/b"&gt;Home&lt;/Link&gt;&lt;Route exact={true}path="/home"component={Home}/&gt;Redirect重定向当Redirect前面的路由都匹配不上时，走Redirect指定的路径。import{Redirect}from'react-router-dom'&lt;Switch&gt;&lt;Route path="/home"component={Home}/&gt;&lt;Route path="/about"component={About}/&gt;&lt;Redirect to="/home"/&gt;// 当没有点击导航，页面访问根路径“/”的时候，默认到home页面&lt;/Switch&gt;嵌套路由（二级路由）路由按照注册的顺序进行匹配，严格匹配会导致无法匹配二级路由&lt;div&gt;&lt;div&gt;&lt;Switch&gt;&lt;NavLink to="/home"&gt;Home&lt;/NavLink&gt;// 当开启严格匹配，点击Home组件中的二级路由链接，会跳转到about组件，展示不了Home组件&lt;NavLink to="/about"&gt;About&lt;/NavLink&gt;&lt;Redirect to="/about"/&gt;&lt;/Switch&gt;&lt;/div&gt;&lt;div&gt;&lt;Route path="/home"component={Home}/&gt;&lt;Route path="/about"component={About}/&gt;&lt;/div&gt;&lt;/div&gt;// Home组件&lt;div&gt;&lt;div&gt;&lt;NavLink to="/home/a"&gt;Home&lt;/NavLink&gt;&lt;NavLink to="/home/b"&gt;About&lt;/NavLink&gt;&lt;/div&gt;&lt;div&gt;&lt;Route path="/home/a"component={HomeA}/&gt;// 先匹配/home路由，来到Home页面，才继续匹配/a&lt;Route path="/home/b"component={HomeB}/&gt;&lt;/div&gt;&lt;/div&gt;向路由组件传递参数params参数&lt;Link to="/details/apple/18"&gt;详情&lt;/Link&gt;&lt;Route path="details/:name/:price"component={Details}/&gt;this.props.match.params// 获取参数search参数importqsfrom'querystring'&lt;Link to="/details?name=apple&amp;price=18"&gt;详情&lt;/Link&gt;&lt;Route path="/details"component={Details}/&gt;qs.parse(this.props.location.search)// 接收参数，获取到的是urlencode编码字符串，需要借助querystring解析state参数&lt;Link to={{path:'/details',state:{name:'apple',price:18}}}&gt;详情&lt;/Link&gt;&lt;Route path="/details"component={Details}/&gt;this.props.location.state编程式路由导航路由跳转有replace和push两种方式，默认是push，push方式可以返回，在浏览器路径可以看到，replace是替换之前的路径，不可返回前面的路径。// 编程式路由导航，使用方法改变路由const{id,name}=this.props.match.params// const {search} = this.props.location// const {id,name} = qs.parse(search.slice(1))// const {is,name} = this.props.location.state || {}replaceShow=(id,name)=&gt;{this.props.history.replace('/users/${id}/${name}')// this.props.history.replace('/users?id=${id}&amp;name=${name}')// this.props.history.replace('/users',{id:id,name:name})}pushShow=(id,name)=&gt;{this.props.history.push('/users/${id}/${name}')// this.props.history.push('/users?id=${id}&amp;name=${name}')// this.props.history.push('/users',{id:id,name:name})}back=()=&gt;{this.props.history.goBack()}forward=()=&gt;{this.props.history.goForward()}go=()=&gt;{this.props.history.go(2)// 前进两页，正数为前进，负数为后退}&lt;button onClick={()=&gt;{this.replaceShow(obj.id,obj.name)}}&gt;replace查看&lt;/button&gt;&lt;button onClick={()=&gt;{this.pushShow(obj.id,obj.name)}}&gt;push查看&lt;/button&gt;&lt;button onClick={this.back}&gt;回退&lt;/button&gt;&lt;button onClick={this.forward}&gt;前进&lt;/button&gt;&lt;button onClick={this.go}&gt;跳转&lt;/button&gt;// params&lt;Link to={'/users/${obj.id}/${obj.name}'}&gt;{obj.name}&lt;/Link&gt;&lt;Route path="/users/:id/:name"component={User}/&gt;// search&lt;Link to={'/users/?id=${id}&amp;name=${name}'}&gt;{obj.name}&lt;/Link&gt;&lt;Route path="/users"component={User}/&gt;// state&lt;Link to={{pathname:'/users',state:{id:obj.id,name:obj.name}}}&gt;{obj.name}&lt;/Link&gt;&lt;Route path="/users"component={User}/&gt;withRouterwithRouter可以加工一般组件，让一般组件带有路由组件有的API（history,location,match），返回值是一个新组件。// Header组件import{withRouter}from'react-router-dom'classHeaderextendsComponent{back=()=&gt;{this.props.history.goBack()}render(){return(&lt;button onClick={this.back}&gt;回退&lt;/button&gt;)}}exportdefaultwithRouter(Header)//User组件exportdefaultclassUserextendsComponent{render(){return(&lt;div&gt;&lt;Link to={'/users/${obj.id}/${obj.name}'}&gt;{obj.name}&lt;/Link&gt;&lt;Route path="/users/:id/:name"component={User}/&gt;&lt;/div&gt;)}}antd UI参考ant-Design官网文档add antd  // 终端引入库import{Button}from'antd'// 引入Button组件样式import'antd/dist/antd.css'// 新版可不引入exportdefaultclassAppextendsComponent{render(){return(&lt;Button type="primary"&gt;按钮&lt;/Button&gt;)}}http://www.ppmy.cn/news/1541531.html相关文章stm32 单片机使用 rt-thread 的syswatch 系统守护软件包一、系统看守(syswatch)组件 介绍 
系统看守(syswatch)组件 主要功能是保障实时操作系统正常运行&amp;#xff0c;防止系统死机以及各种异常引起的线程阻塞&amp;#xff0c;保障整个系统长期正常运行。 系统看守具备以下几种行为模式&amp;#xff1a; 1、系统崩溃或硬件异常导致系统失去调度…阅读更多...zookeeper的作用--有无zookeeper的区别如果光了解zookeeper的作用可能有些抽象&amp;#xff0c;本文从对比有无zookeeper的情况来更直观凸显其作用。 
ZooKeeper在分布式系统中提供了多种关键功能&amp;#xff0c;包括配置管理、命名服务、分布式锁、集群管理等。下面通过一些具体场景来对比有ZooKeeper和没有ZooKeeper的情况…阅读更多...开发板+freertos+lvgl学习1#目的 最近找到了一块开发板&amp;#xff0c;并且买了一个手表屏幕&amp;#xff0c;准备学习下lvglfreerots #详细实验步骤 ##整体配置如下 首先是连接硬件并通过cubemx对主板进行配置  大体分类几类功能&amp;#xff1a; 其中spi1lcd开头的引脚用来控制手表lcd屏幕 其中i2ctouch开头的引脚…阅读更多...create-vite my-vite-uniapp-project搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目&amp;#xff0c;你可以遵循以下步骤&amp;#xff1a; 
安装 Node.js 和 npm。 
使用以下命令全局安装 Vue CLI&amp;#xff1a; 
npm install -g vue/cli创建一个新的 Vue 3项目&amp;#xff0c;并选择 TypeScr…阅读更多...15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:39 +0000</pubDate>
    </item>
    <item>
      <title>stm32 单片机使用 rt-thread 的syswatch 系统守护软件包</title>
      <link>https://www.ppmy.cn/news/1541530.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维stm32 单片机使用 rt-thread 的syswatch 系统守护软件包news/2025/11/4 0:22:37/一、系统看守(syswatch)组件 介绍系统看守(syswatch)组件 主要功能是保障实时操作系统正常运行，防止系统死机以及各种异常引起的线程阻塞，保障整个系统长期正常运行。系统看守具备以下几种行为模式：1、系统崩溃或硬件异常导致系统失去调度时，执行 系统复位 恢复系统正常运行。2、当有异常导致某些线程长时间阻塞时，可根据用户的配置实施 系统复位 / 杀掉阻塞线程 / 重启阻塞线程 的方式恢复系统正常运行。原理介绍系统看守(syswatch)组件 使用实时操作系统中允许的最高优先级作为看守线程的优先级，保障看守线程不会被阻塞，同时看守线程由看门狗提供看护，保障看守线程正常运行。系统看守通过 线程调度回调接口 监测线程的调度情况，当检测到有线程发生异常阻塞时，开始检测和确认具体哪个线程发生了异常阻塞，最后根据异常解决模式执行 系统复位 / 杀掉阻塞线程 / 重启阻塞线程 清除异常，使系统恢复正常运行。配置参数说明注意事项1、syswatch 依赖于看门狗设备而工作，使用本组件时请确认已注册了看门狗设备。2、syswatch 全权管理看门狗，请不要在其它线程中使用和操作看门狗。3、syswatch 提供了3种异常解决模式，请根据实际需要配置适合的工作模式。4、syswatch_set_event_hook 提供用户安装事件回调函数，以便针对重要事件发生时进行一些必要处理，如系统复位前须对重要数据进行保存时，可设置回调函数完成相应处理，如不需要可不设置。二、开发配置2.1 开发环境基于 env 进行配置开发。RT-Thread Env 工具包括配置器和包管理器，用来对内核和组件的功能进行配置，对组件进行自由裁剪，对线上软件包进行管理，使得系统以搭积木的方式进行构建，简单方便。硬件：基于野火 stm32f407 开发板软件：rt-thread 4.1.1 版本，基于 stm32f407-atk-explorer bsp包2.2 时钟配置stm32f407-atk-explorer bsp包的外部晶振是8MHZ，野火 stm32f407 开发板外部晶振是25MHZ，需要先修改配置系统时钟。参考野火教程：系统时钟的计算：SYSCLK=PLLCLK=HSE/m*n/pHSE 使用 25M，参数 m 设置为 25，所以需要修改系统时钟的时候只需要修改参数 n 和 p 即可，SYSCLK=PLLCLK=HSE/m*n/p。系统时钟配置完整代码如下：void SystemClock_Config(void)
{RCC_OscInitTypeDef RCC_OscInitStruct = {0};RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};/**Configure the main internal regulator output voltage*/__HAL_RCC_PWR_CLK_ENABLE();__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);/**Initializes the CPU, AHB and APB busses clocks*/RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;RCC_OscInitStruct.HSEState = RCC_HSE_ON;RCC_OscInitStruct.LSEState = RCC_LSE_ON;RCC_OscInitStruct.LSIState = RCC_LSI_ON;RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;RCC_OscInitStruct.PLL.PLLM = 25;RCC_OscInitStruct.PLL.PLLN = 336;RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;RCC_OscInitStruct.PLL.PLLQ = 7;if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK){Error_Handler();}/**Initializes the CPU, AHB and APB busses clocks*/RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK){Error_Handler();}PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;if (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK){Error_Handler();}
}2.3 开启看门狗Kconfig 文件 相关config BSP_USING_WDTbool "Enable Watchdog Timer"select RT_USING_WDTdefault n开始之后，下面的选项会自动勾选。Kconfig 文件 相关config RT_USING_WDTbool "Using Watch Dog device drivers"default n重新编译，下载到开发板，查看设备使用的是独立看门狗(IWDG)区分独立看门狗(IWDG)和窗口看门狗(WWDG)2.4 syswatch 组件开启 syswatch 组件下载软件包编译三、测试下载到开发板，运行如下查看线程配置的异常解决模式是2，可知可重启异常线程。测试代码，编写异常线程：/** Copyright (c) 2006-2021, RT-Thread Development Team** SPDX-License-Identifier: Apache-2.0** Change Logs:* Date           Author       Notes* 2018-11-06     SummerGift   first version* 2018-11-19     flybreak     add stm32f407-atk-explorer bsp*/#include &lt;rtthread.h&gt;
#include &lt;rtdevice.h&gt;
#include &lt;board.h&gt;#define THREAD_PRIORITY         25
#define THREAD_STACK_SIZE       512
#define THREAD_TIMESLICE        5static rt_thread_t tid1 = RT_NULL;/* defined the LED0 pin: PF6 */
#define LED0_PIN    GET_PIN(F, 6)
#define LED1_PIN    GET_PIN(C, 6)/* 线程 1 的入口函数 */
static void thread1_entry(void *parameter)
{rt_kprintf("hello world\r\n");while(1){}
}int main(void)
{/* set LED0 pin mode to output */rt_pin_mode(LED0_PIN, PIN_MODE_OUTPUT);rt_pin_mode(LED1_PIN, PIN_MODE_OUTPUT);/* 创建线程 1，名称是 thread1，入口是 thread1_entry*/tid1 = rt_thread_create("thread1",thread1_entry, RT_NULL,THREAD_STACK_SIZE,THREAD_PRIORITY, THREAD_TIMESLICE);/* 如果获得线程控制块，启动这个线程 */if (tid1 != RT_NULL)rt_thread_startup(tid1);while (1){rt_pin_write(LED0_PIN, PIN_HIGH);rt_pin_write(LED1_PIN, PIN_HIGH);rt_thread_mdelay(500);rt_pin_write(LED0_PIN, PIN_LOW);rt_pin_write(LED1_PIN, PIN_LOW);rt_thread_mdelay(500);}
}测试结果，异常线程可重新重启参考：https://gitee.com/RT-Thread-Mirror/rt-thread-syswatchSTM32库开发实战指南——基于野火霸天虎开发板http://www.ppmy.cn/news/1541530.html相关文章zookeeper的作用--有无zookeeper的区别如果光了解zookeeper的作用可能有些抽象&amp;#xff0c;本文从对比有无zookeeper的情况来更直观凸显其作用。 
ZooKeeper在分布式系统中提供了多种关键功能&amp;#xff0c;包括配置管理、命名服务、分布式锁、集群管理等。下面通过一些具体场景来对比有ZooKeeper和没有ZooKeeper的情况…阅读更多...开发板+freertos+lvgl学习1#目的 最近找到了一块开发板&amp;#xff0c;并且买了一个手表屏幕&amp;#xff0c;准备学习下lvglfreerots #详细实验步骤 ##整体配置如下 首先是连接硬件并通过cubemx对主板进行配置  大体分类几类功能&amp;#xff1a; 其中spi1lcd开头的引脚用来控制手表lcd屏幕 其中i2ctouch开头的引脚…阅读更多...create-vite my-vite-uniapp-project搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目&amp;#xff0c;你可以遵循以下步骤&amp;#xff1a; 
安装 Node.js 和 npm。 
使用以下命令全局安装 Vue CLI&amp;#xff1a; 
npm install -g vue/cli创建一个新的 Vue 3项目&amp;#xff0c;并选择 TypeScr…阅读更多...15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:37 +0000</pubDate>
    </item>
    <item>
      <title>zookeeper的作用--有无zookeeper的区别</title>
      <link>https://www.ppmy.cn/news/1541529.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维zookeeper的作用--有无zookeeper的区别news/2025/11/4 0:22:36/如果光了解zookeeper的作用可能有些抽象，本文从对比有无zookeeper的情况来更直观凸显其作用。ZooKeeper在分布式系统中提供了多种关键功能，包括配置管理、命名服务、分布式锁、集群管理等。下面通过一些具体场景来对比有ZooKeeper和没有ZooKeeper的情况。1. 配置管理没有ZooKeeper配置文件：每个节点可能需要一个本地配置文件。更新配置：当配置发生变化时，需要手动更新每个节点的配置文件。同步问题：很难保证所有节点的配置是同步的，容易出现不一致的问题。扩展性：添加或移除节点时，需要手动更新配置文件。有ZooKeeper集中存储：配置信息存储在ZooKeeper中，所有节点从ZooKeeper读取配置。自动通知：配置发生变化时，ZooKeeper可以自动通知所有相关的节点。一致性：ZooKeeper保证所有节点看到的配置是一致的。动态管理：可以动态地添加或移除节点，而不需要手动更新配置文件。2. 名服务没有ZooKeeper硬编码：服务名称和地址可能需要硬编码在客户端代码中。维护困难：当服务的地址发生变化时，需要手动更新所有客户端代码。缺乏灵活性：难以支持动态的服务发现和负载均衡。有ZooKeeper动态注册：服务可以在启动时向ZooKeeper注册自己的名称和地址。服务发现：客户端可以从ZooKeeper获取服务列表，并选择合适的服务实例。负载均衡：可以通过ZooKeeper实现简单的负载均衡策略。高可用性：即使某些服务实例失败，ZooKeeper可以提供最新的服务列表。3. 分布式锁没有ZooKeeper复杂实现：需要自己实现分布式锁机制，可能涉及复杂的网络通信和状态管理。一致性问题：难以保证锁的一致性和可靠性。性能问题：自定义的锁机制可能不如ZooKeeper提供的高效。有ZooKeeper简单实现：ZooKeeper提供了现成的分布式锁实现，使用起来非常简单。一致性：ZooKeeper保证了锁的一致性和可靠性。高性能：ZooKeeper的锁机制经过优化，性能较高。4. 集群管理没有ZooKeeper手动管理：需要手动监控和管理集群中的节点。故障检测：需要自己实现故障检测机制，可能会比较复杂。选举主节点：需要自己实现主节点选举机制，可能会出现脑裂等问题。有ZooKeeper自动管理：ZooKeeper可以自动监控集群中的节点，检测节点的加入和离开。故障检测：ZooKeeper提供了内置的故障检测机制，可以快速发现节点故障。选举主节点：ZooKeeper可以自动进行主节点选举，确保只有一个主节点存在，避免脑裂问题。总结没有ZooKeeper：需要手动处理配置管理、服务发现、分布式锁、集群管理等问题。实现复杂，容易出错，难以保证一致性。维护成本高，扩展性差。有ZooKeeper：提供了现成的解决方案，简化了分布式系统的开发和维护。保证了一致性和可靠性，提高了系统的稳定性和性能。易于扩展和维护，降低了开发和运维的成本。通过这些具体的例子，可以看到ZooKeeper在分布式系统中起到了至关重要的作用，使得系统更加健壮、可靠和易于管理。http://www.ppmy.cn/news/1541529.html相关文章开发板+freertos+lvgl学习1#目的 最近找到了一块开发板&amp;#xff0c;并且买了一个手表屏幕&amp;#xff0c;准备学习下lvglfreerots #详细实验步骤 ##整体配置如下 首先是连接硬件并通过cubemx对主板进行配置  大体分类几类功能&amp;#xff1a; 其中spi1lcd开头的引脚用来控制手表lcd屏幕 其中i2ctouch开头的引脚…阅读更多...create-vite my-vite-uniapp-project搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目&amp;#xff0c;你可以遵循以下步骤&amp;#xff1a; 
安装 Node.js 和 npm。 
使用以下命令全局安装 Vue CLI&amp;#xff1a; 
npm install -g vue/cli创建一个新的 Vue 3项目&amp;#xff0c;并选择 TypeScr…阅读更多...15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:37 +0000</pubDate>
    </item>
    <item>
      <title>开发板+freertos+lvgl学习1</title>
      <link>https://www.ppmy.cn/news/1541528.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维开发板+freertos+lvgl学习1news/2025/11/4 0:22:36/#目的最近找到了一块开发板，并且买了一个手表屏幕，准备学习下lvgl+freerots#详细实验步骤##整体配置如下首先是连接硬件并通过cubemx对主板进行配置大体分类几类功能：其中spi1+lcd开头的引脚用来控制手表lcd屏幕其中i2c+touch开头的引脚用来支持手表lcd屏幕的触摸余下led开头的表明主板上的两个灯，用于调试K开头的表明按键引脚，主板有三个按键##中断配置如下：这里只有三个按键中断和触摸屏的中断，其他暂时不需要，后续如果需要再次添加##gpio配置如下，注意中断引脚必须内部上拉##clock配置如下：##注意开发板一般都是将引脚引出，所以i2c1并没有上拉电阻，导致调试出现问题，在这里需要手工焊接上拉电阻4.7k到3.3v。之前手头没有4.7k的，只能使用10k的弱上拉，然后导致i2c只支持100k的传输速率。填上一个工程名字，就可以进入下一步了http://www.ppmy.cn/news/1541528.html相关文章create-vite my-vite-uniapp-project搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目&amp;#xff0c;你可以遵循以下步骤&amp;#xff1a; 
安装 Node.js 和 npm。 
使用以下命令全局安装 Vue CLI&amp;#xff1a; 
npm install -g vue/cli创建一个新的 Vue 3项目&amp;#xff0c;并选择 TypeScr…阅读更多...15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:36 +0000</pubDate>
    </item>
    <item>
      <title>create-vite my-vite-uniapp-project</title>
      <link>https://www.ppmy.cn/news/1541527.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维create-vite my-vite-uniapp-projectnews/2025/11/4 0:22:35/搭建一个使用 Vue 3、TypeScript、Vite、uni-app、uView UI库和Element Plus的项目，你可以遵循以下步骤：安装 Node.js 和 npm。使用以下命令全局安装 Vue CLI：npminstall-g @vue/cli创建一个新的 Vue 3项目，并选择 TypeScript 和 Vite：vue create my-uni-appcdmy-uni-app
vueaddtypescript集成 uni-app。首先，安装 @vue/cli-plugin-uni 插件：npminstall@vue/cli-plugin-uni然后，通过 Vue CLI 添加 uni-app 支持：vueadduni安装 uView UInpminstalluview-ui导入 uView UI 到项目中，在 main.ts 或 main.js 文件中添加：importuView from'uview-ui';createApp(App).use(uView).mount('#app');http://www.ppmy.cn/news/1541527.html相关文章15_卸载操作在之前我们就提到&amp;#xff0c;首次渲染之后&amp;#xff0c;后续如果再调用 render 函数时&amp;#xff0c;传递的 vnode 为 null 则表示是卸载。 
当时我们是直接通过执行 container.innerHTML  ‘’ 来实现的&amp;#xff0c;但是这样做会有以下几个问题&amp;#xff0c;如下&amp;#xff1a; 
容…阅读更多...关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:35 +0000</pubDate>
    </item>
    <item>
      <title>15_卸载操作</title>
      <link>https://www.ppmy.cn/news/1541526.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维15_卸载操作news/2025/11/4 0:22:34/在之前我们就提到，首次渲染之后，后续如果再调用 render 函数时，传递的 vnode 为 null 则表示是卸载。当时我们是直接通过执行 container.innerHTML = ‘’ 来实现的，但是这样做会有以下几个问题，如下：容器内可能是由某个或者多个组件渲染的，当卸载操作发生时，应该正确的调用这些组件的 beforUnmount、unmounted 等生命周期函数。即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该再在卸载操作发生时正确的执行这些对应指令的钩子函数。使用 innerHTML 清空容器的还有一个缺陷是，它并不会移除绑定在 DOM 元素上的事件处理函数正确的卸载方式应该是，根据 vnode 对象获取对应与其相关联的真实 DOM 元素，然后使用原生 DOM 操作方式将该元素移除。为此，我们需要再 vnode 与真实 DOM 元素之间建立联系，修改 mountElement 函数，如下：functionmountElement(vnode,container){// 让 vnode.el 引用真实的 dom 元素constel=(vnode.el=hostCreateElement(vnode.type))// ... 省略其他代码}这样建立联系之后，当卸载的时候，只需要根据 vnode.el 属性即可获取真实的 dom 元素，然后在将其从父元素中移除，如下：functionrender(vnode,container){if(vnode){patch(container._vnode,vnode,container)}else{// 卸载操作if(container._vnode){// 获取 vnode 关联的真实 domconst{el}=container._vnode// 获取 el 的父元素constparent=el.parentNode// 调用父元素的 removeChild 方法if(parent){parent.removeChild(el)}}container._vnode=vnode}}根据之前的设计方案，这个卸载子元素的操作，会经常用到，我们将其提取出来，封装到 unmount 函数中，如下：functionunmount(vnode){const{el}=vnodeconstparent=el.parentNodeif(parent){parent.removeChild(el)}}http://www.ppmy.cn/news/1541526.html相关文章关于使用 C# 处理水位数据多种格式的统一转换关于使用 C# 处理水位数据多种格式的统一转换 1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码&amp;#xff0c;文件输出保存 1、…阅读更多...简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:34 +0000</pubDate>
    </item>
    <item>
      <title>关于使用 C# 处理水位数据多种格式的统一转换</title>
      <link>https://www.ppmy.cn/news/1541525.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维关于使用 C# 处理水位数据多种格式的统一转换news/2025/11/4 0:22:34/关于使用 C# 处理水位数据多种格式的统一转换1、前言2、水位数据的多种格式3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间4.2、多种格式的统一转换 C# 代码4.3、多种格式的统一转换 C# 代码，文件输出保存1、前言YAC9900 水位雨量存储器有很多固件版本，SD 卡存储的数据存在多种数据格式。统一转换数据格式精简优化编程代码。同时多种版本的文件在打开对话框进行多选文件，合并所有月份的数据，整合数据文件。2、水位数据的多种格式因 YAC9900 版本不同，SD卡存储数据格式有四种情况1、日期、时间、水位(Z:)、雨量(PT:)、电压(VT:)"2024/03/31 23:55:00 Z:28.29 PT:976.5 VT:12.91",2、数据个数、日期、时间、水位(Z:)、雨量(PT:)、电压(VT:)"num1120 2024/07/02 09:45:00 Z:34.94 PT:269.5 VT:14.24",3、日期、时间、水位、雨量、电压"2024/04/30 23:55:00 29.179 277.5 12.71",4、每30分钟记录水位，其它无水位："2021/01/01 00:00:00 Z:27.37 PT:0 VT:11.31","2021/01/01 00:05:00 PT:0 VT:11.33","2021/01/01 00:10:00 PT:0 VT:11.36","2021/01/01 00:15:00 PT:0 VT:11.30","2021/01/01 00:20:00 PT:0 VT:11.31","2021/01/01 00:25:00 PT:0 VT:11.32","2021/01/01 00:30:00 Z:27.36 PT:0 VT:11.23",从上面数据可以看出，以空格分解；设定以第一列为日期，则后面依次是：第二列为时间，则第三列为水位，第四列为雨量，第五列为设备电压。3、水位数据多种格式的统一转换程序展示4、水位数据多种格式的统一转换 C# 代码4.1、声明引用命名空间usingSystem;usingSystem.Collections.Generic;usingSystem.Linq;usingSystem.Text;usingSystem.IO;usingSystem.Globalization;4.2、多种格式的统一转换 C# 代码Array.Sort(FilesList);//打开对话框选择多个 SD 卡数据文件后，进行文件字符串排序//Console.WriteLine("文件列表: " + String.Join("\r\n", x));stringFilePathName=FilesList[0];intPos=FilePathName.LastIndexOf(".");List&lt;string&gt;WaterLevelAndRain=newList&lt;string&gt;();foreach(stringFileStrinFilesList){using(StreamReadersr=newStreamReader(FileStr)){stringline;while((line=sr.ReadLine())!=null){WaterLevelAndRain.Add(line);//将多文件的所有数据添加到LIST列表}}}//Console.WriteLine("原始列表: " + String.Join("\r\n", WaterLevelAndRain));WaterLevelAndRain.RemoveAll(str=&gt;string.IsNullOrEmpty(str));//删除LIST空值WaterLevelAndRain=WaterLevelAndRain.Distinct().ToList();//删除LIST重复项，即删除 行数据 重复值string[]WR=WaterLevelAndRain.ToArray();//转换为数组WaterLevelAndRain.Clear();//清除列表，，释放内存空间intWRL=WR.Length;//Console.WriteLine(WR.Length);DateTime[]DataDT=newDateTime[WRL];Double[]WL=newdouble[WRL];Double[]RL=newdouble[WRL];for(inti=0;i&lt;WRL;i++){string[]split=WR[i].Split(',',' ','\t');//以逗号、空格、制表符分裂intnum1=split[0].IndexOf("num");intnum2;if(num1==0)//前有num，新YAC9900前有数据个数标志 num{DataDT[i]=DateTime.Parse(split[1]+" "+split[2]);//整合为时间序列num2=split[3].IndexOf(":");//水位有前缀的按冒号分裂if(num2&gt;0){intnum3=split[3].IndexOf("Z:");if(num3==-1)//数据无水位:{WL[i]=-20000;//假定为无效水位，没有正常读取传感器的水位intindex=split[3].IndexOf(':')+1;stringR=split[3].Substring(index);RL[i]=Convert.ToDouble(R);}else{intindex=split[3].IndexOf(':')+1;stringW=split[3].Substring(index);index=split[4].IndexOf(':')+1;stringR=split[4].Substring(index);WL[i]=Convert.ToDouble(W);RL[i]=Convert.ToDouble(R);}}else{WL[i]=Convert.ToDouble(split[3]);RL[i]=Convert.ToDouble(split[4]);}}elseif(num1==-1)//前无num{inttest=split[0].IndexOf('/');if(test&gt;4)//旧YAC_BUG，在日期数据前出现文件名{split[0]=split[0].Substring(test-4);}DataDT[i]=DateTime.Parse(split[0]+" "+split[1]);num2=split[2].IndexOf(":");if(num2&gt;0){intnum3=split[2].IndexOf("Z:");if(num3==-1)//无水位:{WL[i]=-20000;//假定为无效水位intindex=split[2].IndexOf(':')+1;stringR=split[2].Substring(index);RL[i]=Convert.ToDouble(R);}else{intindex=split[2].IndexOf(':')+1;stringW=split[2].Substring(index);index=split[3].IndexOf(':')+1;stringR=split[3].Substring(index);WL[i]=Convert.ToDouble(W);RL[i]=Convert.ToDouble(R);}}else{WL[i]=Convert.ToDouble(split[2]);RL[i]=Convert.ToDouble(split[3]);}}//Console.WriteLine(String.Join(",", split));//Console.WriteLine(DataDT[i]);//Console.WriteLine(WL[i]);//Console.WriteLine(RL[i]);//Console.WriteLine();}4.3、多种格式的统一转换 C# 代码，文件输出保存stringStartDate=DataDT[0].ToString("yyyy年MM月dd日",CultureInfo.InvariantCulture);//获取数据的开始日期stringEneDate=DataDT[WRL-1].ToString("yyyy年MM月dd日",CultureInfo.InvariantCulture);//获取数据的结束日期stringRainFilePathName=FilePathName.Substring(0,Pos)+"-"+StartDate+"至"+EneDate+"雨量"+FilePathName.Substring(Pos);stringWaterLevelFilePathName=FilePathName.Substring(0,Pos)+"-"+StartDate+"至"+EneDate+"水位"+FilePathName.Substring(Pos);FileStreamSaveWLFS=newFileStream(WaterLevelFilePathName,FileMode.Create);StreamWriterSWWLFS=newStreamWriter(SaveWLFS,Encoding.GetEncoding("gb2312"));FileStreamSaveRAFS=newFileStream(RainFilePathName,FileMode.Create);StreamWriterSWRAFS=newStreamWriter(SaveRAFS,Encoding.GetEncoding("gb2312"));for(inti=0;i&lt;WRL;i++){stringOutWL="";stringOutRA="";if(i==0&amp;&amp;WL[i]!=-20000){OutWL=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+((int)(WL[i]*100)).ToString("000000");OutRA=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+RL[i].ToString("0000.0");}elseif(WL[i]!=-20000&amp;&amp;DataDT[i]!=DataDT[i-1]){OutWL=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+((int)(WL[i]*100)).ToString("000000");OutRA=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+RL[i].ToString("0000.0");}elseif(i==WRL-1&amp;&amp;WL[i]==-20000)//最后一个是-20000{OutWL="";OutRA=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+RL[i].ToString("0000.0");}elseif(i&gt;0&amp;&amp;WL[i]==-20000&amp;&amp;WL[i+1]!=-20000&amp;&amp;WL[i-1]!=-20000&amp;&amp;Math.Abs(WL[i+1]-WL[i-1])&lt;=0.03&amp;&amp;DataDT[i]!=DataDT[i-1]){WL[i]=(WL[i+1]+WL[i-1])/2;OutWL=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+((int)(WL[i]*100)).ToString("000000");OutRA=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+RL[i].ToString("0000.0");}else{OutWL="";OutRA=DataDT[i].ToString("yyyy/MM/dd HH:mm ",CultureInfo.InvariantCulture)+RL[i].ToString("0000.0");}if(OutWL!=""){SWWLFS.WriteLine(OutWL);}SWRAFS.WriteLine(OutRA);OutWL="";OutRA="";//Console.WriteLine(OutWL);//Console.WriteLine();// OutSTR = DataDT[i].ToString("yy/MM/dd hh:mm ", CultureInfo.InvariantCulture) + RL[i].ToString("0000.0");}SWWLFS.Flush();//关闭打开的文件，释放内存空间SWWLFS.Close();SWRAFS.Flush();SWRAFS.Close();Array.Clear(DataDT,0,WRL);//关闭数组，释放内存空间Array.Clear(WL,0,WRL);Array.Clear(RL,0,WRL);http://www.ppmy.cn/news/1541525.html相关文章简单的 curl HTTP的POSTGET请求以及ip port连通性测试简单的 curl HTTP的POST&amp;GET请求以及ip port连通性测试 
1. 需求 
我们公司有一个演示项目&amp;#xff0c;需要到客户那边进行项目部署&amp;#xff0c;项目部署完成后我们需要进行项目后端接口的测试功能&amp;#xff0c;但是由于客户那边么有条件安装类似于postman这种的测试工具&amp;am…阅读更多...STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:34 +0000</pubDate>
    </item>
    <item>
      <title>简单的 curl HTTP的POSTGET请求以及ip port连通性测试</title>
      <link>https://www.ppmy.cn/news/1541524.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维简单的 curl HTTP的POSTGET请求以及ip port连通性测试news/2025/11/4 0:22:33/简单的curlHTTP的POST&amp;GET请求以及ip port连通性测试1. 需求我们公司有一个演示项目，需要到客户那边进行项目部署，项目部署完成后我们需要进行项目后端接口的测试功能，但是由于客户那边么有条件安装类似于postman这种的测试工具，所以我们只能使用LINUX curl命令来模拟登录接口的登录测试。2. 模拟测试过程我们测试的登录一共有两个接口，其中一个是我们uaa-server登录服务，使用登录服务ip端口直接进行登录，另一个为我们使用网关接口，进行登录转发到登录系统，进行登录操作。接口支持form-data以及json格式参数登录，请求方式为POST形式。注意：我们测试环境密码校验部分已经注释，可以随意填写，所以测试密码为随机填写具体参数如下：header：登录服务为信贷以及风险两个项目提供登录，使用一个systemFlag为系统判定参数，0 信贷 1风险username: 用户名password: 用户密码uaa-server以及credit-gateway两个服务具体的请求的地址分别如下：uaa-server：http://10.100.3.13:11204/logincredit-gateway：http://10.100.3.12:11200/dics/demo/login/login2.1 postman 测试接口我们使用postman分别进行接口测试，由于两种登录的参数相同，那么我们就使用一个接口进行postman进行测试了，我们使用网关接口进行测试：header 内容为 0 信贷查询请求参数为 name以及password，请求类型为 form-data请求返回结果如下：我们使用 json 格式再次进行请求，发现可以正常请求2.2 curl 测试接口我们使用curl 进行测试接口，接口使用网关接口，首先我们使用json格式进行请求接口curl-v -X POST -H"Content-Type:application/json""systemFlag: 0"-d'{"password":"a11111","username":331326}'http://10.100.3.12:11200/dics/demo/login/login具体的参数解释如下：-v：启用详细模式，显示更多调试信息。-X POST：指定请求方法为 POST。-H “Content-Type:application/json” 设置Content-Type为json格式-H “systemFlag: 0”：添加一个名为 systemFlag 的请求头，并将其值设置为 0。-d ‘{“password”:“a11111”,“username”:331326}’ json格式的请求体执行结果如下，成功相应token信息：我们再使用form-data形式请求接口，具体的请求语句如下：curl-v -H"Content-Type: multipart/form-data"-X POST -F'username=331326'-F'password=a11111'http://10.100.3.12:11200/dics/demo/login/login --insecure具体的参数解释跟上面解释相同，稍微不同的解释如下：-H “Content-Type: multipart/form-data” 使用 form-data形式访问-F ‘username=331326’ -F ‘password=a11111’ 具体的请求标点 form 参数–insecure 允许 curl 忽略 SSL 证书验证请求结果如下所示，发现卡住了，卡在了HTTP/1.1 100 Continue处不动了 ：原因：当你执行 curl 命令时，如果遇到HTTP/1.1 100 Continue响应并卡住，这通常是由于服务器在等待客户端发送完整的请求体。100 Continue 是 HTTP/1.1 中的一种状态码，表示服务器已经收到了请求头，并且客户端应该继续发送请求体。解决方法：尝试禁用 100 Continue 状态码的处理，使用 -H “Expect:” 参数来禁用 Expect: 100-continue 头，修改后的脚本为：curl-v -H"Content-Type: multipart/form-data"-H"Expect:"-X POST -F'username=331326'-F'password=wcwcwcw'http://10.100.3.12:11200/dics/demo/login/login --insecure发现脚本可以正常执行了，并且返回了需要的token信息。3. curlip port连通性测试我们测试当前机器是否与10.100.3.12:11200网络相同，可以使用curl 命令进行测试，具体脚本如下：# -m 为设置超时时间10scurl-v -m10--insecure http://10.100.3.12:11200/我们在服务器上执行的结果如下：如果连接成功如果连接失败http://www.ppmy.cn/news/1541524.html相关文章STM32CubeMX软件界面不清晰调整方法STM32CubeMX软件界面不清晰调整方法 
添加系统环境变量 变量名: J2D_D3D 变量值: false 
结果 貌似没有多大变化 
添加上述系统环境变量后界面变化如下(没什么大变化) 参考链接 
STM32CubeMX软件界面花屏&amp;#xff0c;混乱的解决方案。 
彻底解决STM32CUBEMX画面撕裂/重影问题阅读更多...【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:33 +0000</pubDate>
    </item>
    <item>
      <title>STM32CubeMX软件界面不清晰调整方法</title>
      <link>https://www.ppmy.cn/news/1541523.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维STM32CubeMX软件界面不清晰调整方法news/2025/11/4 0:22:32/STM32CubeMX软件界面不清晰调整方法添加系统环境变量变量名:J2D_D3D变量值:false结果貌似没有多大变化添加上述系统环境变量后界面变化如下(没什么大变化)参考链接STM32CubeMX软件界面花屏，混乱的解决方案。彻底解决STM32CUBEMX画面撕裂/重影问题http://www.ppmy.cn/news/1541523.html相关文章【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget文章目录 Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar Widget Qt 4. Qt显示类控件 
Label QLabel 可以用来显示文本和图片。 
属性说明textQLabel 中的文本textFormat文本的格式&amp;#xff1a;Qt::PlainText&amp;#xff1a;纯文本 Qt::RichText&amp;#xff1a;富文本&amp;#xf…阅读更多...FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:32 +0000</pubDate>
    </item>
    <item>
      <title>【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widget</title>
      <link>https://www.ppmy.cn/news/1541522.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Qt】控件——Qt显示类控件、常见的显示类控件、显示类控件的使用、Label、LCD Number、ProgressBar、Calendar Widgetnews/2025/11/4 0:22:31/文章目录Qt4. Qt显示类控件LabelLCD NumberProgressBarCalendar WidgetQt4. Qt显示类控件LabelQLabel 可以用来显示文本和图片。属性说明textQLabel 中的文本textFormat文本的格式：Qt::PlainText：纯文本 Qt::RichText：富文本（支持 html 标签） Qt::MarkdownText：markdown 格式 Qt::AutoText：根据文本内容自动决定文本格式pixmapQLabel 内部包含的图片scaledContents设为 true 表示内容自动拉伸填充 QLabel，设为 false 则不会自动拉伸alignment对齐方式，可以设置水平和垂直方向如何对齐wordWrap设为 true 内部的文本会自动换行，设为 false 则内部文本不会自动换行indent设置文本缩进，水平和垂直方向都生效margin内部文本和边框之间的边距，不同于 indent，但是是上下左右四个方向都同时有效，而 indent 最多只是两个方向有效（具体哪两个方向有效取决于 alignment）openExternalLinks是否允许打开一个外部的链接（当 QLabel 文本内容包含 url 的时候涉及到）buddy给 QLabel 关联一个 “伙伴”，这样点击 QLabel 时就能激活对应的伙伴，例如伙伴如果是一个 QCheckBox，那么该 QCheckBox 就会被选中。我们通过设置 textFormat 来设置 QLabel 的文本格式。我们还可以向QLabel中添加图片，只要使用setPixmap函数。可以对QLabel中的图片进行位置和大小的调整。QFrame 是 QLabel 的父类. 其中 frameShape 属性用来设置边框性质。属性性质QFrame::Box矩形边框。QFrame::Panel带有可点击区域的面板边框。QFrame::WinPanelWindows 风格的边框。QFrame::HLine水平线边框。QFrame::VLine垂直线边框。QFrame::StyledPanel带有可点击区域的面板边框，但样式取决于窗口主题。LCD NumberQLCDNumber 是一个专门用来显示数字的控件。属性说明intValueQLCDNumber 显示的数字值（int）valueQLCDNumber 显示的数字值（double），和 intValue 是联动的。例如给 value 设为 1.5，intValue 的值就是 2。另外，设置 value 和 intValue 的方法名字为 display，而不是 setValue 或者 setIntValuedigitCount显示几位数字mode数字显示形式：QLCDNumber::Dec：十进制模式，显示常规的十进制数字。 QLCDNumber::Hex：十六进制模式，以十六进制格式显示数字。 QLCDNumber::Bin：二进制模式，以二进制格式显示数字。QLCDNumber::Oct：八进制模式，以八进制格式显示数字。只有十进制的时候才能显示小数点后的内容。segmentStyle设置显示风格：QLCDNumber::Flat：平面的显示风格，数字呈现在一个平坦的表面上。QLCDNumber::Outline：轮廓显示风格，数字具有清晰的轮廓和阴影效果。QLCDNumber::Filled：填充显示风格，数字被填充颜色并与背景区分开。smallDecimalPoint设置比较小的小数点。创建一个倒计时框，并且设置初始数字为10。使用计时器来实现计时器，timer每次计一秒，当时间到了触发槽函数，令计时器中的数字减一。ProgressBar使用 QProgressBar 表示一个进度条。属性说明minimum进度条最小值maximum进度条最大值value进度条当前值alignment文本在进度条中的对齐方式：Qt::AlignLeft：左对齐 Qt::AlignRight：右对齐 Qt::AlignCenter：居中对齐 Qt::AlignJustify：两端对齐textVisible进度条的数字是否可见orientation进度条的方向是水平还是垂直invertAppearance是否是朝反方向增长进度textDirection文本的朝向format展示的数字格式：% p：表示进度的百分比（0-100）% v：表示进度的数值（0-100）% m：表示剩余时间（以毫秒为单位）% t：表示总时间（以毫秒为单位）创建进度条。Calendar WidgetQCalendarWidget 表示一个 “日历”属性说明selectDate当前选中的日期minimumDate最小日期maximumDate最大日期firstDayOfWeek每周的第一天（也就是日历的第一列）是周几gridVisible是否显示表格的边框selectionMode是否允许选择日期navigationBarVisible日历上方标题是否显示horizontalHeaderFormat日历上方标题显示的日期格式verticalHeaderFormat日历第一列显示的内容格式dateEditEnabled是否允许日期被编辑创建日历。http://www.ppmy.cn/news/1541522.html相关文章FileLink跨网文件交换平台——能源化工行业的安全传输解决方案在现代能源化工行业中&amp;#xff0c;数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加&amp;#xff0c;传统文件传输方式已无法满足日益增长的需求。为此&amp;#xff0c;FileLink跨网文件交换平台应运而生&amp;#xff0c;成为能源化工行业高效、安全的传输解决方案。 Fil…阅读更多...npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:32 +0000</pubDate>
    </item>
    <item>
      <title>FileLink跨网文件交换平台——能源化工行业的安全传输解决方案</title>
      <link>https://www.ppmy.cn/news/1541521.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维FileLink跨网文件交换平台——能源化工行业的安全传输解决方案news/2025/11/4 0:22:31/在现代能源化工行业中，数据的快速、安全传输至关重要。随着项目的复杂性和跨地域合作的增加，传统文件传输方式已无法满足日益增长的需求。为此，FileLink跨网文件交换平台应运而生，成为能源化工行业高效、安全的传输解决方案。FileLink跨网文件交换平台FileLink跨网文件交换的核心优势在于其跨网传输能力。无论您是在不同的网络环境中，还是需要在多个工地和办公室之间传递重要文件，FileLink跨网文件交换都能快速稳定地完成文件交换。其支持多种网络协议，确保数据在不同环境间的无缝传输，助力企业高效协作。安全性是FileLink跨网文件交换的另一大亮点。在能源化工行业，数据泄露可能导致巨大的经济损失和安全隐患。FileLink跨网文件交换采用先进的加密技术，确保文件在传输过程中的安全性。每一份文件都经过多层加密，只有经过授权的人员才能访问，从而有效防止数据被非法获取。易用性也是FileLink跨网文件交换的一大优势。平台界面友好，操作直观，用户无需专业技术背景也能轻松上手。通过简单的配置，用户可以快速进行文件上传和下载，大幅提升工作效率。无论是文件大小还是格式，FileLink跨网文件交换都能迅速处理，为能源化工企业提供了极大的便利。此外，FileLink跨网文件交换还具备强大的搜索和分类功能，用户可以根据关键词或项目快速找到所需文件，避免了因信息混乱而导致的工作延误。这种高效的数据管理方式，确保了企业在面对复杂项目时，始终能够快速获取关键信息。总之，FileLink跨网文件交换平台为能源化工行业提供了一种高效、安全的数据传输解决方案。通过快速传输和强大的安全保障，FileLink跨网文件交换助力企业在激烈的市场竞争中稳步前行，让数据为业务增长提供有力支持。http://www.ppmy.cn/news/1541521.html相关文章npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednpm run serve 提示Cannot read property ‘upgrade’ of undefined 一般是proxy的target代理域名问题导致的&amp;#xff0c;如下&amp;#xff1a;  解决方案&amp;#xff1a; proxy: { “/remoteDealerReportApi”: { target: ‘http://demo-.com.cn’, //此域名有问题&amp;#xff0c;会导致…阅读更多...数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:31 +0000</pubDate>
    </item>
    <item>
      <title>npm run serve 提示异常Cannot read property ‘upgrade‘ of undefined</title>
      <link>https://www.ppmy.cn/news/1541520.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维npm run serve 提示异常Cannot read property ‘upgrade‘ of undefinednews/2025/11/4 0:22:30/npm run serve 提示Cannot read property ‘upgrade’ of undefined一般是proxy的target代理域名问题导致的，如下：解决方案：proxy: {“/remoteDealerReportApi”: {target: ‘http://demo-.com.cn’, //此域名有问题，会导致运行异常ws: true,changeOrigin: true,pathRewrite: {“^/remoteDealerReportApi”: “”}},http://www.ppmy.cn/news/1541520.html相关文章数据库安全：常见数据库安全攻击手段及防范措施数据库安全： 常见数据库安全攻击手段及防范措施 
在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。 
一、常见数据库…阅读更多...MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:30 +0000</pubDate>
    </item>
    <item>
      <title>数据库安全：常见数据库安全攻击手段及防范措施</title>
      <link>https://www.ppmy.cn/news/1541519.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维数据库安全：常见数据库安全攻击手段及防范措施news/2025/11/4 0:22:29/数据库安全： 常见数据库安全攻击手段及防范措施在当今数字化时代，数据库存储着大量的关键信息，包括用户数据、财务信息、商业机密等。因此，数据库安全至关重要。了解常见的数据库安全攻击手段以及相应的防范措施，可以帮助我们更好地保护数据库免受攻击。一、常见数据库安全攻击手段（一）SQL 注入攻击攻击原理：SQL 注入是一种常见的数据库攻击手段，攻击者通过在输入参数中插入恶意的 SQL 语句，欺骗数据库服务器执行这些恶意语句，从而获取、修改或删除数据库中的数据。例如，一个网站的登录页面可能使用 SQL 语句来验证用户的登录信息。如果这个页面没有对用户输入的用户名和密码进行充分的过滤和验证，攻击者就可以在用户名或密码输入框中输入恶意的 SQL 语句，例如“’ OR 1=1 --”。这个语句会使数据库服务器认为条件永远为真，从而允许攻击者登录系统，即使他们不知道正确的用户名和密码。危害：可能导致敏感数据泄露，如用户的个人信息、财务数据等。可以修改或删除数据库中的数据，破坏数据的完整性。攻击者可以获取数据库的管理员权限http://www.ppmy.cn/news/1541519.html相关文章MySQL笔试面试题之AI答（2）文章目录 6. 如何通过 Shell 登入 MySQL&amp;#xff1f;7. MySQL如何列出所有数据库&amp;#xff1f;8. 如何MySQL切换到某个数据库并在上面工作&amp;#xff1f;一、登录到 MySQL二、查看所有数据库&amp;#xff08;可选&amp;#xff09;三、切换到目标数据库四、在目标数据库上工作五、注意事项 …阅读更多...探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:29 +0000</pubDate>
    </item>
    <item>
      <title>MySQL笔试面试题之AI答（2）</title>
      <link>https://www.ppmy.cn/news/1541518.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQL笔试面试题之AI答（2）news/2025/11/4 0:22:28/文章目录6. 如何通过 Shell 登入 MySQL？7. MySQL如何列出所有数据库？8. 如何MySQL切换到某个数据库并在上面工作？一、登录到 MySQL二、查看所有数据库（可选）三、切换到目标数据库四、在目标数据库上工作五、注意事项9. MySQL如何列出某个数据库内所有表？10. MySQL 如何获取表内所有 Field 对象的名称和类型？方法一：使用 `DESCRIBE` 语句方法二：查询 `INFORMATION_SCHEMA.COLUMNS` 表6. 如何通过 Shell 登入 MySQL？要通过 Shell 登入 MySQL 数据库，你需要使用 MySQL 提供的命令行工具mysql。以下是具体步骤：打开 Shell：在 Linux 或 macOS 上，你可以打开终端（Terminal）。在 Windows 上，你可以使用命令提示符（Command Prompt）或 PowerShell。确保 MySQL 已安装并运行：验证 MySQL 服务是否已安装并正在运行。在 Linux 上，你可以使用如sudo systemctl status mysql或sudo service mysql status来检查 MySQL 服务状态。在 Windows 上，你可以通过“服务”管理工具查看 MySQL 服务的状态。使用mysql命令登录：基本的mysql命令格式如下：mysql -u 用户名 -p例如，如果你的 MySQL 用户名是root，你可以使用以下命令：mysql -u root -p你会被提示输入密码，输入密码后按回车即可登录。注意，在输入密码时，密码不会在屏幕上显示。（可选）指定数据库：如果你希望在登录时直接选择一个特定的数据库，可以使用-D选项。例如：mysql -u root -p -D mydatabase（可选）指定主机：默认情况下，mysql命令会尝试连接到本地主机上的 MySQL 服务器。如果你需要连接到远程主机，可以使用-h选项。例如：mysql -u 用户名 -p -h 远程主机地址（可选）指定端口：如果 MySQL 服务器使用非默认端口（3306），你可以使用-P选项指定端口号。例如：mysql -u 用户名 -p -P 3307以下是一个综合示例，假设你要以用户名root，密码yourpassword（注意：实际使用中，不要在命令行中直接明文输入密码），连接到远程主机192.168.1.100的mydatabase数据库，且该 MySQL 服务器运行在端口3307上：mysql -u root -p -h 192.168.1.100 -P 3307 -D mydatabase然后，系统会提示你输入密码。输入你的密码并按回车即可登录。登录成功后，你会看到 MySQL 的提示符，通常是mysql&gt;，表示你现在已经成功登录到 MySQL 数据库中，可以开始执行 SQL 命令了。7. MySQL如何列出所有数据库？在 MySQL 中，要列出所有数据库，你可以使用SHOW DATABASES;命令。以下是在成功登录到 MySQL 后执行此命令的步骤：登录到 MySQL：使用mysql命令行工具登录到你的 MySQL 服务器。例如：mysql -u 用户名 -p然后输入你的密码。执行命令：在 MySQL 提示符（mysql&gt;）下，输入以下命令并回车：SHOWDATABASES;查看结果：MySQL 会返回一个包含所有数据库名称的列表。每个数据库名称占据一行。例如，登录后执行SHOW DATABASES;命令的输出可能类似于以下内容：mysql&gt; SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| your_database      |
+--------------------+
5 rows in set (0.00 sec)在这个例子中，information_schema、mysql、performance_schema和sys是 MySQL 的内置数据库，而your_database是你创建的数据库。注意：执行SHOW DATABASES;命令需要适当的权限。如果你没有足够的权限，MySQL 可能会返回一个错误消息。通常，具有全局SHOW DATABASES权限的用户（如root用户）可以查看所有数据库。8. 如何MySQL切换到某个数据库并在上面工作？在 MySQL 中，切换到某个数据库并在上面工作的过程相对简单。以下是具体步骤：一、登录到 MySQL首先，你需要使用mysql命令行工具登录到你的 MySQL 服务器。例如：mysql -u 用户名 -p然后输入你的密码。成功登录后，你会看到 MySQL 的提示符，通常是mysql&gt;。二、查看所有数据库（可选）在切换数据库之前，你可以使用SHOW DATABASES;命令来查看所有可用的数据库。这有助于确认你要切换到的数据库是否存在。SHOWDATABASES;三、切换到目标数据库使用USE语句来切换到目标数据库。语法如下：USEdatabase_name;其中database_name是你要切换到的数据库的名称。例如，如果你要切换到名为mydatabase的数据库，可以执行以下命令：USEmydatabase;如果数据库存在，MySQL 会返回一条消息，表明你已经成功切换到了该数据库。四、在目标数据库上工作一旦你切换到了目标数据库，所有的 SQL 语句都会在该数据库中执行，直到你切换到另一个数据库或者退出 MySQL。你可以执行各种 SQL 命令来查询、更新、删除或插入数据。例如：-- 查询表中的数据SELECT*FROMmytable;-- 插入新数据INSERTINTOmytable(column1,column2)VALUES('value1','value2');-- 更新数据UPDATEmytableSETcolumn1='newvalue'WHEREcolumn2='value2';-- 删除数据DELETEFROMmytableWHEREcolumn2='value2';五、注意事项数据库名称大小写敏感：在 MySQL 中，数据库名称是大小写敏感的（这取决于操作系统和 MySQL 的配置）。因此，在切换数据库时，请确保你输入的数据库名称与实际数据库名称的大小写一致。权限问题：确保你有权访问和修改目标数据库。如果你没有足够的权限，MySQL 会返回一个错误消息。连接信息：切换数据库不会改变当前的数据库连接。这意味着你可以在同一次数据库连接中切换到多个数据库。通过以上步骤，你可以轻松地在 MySQL 中切换到某个数据库并在上面工作。9. MySQL如何列出某个数据库内所有表？在 MySQL 中，要列出某个数据库内的所有表，你可以使用SHOW TABLES;命令。以下是在已经选择（或切换到）目标数据库后执行此命令的步骤：登录到 MySQL：首先，使用mysql命令行工具登录到你的 MySQL 服务器。例如：mysql -u 用户名 -p然后输入你的密码。选择数据库：在成功登录后，使用USE语句来选择你想要列出表的数据库。例如：USEyour_database_name;其中your_database_name是你想要列出表的数据库的名称。列出所有表：在选择数据库后，使用SHOW TABLES;命令来列出该数据库内的所有表。例如：SHOWTABLES;查看结果：MySQL 会返回一个包含所有表名称的列表。每个表名称占据一行。例如，如果你已经选择了名为mydatabase的数据库，并执行SHOW TABLES;命令，输出可能类似于以下内容：mysql&gt; SHOW TABLES;
+------------------+
| Tables_in_mydatabase |
+------------------+
| mytable1         |
| mytable2         |
| another_table    |
+------------------+
3 rows in set (0.00 sec)在这个例子中，mytable1、mytable2和another_table是mydatabase数据库中的表。请确保你有权访问所选数据库，并且该数据库中存在表。如果你没有足够的权限或数据库为空，MySQL 可能会返回一个错误消息或空列表。10. MySQL 如何获取表内所有 Field 对象的名称和类型？在 MySQL 中，要获取某个表内所有字段（Field）的名称和类型，你可以使用DESCRIBE语句或查询INFORMATION_SCHEMA.COLUMNS表。以下是两种方法的详细说明：方法一：使用DESCRIBE语句DESCRIBE语句是获取表结构信息的快捷方式。它会显示表的字段名称、类型、是否允许 NULL、键信息、默认值以及其他额外信息。语法：DESCRIBEtable_name;或简写形式：DESCtable_name;示例：DESCRIBEmy_table;输出将包含类似以下的信息：+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| id          | int(11)      | NO   | PRI | NULL    | auto_increment |
| name        | varchar(255) | YES  |     | NULL    |                |
| created_at  | datetime     | NO   |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+在这个例子中，Field列显示了字段名称，Type列显示了字段类型。方法二：查询INFORMATION_SCHEMA.COLUMNS表INFORMATION_SCHEMA是一个包含了关于所有其他数据库的信息的虚拟数据库。COLUMNS表包含了关于数据库中所有表的列（字段）的信息。语法：SELECTCOLUMN_NAME,DATA_TYPEFROMINFORMATION_SCHEMA.COLUMNSWHERETABLE_SCHEMA='database_name'ANDTABLE_NAME='table_name';示例：SELECTCOLUMN_NAME,DATA_TYPEFROMINFORMATION_SCHEMA.COLUMNSWHERETABLE_SCHEMA='my_database'ANDTABLE_NAME='my_table';输出将包含类似以下的信息：+-------------+-----------+
| COLUMN_NAME | DATA_TYPE |
+-------------+-----------+
| id          | int       |
| name        | varchar   |
| created_at  | datetime  |
+-------------+-----------+在这个例子中，COLUMN_NAME列显示了字段名称，DATA_TYPE列显示了字段类型（注意，这里的数据类型可能会比DESCRIBE输出的更简洁，例如varchar(255)可能只显示为varchar）。你可以根据需要选择其中一种方法来获取表内所有字段的名称和类型。如果你只需要快速查看表结构，DESCRIBE语句通常更方便。如果你需要更详细的信息或想要以编程方式处理这些信息，查询INFORMATION_SCHEMA.COLUMNS表可能更合适。答案来自文心一言，仅供参考http://www.ppmy.cn/news/1541518.html相关文章探索 JavaScript 事件机制（二）：如何自定义事件前言 
在上篇文章中&amp;#xff0c;我们了解了 JavaScript 的事件机制是怎么回事&amp;#xff1a;从事件冒泡到事件捕获&amp;#xff0c;再到事件委托。这次我们要更进一步&amp;#xff0c;聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器&amp;#xff0c;学会之后&amp;#xf…阅读更多...大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:28 +0000</pubDate>
    </item>
    <item>
      <title>探索 JavaScript 事件机制（二）：如何自定义事件</title>
      <link>https://www.ppmy.cn/news/1541517.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维探索 JavaScript 事件机制（二）：如何自定义事件news/2025/11/4 0:22:28/前言在上篇文章中，我们了解了 JavaScript 的事件机制是怎么回事：从事件冒泡到事件捕获，再到事件委托。这次我们要更进一步，聊聊如何在 JavaScript 中自定义事件。这玩意儿可是前端开发中的一把利器，学会之后，你就可以为自己的应用增加更多的互动性和灵活性。历史文章探索 JavaScript 事件机制（一）从基础概念到实战应用什么是自定义事件？我们在开发过程中，常常会碰到一些场景，用原生的浏览器事件（如点击、滚动等）并不能完全满足需求。这时我们就需要“自定义事件”，它就像我们自己定义的一套规则，想啥时候触发就啥时候触发。自定义事件的基本方法JavaScript 提供了 CustomEvent 构造函数，让我们可以轻松创建自定义事件。下面是创建和触发自定义事件的基本步骤：创建事件： 使用 CustomEvent 构造函数。触发事件： 使用元素的 dispatchEvent 方法。监听事件： 使用 addEventListener 监听自定义事件。自定义事件的创建与使用为了让大家更直观地理解，我们来通过一个小例子演示。假设我们有一个计数器，当计数达到某个值时，我们想触发一个自定义事件来通知系统。第一步：创建自定义事件// 创建一个名为 ‘countReached’ 的自定义事件letcountReachedEvent=new CustomEvent('countReached',{detail:{// detail 属性可以用来传递数据message:'计数达到指定值!',time: new Date()}});第二步：监听自定义事件// 选择要监听事件的元素，这里假设是一个按钮letbutton=document.getElementById('myButton');// 为按钮添加自定义事件的监听器
button.addEventListener('countReached', function(event){console.log(event.detail.message);// 输出: 计数达到指定值!console.log('事件触发时间:', event.detail.time);});第三步：触发自定义事件// 定义一个计数器变量letcount=0;// 模拟计数器的增加functionincrementCounter(){count++;console.log('当前计数:', count);// 当计数达到5时，触发自定义事件if(count===5){button.dispatchEvent(countReachedEvent);}}// 假设这个函数被某个其它事件（比如按钮点击）调用document.getElementById('incrementButton').addEventListener('click', incrementCounter);完整代码&lt;!DOCTYPE html&gt;&lt;htmllang="en"&gt;&lt;head&gt;&lt;metacharset="UTF-8"&gt;&lt;metaname="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;自定义事件示例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;buttonid="incrementButton"&gt;增加计数&lt;/button&gt;&lt;buttonid="myButton"&gt;监听自定义事件&lt;/button&gt;&lt;script&gt;// 创建一个名为'countReached'的自定义事件letcountReachedEvent=new CustomEvent('countReached',{detail:{message:'计数达到指定值!',time: new Date()}});// 选择要监听事件的元素letbutton=document.getElementById('myButton');// 为按钮添加自定义事件的监听器button.addEventListener('countReached', function(event){console.log(event.detail.message);console.log('事件触发时间:', event.detail.time);});// 定义一个计数器变量letcount=0;// 模拟计数器的增加functionincrementCounter(){count++;console.log('当前计数:', count);if(count===5){button.dispatchEvent(countReachedEvent);}}// 按钮点击事件document.getElementById('incrementButton').addEventListener('click', incrementCounter);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;在上面的例子中，我们已经看到了如何创建和使用自定义事件。接下来，我们再扩展一些实用的技巧和高级用法，让你在实际项目中更得心应手。高级用法：事件传播与事件目标在事件机制中，我们需要了解事件是如何从目标元素传播（冒泡或捕获）的。自定义事件同样可以利用这种机制。我们可以指定事件是否冒泡以及是否可以被取消。冒泡与取消默认情况下，自定义事件是不冒泡的，但我们可以通过配置选项来改变这一行为。letbubblingEvent=new CustomEvent('bubblingEvent',{bubbles: true, // 允许事件冒泡cancelable: true, // 允许事件取消detail:{message:'这个事件会冒泡！',time: new Date()}});接着，我们可以注册多个事件监听器，分别在不同的 DOM 层次上监听这个事件。&lt;divid="parent"&gt;&lt;divid="child"&gt;&lt;buttonid="bubblingButton"&gt;触发冒泡事件&lt;/button&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 获取 DOM 元素letparent=document.getElementById('parent');letchild=document.getElementById('child');letbubblingButton=document.getElementById('bubblingButton');// 为父元素添加事件监听器parent.addEventListener('bubblingEvent', function(event){console.log('父元素捕获到事件:', event.detail.message);});// 为子元素添加事件监听器child.addEventListener('bubblingEvent', function(event){console.log('子元素捕获到事件:', event.detail.message);});// 触发事件bubblingButton.addEventListener('click',function(){bubblingButton.dispatchEvent(bubblingEvent);});&lt;/script&gt;在这个例子中，当我们点击按钮时，自定义事件会从按钮冒泡到它的父元素。父元素和子元素的事件监听器都会被触发，这就展示了事件冒泡的强大之处。取消事件有时候，我们可能需要在事件传播的过程中取消事件。这个时候，我们可以利用 event.preventDefault() 和 event.stopPropagation() 方法。下面是一个例子：// 创建可以取消的事件letcancelableEvent=new CustomEvent('cancelableEvent',{bubbles: true,cancelable: true,detail:{message:'你可以取消这个事件',time: new Date()}});// 父元素
parent.addEventListener('cancelableEvent', function(event){if(!event.defaultPrevented){console.log('父元素捕获到事件:', event.detail.message);}});// 子元素
child.addEventListener('cancelableEvent', function(event){// 取消事件event.preventDefault();console.log('子元素取消了事件:', event.detail.message);});// 按钮点击触发事件
bubblingButton.addEventListener('click',function(){bubblingButton.dispatchEvent(cancelableEvent);});在这个例子中，子元素的事件监听器会取消事件的默认行为，所以父元素的事件监听器不会接收到这个事件。应用场景表单验证在复杂的表单验证中，我们常常需要在某个字段验证成功或失败时通知其他部分。自定义事件可以很方便地实现这一点。letform=document.getElementById('myForm');letinput=document.getElementById('myInput');// 创建自定义事件letvalidationEvent=new CustomEvent('fieldValidated',{detail:{field:'myInput',valid: false,message:'输入不合法'}});// 表单监听验证事件form.addEventListener('fieldValidated', function(event){if(!event.detail.valid){console.log('验证失败:', event.detail.message);}else{console.log('验证成功');}});// 模拟验证过程input.addEventListener('blur',function(){if(input.value===''){input.dispatchEvent(validationEvent);}});AJAX 请求完成通知在前端开发中，AJAX 请求完成后，需要更新页面的其他部分，这时自定义事件就变得非常有用。letajaxEvent=new CustomEvent('ajaxComplete',{detail:{message:'AJAX 请求已完成',data:{/* 返回的数据 */}}});// 监听 AJAX 完成事件document.addEventListener('ajaxComplete', function(event){console.log(event.detail.message);// 更新页面部分// updatePage(event.detail.data);});// 模拟 AJAX 请求functionmockAjaxRequest(){setTimeout(function(){document.dispatchEvent(ajaxEvent);},1000);}// 模拟按钮点击发送 AJAX 请求letajaxButton=document.getElementById('ajaxButton');ajaxButton.addEventListener('click', mockAjaxRequest);总结自定义事件在前端开发中提供了极大的灵活性，可以帮助我们简化代码逻辑，提升代码的可维护性。通过本文的学习，希望你能够更好地理解和使用自定义事件，为你的项目增添更多的互动和动态效果。http://www.ppmy.cn/news/1541517.html相关文章大厂面试真题-了解云原生吗，简单说一下docker和k8sK8s&amp;#xff08;Kubernetes&amp;#xff09;和Docker都是容器化技术中的关键组件&amp;#xff0c;但它们各自扮演着不同的角色。以下是对这两者的详细解析&amp;#xff1a; 
一、Docker 
Docker是一个开源的容器化平台&amp;#xff0c;它允许开发人员将应用程序及其依赖项打包为一个独立的镜像&amp;…阅读更多...java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:28 +0000</pubDate>
    </item>
    <item>
      <title>大厂面试真题-了解云原生吗，简单说一下docker和k8s</title>
      <link>https://www.ppmy.cn/news/1541516.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大厂面试真题-了解云原生吗，简单说一下docker和k8snews/2025/11/4 0:22:27/K8s（Kubernetes）和Docker都是容器化技术中的关键组件，但它们各自扮演着不同的角色。以下是对这两者的详细解析：一、DockerDocker是一个开源的容器化平台，它允许开发人员将应用程序及其依赖项打包为一个独立的镜像，以便在不同的环境中运行。Docker提供了一种轻量级的虚拟化方式，将应用程序与底层操作系统隔离开来，但共享操作系统的内核。这使得Docker容器可以更快速地启动和停止，以及更有效地使用系统资源。主要功能：容器化：将应用程序及其依赖项打包为容器，实现一致性和可移植性。镜像管理：通过Docker镜像，可以轻松地分发和部署应用程序。容器操作：提供了启动、停止、删除等基本的容器操作命令。应用场景：本地开发：开发人员可以使用Docker在本地构建、测试和部署应用程序。持续集成/持续部署（CI/CD）：Docker容器可以作为CI/CD管道中的一部分，用于自动化测试和部署。二、K8s（Kubernetes）K8s是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一个容器编排和调度的环境，可以在多个主机上同时管理和运行多个Docker容器。主要功能：容器编排：自动化部署、扩展和管理容器化应用程序。服务发现：允许容器在集群中相互发现和通信。负载均衡：自动分配流量到不同的容器实例上。自动伸缩：根据应用程序的负载情况自动调整容器的数量。滚动更新：在不中断服务的情况下更新应用程序。核心组件：Master节点：负责集群的调度、管理和运维。Worker节点：负责运行容器化应用程序的工作负载。API Server：作为K8s的请求入口服务，处理所有资源请求和调用操作。Controller Manager：负责监控整个集群的状态，并确保集群处于预期的工作状态。Scheduler：负责为新创建的Pod选择一个合适的Node节点。应用场景：大规模容器管理：K8s适用于管理数百甚至数千个容器的大型集群。微服务架构：K8s提供了强大的服务发现和负载均衡功能，非常适合微服务架构的应用程序。生产环境：K8s提供了高可用性和自动伸缩功能，使其成为生产环境中容器化应用程序的理想选择。三、K8s与Docker的关系互补性：Docker为K8s提供了基础的容器化技术，使得应用程序及其依赖项可以被打包成独立的容器镜像。而K8s则进一步扩展了Docker的能力，通过提供自动化部署、扩缩容、服务发现与负载均衡等高级功能，使得开发者能够更便捷地构建和管理微服务应用。结合使用：在实际应用中，通常使用Docker来构建和打包应用程序的容器镜像，然后使用K8s来管理和调度这些容器。这两个工具可以一起使用，以便获得更好的容器化和应用程序管理体验。综上所述，K8s和Docker在容器化技术领域各有其独特的功能和定位。Docker提供了容器化的基本功能，而K8s则在此基础上发展为一个功能强大的容器编排平台。http://www.ppmy.cn/news/1541516.html相关文章java项目篇-用户脱敏展示用户敏感信息脱敏展示 
定义手机号和证件号的 Jackson 自定义序列化器&amp;#xff0c;并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段&amp;#xff08;身份证号&amp;#xff0c;手机号&amp;#xff0c;银行卡号等&amp;#xff09;序列化的时候&amp;#xff0c;该字段自动…阅读更多...智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:27 +0000</pubDate>
    </item>
    <item>
      <title>java项目篇-用户脱敏展示</title>
      <link>https://www.ppmy.cn/news/1541515.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维java项目篇-用户脱敏展示news/2025/11/4 0:22:26/用户敏感信息脱敏展示定义手机号和证件号的 Jackson 自定义序列化器，并在对应需要脱敏的敏感字段上指定自定义序列化器。在进行指定的需要脱敏的字段（身份证号，手机号，银行卡号等）序列化的时候，该字段自动变成脱敏json对象。1）身份证号序列化器importcn.hutool.core.util.DesensitizedUtil;importcom.fasterxml.jackson.core.JsonGenerator;importcom.fasterxml.jackson.databind.JsonSerializer;importcom.fasterxml.jackson.databind.SerializerProvider;importjava.io.IOException;/*** 身份证号脱敏反序列化*/publicclassIdCardDesensitizationSerializerextendsJsonSerializer&lt;String&gt;{@Overridepublicvoidserialize(StringidCard,JsonGeneratorjsonGenerator,SerializerProviderserializerProvider)throwsIOException{StringphoneDesensitization=DesensitizedUtil.idCardNum(idCard,4,4);jsonGenerator.writeString(phoneDesensitization);}}2）手机号序列化器importcn.hutool.core.util.DesensitizedUtil;importcom.fasterxml.jackson.core.JsonGenerator;importcom.fasterxml.jackson.databind.JsonSerializer;importcom.fasterxml.jackson.databind.SerializerProvider;importjava.io.IOException;/*** 手机号脱敏反序列化*/publicclassPhoneDesensitizationSerializerextendsJsonSerializer&lt;String&gt;{@Overridepublicvoidserialize(Stringphone,JsonGeneratorjsonGenerator,SerializerProviderserializerProvider)throwsIOException{StringphoneDesensitization=DesensitizedUtil.mobilePhone(phone);jsonGenerator.writeString(phoneDesensitization);}}3） 敏感字段上自定义序列化器。importcom.fasterxml.jackson.annotation.JsonFormat;importcom.fasterxml.jackson.databind.annotation.JsonSerialize;importlombok.experimental.Accessors;importjava.util.Date;/*** 乘车人返回参数*/@Data@Accessors(chain=true)publicclassPassengerRespDTO{/*** 证件号码*/@JsonSerialize(using=IdCardDesensitizationSerializer.class)privateStringidCard;/*** 手机号*/@JsonSerialize(using=PhoneDesensitizationSerializer.class)privateStringphone;}http://www.ppmy.cn/news/1541515.html相关文章智能去毛刺：2D视觉引导机器人如何重塑制造业未来机器人技术已经深入到各个工业领域中&amp;#xff0c;为制造业带来了前所未有的变革。其中&amp;#xff0c;2D视觉引导机器人技术以其精准、高效的特点&amp;#xff0c;在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用&amp;#…阅读更多...[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:26 +0000</pubDate>
    </item>
    <item>
      <title>智能去毛刺：2D视觉引导机器人如何重塑制造业未来</title>
      <link>https://www.ppmy.cn/news/1541514.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维智能去毛刺：2D视觉引导机器人如何重塑制造业未来news/2025/11/4 0:22:25/机器人技术已经深入到各个工业领域中，为制造业带来了前所未有的变革。其中，2D视觉引导机器人技术以其精准、高效的特点，在去毛刺工艺中发挥着越来越重要的作用。本文将为您介绍2D视觉引导机器人技术的基本原理及其在去毛刺工艺中的应用，以及这一技术如何助力提高生产效率和产品质量。一、2D视觉引导机器人技术的基本原理2D视觉引导机器人技术是通过搭载在机器人上的2D视觉相机捕捉目标物体的图像信息，利用图像处理技术识别出物体的位置、姿态等关键信息，进而引导机器人进行精准操作。这种技术能够实现对不同形状、尺寸和表面特征的物体进行快速、准确的定位和抓取，大大提高了机器人的灵活性和适应性。二、2D视觉引导机器人在去毛刺工艺中的应用去毛刺是制造业中一道重要的工序，主要用于去除工件表面的毛刺、飞边等不规则凸起，以提高产品的外观质量和性能。传统的去毛刺方法往往依赖于人工操作，效率低下且存在安全隐患。而2D视觉引导机器人技术的应用，为去毛刺工艺带来了革命性的改变。1. 精准定位与抓取：通过2D视觉相机捕捉工件表面的图像信息，机器人能够迅速识别出毛刺的位置和大小，从而实现对毛刺的精准定位和抓取。这大大提高了去毛刺的准确性和效率，降低了操作难度。2. 自动化操作：机器人能够根据预设的程序和参数，自动完成去毛刺的整个过程，无需人工干预。这不仅提高了生产效率，还降低了人工成本和安全风险。3. 柔性生产：由于2D视觉引导机器人技术具有高度的灵活性和适应性，因此能够轻松应对不同形状、尺寸和材质的工件，实现柔性生产。这有助于企业快速响应市场需求，提高竞争力。三、提高生产效率和产品质量2D视觉引导机器人技术在去毛刺工艺中的应用，显著提高了生产效率和产品质量。具体来说，该技术具有以下优势：1. 提高生产效率：机器人能够连续、稳定地进行去毛刺操作，不受疲劳和人为因素的影响，从而大大提高了生产效率。同时，机器人操作速度快，能够在短时间内完成大量工件的去毛刺工作，进一步缩短了生产周期。2. 提高产品质量：通过精准的定位和抓取，机器人能够彻底去除工件表面的毛刺和飞边，使得产品表面更加光滑、整洁。这有助于提高产品的外观质量和性能，增强客户满意度。3. 降低生产成本：虽然机器人的初期投资成本较高，但长期来看，机器人能够降低人工成本、减少人为因素导致的质量问题和生产中断，从而降低整体生产成本。2D视觉引导机器人技术在去毛刺工艺中的应用具有广阔的前景和巨大的潜力。随着技术的不断进步和完善，相信未来这一技术将在更多领域得到应用，为制造业的发展注入新的活力。http://www.ppmy.cn/news/1541514.html相关文章[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）思路&amp;#xff1a;根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解&amp;#xff0c;我们设dp[i][j]代表第i个数为j时的方案数&amp;#xff0c;dp[i][j]应为dp[i - 1][t] (t &lt; j - k) 和dp[i - 1][j  k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的&amp;#…阅读更多...【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:26 +0000</pubDate>
    </item>
    <item>
      <title>[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）</title>
      <link>https://www.ppmy.cn/news/1541513.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维[ABC253E] Distance Sequence（线性dp且利用前缀和进行优化）news/2025/11/4 0:22:25/思路：根据数据范围还有题目所处的位置我们可以联想到该题可以用dp来求解，我们设dp[i][j]代表第i个数为j时的方案数，dp[i][j]应为dp[i - 1][t] (t &lt;= j - k) 和dp[i - 1][j + k]转移过来,如果我们不做任何优化的话n* m * n是肯定超时的，因此我们可以利用前缀和来求解两段的方案数,对于前缀和当n等于1时我们是可以确定地sum[i] = sum[i - 1] + 1,但是题目中k可以为0，当k等于0时左右两段是有重复点地，因此我们只需要计算一次即可，最终是求地总的方案数因此我们直接输出sum[m]即可，转换着求也挺难想地，而不是直接由dp求出，下面给出AC代码：AC代码：#include&lt;bits/stdc++.h&gt;usingnamespacestd;constintN=2e5+10;constintM=1e9+7;constintMOD=998244353;typedeflonglongll;typedefpair&lt;ll,ll&gt;PII;typedefpair&lt;char,int&gt;PCI;ll n,m,k;ll dp[1010][5050];//第i个数为j的总的方案数ll sum[N];//dp[i][j] = dp[i - 1][j] + pre[j - k] + pre[m] - pre[j + k - 1];//后缀用总的 - 前缀intmain(){cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;for(inti=1;i&lt;=m;i++){sum[i]=sum[i-1]+1;}//初始化本身也是一个for(inti=2;i&lt;=n;i++){for(intj=1;j&lt;=m;j++){if(j+k&lt;=m){dp[i][j]=(dp[i][j]+((sum[m]-sum[j+k-1])%MOD+MOD)%MOD)%MOD;}//用前缀和在dp过程中来优化是真的不好想if(j-k&gt;=1){if(k==0){dp[i][j]=(dp[i][j]+sum[j-k-1]%MOD)%MOD;}//等于0时左右两段就会有重复deelse{dp[i][j]=(dp[i][j]+sum[j-k]%MOD)%MOD;}}}//预处理前缀和memset(sum,0,sizeofsum);for(intj=1;j&lt;=m;j++){sum[j]=(sum[j-1]+dp[i][j])%MOD;}}cout&lt;&lt;sum[m]%MOD&lt;&lt;endl;return0;}http://www.ppmy.cn/news/1541513.html相关文章【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步文章目录 1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能&amp;#xff0c;因此安装好软件&amp;#xff0c;只需确认设备信息是否对应即可2.1.2. 如果没有发现到&amp;#xff0c;可以通过设备ID连接2.1.3. 设置GUI身份验证用户&amp;#xff0c;让无关设备…阅读更多...python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:25 +0000</pubDate>
    </item>
    <item>
      <title>【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步</title>
      <link>https://www.ppmy.cn/news/1541512.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【个人同步与备份】电脑（Windows）与手机/平板（Android）之间文件同步news/2025/11/4 0:22:24/文章目录1. syncthing软件下载2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能，因此安装好软件，只需确认设备信息是否对应即可2.1.2. 如果没有发现到，可以通过设备ID连接2.1.3. 设置GUI身份验证用户，让无关设备不能连接2.2. 创建同步文件夹2.2.1. 添加文件夹2.2.2. 几个文件夹创建要注意的点2.2.2.1 文件夹标签是个人备注，文件夹路径是本设备同步路径2.2.2.2 设置共享的设备2.2.2.3 按需设置版本控制，避免删除文件导致找不回来的问题2.2.2.4 可以根据正则表达式忽略某些文件2.2.2.5 设置文件夹的发送和接收类型2.3. 其他使用提示2.3.1. 查看变更事件2.3.2. 安卓syncthing注意赋予足够权限，设置后台运行，取消省电优化Syncthing 是一款开源的分布式文件同步工具。与传统的集中式文件同步服务不同，Syncthing 没有中心服务器。这意味着你的数据不会存储在第三方服务器上，完全由你自己掌控，极大地提高了数据的安全性和隐私性。各个设备之间直接进行通信和同步，不依赖于外部服务器，即使没有互联网连接，在局域网内也可以进行文件同步。由此可以利用电脑（Windows）与手机/平板（Android）进行相互备份和同步。1. syncthing软件下载Windows版本：https://github.com/Bill-Stewart/SyncthingWindowsSetup/releasesAndriod版本：https://github.com/syncthing/syncthing-android/releases其他系统版本自行参考官网：https://syncthing.net/downloads/2. syncthing的使用2.1. 添加设备2.1.1. syncthing具备设备发现功能，因此安装好软件，只需确认设备信息是否对应即可2.1.2. 如果没有发现到，可以通过设备ID连接2.1.3. 设置GUI身份验证用户，让无关设备不能连接2.2. 创建同步文件夹2.2.1. 添加文件夹2.2.2. 几个文件夹创建要注意的点2.2.2.1 文件夹标签是个人备注，文件夹路径是本设备同步路径2.2.2.2 设置共享的设备2.2.2.3 按需设置版本控制，避免删除文件导致找不回来的问题2.2.2.4 可以根据正则表达式忽略某些文件2.2.2.5 设置文件夹的发送和接收类型2.3. 其他使用提示2.3.1. 查看变更事件2.3.2. 安卓syncthing注意赋予足够权限，设置后台运行，取消省电优化http://www.ppmy.cn/news/1541512.html相关文章python装饰器property的使用使用 Python 的 property 装饰器管理类属性 
在 Python 中&amp;#xff0c;property 装饰器是一个非常有用的工具&amp;#xff0c;它允许我们将一个方法转换为属性调用。这样&amp;#xff0c;我们就可以像访问对象的属性一样来调用该方法&amp;#xff0c;而不需要使用括号。这通常用于封装数据&amp;…阅读更多...w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:24 +0000</pubDate>
    </item>
    <item>
      <title>python装饰器property的使用</title>
      <link>https://www.ppmy.cn/news/1541511.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维python装饰器property的使用news/2025/11/4 0:22:23/使用 Python 的@property装饰器管理类属性在 Python 中，@property装饰器是一个非常有用的工具，它允许我们将一个方法转换为属性调用。这样，我们就可以像访问对象的属性一样来调用该方法，而不需要使用括号。这通常用于封装数据，使得代码更加清晰和易于维护。使用@property的好处封装：可以隐藏对象内部的数据，防止外部直接修改。接口一致性：即使内部实现改变，外部调用方式保持不变。增加控制：可以在获取或设置属性值时加入逻辑判断。基本用法假设我们有一个Person类，其中包含一个属性age，我们希望对这个属性的读取和写入进行一些额外的处理。示例代码classPerson:def__init__(self,name,age):self._name=name# 使用 setter 方法初始化 age 属性self.age=age@propertydefage(self):"""获取年龄"""print(f"Getting age for{self._name}")returnself._age@age.setterdefage(self,value):"""设置年龄"""print(f"Setting age for{self._name}to{value}")ifnotisinstance(value,int):raiseValueError("Age must be an integer.")ifvalue&lt;0:raiseValueError("Age cannot be negative.")self._age=value@age.deleterdefage(self):"""删除年龄"""print(f"Deleting age for{self._name}")delself._age# 创建一个 Person 对象person=Person("Alice",30)# 访问 age 属性print(person.age)# 输出: Getting age for Alice#       30# 修改 age 属性person.age=35# 输出: Setting age for Alice to 35print(person.age)# 输出: Getting age for Alice#       35# 尝试设置一个无效的 age 值try:person.age=-5exceptValueErrorase:print(e)# 输出: Age cannot be negative.# 删除 age 属性delperson.age# 输出: Deleting age for Alice# 尝试访问已删除的 age 属性try:print(person.age)exceptAttributeErrorase:print(e)# 输出: 'Person' object has no attribute '_age'初始化：
在 __init__ 方法中，我们使用 self.age=age 来初始化 age 属性。这里实际上是调用了 @age.setter 方法，确保了初始值的有效性。
访问属性：@property装饰器将 age 方法转换为一个属性，因此可以通过 person.age 直接访问 age 属性。每次访问时，都会打印一条消息，显示正在获取年龄。
设置属性：@age.setter装饰器定义了设置 age 属性的方法。在设置新值之前，会进行类型检查和值检查，确保 age 是一个非负整数。
删除属性：@age.deleter装饰器定义了删除 age 属性的方法。调用delperson.age 会删除 _age 属性，并打印一条消息。http://www.ppmy.cn/news/1541511.html相关文章w~自动驾驶合集9我自己的原文哦~ https://blog.51cto.com/whaosoft/12320882 
#自动驾驶数据集全面调研 
自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展&amp;#xff0c;并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集&amp;…阅读更多...【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:23 +0000</pubDate>
    </item>
    <item>
      <title>w~自动驾驶合集9</title>
      <link>https://www.ppmy.cn/news/1541510.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维w~自动驾驶合集9news/2025/11/4 0:22:22/我自己的原文哦~https://blog.51cto.com/whaosoft/12320882#自动驾驶数据集全面调研自动驾驶技术在硬件和深度学习方法的最新进展中迅速发展，并展现出令人期待的性能。高质量的数据集对于开发可靠的自动驾驶算法至关重要。先前的数据集调研试图回顾这些数据集，但要么集中在有限数量的数据集上，要么缺乏对数据集特征的详细调查。为此，这里从多个角度对超过200个自动驾驶数据集进行了详尽的研究，包括传感器模态、数据大小、任务和上下文条件。引入了一种新的评估每个数据集影响的度量标准，该标准还可以成为建立新数据集的指南。进一步分析了数据集的标注过程和质量。此外，对几个重要数据集的数据分布进行了深入分析。最后，讨论未来自动驾驶数据集的发展趋势。当前行业的概述自动驾驶（AD）旨在通过创建能够准确感知环境、做出智能决策并在没有人类干预的情况下安全行驶的车辆，彻底改变交通系统。由于令人激动的技术发展，各种自动驾驶产品已在多个领域实施，例如无人出租车。这些对自动驾驶的快速进展在很大程度上依赖于大量的数据集，这些数据集帮助自动驾驶系统在复杂的驾驶环境中变得稳健可靠。近年来，自动驾驶数据集的质量和种类显著增加。数据集开发的第一个显著现象是各种不同的数据收集策略，包括通过仿真器生成的合成数据集和从真实世界记录的数据集等。其次，数据集在组成方面也各种各样，包括但不限于多种感知数据（如相机图像和LiDAR点云）以及用于自动驾驶各个任务的不同标注类型。下图1以俯视图的方式显示了六个真实世界数据集（Argoverse 2 、KITTI 、nuScenes 、ONCE 、Waymo 和ZOD ）的3D目标边界框分布的统计数据，展示了每个数据集的独特标注特性。根据传感器的设备位置，数据集的多样性还体现在感知领域中，包括车载、V2X、无人机等。此外，几何多样性和天气条件的改变提高了自动驾驶数据集的泛化能力。为什么研究？动机是什么？下图2中展示了每年发布的感知数据集数量，以从一个角度反映自动驾驶数据集的趋势。由于存在大量且不断增加的公开发布的数据集，对自动驾驶数据集进行全面调查对推动学术和工业研究非常有价值。在先前的工作中，Yin等人总结了27个在公共道路上收集的数据的公开可用数据集。[35]除了描述现有数据集，讨论了合成数据和真实数据之间的域适应以及自动标注方法。[36]总结了现有数据集，并对下一代数据集的特征进行了详尽的分析。然而，这些调查仅总结了少量数据集，导致范围不够广泛。AD-Dataset 收集了大量数据集，但缺乏对这些数据集属性的详细分析。与对所有类型的数据集进行研究相比，一些研究人员对特定类型的自动驾驶数据集进行了调查，例如异常检测、合成数据集、3D语义分割和决策。因此，本文的目标是提出一项全面而系统的研究，涵盖自动驾驶中的大量数据集，从感知到控制的所有任务，考虑真实世界和合成数据，并深入了解若干关键数据集的数据模态和质量。在下表I中对比了其他数据集调查和作者的调查。主要贡献本文的主要贡献可总结如下：对自动驾驶数据集进行了全面调查。尽可能全面地考虑公开可用数据集，记录它们的基本特征，如发布年份、数据大小、传感器模态、感知领域、几何和环境条件以及支持任务。据我们所知，本工作提供了迄今为止记录的最广泛的自动驾驶数据集概述。系统地说明了收集自动驾驶数据的传感器和感知领域。此外，描述了自动驾驶的主要任务，包括任务目标、所需数据模态和评估指标。根据感知领域和支持任务对数据集进行了总结和划分，以帮助研究人员高效选择和收集目标数据集的信息。从而促进更有针对性和有效的研究和开发工作。此外，引入了一个影响分数度量标准，评估了在社区中发布的感知数据集的影响力。这个指标也可以作为未来数据集开发的指导。深入分析了具有最高分数的数据集，突出它们的优势和效用。调查了数据集的标注质量以及各种自动驾驶任务的现有标注程序。进行了详细的数据统计，展示了不同角度的各种数据集的数据分布，展示了它们固有的限制和适用情况。分析了最近的技术趋势，并展示了下一代数据集的发展方向。还展望了大语言模型进一步推动未来自动驾驶的潜在影响。范围与局限性本文的目标是对现有的自动驾驶数据集进行详尽调查，以提供对该领域未来算法和数据集的开发提供帮助和指导。收集了侧重于四个基本自动驾驶任务的数据集：感知、预测、规划和控制。由于有几个多功能数据集支持多个任务，作者只在它们主要支持的主要范围中解释它们，以避免重复介绍。此外，收集了大量数据集，并以它们的主要特征展示在表格中。然而，对所有收集到的数据集进行详细解释可能无法突显最受欢迎的数据集，可能会妨碍研究人员通过这项调查找到有价值的数据集。因此，只详细描述了最有影响力的数据集。文章结构本文的其余部分结构如下：第二节介绍了用于获取公共数据集以及数据集的评估指标的方法。第三节展示了自动驾驶中使用的主要传感器及其模态。第四节讨论了自动驾驶任务、相关挑战和所需数据。在第五节进一步讨论了几个重要的数据集。在第六节展示了标注过程和影响标注质量的因素。此外，在第七节对几个数据集的数据分布进行了统计。在第八节中，调查了自动驾驶数据集的发展趋势和未来工作。最后，在第九节总结。此调查的分类结构如下图3所示。方法论介绍本节包括1) 如何收集和筛选数据集（II-A），以及2) 如何评估数据集对自动驾驶领域的影响（II-B）。数据集收集作者遵循[42]的方法进行系统性的回顾，以详尽收集已发布的自动驾驶数据集。为确保来源的多样性，作者利用了知名的搜索引擎，如Google、Google Scholar和Baidu来搜索数据集。为了确保从各个国家和地区全面收集数据集，使用英语、中文和德语进行搜索，使用关键词如“autonomous driving datasets”、“intelligent vehicle datasets”以及与目标检测、分类、跟踪、分割、预测、规划和控制相关的术语。此外，在IEEE Xplore和自动驾驶及智能交通系统领域的相关会议中搜索，以收集来自期刊和会议论文集的数据集。通过关键词搜索和手动标题审查验证了这些来源的数据集。最后，为了确保包括专业或较少知名的数据集，作者通过Github仓库和Paperwithcodes进行了搜索。类似于数据库，对数据集进行了手动和基于关键词的搜索。数据集评估指标作者引入了一个新的度量标准，即影响分数（impact score），用于评估已发布数据集的重要性，这也可以作为准备新数据集的指南。在本节中，详细解释了计算自动驾驶数据集影响分数的方法。为了进行公平和可比较的比较，作者仅考虑与感知领域相关的数据集，因为感知领域占据了自动驾驶数据集的很大一部分。此外，为了确保评分系统的客观性和可理解性，考虑了各种因素，包括引用次数、数据维度和环境多样性。所有的值都是从官方论文或开源数据集网站收集而来。环境多样性评分。根据以下因素评估数据集的环境多样性：天气条件，例如雨雪。白天或黄昏等数据收集时间。驾驶场景的类型，例如城市或乡村。几何范围指的是数据记录的国家或城市数量。数据源和自动驾驶中的协同感知本节介绍主要用于自动驾驶的传感器及其模态。此外，分析了数据采集和通信领域，如车载、无人机和V2X的协同感知。数据的传感器和模态高效而准确地从周围环境中收集数据是自动驾驶可靠感知系统的关键。为了实现这一目标，在自动驾驶车辆和基础设施上使用了各种类型的传感器。传感器的示例如下图 4 所示。最常用的传感器是相机、LiDAR 和Radar。事件型和热成像相机也安装在车辆或道路旁边，以进一步提高感知能力。RGB 图像。RGB 图像通常由单目、双目或鱼眼相机记录。单目相机提供不带深度的 2D 视图；双目相机通过其双镜头提供深度感知；鱼眼相机使用广角镜头捕捉广阔的视野。所有这些相机通过透镜将光传导到图像传感器（例如 CMOS），将这些光转换为表示图像的电子信号。如下图 5 (a) 所示，2D 图像捕捉环境的颜色信息、丰富的纹理、模式和视觉细节。由于这些特性，RGB 图像主要用于检测车辆和行人，并识别道路标志。然而，RGB 图像容易受到低照明、雨、雾或耀斑等条件的影响 。LiDAR 点云。LiDAR 使用激光束测量传感器与目标之间的距离，从而创建 3D 环境表示 。LiDAR 点云（如下图 5 (b) 所示）提供高分辨率的精确空间信息，可以检测长距离内的目标。然而，这些点的密度会随着距离的增加而减小，导致远处目标的表示更为稀疏。天气条件，如雾，也会限制 LiDAR 的性能。总体而言，LiDAR 适用于需要 3D 简要信息的情况。Radar点云。Radar通过发射射频波并分析其反射来检测目标、距离和相对速度。此外，Radar在各种天气条件下都具有很强的鲁棒性 。然而，Radar点云通常比 LiDAR 数据更粗糙，缺乏目标的详细形状或纹理信息。因此，Radar通常用于辅助其他传感器。下图 5 (c) 展示了Radar点云。事件相机。事件型相机异步捕捉数据，仅在像素检测到亮度变化时才激活。捕捉到的数据称为事件（如图 5 (d) 所示）。由于采用了特定的数据生成方法，记录的数据具有极高的时间分辨率，并且可以捕捉快速运动而不模糊 。热成像相机的红外图像。热成像相机（见下图 5 (e)）通过捕捉红外辐射来检测热特征 。由于基于温差生成图像，热成像相机可以在完全黑暗中工作，并且不受雾或烟影响。然而，热成像相机无法分辨颜色或详细的视觉图案。此外，与光学相机相比，红外图像的分辨率较低。惯性测量单元（IMU）。IMU 是一种电子设备，用于测量并报告目标的特定力、角速度，有时还有目标周围的磁场 。在自动驾驶中，它用于跟踪车辆的运动和方向。虽然 IMU 不包含周围环境的视觉信息，但通过将 IMU 的数据与其他传感器的数据融合，感知系统可以更准确、更鲁棒地跟踪车辆的运动和方向。作者从收集的数据集中分析传感器的分布，如下图 6 所示。超过一半的传感器是单目相机（53.85%），这是因为它们价格低廉且性能可靠。此外，93 个数据集包含 LiDAR 数据，由于其高分辨率和精确的空间信息而受到重视。然而，由于高昂的成本，限制了 LiDAR 的广泛使用。除 LiDAR 点云外，29 个数据集利用双目相机捕捉深度信息。此外，分别包含Radar、热像相机和鱼眼相机的数据集比例分别为5.41％、3.42％和1.71％。考虑到以事件为基础的相机捕捉动态场景的时间效率，有三个数据集生成基于事件的相机数据。传感域和协同感知系统自动驾驶系统中，自车与周围环境中其他实体之间的感知数据和通信起着至关重要的作用，确保了自动驾驶系统的安全性、效率性和整体功能性。因此，传感器的位置决定了可以收集的数据的质量、角度和范围，因此非常关键。总体而言，在自动驾驶环境中，传感器可以分为以下几个领域：自车、车联网（V2X）、无人机和其他。自车：自车传感器直接安装在自动驾驶车辆上，通常包括相机、LiDAR、Radar和惯性测量单元（IMU）。这些传感器提供了车辆视角的直接视图，即时反馈车辆周围的情况。然而，由于车辆检测范围的限制，自车传感器可能在提供盲点内障碍物的预警或检测急弯附近的危险方面存在局限性。车联网（V2X）：车联网包括车辆与交通系统中的任何其他组件之间的通信，包括车辆对车辆（V2V）、车辆对基础设施（V2I）和车辆对网络（V2N）（如下图7所示）。除了直接的感知输入外，协同系统确保多个实体协同工作。车到车（V2V） V2V使附近的车辆能够共享数据，包括它们的位置、速度和传感器数据，如相机图像或LiDAR扫描，有助于更全面地了解驾驶场景。车到基础设施（V2I） V2I促进了自动驾驶车辆与基础设施组件之间的通信，例如交通灯、标志或路边传感器。嵌入在道路基础设施中的传感器，包括相机、LiDAR、Radar或基于事件的相机，协同工作以扩展感知范围并提高自动驾驶车辆的情境感知。在这项调查中，作者将通过基础设施或V2I进行的感知都归类为V2I。车到网络（V2N） V2N指的是在车辆和更广泛的网络基础设施之间交换信息，通常利用蜂窝网络为车辆提供对云数据的访问。V2N通过共享跨区域数据或提供有关交通拥堵或道路封闭的实时更新，帮助V2V和V2I的合作感知。无人机（Drone）：无人机提供了一种空中视角，提供了轨迹预测和路径规划所需的数据。例如，来自无人机的实时数据可以集成到交通管理系统中，以优化交通流并提醒自动驾驶车辆前方的事故。其他未由前三种类型收集的数据被定义为其他，例如安装在非车辆目标上或多个领域的其他设备。自动驾驶中的任务这一部分深入介绍了自动驾驶中的关键任务，如感知和定位、预测以及规划和控制。自动驾驶流程的概览如下图8所示。详细说明它们的目标、它们所依赖的数据的性质以及固有的挑战。图9展示了自动驾驶中若干主要任务的示例。感知和定位感知侧重于根据感知数据理解环境，而定位确定自动驾驶车辆在该环境中的位置。2D/3D 目标检测2D或3D目标检测旨在识别和分类驾驶环境中的其他实体。而2D目标检测在图像空间中识别目标，3D目标检测进一步整合由LiDAR提供的精确深度信息。尽管检测技术取得了显著进展，但仍存在一些挑战，如目标遮挡、光照变化和多样的目标外观。通常情况下，使用AP度量来评估目标检测性能。根据[1]，AP度量可表述为:2D/3D 语义分割语义分割涉及将图像的每个像素或点云的每个点分类到其语义类别。从数据集的角度来看，保持细粒度的目标边界并管理大量标签要求对这个任务来说是一个重要的挑战。正如中提到的，用于分割的主要度量标准包括平均像素准确率（mPA）:目标跟踪目标跟踪监控单个或多个目标随时间的轨迹。这项任务需要时间序列的RGB数据、LiDAR或Radar序列。通常，目标跟踪包括单目标跟踪或多目标跟踪（MOT）。多目标跟踪准确度（MOTA）是用于多目标跟踪的广泛使用的度量，它结合了假反例、假正例和不匹配率（参见方程9）：此外，与其考虑单一阈值不同，Average MOTA（AMOTA）是基于所有目标置信阈值计算的。高精度地图高精度地图的目标是构建详细、高度准确的表示，其中包括有关道路结构、交通标志和地标的信息。一个数据集应该提供LiDAR数据以获取精确的空间信息，以及相机数据以获取视觉细节，以确保建立的地图准确性。根据，高精度地图自动化和高精度地图变更检测越来越受到关注。通常，高精度地图的质量是通过准确度度量来估算的。SLAM同时定位与建图（SLAM）涉及构建周围环境的同时建图，并在该地图中定位车辆。因此，来自相机、用于位置跟踪的IMUs以及实时LiDAR点云的数据是至关重要的。引入了两个评估指标，相对位姿误差（RPE）和绝对轨迹误差（ATE），用于评估从输入RGB-D图像估计的轨迹的质量。预测预测是指对周围agents的未来状态或行为进行预测。这种能力确保在动态环境中更安全地导航。预测使用了一些评估指标，例如均方根误差（RMSE）：轨迹预测利用来自相机和LiDAR等传感器的时间序列数据，轨迹预测涉及预测其他实体（如行人、骑车人或其他车辆）未来的路径或移动模式。行为预测行为预测预测其他道路使用者的潜在动作，例如车辆是否会变道。训练行为预测模型依赖于具有广泛标注的数据，因为在不同情境中实体可能采取各种潜在动作。意图预测意图预测侧重于推断目标行为背后的意图的高级目标，涉及对人类目标的物理或心理活动进行更深层次的语义理解。由于任务的复杂性，它不仅需要来自感知相机等传感器的数据，还需要其他信息，如交通信号和手势，以推断其他agents的意图。规划与控制规划：规划代表对感知环境和预测做出反应的决策过程。经典的三级分层规划框架包括路径规划、行为规划和运动规划。路径规划：路径规划，也称为路线规划，涉及设定长期目标。这是一个高层次的过程，确定到达目的地的最佳路径。行为规划：行为规划位于框架的中层，与决策制定相关，包括变道、超车、合并和十字路口穿越等。这个过程依赖于对其他agents行为的正确理解和交互。运动规划：运动规划处理车辆实时应该遵循的实际轨迹，考虑到障碍物、道路状况和其他道路agents的预测行为。与路径规划相反，运动规划生成实现局部目标的适当路径。控制：自动驾驶中的控制机制管理自动驾驶汽车如何执行来自运动规划系统的决定的路径或行为，并纠正跟踪误差。它将高级命令转换为可执行的油门、刹车和转向命令。端到端自动驾驶端到端自动驾驶是指单个深度学习模型处理从感知到控制的所有任务，绕过传统的模块化流程。这样的模型通常更具适应性，因为它们通过学习来调整整个模型。它们的固有优势在于简单性和效率，通过减少手工制作组件的需求。然而，实施端到端模型面临着关键限制，如大量的训练数据需求、低解释性和不灵活的模块调整。对端到端自动驾驶进行大规模基准测试可以分为闭环和开环评估。闭环评估基于仿真环境，而开环评估涉及根据来自真实世界数据集的专业驾驶行为评估系统的性能。高影响力数据集本节描述了在感知、预测、规划和控制领域中的具有里程碑意义的自动驾驶数据集。还展示了端到端自动驾驶的数据集。感知数据集感知数据集对于开发和优化自动驾驶系统至关重要。它们通过提供丰富的多模态感知数据，确保对周围环境进行有效感知和理解，从而增强车辆的可靠性和稳健性。作者利用提出的数据集评估指标计算收集的感知数据集的影响分数，随后根据这些分数选择前50个数据集，以创建一个按时间顺序排列的概述，如下图10所示。同时，如前章节中所述，将数据集分为车载、V2X、无人机和其他，从每个类别中选择一个子集，编制一个包含50个数据集的综合表格（下表II）。值得注意的是，表中的数据集是按照其各自类别内的影响分数进行排序的，不代表总体的前50。在以下部分，作者选择了每个感知来源中影响分数最高的几个数据集，并考虑它们的发布年份。车载KITTI：KITTI  自2012年发布以来，深刻影响了自动驾驶领域。KITTI包含通过各种传感器记录的各种真实驾驶场景，包括相机、LiDAR和GPS/IMU。其丰富的标注和高分辨率的传感器数据促进了在各种自动驾驶任务（如目标检测、跟踪、光流、深度估计和视觉里程计）方面的算法开发和基准测试。Cityscapes：Cityscapes  包括在复杂城市环境中明确捕获的大量图像。通过精心标注，Cityscapes为30个不同的目标类别提供像素级分割，其中包括各种车辆类型、行人、道路和交通标志信息。由于其复杂性和丰富性，Cityscapes已成为诸如城市场景中语义分割等任务的标准基准。SYNTHIA：SYNTHIA  是自动驾驶领域的合成数据集。该数据集包含13,400张图像，具有语义分割的逐像素标注。SYNTHIA的一个显著特点是它能够弥合现实世界和合成数据之间的差距，促进了在不同领域之间开发稳健且可转移的方法。Virtual KITTI：Virtual KITTI  通过虚拟环境密切模仿了原始KITTI数据集，通过提供包含各种交通情况和环境条件的高分辨率视频序列而脱颖而出。类似于，Virtual KITTI支持关键的自动驾驶任务，包括目标检测、语义分割和目标跟踪。VIPER：VIPER  是从现实虚拟世界的驾驶、骑行和步行视角收集的合成数据集，解决了数据稀缺和标注现实世界数据的高成本挑战。VIPER包含超过25万帧视频，为低级和高级视觉任务提供了真值数据，同时涵盖各种天气条件、光照场景和复杂的城市风景。总体而言，VIPER为研究人员提供了一个宝贵且经济高效的工具，以加速可靠且安全的自动驾驶的发展。Apolloscapes：Apolloscapes 提供了超过140,000个高分辨率帧，具有准确的边界框和像素级语义标签，对于训练和验证自动车辆的感知和导航系统至关重要。Apolloscapes支持图像和点云的语义分割，2D/3D目标检测，多目标跟踪和车道线分割，从而实现先进且安全的自动驾驶系统的创建和评估。SemanticKITTI：SemanticKITTI 是KITTI家族的一个显著扩展，专注于自动驾驶领域的语义分割。SemanticKITTI包含超过43,000个LiDAR点云帧，使其成为户外环境中3D语义分割最大的数据集之一。SemanticKITTI为28个类别提供精确的标签，如汽车、道路、建筑等，为评估点云语义分割方法的性能提供了强有力的基准，支撑了相关领域的许多研究和创新。nuScenes：nuScenes 是自动驾驶领域的重要贡献，提供了一个丰富的数据库，满足感知系统的多样化需求。nuScenes利用LiDAR、Radar和相机记录来自波士顿和新加坡不同城市场景的数据。值得一提的是，其六个相机提供了对周围环境的全面视角，在多视角目标检测任务中得到广泛应用。总体而言，nuScenes数据集是发展自动驾驶技术的基石，支持多任务和应用，并在该领域设立了新的基准。Waymo：Waymo Open Dataset ，于2019年推出，通过提供大量的多模态感知数据和高质量标注，显著影响了自动驾驶研究和进展。Waymo数据集的关键贡献包括其对驾驶条件和地理位置的全面覆盖，这对于不同任务（如检测、跟踪和分割）的鲁棒性和通用性至关重要。BDD100K：BDD100K 数据集，由伯克利DeepDrive中心于2018年发布，是一个规模庞大且多样化的驾驶数据集，以其规模和多样性而闻名。它包括100,000个大约40秒的视频。同时，它为目标检测、跟踪、语义分割和车道线检测提供了各种标注标签。这个庞大的数据集推动了自动驾驶社区的进展，成为研究人员和工程师提出和改进算法的具有挑战性和多功能的平台。RADIATE：RADIATE 是第一个公开的Radar数据集，包含44,140帧在不同恶劣天气条件下收集的带标注的图像，如雨天、雾天、阴天和雪天。它还整合了LiDAR和相机数据，使驾驶环境的全面感知和理解成为可能。Argoverse 2：Argoverse 2 作为Argoverse 1 的续集，引入了更多样化和复杂的驾驶场景，展示了迄今为止最大的自动驾驶分类法。它捕捉了六个城市和不同条件下的各种实际驾驶场景。Argoverse 2支持多个重要任务，包括但不限于3D目标检测、语义分割和跟踪。总之，Argoverse 2数据集提供了大量真实驾驶场景的多模态数据，促进了算法的创新和进步，并展示了其在自动驾驶中作为重要资源的实质潜力。V2XV2VNet：V2VNet 引入的数据集专注于利用V2V通信，允许自动车辆从多个视点共享信息，这对于检测被遮挡目标和预测其他交通参与者的行为至关重要。该数据集使用名为Lidarsim 的高保真LiDAR仿真器创建，该仿真器利用真实世界数据生成各种交通场景的逼真LiDAR点云。总的来说，这项工作引起了对V2V作为提高自动车辆能力的有前途的途径的关注。DAIR-V2X：DAIR-V2X 是在车辆基础设施协同自动驾驶领域的开创性资源，提供大规模、多模态、多视图的真实世界数据。该数据集旨在解决车辆和基础设施传感器之间的时间不同步以及此类协作系统中涉及的数据传输成本等挑战。DAIR-V2X数据集对自动驾驶的影响很大，因为它为车辆基础设施合作的复杂性设立了一个基准，多亏了其来自真实世界的多种场景。Rope3D：Rope3D 是感知系统的重要贡献，通过利用从路边相机收集的数据，填补了自动驾驶中的关键差距。Rope3D包括50,000张图像，处于不同的环境条件，包括不同的照明（白天、夜晚、黄昏）和天气情况（雨天、晴天、多云）。总体而言，Rope3D数据集是推动路边感知在自动驾驶中取得进展的先导工作，同时也是研究人员和工程师开发更健壮、智能的自动驾驶系统的重要工具。V2V4Real：V2V4Real 是第一个大规模的真实世界数据集，用于处理V2V合作感知。该数据集从两辆配备有多模态传感器（如LiDAR和相机）的车辆中收集。V2V4Real关注一系列感知任务，如合作3D目标检测、合作3D目标跟踪和Sim2Real域适应。这种多功能性使其成为开发和基准测试自动驾驶算法的宝贵资源。无人机UAVDT：UAVDT 数据集包含80,000个准确标注的帧，其中包括14种属性，如天气条件、飞行姿态、相机视图、车辆类别和遮挡级别。该数据集专注于在城市环境中基于UAV的目标检测和跟踪。此外，UAVDT基准测试包括密集场景、小型目标和显著的相机运动，这对于当前最先进的方法来说都是具有挑战性的。DroneVehicle：DroneVehicle 提出了一个大规模的基于无人机的数据集，提供28,439个RGB-红外图像对，用于解决低照明条件下的目标检测问题。此外，它涵盖了各种场景，如城市道路、住宅区和停车场。由于其在广泛条件下的独特无人机视角，这个数据集是发展自动驾驶技术的重要一步。其它Pascal3D+：Pascal3D+ 是PASCAL VOC 2022 的扩展，通过为图像提供更丰富和多样化的标注来克服以前数据集的局限性。Pascal3D+通过为12个刚性目标类别（如汽车、公共汽车、自行车）提供3D姿势标注，并从ImageNet 添加更多图像，实现了高度的可变性。TT 100K：清华大学-腾讯100K 解决了在现实驾驶条件下检测和分类交通标志的挑战。它提供了100,000张图像，包括30,000个交通标志实例。除了大规模的数据大小外，高分辨率的图像涵盖了各种照明和天气条件，使其对于交通标志识别的训练和验证具有鲁棒性。Mapillary Vistas ：由于2017年提出，主要旨在对街景进行语义分割。该数据集包含25,000张图像，标有66个目标类别，并包括37个类别的实例特定标注。它包含来自不同天气、时间和几何位置的图像，有助于减轻对特定区域或条件的偏见。预测、规划和控制数据集预测、规划和控制数据集是促进训练和评估驾驶系统的基础，用于预测交通动态、行人移动和其他影响驾驶决策的重要因素。通过仿真各种驾驶场景，它们使自动驾驶车辆能够做出明智的决策，穿越复杂的环境，并在道路上保持安全和高效。因此，作者根据数据大小、模态和引用数量详细展示与这些任务相关的几个高影响力的数据集。将预测、规划和控制数据集总结为任务特定和多任务两组。任务特定数据集:highD。基于无人机的highD 数据集提供了德国高速公路上自然车辆轨迹的大规模收集，包含110,000辆汽车和卡车的后处理轨迹。该数据集旨在克服现有基于场景的安全验证测量方法的局限性，这些方法通常无法捕捉道路用户的自然行为或包含具有足够质量的所有相关数据。PIE。由提出的行人意图估计（PIE）数据集在理解城市环境中的行人行为方面取得了重大进展。它包含在多伦多市中心记录的超过6小时的行车录像，涵盖了各种光照条件。PIE数据集提供了对感知和视觉推理的丰富标注，包括带有遮挡标志的边界框、过街意图置信度以及行人行为的文本标签。长时间的连续序列和标注有助于多个任务，如轨迹预测和行人意图预测。USyd。USyd 在没有交通信号灯的城市交叉口背景下推动了驾驶员意图预测的进展，这在城市设置中很常见，由于缺乏明确的道路规则和信号，构成了一项挑战。该数据集包括超过23,000辆车穿越五个不同的交叉口的数据，使用车载LiDAR跟踪系统收集。数据模态包括详尽无遗的提供了横向和纵向坐标、航向和速度的车辆轨迹。这些信息对于预测驾驶行为至关重要，考虑到人类驾驶模式中固有的不确定性。Argoverse。Argoverse 是3D目标跟踪和运动预测中的一个关键数据集。Argoverse提供了来自7个相机、前视双目图像和LiDAR点云的360°图像。记录的数据涵盖了来自290km映射车道线的300,000多条车辆轨迹。借助丰富的传感器数据和语义地图，Argoverse对于推动预测系统的研究和开发至关重要。inD。inD 的重要性在于它大规模、高质量且多样化的轨迹数据，对于道路用户预测模型和城市交叉口环境中自动车辆的基于场景的安全验证至关重要。它涵盖了大约11,500条不同的道路用户轨迹，例如车辆、自行车和行人。这些轨迹的定位误差小于0.1米，对于数据的可靠性至关重要。PePscenes。PePscenes 解决了在动态驾驶环境中理解和预测行人动作的需求。该数据集通过添加每帧2D/3D边界框和行为标注，重点关注行人过马路行为，增强了nuScenes 数据集。的一个关键属性是结合各种数据类型，包括语义地图、场景图像、轨迹和自车状态，这对于创建能够理解复杂交通场景的强大模型至关重要。openDD。openDD 数据集专注于分析和预测环状交叉口周围的交通场景，这些场景复杂且不受交通信号灯约束。它是在使用高分辨率（4K）的无人机捕获的图像的基础上创建的，跨足了来自501次单独飞行的62小时轨迹数据。该数据集不仅包含轨迹，还包括描述道路拓扑结构的shapefiles和可扩展标注语言（XML）文件，以及每个底层交叉口的参考图像。nuPlan。nuPlan 是自动驾驶中世界上第一个闭环机器学习规划基准。这个多模态数据集包括来自美国和亚洲四个城市的约1,500小时的人类驾驶数据，展示了不同的交通模式，如合并、变道、与骑自行车和行人的互动以及在施工区驾驶。nuPlan数据集的这些特征考虑了实际驾驶的动态和互动性质，使其更适合进行更真实的评估。exiD。exiD 轨迹数据集是2022年提出的，对高度交互的高速公路场景具有重要意义。它利用无人机记录交通情况，减少对交通的影响，并确保高数据质量和效率。这个基于无人机的数据集在捕捉各种交互中的多样性方面超过了先前的数据集，特别是涉及高速入口和出口的车道线变更。MONA。Munich Motion Dataset of Natural Driving (MONA) 是一个庞大的数据集，包含来自130小时视频的702,000条轨迹，覆盖了具有多个车道线的城市道路、市区高速公路以及它们的过渡。这个数据集展示了0.51米的平均整体位置精度，展示了使用高度精确的定位和LiDAR传感器收集数据的质量。多任务数据集:INTERACTION。INTERACTION 数据集涵盖了多样、复杂和关键的驾驶场景，结合了全面的语义地图，使其成为一个多功能平台，可用于多种任务，如运动预测、模仿学习以及决策和规划的验证。它包括不同国家的数据，进一步提高了对不同文化驾驶行为进行分析的鲁棒性，这对全球自动驾驶的发展至关重要。BLVD。BLVD 基准有助于动态4D（3D+时间）跟踪、5D（4D+交互）交互事件识别和意图预测等任务，这些对于更深入理解交通场景至关重要。BLVD提供了来自不同交通场景的约120,000帧，包括目标密度（低和高）和照明条件（白天和夜晚）。这些帧被完全标注，包括大量的3D标签，涵盖了车辆、行人和骑手。rounD。由提出的rounD数据集对于场景分类、道路用户行为预测和驾驶员建模至关重要，因为它收集了在环状交叉口的大量道路用户轨迹。该数据集利用装备有4K分辨率相机的无人机收集了超过六小时的视频，记录了超过13,000名道路用户。广泛记录的交通情况和高质量的录像使rounD成为自动驾驶中不可或缺的数据集，促进了对公共交通中自然驾驶行为的研究。Lyft Level 5。Lyft Level 5 是迄今为止最大规模的用于运动预测的自动驾驶数据集之一，拥有超过1,000小时的数据。它包括17,000个25秒长的场景，一个具有超过15,000个人工标注的高清语义地图，8,500个车道线段和该区域的高分辨率航拍图像。它支持多个任务，如运动预测、运动规划和仿真。详细标注的众多多模态数据使Lyft Level 5数据集成为预测和规划的重要基准。LOKI。LOKI 代表着长期和关键意图（Long Term and Key Intentions），是多agents轨迹预测和意图预测中的一个重要数据集。LOKI通过提供大规模、多样化的数据，包括行人和车辆在内，弥补了智能和安全关键系统的一个关键空白。该数据集通过利用带有相应LiDAR点云的相机图像，提供了交通场景的多维视图，使其成为社区中非常灵活的资源。SceNDD。SceNDD 引入了真实驾驶场景，展示了多样的轨迹和驾驶行为，可用于开发高效的运动规划和路径跟踪算法。它还适用于自动驾驶汽车不同配置，并包含可以分解为时间戳进行详细分析的预测时间视角。总的来说，SceNDD数据集是自动驾驶预测和规划研究的重要补充。DeepAccident。合成数据集DeepAccident 是第一个为自动驾驶汽车提供直接且可解释的安全评估指标的工作。这个包含57,000个带标注帧和285,000个带标注样本的大规模数据集支持端到端的运动和事故预测，对于提高自动驾驶系统在避免碰撞和确保安全方面的预测能力至关重要。此外，这个多模态数据集对于各种基于V2X的感知任务，如3D目标检测、跟踪和鸟瞰（BEV）语义分割，都是多才多艺的。Talk2BEV。创新的数据集Talk2BEV 推动了从传统的自动驾驶任务转向在自动驾驶背景下将大型视觉语言模型与BEV地图相结合的趋势。Talk2BEV利用了视觉语言模型的最新进展，允许对道路场景进行更灵活、全面的理解。该数据集包含超过20,000个多样的问题类别，全部由人工标注，并源自。所提出的Talk2BEV-Bench基准可用于多项任务，包括决策制定、视觉和空间推理以及意图预测。V2X-Seq（预测）。轨迹预测数据集是现实世界数据集V2X-Seq 的重要组成部分，包含约80,000个基础设施视图和80,000个车辆视图场景，以及额外的50,000个协同视图场景。这种感知领域的多样性为研究和分析车辆基础设施协同（VIC）轨迹预测提供了更全面的视角。端到端数据集端到端已经成为自动驾驶中的一个趋势，作为模块化架构的替代。一些多功能数据集（如nuScenes 和Waymo ）或仿真器（如CARLA ）提供了开发端到端自动驾驶的机会。同时，一些工作提出了专门用于端到端驾驶的数据集。DDD17。DDD17 数据集因其使用事件型相机而显著，该相机提供标准主动像素传感器（APS）图像和动态视觉传感器（DVS）时间对比事件的同时流，提供了视觉数据的独特组合。此外，DDD17捕捉了包括高速公路和城市驾驶在内的各种驾驶场景，以及不同的天气条件，为训练和测试端到端自动驾驶算法提供详尽而现实的数据。在本调查中总结的其他数据集显示在表IV、表V、表VI中。标注过程自动驾驶算法的成功和可靠性不仅依赖于大量的数据，还依赖于高质量的标注。本节首先解释了标注数据的方法。此外分析了确保标注质量的最重要方面。标注是如何创建的不同的自动驾驶任务需要特定类型的标注。例如，目标检测需要实例的边界框标签，分割基于像素或点级别的标注，对于轨迹预测来说，标注连续的轨迹至关重要。另一方面，如下图11所示，标注流程可以分为三种类型：手动标注、半自动标注和全自动标注。在本节详细说明了不同类型标注的标注方法。标注分割数据。标注分割数据的目标是为图像中的每个像素或LiDAR帧中的每个点分配一个标签，以指示它属于哪个目标或区域。在标注之后，属于同一目标的所有像素都用相同的类别进行标注。对于手动标注过程，标注者首先在目标周围画出边界，然后填充区域或直接涂抹像素。然而，以这种方式生成像素/点级别标注是昂贵且低效的。许多研究提出了全自动或半自动的标注方法以提高标注效率。提出了一种基于弱监督学习的完全自动标注方法，用于分割图像中提出的可行驶路径。[265]是一种半自动标注方法，利用目标先验生成分割mask。之后，[266]提出了一种考虑20个类别的半自动方法。Polygon-RNN++ 提出了一种交互式分割标注工具，遵循[268]的思路。[269]不使用图像信息生成像素级标签，而是将3D信息转移到2D图像领域生成语义分割标注。对于标注3D数据，[270]提出了一个图像辅助标注流程。[271]利用主动学习选择少量点并形成最小训练集，以避免标注整个点云场景。[272]引入了一种使用半/弱监督学习进行标注的高效标注框架，以标注室外点云。标注2D/3D边界框。边界框标注的质量直接影响了自动驾驶车辆感知系统（如目标检测）在现实场景中的有效性和鲁棒性。标注过程通常涉及使用矩形框标注图像或使用长方体标注点云，以精确包围感兴趣的目标。Labelme 是一种专注于为目标检测标注图像的工具。然而，由专业标注者生成边界框面临与手动分割标注相同的问题。Wang等人 提出了一种基于开源视频标注系统VATIC的半自动视频标注工具。[275]是另一种用于自动驾驶场景的视频标注工具。与白天标注相比，处理夜间的边界框标注更具挑战性。[276]介绍了一种利用轨迹的半自动方法来解决这个问题。与2D标注相比，3D边界框包含了更丰富的空间信息，如准确的位置、目标的宽度、长度、高度以及空间中的方向。因此，标注高质量的3D标注需要一个更复杂的框架。Meng等人 应用了一个两阶段的弱监督学习框架，使用人为循环来标注LiDAR点云。ViT-WSS3D 通过对LiDAR点和相应弱标签之间的全局交互建模来生成伪边界框。Apolloscape 采用了类似于的标注流程，包括3D标注和2D标注两个分支，分别处理静态背景/目标和移动目标。3D BAT 开发了一个标注工具箱，以辅助在半自动标注中获取2D和3D标签。标注轨迹。轨迹本质上是一系列点，映射了目标随时间的路径，反映了空间和时间信息。为自动驾驶标注轨迹数据的过程涉及对驾驶环境中各种实体的路径或运动模式进行标注，如车辆、行人和骑车者。通常，标注过程依赖于目标检测和跟踪的结果。在轨迹标注的先前工作中，[280]在线生成了用于演习的动作，并被标注到轨迹中。[281]包括一个众包步骤，后跟一个专家集成的精确过程。[282]开发了一个主动学习框架来标注驾驶轨迹。精确地预测行人的运动模式对于驾驶安全至关重要。Styles等人 引入了一种可扩展的机器标注方案，用于无需人工努力的行人轨迹标注。在合成数据上进行标注。由于在真实世界数据上进行手动标注的费时昂贵，通过计算机图形和仿真器生成的合成数据提供了解决这个问题的替代方法。由于数据生成过程是可控的，场景中每个目标的属性（如位置、大小和运动）都是已知的，因此可以自动且准确地标注合成数据。生成的合成场景被设计成模仿真实世界的条件，包括多个目标、各种地貌、天气条件和光照变化。为了实现这个目标，一些研究人员利用了《侠盗猎车手5》（GTA5）游戏引擎构建了数据集 。[284]基于多个游戏构建了一个实时系统，用于生成各种自动驾驶任务的标注。SHIFT 、CAOS 和V2XSet 是基于CARLA 仿真器创建的，而不是应用游戏视频。与[11]相比，V2X-Sim 研究了使用多个仿真器 ，为V2X感知任务生成数据集。CODD 进一步利用生成用于合作驾驶的3D LiDAR点云。其他工作利用Unity开发平台 生成合成数据集。标注的质量现有基于监督学习的自动驾驶算法依赖于大量的标注数据。然而，在质量低的标注上进行训练可能会对自动驾驶车辆的安全性和可靠性产生负面影响。因此，确保标注的质量对于提高在复杂的现实环境中行驶时的准确性是至关重要的。根据研究，标注质量受到多个因素的影响，例如一致性、正确性、精度和验证。一致性是评估标注质量的首要标准。它涉及在整个数据集上保持一致性，对于避免在训练在这些数据上的模型时产生混淆至关重要。例如，如果特定类型的车辆被标注为汽车，那么在所有其他情况下，它应该被一致地进行相同的标注。标注精度是另一个重要的指标，它指的是标签是否与目标或场景的实际状态相匹配。相比之下，正确性强调标注的数据是否适用于数据集的目的和标注准则。在标注之后，验证标注数据的准确性和完整性是至关重要的。这个过程可以通过专家或算法的手动审查来完成。验证有助于在问题影响自动驾驶车辆性能之前有效地防止数据集中的问题，从而减少潜在的安全风险。[288]提出了一种面向数据的验证方法，适用于专家标注的数据集。KITTI 的一个标注失败案例如下图12所示。在相应的图像和LiDAR点云中说明了真值边界框（蓝色）。在图像的左侧，汽车的标注（用红色圈出）不准确，因为它未包含整个汽车目标。此外，尽管相机和LiDAR清晰捕捉到两辆汽车（绿色长方体突出显示），但它们未被标注。数据分析这一部分将详细系统地从不同角度分析数据集，例如全球数据的分布，时间趋势，以及数据分布。全球分布在图13中展示了191个自动驾驶数据集的全球分布概况。该图表显示美国处于领先地位，拥有40个数据集（占比21%），突显了其在自动驾驶领域的领导地位。德国拥有24个数据集，反映了其强大的汽车工业和对自动驾驶技术推动的影响。中国紧随其后，拥有16个数据集，表明中国在这一领域的兴趣和投资。另一个值得注意的点是，全球范围内有11个数据集，欧洲地区（不包括德国）有24个数据集。这种多样化的区域分布增强了收集到的数据的稳健性，并突显了研究界和工业界的国际合作和努力。另一方面，尽管较小的部分代表了包括加拿大、韩国、英国、日本和新加坡在内的其他国家，这些国家都是拥有坚实技术背景和积累的发达国家——这一统计数据反映了极端的地区偏见。美国、西欧和东亚的主导地位导致了自动驾驶系统在这些地区典型的环境条件下过度拟合的偏见。这种偏见可能导致自动驾驶车辆在各种或未知的地区和情况下无法正常运行。因此，引入来自更广泛国家和地区的数据，如非洲，可以促进自动驾驶车辆的全面发展。此外，由CARLA 等仿真器生成的35个合成数据集占18.32%。由于实际驾驶环境录制的局限性，这些合成数据集克服了这些缺点，对于开发更强大和可靠的驾驶系统至关重要。感知数据集的时间趋势在图10中，作者介绍了从2007年到2023年（截至本文撰写时）具有前50影响分数的感知数据集的时间趋势概览。这些数据集根据它们的数据来源领域进行了颜色编码，并且合成数据集用红色外框标注，清晰地展示了朝着多样化数据收集策略的进展。一个明显的趋势显示了多年来数据集的数量和种类的增加，表明随着自动驾驶领域的不断发展，需要高质量数据集。总体而言，由于自动驾驶汽车有效而准确地感知周围环境的能力的重要性，大多数数据集提供了来自装备在自车上的传感器的感知视角（车载）。另一方面，由于实际世界数据成本高昂，一些研究人员提出了高影响力的合成数据集，如VirtualKITTI （2016年），以减轻对实际数据的依赖。在仿真器的有效性的推动下，近年来发布了许多新颖的合成数据集。在时间线上，像DAIR-V2X （2021年）这样的V2X数据集也呈现出向合作驾驶系统的趋势。此外，由于无人机提供的非遮挡视角，基于无人机的数据集，如2018年发布的UAVDT ，在推动感知系统方面发挥着关键作用。数据分布在图14中介绍了这些数据集每帧目标数量的情况。值得注意的是，Waymo  展示了大量帧数少于50个目标的情况，同时在图表中占据了广泛的位置，说明了它在每帧中从低到高的目标密度涵盖了各种场景。相反，KITTI  展示了一个更为受限的分布和有限的数据规模。Argoverse 2  具有大量帧数的高目标计数，其峰值约为70，这表明了它在一般情况下复杂的环境表示。对于 ONCE ，其目标密度均匀地分布在支持的感知范围内。像 nuScenes  和 ZOD  这样的数据集展示了类似的曲线，快速上升然后缓慢下降，暗示了环境复杂性的适度水平，每帧中目标数量具有相当的可变性。除了场景中目标数量之外，基于与自车的距离的目标分布是揭示数据集的多样性和显著差异的另一个重要点，如下图15所示。Waymo 数据集展示了大量标注目标在近场到中场场景中。相反，Argoverse 2 和 ZOD 展示了更宽的检测范围，有些帧甚至包括超过200米的边界框。nuScenes 的曲线意味着它在较短范围内的目标非常丰富，这在城市驾驶场景中是典型的。然而，随着距离的增加，nuScenes 数据集的目标数量迅速减少。ONCE 数据集覆盖了目标在不同距离上更均匀的分布，而KITTI 数据集更注重近距离检测。讨论与未来工作本文主要关注分析现有数据集，这些数据集通常包含丰富的视觉数据，并旨在完成模块化pipeline中的任务。然而，随着技术的迅速发展，尤其是大语言模型的出色性能，下一代自动驾驶数据集出现了许多新的趋势，提出了新的挑战和需求。端到端驾驶数据集。与模块化设计的自动驾驶pipeline相比，端到端架构简化了整体设计过程并减少了集成复杂性。UniAD  的成功验证了端到端模型的潜在能力。然而，端到端自动驾驶的数据集数量有限 。因此，引入专注于端到端驾驶的数据集对推动自动驾驶车辆的发展至关重要。另一方面，在数据引擎中实施自动标注pipeline可以显著促进端到端驾驶框架和数据的开发 。自动驾驶数据集中引入语言。视觉语言模型（VLMs）最近在许多领域取得了令人印象深刻的进展。其在为视觉任务提供语言信息方面的固有优势使得自动驾驶系统更具解释性和可靠性。强调了多模式大语言模型在各种自动驾驶任务中的重要作用，例如感知 ，运动规划 和控制 。下面表 VII 中展示了包含语言标签的自动驾驶数据集。总体而言，将语言纳入自动驾驶数据集是未来数据集发展的趋势。通过VLMs生成数据。正如所提到的，VLMs的强大能力可以用于生成自动驾驶数据。例如，DriveGAN  通过在没有监督的情况下解开不同组件来生成高质量的自动驾驶数据。此外，由于世界模型理解驾驶环境的能力，一些工作探索了使用世界模型生成高质量驾驶视频。DriveDreamer  作为从真实场景中派生的先驱性工作，解决了游戏环境或仿真设置的局限性。域自适应。域自适应是开发自动驾驶车辆时面临的关键挑战 ，它指的是在一个数据集（源域）上训练的模型在另一个数据集（目标域）上能够稳定执行的能力。这个挑战表现在多个方面，如环境条件的多样性 、传感器设置  或从合成到真实的转换 。结论本文对200多个现有的自动驾驶数据集进行了详尽而系统的回顾和分析。从传感器类型和模态、感知领域以及与自动驾驶数据集相关的任务开始。引入了一个称为"影响分数"的新型评估指标，以验证感知数据集的影响力和重要性。随后，展示了几个高影响力数据集，涉及感知、预测、规划、控制和端到端自动驾驶。此外，解释了自动驾驶数据集的标注方法，并调查了影响标注质量的因素。此外，描述了收集到的数据集的年代和地理分布，为理解当前自动驾驶数据集的发展提供了全面的视角。同时，研究了几个数据集的数据分布，为理解不同数据集之间的差异提供了一个具体的观点。最后，讨论了下一代自动驾驶数据集的发展和趋势。#关于BEV落地的点点滴滴1: 21年的大争论现在回看21年底组内决定做BEV障碍物的时候，应该来说是一个幸运，或者说有一点运气在里面。最开始面临的当时是大家每个人都熟悉的拍板的事情，到底是按照业界成熟的2D检测方案，或者说单目3D的的检测方案来做。还是说按照21 在自动驾驶届最火的那个Tesla Ai Day 的方案来做。争论，和彷徨应该持续了有一个月左右的时间。很幸运的是，最终我们老大直接拍板了，决定做BEV 障碍物。现在回看为什么说幸运：一个是在21年后学术届有很多优秀的BEV论文出来，一个是行车感知这块一直没有作为一个正式项目立项，给了我们足够的时间去试错，(最开始只有2-3个人来做这件事情)。如果缺少这一些因素，也许最后是做不出来的。这样可能往往一件成功的事情都伴随着一些幸运在里面吧。2：BEV 如何做方案在21年10份的时候，能够找到的BEV 障碍物检测的资料还是比较少的，看的最多的就是21 年Tesla AI day 上面的BEV pipeline。我记得很清楚组内对21年的Tesla AI day 的pipeline 方案(感知部分)进行了拆解分析，最后的难点卡在了2D image Feature 到 BEV Feature 的转换上面。其实那个时候还真不知道如何和Tranformer 结合来做这个。在这里不得不感慨CV 领域的开源文化，有一天看到了 Patrick Langechuan Liu. (在这里很感谢刘兰个川持续关于自动驾驶经典论文的输出Paper notes，不过近期看到刘兰个川从自动驾驶行业跳去做机器人和大模型去了。)写的一篇文章,里面有一个图，感觉对2Dto BEV 的转换清楚了很多。如图1图1 来自​​https://towardsdatascience.com/monocular-bev-perception-with-transformers-in-autonomous-driving-c41e4a893944​​然后我们就开始按图索骥，开始设计我们的网络，后面Detr3D DETR3D: 3D Object Detection from Multi-view Images via 3D-to-2D Queri 开源，结合Detr3D 我们的BEV 障碍物网络在nuscenes 数据集上开始收敛还不错。在验证集上跑出一个视频效果，大家都比较兴奋。那个时候我们只有2张40G的A100， 现在回想哈哈，我们真是无知者无畏。3: 痛苦开始的22年到22年的时候，我们面临的两个问题一个是自己车型的BEV训练数据如何构建，一个是如何把BEV 网络部署到车上。先说数据，这面临两个问题，一个是采集，一个是标注，还有一个是标定。采集我们搞了一台真值采集车，但是因为没有搞硬同步，导致7v(前视2V，后视1V，周视4V) 摄像头 和lidar 时间同步有问题，然后我们就搞了一套所谓的软同步的方案，只能说凑合着够用。然后说到标注，其实在22年标注行业里面，或者说我们选到标注供应商他们是没有标注过BEV 障碍物的, 然后我们就从零开始写标注文档(这个过程是真痛苦)， 第一版的标注文档，加上供应商提供的标注工具，最后标注出来的数据，一个字是真贵呀, 每标一帧都在滴血。经过1-2个月双方痛苦的磨合和优化过程，最终价格在一个合理的范围内了，不过现在回看，我们在22年标注的数据量还是有点多了。标定，最开始标定我们是求助外力来搞的，但是效果是真不行。最终只能自己动手风衣足食，磕磕绊绊搞了一个lidar 和7v 的联合标注。经过这一系列的操作，在这里感谢商汤开源的标定工具，https://github.com/pjlab-adg/sensorscalibration。我们终于搞到了质量还算可以的数据(现在回看，我们应该提早为时序模型的数据进行布局)。然后就是部署了，我记得很清楚上海刚好有疫情，然后我们居家了3个月左右。我们差不多痛苦了1个多月，在部署的时候，有一些算子不支持(也主要是2D-to-3D 的算子)，后面是转出来模型性能差，然后优化。然后是Pytroch 的模型和转出来在工程上部署的模型掉点很严重，我们曾一度想搞一个Fcos3D(https://arxiv.org/abs/2104.10956) 的网络先搞到板子上。组内的同学很给力的，我们差不多就3-4个人力左右的情况下，最后我们的模型能跑到10hz, 然后在大家的努力下我们差不多在22年7，8月份的时候，我们的视觉 BEV 障碍物就能跑上车了。看到BEV 障碍物在车上实时跑起来的时候，还是感觉到很兴奋的。（跨相机的case 是真稳，整个后处理pipeline 是真的很简洁的)。整个22年对我们来说收获还很大的，BEV 障碍物跑的不错。但22年我们也面临了来自项目的压力我们曾面临着人力资源紧缺，只有一个人力在投入在BEV 上面，还好大家坚持了下。4：收获的23年在前面差不多1年多的积累下，也随着组内的资源越来越多，23年我们做出来BEV 车道线，还有前融合的BEV多任务模型，端到端的红绿灯(一介书生：城市自动驾驶红绿灯方案何去何从？)目前都已经落地，在项目中开始测试，交付中。目前我们在探索时序的BEV，以及大模型相关的(一介书生：2024年自动驾驶标注行业是否会被世界模型所颠覆？) 现在来看在21年投入去积累BEV技术，是一个很恰当的时机，当然抛开技术本身，我们老大也顶下来很大的压力和质疑，因为有人的地方就有江湖的。#自动驾驶岗位算法工程师激光SLAM算法工程师视觉SLAM算法工程师多传感器融合算法工程师机器学习算法工程师计算机视觉算法工程师自然语言处理算法工程师决策算法工程师规划算法工程师控制算法工程师非算法类工程师软件平台开发工程师系统工程师功能安全工程师标定工程师仿真环境工程师测试工程师数据工程师UI开发工程师下面详细介绍每个岗位的工作职责和需要学习的内容2.算法工程师2.1.激光SLAM算法工程师岗位介绍：采集激光传感器数据，根据点云数据对自动驾驶车辆的周围环境进行地图构建。负责实现基于激光传感器的SLAM算法设计和开发，能够覆盖各种复杂场景的高精度地图更新和制作。技能要求：使用c、c++编程；需要有滤波算法知识：ESKF、EKF、UKF等；同时需要学习G2O、ceres等用来优化非线性误差函数的c++框架。熟悉开源SLAM框架，如GLoam、kimera、VINS等优先；2.2.视觉SLAM算法工程师岗位介绍：以VSLAM为基础，研发机器人自主导航定位算法，包括基于激光雷达、陀螺仪、里程计、视觉等多信息融合，构建机器人运动模型技能要求：学习常用的VSLAM算法，如ORB-SLAM、SVO、DSO、MonoSLAM，VINS以及RGB-D等；ROS机器人操作系统；需要有滤波算法知识：ESKF、EKF、UKF等；同时需要学习G2O、ceres等用来优化非线性误差函数的c++框架。2.3.多传感器融合算法工程师岗位介绍：将相机、激光雷达、毫米波雷达等多传感器的信息处理和融合，提高自 主驾驶车的环境感知能力；负责基于多源信息融合的目标检测、跟踪、识别与定位；负责基于多源信息融合的环境特征抽取，为地图构建提供支持；为基于基于多源信息融合的导航定位提供支持。技能要求：掌握camera、毫米波雷达、激光雷达、惯性导航等相关数据解析融合算法；计算机信息科学、电子工程或数学相关专业本科及以上学历，具备扎实的计算机理论基础精度相机模型、多视觉几何、Bundle Adjustment 原理，有SfM、几何测距等项目经验精通C/C++，熟悉Matlab，良好的面向对象编程思想和编码习惯熟悉IMU、GPS、DR等惯导定位算法框架熟悉IMU、GPS、车身系统原理、硬件特性、标定算法2.4.机器学习算法工程师岗位介绍：该方向主要负责车辆行驶过程中产生的数据在工程上的应用，偏向于数据分析方向，如车辆行驶里程的影响分析、大数据分析建模等等。技能要求：Python，C/C++学习机器学习的基础理论算法，如 LR、GBDT、SVM、DNN等等；学习scikit-learn 等传统机器学习框架的模型训练；熟悉 PyTorch、TensorFlow等深度学习框架（偏神经网络部分）等等。2.5.计算机视觉算法工程师岗位介绍：该方向主要基于摄像头传感器，主要包括：车道线检测、车辆等障碍物检测、可行驶区域检测、红绿灯等交通信息检测等等。技能要求：C/C++，Python，OpenCV；需要机器学习的基本算法 ( 降维、分类、回归等 )；需要学习深度学习，深度学习框架；学习计算机视觉和图像处理的常用方法 ( 物体检测、跟踪、分割、分类识别等 ) 。2.6.自然语言处理算法工程师岗位介绍：该方向主要负责车载场景下的语音识别，语音交互设计等等技能要求：学习机器学习算法、深度学习算法（RNN）；自然语言处理基本任务（分词、词性标注、句法分析、关键字抽取）需要使用机器学习方法聚类、分类、回归、排序等模型解决文本业务问题；熟悉 PyTorch、TensorFlow等深度学习框架（偏RNN部分）等等。2.7.决策算法工程师岗位介绍：自动驾驶的决策是将感知模块传递的信息，转化成车辆的行为，达到驾驶的目标。例如，汽车加速、减速、左转、右转、换道、超车都是决策模块的输出。决策需要考虑到汽车的安全性和舒适性，保证乘客的安全的情况下，尽快到达目标地点。技能要求：c/c++/python，熟悉ROS系统；学习常用的决策算法，如决策状态机、决策树、马尔可夫决策过程，POMDP等；如果往深里学的话，需要熟悉机器学习算法（RNN、LSTM、RL），掌握至少一种深度学习框架（比如gym或者universe等深度强化学习平台）；熟悉车辆运动学和动力学模型。2.8.规划算法工程师岗位介绍：规划包括路径规划和速度规划规划算法中，自动驾驶车辆首先通过路径规划确定车辆可行驶的路径，然后选择该路径确定可行驶的速度。技能要求：c/c++/python，ROS机器人操作系统；（有些公司是用Matlab/simulink开发的）学习常见路径规划算法，例如A、D、RRT等；学习一些曲线的表示方法，如：五次曲线、回旋线、三次样条曲线、B样条曲线等；如果往深里学的话；学习轨迹预测算法，如MDP、POMDP、Came Theory等；学习深度学习和强化学习技术也是加分项，例如RNN、LSTM、Deep Q-Learning等；有数学理论基础和背景，熟悉车辆运动学和动力学模型。2.9.控制算法工程师岗位介绍：一般是对车辆横纵向动力学建模，然后开发控制算法，实现车辆运动控制等；这个岗位跟车辆打交道较多，对于传统车厂转型到自动驾驶领域的伙伴来说，是个很好的切入机会。技能要求：C/C++、Matlab/Simulink学习自动控制理论基础，学习现代控制理论；学习PID、LQR、MPC算法；学习车辆运动学、动力学模型，对汽车的底盘有一定了解；学习CarSim等仿真软件；学习ACC、AEB、APA、LKA、LCC等辅助驾驶功能开发的是加分项；拥有实车调试经验也是加分项。3.非算法类工程师3.1.软件平台开发工程师岗位介绍：设计和实现自动驾驶软件平台，包括内核修改/扩展、驱动程序实现/增强、中间件实现/增强、系统集成、性能/功耗优化、压力/稳定性/符合性测试；负责搭建系统架构、编写底层驱动程序；负责视觉相关算法在嵌入式处理器（GPU、DSP、ARM等平台）上的代码实现及性能优化、测试和维护；协助算法工程师完成算法在嵌入平台上的移植、集成、测试和优化。技能要求：C/C++编程技巧、Python；具有嵌入式操作系统和实时操作系统的内核或驱动开发经验，熟悉QNX、ROS；熟悉软件调试和debug工具；了解车辆ADAS ECU和传感器，如雷达、摄像头、超声波和激光雷达；熟悉通用诊断服务（UDS）、控制器局域网（CAN）；熟悉通信协议（CAN、UDS、DoIP、SOME/IP、DDS、MQTT、REST等）是加分项。3.2.系统工程师岗位介绍：负责客户需求对接，以及与内部开发人员的需求释放；负责无人驾驶软件系统框架构建 ；负责模块化、可验证的系统软件架构设计和实时性能优化；与硬件、算法和测试团队合作，集成并优化自动驾驶系统。技能要求：拥有扎实的计算机基础理论知识（如：自动控制、模式识别、机器学习、计算机视觉、点云处理）；具有嵌入式操作系统和实时操作系统的内核或驱动开发经验；具备很好的沟通表达能力和团队合作意识3.3.功能安全工程师岗位介绍：在产品全生命周期内对产品的功能安全进行支持负责无人/自动驾驶系统产品的功能安全系统设计,并对现有流程提出改进意见;负责无人/自动驾驶系统的危险分析(HARA, FMEAs, FMEDA, FTA）;负责无人/自动驾驶系统的安全目标定义;负责无人/自动驾驶系统的安全需求定义;技能要求：精通ISO26262并有自动驾驶或者ADAS系统功能安全项目实施经验；（在传统车厂做功能安全想要转行的也可以考虑）；了解FMEA，FMEDA，FMEA-MSR，FTA等相应的方法；3.4标定工程师岗位介绍：负责自动驾驶多传感器标定，包括GPS、IMU、LiDAR、Camera、Radar 和 USS 等；设计实现传感器内参外参标定算法，搭建多传感器标定系统；负责对标定参数进行相关车辆测试，给出测试报告。技能要求：C++编程, 熟悉 Linux及ROS系统；有传感器标定工作经历，熟悉视觉或激光 SLAM 算法；3.5仿真环境工程师岗位介绍：该方向需要参与自动驾驶相关仿真系统的搭建，包括车辆动力学相关仿真，各类虚拟传感器模型和虚拟场景的建模与仿真，根据测试案例搭建测试场景，执行自动驾驶算法仿真测试等等；负责搭建无人驾驶模拟系统，对汽车、传感器、环境进行软件模拟。模拟结果将与真实数据一同用于预测汽车在真实场景中的行为；配合驾驶决策、路径规划、仿真算法等模块，实现自动驾驶闭环仿真，并可视化相关调试信息。技能要求：MATLAB/simulink、Python/C++熟练操作一种常用车辆动力学或无人车相关仿真软件，比如Perscan、Carsim、Carmaker等；熟悉机器人操作系统ROS等；有的仿真岗位纯属于做仿真，但有的岗位需要做仿真环境的开发，这样的岗位对编程要求会更高一些。3.6测试工程师岗位介绍：该方向主要负责自动驾驶车辆的相关测试工作，测试自动驾驶系统功能各项指标的性能，评估其边界条件和失效模式；负责自动化测试（SIL、HIL）的设计实现及智能驾驶产品的相关验证；负责根据系统或产品的功能需求制定测试用例和测试计划；负责制定完整的系统或产品的测试计划并实施，最后撰写测试报告；收集和测试系统的边界样例，对智能驾驶系统的安全性进行评估，对技术提出合理的反馈。技能要求：熟悉Ubuntu/Linux操作系统，会写python脚本熟悉CAN总线；熟悉测试用例的编写方法和技巧；熟悉图像识别算法，熟悉深度学习，掌握spark等大数据相关工具者加分；熟悉激光雷达，毫米波雷达，超声波探头和摄像头的应用是加分项。3.7大数据开发工程师岗位介绍：数据包括后台数据架构和前台呈现。一辆自动驾驶车每天都要生成1个T的数据量。数据该怎样快速清洗、提炼、总结，比如怎样迅速找出一次路测中最重要的几次介入（disengagements）。从而更高效的帮助工程师测试。负责自动驾驶大数据平台系统的设计、开发和优化；负责自动驾驶数据标注与处理流程的可视化工具开发，自动化标注平台的设计与研发。技能要求：具备扎实的数据结构及算法功底；精通Java/Python/C++等至少一门高级编程语言；熟悉Linux开发环境；有基于SQL或No-SQL数据库的应用程序的设计、开发经验；熟悉REST服务及Web标准，熟悉一种主流前端开发框架，如React/AngularJS，能独立构建前端应用者加分；熟悉自动驾驶及相关的Lidar、Camera等传感器数据者加分。3.8.UI开发工程师岗位介绍：每个公司都需要搭建内部工具，用于验证整车开发。也需要给远程控制中心做各种交互页面，通过一个UI远程控制自动驾驶车。同时也包括车厢内为乘客准备的UI。喜欢设计或者擅长前端的朋友可以考虑。技能要求：具有优秀的审美和丰富的视觉表现力；精通色彩、图形、信息和GUI设计原则及方法。#SparseAD端到端的范式使用统一的框架在自动驾驶系统中实现多任务。尽管这种范式具有简单性和清晰性，但端到端的自动驾驶方法在子任务上的性能仍然远远落后于单任务方法。同时，先前端到端方法中广泛使用的密集鸟瞰图（BEV）特征使得扩展到更多模态或任务变得成本高昂。这里提出了一种稀疏查询为中心的端到端自动驾驶范式（SparseAD），其中稀疏查询完全代表整个驾驶场景，包括空间、时间和任务，无需任何密集的BEV表示。具体来说，设计了一个统一的稀疏架构，用于包括检测、跟踪和在线地图绘制在内的感知任务。此外，重新审视了运动预测和规划，并设计了一个更合理的运动规划框架。在具有挑战性的nuScenes数据集上，SparseAD在端到端方法中实现了最先进的全任务性能，并显著缩小了端到端范式与单任务方法之间的性能差距。领域背景自动驾驶系统需要在复杂的驾驶场景中做出正确的决策，以确保驾驶的安全性和舒适性。通常，自动驾驶系统集成了多个任务，如检测、跟踪、在线地图、运动预测和规划。如图1a所示，传统的模块化范式将复杂的系统拆分为多个单独的任务，每个任务都独立优化。在这种范式中，独立的单任务模块之间需要手工进行后处理，这使得整个流程变得更为繁琐。另一方面，由于堆叠任务之间的场景信息损失压缩，整个系统的误差会逐渐累积，这可能导致潜在的安全问题。关于上述问题，端到端自动驾驶系统以原始传感器数据作为输入，并以更简洁的方式返回规划结果。早期的工作提出跳过中间任务，直接从原始传感器数据预测规划结果。尽管这种方法更为直接，但在模型优化、可解释性和规划性能方面并不令人满意。另一种具有更好可解释性的多面范式是将自动驾驶的多个部分集成到一个模块化的端到端模型中，其中引入了多维度的监督，以提高对复杂驾驶场景的理解能力，并带来多任务处理的能力。如图1b所示，在大多数先前的模块化端到端方法中，整个驾驶场景通过密集的鸟瞰图（BEV）特征进行表示，这些特征包括多传感器和时间信息，并作为全栈驾驶任务（包括感知、预测和规划）的源输入。尽管密集的BEV特征在跨空间和时间的多模态和多任务中确实发挥了关键作用，将之前使用BEV表示的端到端方法总结为Dense BEV-Centric范式。然而，尽管这些方法具有简洁性和可解释性，它们在自动驾驶的每个子任务上的性能仍然远远落后于相应的单任务方法。此外，在Dense BEV-Centric范式下，长期时间融合和多模态融合主要是通过多个BEV特征图来实现的，这导致了计算成本、内存占用显著增加，给实际部署带来了更大的负担。这里提出了一种新颖的以稀疏查询为中心的端到端自动驾驶范式（SparseAD）。在该范式中，整个驾驶场景中的空间和时间元素均由稀疏查询表示，摒弃了传统的密集鸟瞰图（BEV）特征，如图1c所示。这种稀疏表示使得端到端模型能够更高效地利用更长的历史信息，并扩展到更多模态和任务，同时显著降低了计算成本和内存占用。具体来说，重新设计了模块化端到端架构，并将其简化为一个由稀疏感知和运动规划器组成的简洁结构。在稀疏感知模块中，利用通用的时间解码器[将包括检测、跟踪和在线地图绘制在内的感知任务统一起来。在这个过程中，多传感器特征和历史记忆被视为tokens，而物体查询和地图查询则分别代表驾驶场景中的障碍物和道路元素。在运动规划器中，以稀疏感知查询作为环境表示，同时对自车和周围代理进行多模态运动预测，以获取自车的多种初始规划方案。随后，充分考虑多维度的驾驶约束，生成最终的规划结果。主要贡献：提出了一种新颖的以稀疏查询为中心的端到端自动驾驶范式（SparseAD），该范式摒弃了传统的密集鸟瞰图（BEV）表示方法，因此具有巨大的潜力，能够高效地扩展到更多模态和任务。将模块化的端到端架构简化为稀疏感知和运动规划两部分。在稀疏感知部分，以完全稀疏的方式统一了检测、跟踪和在线地图绘制等感知任务；而在运动规划部分，则在更合理的框架下进行了运动预测和规划。在具有挑战性的nuScenes数据集上，SparseAD在端到端方法中取得了最先进的性能，并显著缩小了端到端范式与单任务方法之间的性能差距。这充分证明了所提出的稀疏端到端范式具有巨大的潜力。SparseAD不仅提高了自动驾驶系统的性能和效率，还为未来的研究和应用提供了新的方向和可能性。SparseAD网络结构如图1c所示，在提出的以稀疏查询为中心的范式中，不同的稀疏查询完全代表了整个驾驶场景，不仅负责模块之间的信息传递和交互，还以端到端的方式在多任务中传播反向梯度以进行优化。与以往以密集鸟瞰图（BEV）为中心的方法不同，SparseAD中没有使用任何视图投影和密集BEV特征，从而避免了沉重的计算和内存负担，SparseAD的详细架构如图2所示。从架构示意图上看，SparseAD主要由三部分组成，包括传感器编码器、稀疏感知和运动规划器。具体来说，传感器编码器将多视图相机图像、雷达或激光雷达点作为输入，并将其编码成高维特征。这些特征随后与位置嵌入（PE）一起作为传感器tokens输入到稀疏感知模块中。在稀疏感知模块中，来自传感器的原始数据将被聚合成多种稀疏感知查询，如检测查询、跟踪查询和地图查询，它们分别代表驾驶场景中的不同元素，并将进一步传播到下游任务中。在运动规划器中，感知查询被视为驾驶场景的稀疏表示，并被充分利用于所有周围agent和自车。同时，考虑了多方面的驾驶约束以生成既安全又符合动力学要求的最终规划。此外，架构中引入了端到端多任务记忆库，用于统一存储整个驾驶场景的时序信息，这使得系统能够受益于长时间历史信息的聚合，从而完成全栈驾驶任务。如图3所示，SparseAD的稀疏感知模块以稀疏的方式统一了多个感知任务，包括检测、跟踪和在线地图绘制。具体来说，这里有两个结构完全相同的时序解码器，它们利用来自记忆库的长期历史信息。其中一个解码器用于障碍物感知，另一个用于在线地图绘制。通过不同任务对应的感知查询进行信息聚合后，检测和跟踪头以及地图部分别被用于解码和输出障碍物和地图元素。之后，进行更新过程，该过程会过滤并保存当前帧的高置信度感知查询，并相应地更新记忆库，这将有利于下一帧的感知过程。通过这种方式，SparseAD的稀疏感知模块实现了对驾驶场景的高效、准确的感知，为后续的运动规划提供了重要的信息基础。同时，通过利用记忆库中的历史信息，模块能够进一步提高感知的准确性和稳定性，确保自动驾驶系统的可靠运行。稀疏感知在障碍物感知方面，在统一的解码器内采用联合检测和跟踪的方式，无需任何额外的手工后处理。检测和跟踪查询之间存在明显的不平衡，这可能导致检测性能的显著下降。为了缓解上述问题，从多个角度改进了障碍物感知的性能。首先，引入了两级记忆机制来跨帧传播时序信息。其中，场景级记忆维持没有跨帧关联的查询信息，而实例级记忆则保持跟踪障碍物相邻帧之间的对应关系。其次，考虑到两者起源和任务的不同，对场景级和实例级记忆采用了不同的更新策略。具体来说，通过MLN来更新场景级记忆，而实例级记忆则通过每个障碍物的未来预测进行更新。此外，在训练过程中，还对跟踪查询采用了增强策略，以平衡两级记忆之间的监督，从而增强检测和跟踪性能。之后，通过检测和跟踪头部，可以从检测或跟踪查询中解码出具有属性和唯一ID的3D边界框，然后进一步用于下游任务。在线地图构建是一个复杂而重要的任务。根据目前所了解的知识，现有的在线地图构建方法大多依赖于密集的鸟瞰视图（BEV）特征来表示驾驶环境。这种方法在扩展感知范围或利用历史信息方面存在困难，因为需要大量的内存和计算资源。我们坚信所有的地图元素都可以以稀疏的方式表示，因此，尝试在稀疏范式下完成在线地图构建。具体来说，采用了与障碍物感知任务中相同的时序解码器结构。最初，带有先验类别的地图查询被初始化为在驾驶平面上均匀分布。在时序解码器中，地图查询与传感器标记和历史记忆标记进行交互。这些历史记忆标记实际上是由之前帧中高度可信的地图查询组成的。然后，更新后的地图查询携带了当前帧地图元素的有效信息，可以被推送到记忆库中，以便在未来的帧或下游任务中使用。显然，在线地图构建的流程与障碍物感知大致相同。也就是说，统一了包括检测、跟踪和在线地图构建在内的感知任务，采用了一种通用的稀疏方式，这种方式在扩展到更大范围（例如100m × 100m）或长期融合时更加高效，而且不需要任何复杂的操作（如可变形注意力或多点注意力）。据我们所知，这是第一个在稀疏方式下在统一感知架构中实现在线地图构建的。随后，利用分段贝塞尔地图Head来回归每个稀疏地图元素的分段贝塞尔控制点，这些控制点可以方便地转换以满足下游任务的要求。Motion Planner我们重新审视了自动驾驶系统中的运动预测与规划问题，并发现许多先前的方法在预测周围车辆运动时忽略了本车（ego-vehicle）的动态。虽然这在大多数情况下可能不会显现出来，但在诸如交叉口等场景中，当近处车辆与本车之间交互紧密时，这可能会带来潜在风险。受此启发，设计了一个更加合理的运动规划框架。在这个框架中，运动预测器同时预测周围车辆和本车的运动。随后，本车的预测结果作为运动先验被用于后续的规划优化器。在规划过程中，我们考虑了不同方面的约束，以产生既满足安全性又符合动力学要求的最终规划结果。如图4所示，SparseAD中的运动规划器将感知查询（包括轨迹查询和地图查询）作为当前驾驶场景的稀疏表示。多模态运动查询被用作媒介，以实现对驾驶场景的理解、对所有车辆（包括本车）之间交互的感知，以及对不同未来可能性的博弈。随后，本车的多模态运动查询被送入规划优化器，其中充分考虑了包括高级指令、安全性和动力学在内的多个方面的驾驶约束。运动预测器。遵循先前的方法，通过标准的transformer层实现了运动查询与当前驾驶场景表示（包括轨迹查询和地图查询）之间的感知和整合。此外，应用自车agent和跨模态交互来共同建模未来时空场景中周围agent和本车之间的交互。通过多层堆叠结构内部和之间的模块协同作用，运动查询能够聚合来自静态和动态环境的丰富语义信息。除了上述内容外，还引入了两种策略来进一步提高运动预测器的性能。首先，利用轨迹查询的实例级时间记忆进行简单直接的预测，并将其作为周围agent运动查询初始化的一部分。通过这种方式，运动预测器能够从上游任务中获得的先验知识中受益。其次，得益于端到端记忆库，能够以几乎可忽略的成本、以流式方式通过代理记忆聚合器从保存的历史运动查询中同化有用信息。需要注意的是，本车的多模态运动查询是同时更新的。通过这种方式，可以获得本车的运动先验，这可以进一步促进规划的学习过程。规划优化器。借助运动预测器提供的运动先验，获得了更好的初始化，从而在训练过程中减少了绕行。作为运动规划器的关键组成部分，成本函数的设计至关重要，因为它将极大地影响甚至决定最终性能的质量。在提出的SparseAD运动规划器中，主要考虑安全和动力学两大方面的约束，旨在生成令人满意的规划结果。具体来说，除了VAD中确定的约束外，还重点关注本车与附近agent之间的动态安全关系，并考虑它们在未来时刻的相对位置。例如，如果agent i相对于本车持续保持在前方左侧区域，从而阻止本车向左变道，那么agent i将获得一个左标签，表示agent i对本车施加了向左的约束。因此，约束在纵向方向上被分为前、后或无，在横向方向上被分为左、右或无。在规划器中，我们从相应的查询中解码其他agent与本车在横向和纵向方向上的关系。这个过程涉及确定这些方向上其他代理与本车之间所有约束关系的概率。然后，我们利用focal loss作为Ego-Agent关系（EAR）的成本函数，有效地捕获附近agent带来的潜在风险：实验结果在nuScenes数据集上进行了大量实验，以证明方法的有效性和优越性。公正地说，将对每个完整任务的性能进行评估，并与之前的方法进行比较。本节实验使用了SparseAD的三种不同配置，分别是仅使用图像输入的SparseAD-B和SparseAD-L，以及使用雷达点云和图像多模态输入的SparseAD-BR。SparseAD-B和SparseAD-BR都使用V2-99作为图像骨干网络，输入图像分辨率为1600 × 640。SparseAD-L则进一步利用ViTLarge作为图像骨干网络，输入图像分辨率为1600×800。在nuScenes验证数据集上的3D检测和3D多目标跟踪结果如下。“仅跟踪方法”指的是通过后期处理关联进行跟踪的方法。“端到端自动驾驶方法”指的是具备自动驾驶全栈任务能力的方法。表中的所有方法都是在全分辨率图像输入下进行评估的。†：结果是通过官方开源代码复现的。-R：表示使用了雷达点云输入。与在线建图方法的性能比较如下，结果是在[1.0m, 1.5m, 2.0m]的阈值下进行评估的。‡：通过官方开源代码复现的结果。†：根据SparseAD中规划模块的需求，我们进一步将边界细分为路段和车道，并分别进行评估。∗：骨干网络和稀疏感知模块的成本。-R：表示使用了雷达点云输入。Multi-Task结果障碍感知。在Tab. 2中将SparseAD的检测和跟踪性能与nuScenes验证集上的其他方法进行了比较。显然，SparseAD-B在大多数流行的仅检测、仅跟踪和端到端多目标跟踪方法中表现出色，同时与SOTA方法如StreamPETR、QTrack在相应任务上的性能相当。通过采用更先进的骨干网络进行扩展，SparseAD-Large实现了整体更好的性能，其mAP为53.6%，NDS为62.5%，AMOTA为60.6%，整体上优于之前的最佳方法Sparse4Dv3。在线建图。在Tab. 3中展示了SparseAD与其他先前方法在nuScenes验证集上的在线建图性能比较结果。需要指出的是，根据规划的需求，我们将边界细分为路段和车道，并分别进行评估，同时将范围从通常的60m × 30m扩展到102.4m × 102.4m，以与障碍感知保持一致。在不失公平性的前提下，SparseAD以稀疏的端到端方式实现了34.2%的mAP，无需任何密集的BEV表示，这优于大多数之前流行的方法，如HDMapNet、VectorMapNet和MapTR，在性能和训练成本方面都具有明显优势。尽管性能略逊于StreamMapNet，但我们的方法证明了在线建图可以在统一的稀疏方式下完成，无需任何密集的BEV表示，这对于以显著较低成本实现端到端自动驾驶的实际部署具有重要意义。诚然，如何有效利用其他模态（如雷达）的有用信息仍是一个值得进一步探索的任务。我们相信在稀疏方式下仍有很大的探索空间。运动预测。在Tab. 4a中展示了运动预测的比较结果，其中指标与VIP3D保持一致。SparseAD在所有端到端方法中实现了最佳性能，具有最低的0.83m minADE、1.58m minFDE、18.7%的遗漏率以及最高的0.308 EPA，优势巨大。此外，得益于稀疏查询中心范式的效率和可扩展性，SparseAD可以有效地扩展到更多模态，并从先进的骨干网络中受益，从而进一步显著提高预测性能。规划。规划的结果呈现在Tab. 4b中。得益于上游感知模块和运动规划器的卓越设计，SparseAD的所有版本在nuScenes验证数据集上都达到了最先进水平。具体来说，与包括UniAD和VAD在内的所有其他方法相比，SparseAD-B实现了最低的平均L2误差和碰撞率，这证明了我们的方法和架构的优越性。与上游任务（包括障碍感知和运动预测）类似，SparseAD通过雷达或更强大的骨干网络进一步提升了性能。#视觉和Lidar里程计自动驾驶的发展需要研究和开发准确可靠的自定位方法。其中包括视觉里程计方法，在这种方法中，精度可能优于基于GNSS的技术，同时也适用于无GPS信号的区域。本文深入回顾了视觉和点云里程计SOTA方法，并对其中一些技术在自动驾驶环境中的性能进行了直接比较。评估的方法包括相机、激光雷达和多模态方法，并从共同的角度比较了基于特征知识和基于学习的算法。在过去十年中，自动驾驶一直是许多技术和科学研究的主题。它的许多好处，如提高乘客安全性、舒适性和便利性、更好的交通流量、无人驾驶交通和降低了燃料消耗，吸引了负责自动驾驶汽车技术进步的大型制造商的投资。对于任何自动驾驶智能体，自定位的能力在每个导航任务中都是必不可少的。尽管GNSS（全球导航卫星系统）接收器通常是现代车辆自定位的主要来源，但大众市场设备提供的精度和可靠性远远低于自动驾驶车辆所需的水平。因此，由于定位误差、信号延迟和服务质量问题的不确定性，自动驾驶车辆不会强依赖于卫星数据[1]。而且这一问题在城市场景中进一步加剧[1]，由于此场景中卫星能见度有限、多径效应、干扰和其他误差。人类驾驶员自己的视觉感知能力弥补了所有这些限制。以同样的方式，自动驾驶汽车可以配备传感器，当与适当的里程计技术一起使用时，传感器可以提供类似人类水平的精确的相对定位。里程计可以被定义为使用局部传感器的数据来估计一个特定的起始点，估计一段时间内车辆的姿态变化。通常，这些方法试图通过传感器（如车轮编码器、RADAR、惯性测量单元（IMU）、LiDAR）来恢复车辆的位置和方向，这些传感器在现代车辆中越来越普遍。同样重要的是，要认识到这些传感器类型不是限制死的，因为里程计方法可以是多模态的，即不同的传感器可以通过一个算法一起使用。随着相机和激光雷达在现代车辆中的使用越来越普遍，基于视觉和点云的里程计正在成为关键的方法。与GNSS不同，这些传感器不需要外部信号。此外，这些技术比车轮里程计更为稳健，并且易于通过IMU或GPS进行补充[2]。随着政府对驾驶员辅助和自动驾驶安全功能的需求增加，自动驾驶相关领域的研究也在增加。参与感知领域的里程计对开发此类系统至关重要。本研究提供了视觉、点云和多模态里程计的概述，并将这些类别与一个共同的基准进行了比较，同时考虑了在完全相同的条件下获得的实际结果。此外，深度学习（DL）技术的兴起使得有必要评估其相对于传统方法的发展现状。这项工作背后的另一个动机是使用一个众所周知的数据集（KITTI-360[3]）创建一个最先进的视觉、基于点云和多模态方法的无偏见基准。基准测试在具有挑战性的情况下测试不同的算法，以验证所调研技术的优势和局限性。本文件还讨论了一些当前的问题，这些问题可以帮助研究人员超越常见的视觉里程限制，例如恶劣的天气条件、计算能力限制和动态目标的存在。本调研主要贡献是：（1）视觉里程计相关和有前景的工作的分类和理论讨论，从基于特征和外观的技术到利用深度学习能力的最新工作；基于点云的里程计，包括基于知识和学习的方法；同时还分析了不同类型的传感器融合。在相同场景下，使用通用评估程序对这些技术进行了分析；（2）对几种开源算法进行基准测试的大量实验，特别关注动态环境、开放空间、亮度变化、密集植被、转向机动和高速等具有挑战性的情况；（3）识别自运动估计的当前挑战，例如对场景外观的依赖性、高计算负载和移动目标的存在。分析和量化这些条件对不同类型所述方法性能的影响；（4）识别自运动估计的当前挑战，例如对场景外观的依赖性、高计算负载和移动目标的存在。分析和量化这些条件对不同类型所述方法性能的影响；视觉里程计现有的 VO 方法可以分为两类: 基于知识的方法和基于学习的方法。前者利用相机的几何关系来评估运动，而后者则基于机器学习技术，依赖于大量的数据来获得姿态预测能力。如下图所示，基于知识的方法可以分为三个子组: 基于外观的、基于特征的和混合的，这取决于如何使用视觉组件来生成里程计估计值。基于知识的技术基于特征的方法侧重于这样一个前提，即每帧中的关键点或区域可以用来确定相机的运动。这些关键点由角、边、线和斑点组成，这些图像模式在强度、颜色或纹理方面与周围环境不同，因此更可能在多个图像中匹配良好[2] ，[4] ，[5]。对于特征提取，通常采用 SIFT [6]、 SURF [7]、 ORB [8]和 BRISK [9]。基于特征的VO对于几何失真和照明不一致都有相当强的鲁棒性[10]。然而，由于这些方法高度依赖于正确的对应关系，因此只选取图像中的某些点，就会丢弃一些有价值的信息，因此必须尽量减少异常值的存在。下图描述了基于特征的算法所使用的pipline。因为这些pipline通常遵循结构化的pipline，其中涉及特征检测和匹配阶段(或特征跟踪) ，然后是运动估计，最后是优化步骤。尽管这些步骤通常是横向的，但是每种技术提出它们的方式都是不同的。在运动估计中，最常用的方法包括特征-特征匹配(2D-2D) ，它利用了纵向几何的约束。纵向约束与从不同角度看到的相同特征有关，其中 P1和 P2是图像坐标上图像1和图像2中同一点的坐标，E 是本质矩阵。通过选择一组匹配，可以计算出运动参数(E 中隐含的) ，从而使纵向约束带来的误差最小化。ORB-SLAM2[12]是 VO 和SLAM中流行的算法。它是 ORB-SLAM [13]用于单目、多目和 RGB-D 相机的扩展。这种开源方法通常被认为是视觉里程计的基准。作为一种 SLAM 技术，该算法由三个线程组成: 跟踪和局部建图，里程计模块和闭环。运动估计是利用关键帧和局部地图上跟踪的 ORB 特征计算出来的，特别强调多步光束法平差。VISO2[14]是2011年的另一个流行算法，它可以使用立体相机构建环境的3D 地图。这种方法应用了著名的立体匹配方法将稀疏的特征集与使用卡尔曼滤波器的里程计方法相结合[15]。此外，Cvisic和 Petrovi [16]-[18]的工作在基于视觉特征的方法领域具有特殊的相关性，因为他们的结果使视觉方法的精度更接近基于 LiDAR 技术的精度水平。在[16]中，作者提出了一个立体里程计算法，其主要重点是仔细选择和跟踪特征(SOFT)和这些步骤对自运动估计的影响。旋转和平移分别计算，以提高整个系统的性能。对于旋转，Nister 的5点[19]以单目方式使用，以概率地减少异常值和不完善的立体设备标定的有害影响，同时利用旋转以后使用3点计算平移。此外，该算法的一个扩展被提出来积分 IMU，用卡尔曼滤波器估计旋转集成。第一个估计有助于进一步去除异常值和减轻计算成本的5点算法，使用 P3P [20]和 Ransac [21]替代。当通过视觉里程计计算旋转时，Kalman 会更新。后来，Cvisic和 Petrovi用一个附加的建图线程扩展了 SOFT，从而产生了 SOFT-SLAM [17]。这种方法最初是为自动驾驶飞行器设计的，侧重于计算效率。SLAM 集成了 SOFT 可视里程计pipline，并通过一个建图模块完成，该建图模块增加了 SLAM 的特性，如闭环和全局一致性约束。这些增加的能力使得这种技术在 KITTI 数据集[22]中的定位精度优于其最先进的替代方案，如 ORB-SLAM2和 LSD-SLAM [23]。最近，Cvisic 等人[18]重新审视了 KITTI 里程数据集的标定参数。在最后的工作中，作者提出了一种新的一次性标定多相机 KITTI 装置参数的方法，该方法可以获得较小的重投影误差，直接影响 VO 算法的精度。将调整后的参数应用于 ORB-SLAM2、 SOFT 和 VISO2，平移误差平均提高了28% ，旋转误差平均提高了46% 。另一方面，基于特征的技术通过仅集中在少数几个选定的点来丢弃图像数据的重要部分。此外，这些技术可能需要额外的计算成本在匹配或跟踪操作和离群点去除。反过来，基于外观的 VO 技术利用捕获帧中的所有信息，而不仅仅是使用关键点。这些方法通过分析图像像素的强度并最小化光度误差来估计相机的姿态，这依赖于一帧中的像素在考虑移动传感器的同时保持其在第二帧中的强度的一致性原则[5]。通过这种方法，可以减轻由重复模式引起的混叠效应，并确保在有限纹理的场景中更加稳健，因为在这些场景中很难检测到好的特征(例如，雾或沙质环境)。基于外观的技术避免了提取和匹配特征以及运行异常去除算法所需的时间。另一方面，与基于特征的 VO 相比，它们对光照变化和相机突变运动敏感。基于外观的方法，也称为直接方法，一般分为基于区域匹配或基于光流的方法。前者通过在连续帧中对齐某些相应区域来估计相机的运动，但是在场景中存在动态目标的情况下，除了容易受到局部极小解的影响外，还会出现失效问题。另一方面，基于光流的技术利用环境场景的光流来估计基于运动模型的相机运动的6自由度(DoF)。下图在直接技术的通用pipline中汇总了两种方法。为了减轻基于特征和基于外观的方法的缺点，以及聚合每种方法的附加值，还可以采用来自每个领域的不同方法。这些被称为混合技术[5]。2017年，恩格尔等[24]提出了直接稀疏里程计法(DSO)。这个方法包括一个直接和稀疏的方案，因此不需要特征提取和配对操作。这种方法通过不断优化光度误差在一个有限的框架窗口。然而，与典型的直接方法相比，该方法同时对所有参数进行优化，包括自运动、相机标定和三维点的反深度。通过考虑完全误差，而不是仅仅考虑特定迭代的误差，该策略限制了异常值的影响。作者得出结论，有了合适的硬件(全局快门、精密镜头和高帧频) ，直接方法在精度方面可以超过几何/间接方法，这些方法在过去十年里一直主导着研究兴趣。传统(或几何)方法已经有了良好的基础，尽管这些方法在其演化过程中产生了合理的结果，但在复杂性增加的环境中，它们仍然被证明是脆弱的。事实上，仅仅依靠这些类型的技术变得极具挑战性，因为通过手工制定来捕捉现实世界的复杂性是极其困难的。基于学习的技术如在不同领域所见，数据驱动的基于学习的方法可以获得对场景的高层次理解，而不需要明确的建模，只要他们在足够大的代表性数据集上进行训练[25]。此外，相机标定参数不需要事先知道; 平移可以用正确的尺度估计，系统对图像噪声的鲁棒性更强[26]。因此，近年来 VO 的范式发生了转变，倾向于采用基于学习的方法。典型的数据驱动技术通常由多个具有不同功能的子网组成，例如深度估计、特征提取和自运动估计[25]。它们可以用来补充传统的pipline，也可以用来构建端到端的体系结构，如下图所示。对网络进行训练的方法是，将输出与监督信号对接，或根据调整和微调网络参数的cost函数对输出进行评估。Yang 等[27]提出了深度虚拟立体里程计(DVSO) ，它用一个基于深度学习的框架来补充 DSO。这项工作的核心是通过网络扩展 DSO 的能力，从而产生精确的深度估计，从而减少尺度漂移。提出的全卷积网络(FCN) StackNet 生成一对深度图，用于模拟虚拟立体平台。通过比较反向扭曲的产出和原始输入，以自监督的方式进行训练。这种技术在基于里程学习的方法中很常见，因此可以避免使用真值，而这些真值的获取成本很高。StackNet 的预测深度图被添加到原始 DSO 通用优化问题的预测深度图中，作为额外的几何约束。深度视觉里程计法迄今未能取代传统的方法。然而，这项工作超越了基于学习的替代方案，更接近于传统的最先进的技术。实际上，在 KITTI 选择的一组序列中，DVSO 比 ORB-SLAM2的平移误差略有提高，提高了2.2% 。此外，虽然 DVSO 不是一个端到端的视觉里程计架构，如 DeepVO [28] ，在 KITTI 数据集中 DVSO 的翻译误差是9.3倍。2020年，同样是 DVSO 的作者，Yang等人[29]提出了Deep Depth,Deep Pose和Deep Uncertainty，也被称为 D3VO。D3VO 的总体结构与 DVSO 和 DSO 略有不同。在 D3VO 中，深度是由一个称为 DepthNet 的卷积网络估计的，它也预测与估计相关的不确定性。反过来，相机的姿态是由另一个叫做 PoseNet 的深度卷积网络估计出来的，除了变换之外，PoseNet 还可以平衡当前帧和之前帧的照度，这两个帧共同构成了一对网络输入，以减少由于光照变化而产生的误差。不确定性在此均衡过程中尤为重要，因为它有助于检测容易违反帧间光度一致性原则的非朗伯反射表面。DepthNet 和 PoseNet 都是以自监督和联合方式进行训练的。姿态预测基于以前的工作DVSO和DSO补充了一个直接跟踪前端模块和一个全局光束法平差后端模块。在轨迹精度方面，结果略高于DVSO(在选定的 KITTI 序列中为10%)。与以前的方法不同，由 Wang 等人[28]提出的 DeepVO 是一种端到端的监督方法，其重点是学习具有适当几何意义的特征提取，并隐式建模一系列帧上的运动动力学。一对连续的图像被叠加并作为输入传递给卷积神经网络(CNN) ，生成一个输入对的简洁描述，然后被馈送给一个递归神经网络(RNN) ，允许捕捉视频的连续属性。尽管如此，与DVSO 和 D3VO 不同，其结果有些令人不满意。然而，这种方法允许非调优相关模型，它可以作为端到端DL方法的概念验证。事实上，计算机视觉中大多数常用的DL结构，如 CNN 和 RNN，并不适合 VO。这项工作可以作为一个起点，催化新的 VO 应用研究。ESP-VO [30]通过计算姿态估计的不确定性扩展了这项工作，这对传感器融合特别有用。按照类似的路径，PoseCon-vGRU [31]是一种端到端的可比方法。PoseCon-vGRU 利用 DeepVO 的时间效率，使用堆叠的门控循环单元(GRU)代替长短期内存模块(LSTM)。LSTM 和 GRU 是特定类型的 RNN，它们通过学习和在内部存储与保持或不保持内部状态相关的内容来捕获连续输入之间的长期关系。这种类型的结构是特别重要的视觉里程计，给予时间几何约束的序列框架。在 PoseConverGRU 中，GRU 是首选的，因为它们在性能方面非常接近于 LSTM，但是用更少的参数和更少的时间实现类似的结果。尽管如此，虽然取得了比 DeepVO 略好的结果，但改善并不显着，因此导致相同的结论。DeepAVO [32]是另一种基于光流的 DL 方法，其依赖于基于学习的光流提取器 PWC-Net [33]。它每个图像象限提供四分支网络，以利用局部视觉线索。卷积块注意模块(CBAM)[34]机制被纳入到特征编码器之前的姿态估计。这种机制作为一个mask，提取相关的特征，集中在不同运动的像素，丢弃前景和模糊的目标。同样依靠 PWC-Net，Zhao等[35]预测光流，计算相机姿态的相对变换，并通过三角测量重建场景的一些三维结构。然后，这些结构被用来标定来自平行神经网络的深度预测，解决姿态和深度预测之间尺度不一致的问题。这是一个阻碍学习过程和结果的问题，因此笔者将姿势分支和深度分支的训练过程进行了划分，利用两者的输出相互补充，形成一致性。ClusterVO[36]是一种动态感知的 VO 技术，它可以在检索相机轨迹和被检测目标轨迹的同时分割动态目标。运动估计部分基于关键帧和滑动窗口优化(部分类似于 ORB-SLAM2)。VLocNet [37]提出了一种应用于视觉里程计的基于辅助学习的方法。除了一个 VO 专用网络，作者提出了另一个模块来估计车辆的全局姿态，在两个任务之间共享特征，因为这两个任务在性质上非常相似。这种做法促进了一个更一致的学习和较少的易感性过度拟合。该技术在 VLocNet++ [38]中通过包含一个场景分割任务得到了进一步的扩展。到目前为止，视觉方法景观已经被传统的基于特征的方法所主导，如 ORB-SLAM2和 SOFT-SLAM。最近，直接的公式化方法已经取得了有趣的成果，而作者也开始观察到一种趋势，即整合基于学习的子模块，以补充更传统的架构，如 DVSO 和 D3VO。与此同时，许多端到端的自运动估计方法已经出现，尽管结果令人失望，但在道路交通环境复杂性的抽象方面仍然有很大的潜力。基于点云的里程计点云帧通常以点云的形式表示，点云由一组直接以世界坐标给出的3D点组成，而VO则是以像素/图像坐标给出点。激光雷达传感器的工作原理是测量发射和反射的激光线的飞行时间或相移。要创建环境的3D点云，需要多次执行此操作以覆盖整个扫描区域。基于点云的里程计方法的分类不像 VO 方法那样简单。将这些工作分类的最简单的方法是将它们分为以下几类: 基于知识的，使用标准和传统算法的，以及基于学习的，使用机器和深度学习技术的。Jonnavithula 等[39]帮助定义激光里程计算法的基本步骤: (1)预处理，(2)特征提取，(3)对应搜索，(4)转换估计和(5)后处理(如下图所示)。基于知识的技术ICP [41]在90年代有了第一个版本，可以被认为是基于 LiDAR 的里程计领域最有影响力的算法之一。在其最基本的版本中，该方法通过两个步骤找到两个点云之间的转换: 数据关联和转换估计。数据关联步骤旨在找到两个点云之间的对应点，这可以使用最近邻方法来完成。第二步通过计算每个点云的质心并对齐，然后利用单值分解(SVD)计算点云的旋转，最小化点对之间的距离。该算法进行多次迭代，直到找到一个局部最小值。ICP 的基本概念被用于各种最先进的方法，例如 CT-ICP [42] ，这是 KITTI 自动驾驶基准上表现最好的里程计系统之一。ICP 算法考虑了传感器运动引起的点云畸变，使得 ICP 算法能够实时工作，就像在自动驾驶场景中发生的那样。这个公式使这种方法对传感器的高频运动具有鲁棒性，这是该方法的主要强项。该算法估计每个激光雷达扫描的初始和最终位置，同时通过插值执行弹性扫描匹配。与类似的方法不同，最终姿态不一定对应于下一次滑动的初始姿态，提供弹性和鲁棒性，以应对传感器运动中更突然的变化。同时，该方法提供了一个完整的建图模块和一个新的闭环过程。通过剪切特定阈值之间的 z 坐标，地图的点被插入到二维高程网格中，只有当传感器在 z 轴上的运动相对稳定时，这种方法才有效。当构建一个新的网格时，使用旋转不变的2D 特征将其与旧网格进行匹配。当一个匹配被验证，ICP 被用来细化二维变换获得一个6自由度的闭环约束。最近的另一种依赖于 ICP 基础的方法是 MULLS (多度量线性最小二乘)[43] ，它提供了一个高效、低漂移的3D SLAM 系统。这种架构是专门设计的独立于激光雷达的规格，不需要转换的激光雷达数据环或Range图像。首先对几何特征点进行提取和编码，区分地面、立面、柱子等几类特征点。下一步涉及多度量线性最小二乘 ICP 的自运动估计，基于选定的特征，这是修改，以提高准确性和效率。这种变化有四个基本步骤。首先，在每个特征类别中确定点对应关系。然后，在考虑点强度等因素的情况下，计算每个对应关系的权重。然后，根据点对应关系和计算出的权值，计算出变换估计。最后，作者使用统计指标来评价注册过程的质量。下图描述了在 LiDAR 收集的点云上执行的 MULLS 注册过程的一个例子。另一项在这个领域具有高度相关性的工作是 LOAM [44]。该方法同时解决了不同频率下的里程计和周边建图问题。里程函数以较高的节奏运作，并产生较低的保真度估计。同时，建图模块在生成和细化全局地图的同时，速度较慢并调整里程估计值。对于里程计，在初始阶段提取点云特征，将点云特征选取并分组为尖锐边缘和平面表面斑块。沿着激光雷达扫描，假设传感器的恒定角速度和线速度，捕获的点逐渐投影到前一帧。当特征被提取和匹配时，ICP 的一个变体会产生新的估计。当扫描完成后，建图模块细化对齐，完成建图并产生更高精度的姿态估计，再次传递回里程计模块。其他的工作，比如 LeGOLOAM [45]和 ELO [46] ，使用了 LOAM 的变体，这些变体专门设计为在保持或改进原始性能的同时具有较低的运行时间。LeGOLOAM 是轻量级和地面优化 LOAM 的缩写，其开发目的是为了在计算能力较低且没有悬挂的车辆上实现(这会加剧点云失真)。基本的工作原理依赖于分割点云，去除小的集群和保留点，可能代表大的目标，如树干和道路表面，并保存在一个range图像中。然后从这些range图像中提取特征，分为地面特征和非地面特征。关于里程计算法本身，由于地面优化过程，跨帧特征匹配变得更快。正如预期的那样，这种方法提高了 LOAM 的效率，使用的特性减少了72% 。ELO[46]是最近由zheng等人提出的。对于 LOAM 这样的方法来说，以基于树的形式对点云进行编码是很常见的，这种方法虽然在搜索方面很有效，但在大规模的点云中会受到一定的限制。为了最大限度地提高效率，该方法提出将激光雷达测量结果投影到球面图像上，直接恢复点之间的邻域。问题在于，在自动驾驶汽车中，激光雷达传感器捕获了大量的地面点，而这些地面点在球面几何学的投影中变得过于遥远。作为一种利用这些点的方式，地面点投影在一个自上而下的鸟瞰角度。通过对地面点和非地面点的合理分割，以及适当的二维投影，使得帧匹配搜索方法的应用更加有效。关于运行时间，作者认为 ELO 在一台普通笔记本电脑上可以达到169帧率。事实上，这项工作记录的运行时间比 KITTI 里程计基准中十个最高位置的平均值低21倍。尽管在提高效率方面做出了努力，但 ELO 的性能与MULLS 等其他方法相当。其他一些工作也应该提到。例如，F-LOAM [47]试图通过将 LOAM 的迭代过程转化为两阶段失真补偿方法来减少计算负担。该算法还利用了局部光滑度较高的边缘特征和平面光滑度较低的特征，有利于匹配。通过这样的努力，该方法在低功耗嵌入式计算单元上实现了20Hz 的周期频率。ISC-LOAM [48]类似于 F-LOAM，但是使用点云的强度值和它们的几何形状来进一步提高循环闭合的能力。R-LOAM [49]通过将 LOAM 框架与关于引用目标的先前知识相结合，以不同的方式对这种改进进行了处理。它需要事先了解障碍物的三维模型及其在全局坐标系上的位置。然而，这种表述使 R-LOAM 不适合于自动驾驶环境。基于学习的技术一种不同类型的方法涉及使用深度学习技术来解决里程计问题。由于来自range传感器的数据是无序和稀疏的，这是具有挑战性的应用典型的卷积为基础的 DL 模块。因此，一些使用 DL 技术的方法将3D 点云转换成其他格式，如range图像。LO-Net [50]是一种使用这种方法检索传感器里程估计的算法。LO-net 首先从点云格式传递到矩阵，将点投影到圆柱坐标系中。然后，对于每个点，计算其各自的法向量。将包含当前时刻法向量和前一次激光雷达扫描法向量的矩阵传递给Siamese神经网络(SNN) ，后者将输出合并并提供给卷积网络，用于估计自运动参数。整个网络都是以监督的方式进行训练的。此外，该算法还包含场景中动态目标的掩模估计模块和建图块，通过扫描-建图匹配进一步细化估计。DeepLO [51]是另一种方法，它首先将入射的点云投影到二维空间中。投影表示被一对包含点云顶点和法线的2D图所替代，而且没有精度损失。从当前时刻和前一时刻的顶点建图被传递到一个完全卷积网络，从中提取各自对的特征向量。这同样适用于法线的图，它们被并行地提供给另一个类似的网络。然后将两个合成的特征向量相加并传递给第三个神经网络，该神经网络预测运动参数。这个网络可以训练，在监督的方式，辅助序列真值，或在无监督的方式，通过一个误差函数，其中包括一个版本的 ICP。LodoNet [52]也值得一提，因为它使用 SIFT 将3D 数据转换成二维表示和每种形式的特征提取，从而在连续扫描之间获得关键点对。然后，这些通信被输入一个卷积神经网络pipline，提取匹配的关键点对(MKPs)。MkPs 可以精确地返回到3D空间，并输入一个为激光雷达里程计设计的卷积神经网络。另一项利用神经网络的工作是 PWCLO-net [53]。该算法以端到端的方式从原始的3D 点云中学习 LiDAR 里程计，不需要将点云投影到2D 表示中。网络的输入是两个点云，由一个孪生特征金字塔编码，提取每个点云的层次特征。然后，利用一个注意力cost体积来关联两个点云，生成包含点相关信息的点嵌入特征。利用嵌入掩模从这些特征中获取姿态变换，同时去除动态元素。其他最近使用深度学习的相关工作是 PSF-LO [54] ，它使用参数化的语义特征来促进注册任务，并使用动态和静态目标分类器; 以及 CAE-LO [55] ，与以前的方法一样，使用无监督的深度学习并使用紧凑的2D 球形环投影。DMLO [56]也是一项有趣的工作，通过将姿态估计分解为两部分来使特征匹配适用于 LiDAR 里程计: 使两个扫描之间的匹配网络和刚性变换估计运算变换估计运算。SuMa++ [57]扩展了 Behley 等人以前的工作[58] ，并对自定位问题有不同的方法。通过分析语义surfel-based的地图变化来估计机器人的位置，同时检测和去除动态目标，提高姿态估计的精度。每个扫描的激光雷达帧被转换成一个二维投影。然后，通过点云分割网络RangeNet++ [59]对每个帧进行分割，因为每个点都属于一个语义标签。在此步骤之后，图像被转换回一个更新世界地图的3D 投影。本节提供了基于点云的里程计的一般概念的概述。文章还分析了这一领域的几个工作，以及它们的独特性，从知识到基于学习的方法，这些方法正在变得越来越流行，就像视觉里程计一样。多模态里程计自动驾驶汽车行驶的道路环境是非常复杂的。自动驾驶车可以通过结合不同的传感器(如相机、激光雷达和IMU) ，接近人类的感知能力，从多模态感知中受益。随着这些传感器开始被汽车制造商广泛采用，这种方法正变得越来越重要。数据融合策略数据融合依赖于从不同的传感器收集数据将允许从周围捕获更丰富和冗余的信息，这反过来又能够降低状态估计的不确定性。这种方法还有助于减少个别传感模式的失败成本，从而提高系统的鲁棒性。例如，视觉里程计可能会受到光照变化、照明条件差和无纹理环境的影响; 激光雷达难以应对高速公路或长隧道等宽阔的开放空间，以及恶劣的天气条件; 如果不定期调整，IMU 的轨迹估计往往漂移得非常快。因此，拥有不止一种模式应该可以弥补最终的短期或长期失败。在多模态方法中，可以根据合并在系统框架上下文中发生的瞬间对数据融合进行分类(如下图)。在早期融合中，在任何预处理之前，通常通过将一个或多个传感器投影到另一个传感器的输入空间，在原始阶段合并数据。这种方法通常具有较低的计算成本，但高度依赖于传感器间的空间和时间标定[60]。后期融合意味着数据的后处理合并。这是最常见的策略，因为它需要更低的复杂性和更高的模块化。然而，它带来了更高的计算费用，并阻碍了每种数据类型的潜在有价值的中间特征的使用[60]。最重要的，在后期融合中的局限性仅仅依赖于姿态估计，它赋予融合层一个抽象级别，在某些情况下可能会受到限制。最后，中间融合是更加全面的技术，因为它可以以许多可能的方式部署，这取决于系统的体系结构，特别是如果是基于DL 的。由于数据经过一定的处理后进行融合，因此也称为特征级融合。在里程计的上下文中，可以对数据如何被用来生成系统的输出进行分类。例如，激光雷达测量可以补充图像，同时估计自运动与视觉里程计或反之亦然，或两种类型的里程计可以分开操作，融合在更高的系统框架抽象层[61]。遵循第一种方法的系统通常表示为紧耦合，而其他系统称为松耦合[62]。在这种情况下，图像和点云通常是里程测量法估计的主要来源，而 IMU 和全球定位系统提供便利的先验和/或轨迹漂移校正。目前的数码相机技术，相比其他传感器，使相机具有非常有竞争力的价格和更小的尺寸和重量。相机通过提取颜色和纹理信息来记录周围场景的高分辨率图像，这对于检测轮廓和物体特别有效，而且，对于 VO 来说，可以识别在连续帧中容易跟踪的感兴趣点。然而，相机是非常依赖于环境条件和照明，面临着一些问题，规模恢复。反过来，激光雷达传感器可以检索自然深度信息，并通常提供更宽的空间覆盖。channel的数量通常在16到128之间，刷新频率可能在5到20Hz 之间变化。然而，雨、雾和雪会对激光雷达的性能造成高达25%的负面影响[63]，因此考虑这些现象非常重要。一些研究，如在[60]，[64]，证明了激光束的波长影响天气条件的不利影响。在合并来自不同传感器的数据时，标定也是一个关键的方面，特别是在紧耦合系统中。每个传感器具有内部和外部标定参数，捕捉传感器的内部几何特性，并将世界帧与设备帧相关联。此外，传感器必须联合标定，以便由不同传感器检测到的完全相同特征的多个检测结果转换到系统公共帧中完全相同的位置（理想情况下）。最常见的技术使用具有众所周知尺寸的物理目标。这些结构必须具有易于检测的特征，并根据每种传感器模式进行分割。每个传感器分割的特征构成了一组物理约束，允许通过参数优化估计它们之间的旋转和平移。例如，在[65]中，作者仅使用一个简单的任意平面多边形进行相机-LiDAR 标定，而在[66]中，作者提出了一个具有四个锥形孔和金属反射镜的矩形块，以允许相机，LiDAR 和雷达的外部标定。[67]作者编制了一套公开可用的传感器外部标定工具包，同时也提出了一些实际的考虑，有时在标定传感器。在[68]-[71]中可以找到一些额外的技术，主要用于相机-激光雷达融合，以及用于多相机和相机-IMU 融合的 kalibr 工具包，其使用来自[72]-[76]的技术。Multi-scale detection其中第一个运动估计是由启发于 DSO 的基于直接贴片的方法产生的[24]。通过应用滑动窗口优化技术，保证局部一致性和实时性，进一步提高了估计精度。如果最新的帧是关键帧候选，则从相应的 LiDAR 扫描中提取特征并加入到全局图中，然后允许在从扫描到建图的过程中再进行一个细化步骤。这个步骤允许使用整个激光雷达的覆盖角度，而不仅仅是相应的拍摄角度。后端模块负责地图维护，包括闭环和姿态图优化器，以减少长途旅行中的累积漂移。此外，DV-LOAM 提出了一个有见地的消融研究。结论表明，这项工作所采用的直接和基于补丁的可视化 LiDAR 里程测量方法比单纯的 LiDAR 里程测量方法具有更高的精度，因为它依赖于图像来检测点云中不易区分的边缘。此外，它还受益于直接深度测量增强图像，这使得该方法即使在图像模糊时也能工作。从 LOAM 的同一作者，V-LOAM [77]旨在减轻 LOAM 对平滑运动的依赖。相机集成到 V-LOAM 允许视觉里程测量作为激光雷达里程测量之前的估计和处理快速运动。类似于 LOAM 的架构，V-LOAM 也使用双频模型。视觉块计算姿态转换的速度更快，使用一种特征匹配方法，它依赖于图像点，其深度或者直接由激光雷达测量，或者通过三角测量获得。同时，当每个激光雷达扫描完成时，假设线性运动不变，新的点云不会失真。这些点被记录在一个由激光里程块维护的局部地图中，如 LOAM 中。注册允许生成自运动估计，纠正影响视觉估计的漂移。此外，LiDAR-camera 组合还支持短期光照爆发期间的操作。与 V-LOAM 不同，由 J.Graeter 等[78]提出的 LIMO 利用激光雷达测量以紧耦合的方式补充摄像机图像的深度信息。从图像帧中选取突出点，丢弃位于汽车和行人上的突出点，以避免动态物体的影响。这是通过深度学习语义分割来完成的。将激光雷达点云投影到图像上，通过平面拟合插值计算每个特征点的邻域深度。融合阶段还包括前景和地面分割。通过匹配特征，姿态变换估计由应用光束法平差的改进后端块生成和调整。在这一块中，特别强调仔细选择关键帧和地标，以及使用修剪后的最小二乘法加强模块，以减少异常值的存在。一种进一步的方法是来自C.Chow等人的紧耦合可视激光雷达 SLAM (TVL-SLAM)[79] ，其中视觉和 LiDAR 模块独立运行，直到来自两者的数据合并时流水线中的某个点，从而构成中间融合情况。关于里程测量领域，视觉前端在视觉残差旁边生成初步的姿态估计。这一估计有助于激光前端残差的计算。融合发生在一个大规模的最佳化问题中，其输入是两个模块的残差。在最后一步中，模块之间的内部和内部一致性由一组约束来确保，这些约束包括视觉标志重投影误差、扫描到地图配准和交叉约束，因为两个前端代表相同的环境。此外，该算法还具有传感器之间的外部标定技术和拒绝运动目标的多步技术。KAIST 数据集[80]的测试由拥挤道路环境中的具有挑战性的场景组成，由于其多模态特征(仅 TVL-SLAM LiDAR 和 ORB-SLAM2的准确性分别提高了88% 和78%)，证明了 TVL-SLAM 的优越性能。Wisth 等[62]最近提出了一种紧耦合的 LiDAR-Visual-IMU 里程测量结构。状态估计被表述为一个具有多传感器因素的大规模姿态图最佳化问题。视觉地标的深度是通过 LiDAR 点的投影计算的，如[78] ，或通过立体匹配; 点云不失真到最接近的图像时间戳，以确保时间同步，使用 IMU 的运动先验; 平面/线特征提取类似于[44] ，这减少了90% 的点为了效率的目的。实验表明对宽阔空间、黑暗隧道、密集的树叶和突然的运动具有相当强的鲁棒性。此外，姿态图公式允许不同的模式独立地影响系统，强调性能一致性的情况下，其中一个传感器的故障。Ramezani 等人的工作组成了一个不同类型的方法，其主要焦点是通过惯性导航系统(INS)估计药剂里程。通过使用多状态约束卡尔曼滤波器来传播智能体的运动状态。同时，在设置中集成了立体装置，允许通过二维和三维特征匹配方法给车辆运动增加额外的约束，限制了 IMU 估计的漂移。本节提供了几个例子，说明如何组合来自不同传感器的数据，以获得更准确的结果和更健壮的体系结构。通过与单一模式方法的直接比较，上述许多技术显示了汇总不同模式和处理数据冗余的重要性。下表汇总所有参考的里程计技术以及各自的分类、类型和相关关键点。视觉里程计基准到目前为止，在里程计领域的一些最相关和创新的工作已经被简要地描述和评论，包括视觉，基于点云，多模态方法。因此，本节将包含对一些暴露问题的一个关键的分析技术，支持的结果由作者获得的 KITTI 里程数据集。KITTI 数据集[22]包括总共22个视觉序列，记录在一辆车上的激光雷达和 GPS/IMU 数据，在常见的道路交通环境中采集，其中11个包括各自的真值。此外，KITTI 还提供了一个比较多种算法的评估工具，并在计分板上对它们进行排名。结果根据三个指标进行评估: i) trel，序列长度为100米至800米的平均相对平移误差(百分比) ; ii) rrel，在轨迹上的 deg/100米的旋转误差; iii)以毫秒为单位的运行时间。表2和表3中的数据对应于 KITTI 里程计基准训练和评估序列中最佳技术的评估。通过以下分析表，值得注意的是，不管它们的模式或技术性如何，顶部位置之间几乎没有隔离。事实上，上表中的前三个位置获得了低于0.5% 的树状图，并且每种方法对应于不同的传感模式，即多传感器，视觉和仅激光雷达。其余的地方都大致包括在0.70% 到0.90% 的范围内，除了最后两个，它们是 DL 端到端架构。类似地，在上表中，前五个位置构成了一个非常小的错误范围，大约为0.06%，同样来自每个模态的代表。还可以观察到，与基于学习的技术相比，传统技术占主导地位。事实上，在过去的几年中，只有在轨迹精度方面有了很小的改进。最终，重点将有所改变，以进一步强化里程计系统，并使其计算效率更高。与运行时或算法分配的数据不同，量化和度量鲁棒性并非易事。对这些技术进行测试的最常见方法是在包含有挑战性场景的数据集中对它们进行评估。虽然 KITTI 被广泛使用，因此适合进行比较，但其他一些数据集，如 KAIST [80]包括更具挑战性的序列。在这方面，多模态系统取得了更好的结果，如 KAIST 的c.Chou 等79和d.wish 等[62]的实验所显示的，这些实验针对针对特定传感器模式的不利条件评估了他们各自的工作，都经受住了测试，并且没有显示出整体退化的迹象，不像视觉或仅激光雷达方法。在效率方面，ELO 脱颖而出无与伦比，同时在准确性方面也表现得非常有竞争力。另一方面，像 TVL-SLAM 这样的复杂方法需要增加计算量，因为它们需要依靠并行运行的多个模块来实现这样的精度和鲁棒性，其中一些可能是需要的，例如优化和建图模块。这种架构的一个可能的解决方案是增强单个功能块，例如将 ELO 或类似的方法集成到激光里程计前端。开源方法的基准为了扩展以前的方法[82] ，对里程计进行结构良好和无偏倚的评估。一些开放源码的方法被选择。这些技术是针对从 KITTI-360数据集[3]中提取的一组具有挑战性的序列进行测试的，这些序列从安静的住宅街道上的常规驾驶到繁忙的高速公路都有所不同。KITTI-360是著名的 KITTI [22]自动驾驶数据集的继承者。它通过增加传感器，如一对鱼眼摄像头和一个额外的激光扫描仪，以及更长和更复杂的驱动器，改进了以前的迭代。通过这种方法，提取了11个序列，并在下表中进行了简要描述。每个序列 ID 的前两位数字对应于 KITTI-360数据集中的驱动器。这些序列构成了各种各样的环境，特别是挑战里程计算法和评估相应的限制。一些挑战包括高亮度变化，存在许多动态目标，传感器堵塞，和广泛开放的空间，等等。所选择的评估场景被用来测试一些视觉里程计方法在不同的情况下同化在不同条件下的最先进的表现，同时讨论每种模式的局限性。选择了一些最流行和性能最好的算法:🔹可视里程计:ORB-SLAM2[12] ，LIBVISO2[14]和 SOFT1[16]和 SOFT-SLAM2[17]的开源实现。深度学习方法 SC-SfMLearner [83]和zhao等[35]的工作也进行了测试。🔹基于点云的里程计:MULLS[43]，CT-ICP[42]，F-LOAM[47]和ISC-LOAM[48]。🔹 多模态里程计:Ramezani等人的工作[81] ，将多目装置与IMU融合。这些方法之所以被选中，是因为它们是开放源码的，并且有良好的文档说明，允许任何人实现它们。有些像 ORB-SLAM2，被认为是 VO 领域的里程碑，而其他像 CT-ICP 则是表现最好的在 KITTI 里程计基准上。本集提供了一个良好的理解和所有视觉里程计类别的代表性，包括知识和学习为基础的工作。挑战分析评估方法的性能将在下面的段落中讨论，特别是关于一些特殊的挑战。植物和开阔的道路在03_02的顺序中，车辆行驶在一条短直路上，整个路边都有茂密的植物环绕，如下图所示。植被对于相机和激光雷达技术来说是一个特殊的挑战。由于重复和噪声的模式使得视觉方法的特征匹配/跟踪变得困难。密集的叶片由于表面的不规则性和多个小遮挡影响了激光束的有缺陷反射，阻碍了点云的精确排列。即使一般来说视觉结果更好，但是基于激光雷达的方法比纯视觉的方法表现更好，平均误差低55%。原因可能是，视觉技术依赖于路上的视觉线索，激光雷达检测不到。除此之外，相机的垂直视野比激光雷达的视野略宽，这得益于更加鲜明的特征，因为顶部的植被没有那么密集。序列07_01包含相对较宽的开放道路（图10b），这对激光雷达技术构成了挑战，因为开放空间由于缺乏特征使得点云的排列变得困难。在这个序列中，性能最好的视觉方法(ORB-SLAM2)比性能最好的基于LiDAR的CT-ICP技术的平移误差降低了20.3% 。同样值得注意的是 IMU 的免疫力，因为它是本体感觉传感器，对场景中的外部因素具有免疫力，因为 Ramezani 等人(与 IMU 一起)在03_02中排名第二，在07_01中排名第一。回转机动和隧道序列06_01具有回转机动，其中基于点云的方法的360度空间覆盖有助于更精确的旋转估计。在图中，可以看到视觉方法出现的最明显的偏差。序列10_02具有一个黑暗的隧道通道，其中视觉方法仅仅依赖于从缩小的窗口中提取的远距离特征，如下图所示。这个通道影响基于相机的里程计技术，这可以在图9c 中观察到，因为所有的视觉方法在最后的左转时开始漂移，因为在弯道前发生的隧道穿越期间错误的前向自运动感知。因此，视觉技术获得的平移误差几乎比基于点云的替代方案在序列10 _ 02中评估的误差大六倍。动态目标序列05_01具有少量大尺度视觉遮挡(如下图)。这种场景对于纯粹的视觉技术来说尤其具有挑战性，因为这些目标所占据的视野范围相当大，难以提取出高质量的特征，甚至由于光圈问题而阻碍了对运动目标的检测。下图展示了当一辆大型卡车在车辆人前面横穿而它是固定的时候，偏差对视觉方法的影响。从下表中可以看出，基于激光雷达的方法在05_01中表现得更加准确，平移误差小了10倍，这要么是因为360度的场景覆盖，要么是因为算法中包含了特定的动态目标抑制方法。序列07_02包含几个启动和停止时刻，其中有多个车辆的速度与车辆相似，如下图所示。类似于序列05_01，多个动态目标扰乱视觉算法，当无数汽车开始移动时，车辆仍然保持静止，造成自运动的错误感觉。ORB-SLAM2(图15)是这种效应的一个明显例子，因为平移错误公式和公式分别是图12的8.7倍和7.0倍。高于这项技术的平均水平。此外，几乎所有其他视觉方法的性能都低于平均水平。LiDAR 方法对这些现象的鲁棒性增强，如表5所示。再次，关于场景中的运动目标，IMU 的集成可以增加一个置信度量来估计姿态，在这些情况下，会有来自两个传感器的分歧信息。观察 Ramezani 等人在07_02序列中的两个版本(有和没有IMU) ，作者可以看到IMU的参考影响，因为平均平移漂移从6.58米下降到1.61米。一般性能比较基准测试的结果加强了基于激光雷达方法的普遍性。从上表5中可以看出，当没有明显的退化迹象时，激光雷达技术的轨迹误差始终低于其他方法，如07_01和07_02。这表明，这些估计不仅准确，而且精确。请注意，评估的误差是通过积分轨迹计算的; 因此，少量具有显著偏差的估计值或多个具有较小偏差的估计值，将导致轨迹误差在整个序列中逐渐传播，或者不传播。实际上，值得注意的是 CT-ICP 和 F-LOAM/ISC-LOAM 在大多数序列中占主导地位，最后两个是相同方法的近似版本。除了基于学习的技术外，纯视觉技术的平均平移误差为9.5米，而基于点云技术的平均平移误差为5.4米。在点云里程计中，周围的3D 结构是直接绘制的，而 VO 中的输入是场景的2D投影，受到像素离散化的影响，因此精度有所下降。此外，虽然视觉技术的感知只限于一小部分涉及的空间，普通的激光雷达有一个360度的水平覆盖。这符合基于激光雷达技术的目的，因为运动估计受益于空间中的离散点，同时对离群点更有弹性。这些直接的比较有助于解释为什么点云方法通常更加精确和健壮。此外，与原始 KITTI 数据集不同的是，点云并非没有扭曲，所以像 MULLS 这样的算法比通常的算法性能更差。关于长序列，如00_01和07_01(图9b 和9i) ，无论该方法的传感模式如何，沿着轨迹的漂移的积累通常会发生，因为里程计是一个综合过程。出于这个原因，总是值得依赖于偶尔校正轨迹的技术，如 SLAM 算法中的建图和环闭合，或精确 GPS 测量的集成。或者，结合多个传感器，如 Ramezani 等[81] ，在自定位中提供冗余，这可以避免与只有一个传感参考相比的漂移趋势。结合外感知(相机，激光雷达，雷达等)和本体感知传感器(IMU) ，在最后一个例子，是特别有用的方面的健壮性。这是因为影响这些传感器的错误性质非常明显，而且它们不太可能受到相同环境条件的影响。此外，尽管 Ramezani 等[81]的工作仅在两个序列中超过了剩余的算法，但在所有序列的平均误差方面，超过了顶尖的 CT-ICP 约6% 的平均平移误差。这一结果表明，包含第二种数据模态（惯性）可以实现更稳定的性能，尽管在某些情况下表现不佳，但在所有测试中仍然表现一致，证明即使面对上述挑战，它也能保持在正轨上。就像原始 KITTI 数据集上显示的结果一样，基于学习的方法呈现的结果仍然远远低于传统方法。尽管在KITTI-360上执行的测试在DL方法级别上没有显着的代表性，但获得的误差大小和各自的轨迹表明它们的性能仍无法与经典拓扑的视觉方法相媲美，即使与基线模型相比也是如此。从原始数据到姿态估计，视觉里程计pipline反映了一个复杂的问题，深度学习端到端方法还不能重现有竞争力的结果。自运动的当前挑战和局限值得注意的是，最近的工作日益复杂，随之而来的性能却没有以同样的速度增长。这种现象可能会指出，传统的基于知识的方法开始显示出成熟的迹象，并可能趋于发展瓶颈。这些技术发展的两个主要障碍与实际环境的高度复杂性和不可预测性密切相关。一方面，里程计系统需要尽可能强大的各种不利条件，如照明和天气，这是直接相关的物理感应周围环境。另一方面，算法应该具有最大可能的抽象性，以便在软件层面上，感知能够承受它可能遇到的各种场景，无论是宽阔的开放区域还是拥挤的区域，有许多动态的目标或植被。因此，这是物理和软件领域的联合泛化问题。从更具体的角度来看，与视觉和基于点云的里程计有关的最相关的障碍可以分为三类: 场景条件，计算成本和动态目标。场景条件基于视觉的系统对环境的视觉外观非常敏感。视觉里程计，更具体地说是基于特征的视觉输出，在环境缺乏可以在后续帧中跟踪的相关数量的高质量特征时，往往表现不佳。这可能发生在不同的场景条件下，在夜间环境能见度很低，或在恶劣的条件下，如大雨或雾。像沙漠或开阔地围绕道路的情况也往往影响这些方法，因为这种环境的无特征性质。光线的变化也会带来额外的困难，特别是在直接视觉里程计的情况下，因为高亮度的变化，比如黑暗隧道的入口，可能会产生显著的影响。发生这种情况是因为光照一致性假设，假设在这种方法中使用的连续帧具有恒定的亮度，在这些条件下不起作用。反过来，基于激光雷达的技术不受光照条件的影响。但激光雷达受天气和大气条件的影响很大。Carballo 等[84]测试了12种不同的激光雷达模型在恶劣的天气条件下，如大雾和降雨，证明了一些局限性。例如，在大雨中，激光束反射到雨滴上，在扫描中形成“雨柱”，在点云中构成高噪音，如下图所示。如前所述，激光束的波长可以影响传感器在不利条件下的性能[64]。基于激光的传感器也受到反射率的严重影响，无法检测到反射率低的目标，如玻璃。像 VO 一样，这些方法也倾向于在没有明显突出线索的环境中失败，例如被广阔开阔的田野包围的乡村道路。KITTI-360数据集的评估证实了这些局限性，其中基于激光雷达的方法显示出性能下降的迹象。另一方面，正如预期的那样，当面对照明变化时，基于激光雷达的方法没有报告任何性能问题。计算成本在计算能力和时间方面的计算成本限制也应该得到解决。在自动驾驶的情况下，这一点尤其重要，因为在自动驾驶的情况下，估计数应该以足够高的速度提供，以满足与自动驾驶车辆有关的严格的时间限制。许多作者使用高性能的硬件来开发他们的工作，但因为移动机器人通常配备低级别的硬件。该设备可能无法以实时操作所需的频率运行算法。在视频录像中，如果无人机有几个摄像头，计算时间是必不可少的，特别是采集的图像是高分辨率的，这会使处理的数据量难以管理。减少计算负担的一种方法是仔细选择特征，而不是使用整个原始图像。尽管如此，特征提取/匹配和异常去除任务也可能耗费大量时间。在基于点云的技术中，同样的问题依然存在，增加的成本与点云的无序性有关，点云的预处理操作可能耗费大量时间。有效地排序和存储点云的一种方法是使用八叉树或 K-D 树，它们允许快速的多维搜索。动态目标动态目标检测在讨论视觉和激光测距时非常有趣，特别是在自动驾驶中，因为这种类型的目标非常普遍，即其他移动的汽车、行人和骑自行车的人。虽然有些作者考虑了动态目标，但大多数作者没有考虑。这意味着假设世界是静态的，这在估计车辆的自运动时有重要的含义。动态目标，当不计入时，会在轨迹估计中引入误差。如果认为运动目标是静态的，里程计算将基于错误的假设，姿态估计将不准确。同样值得注意的是，由于传感器安装在移动的车辆上，在自动驾驶领域，检测动态目标可能特别复杂。因此，检测到的运动有两个组成部分: 自运动(传感器的运动)和目标自身的运动，都与同一固定帧有关。区分这些运动类型的一种方法是使用额外的传感器(如IMU或GPS)来补充里程计算法，以推断自运动，然后通过减牵引来推断被检测目标的运动。对具有挑战性的场景进行的评估显示，当VO方法面临高度动态环境时，除了相机和 IMU 融合方法之外，其准确性显著下降[81]。在这种情况下，基于LiDAR的方法也更加稳健。这是因为 VO算法在没有正确的masking操作时，倾向于从运动目标中提取特征(运动目标通常具有显著的视觉特征）如下图17所示。运动分析技术，例如光学和场景流，是推断场景中目标运动的典型方法[85]。利用光流算法推导出的流场可以实现运动目标的分割方法。此外，随着使用 Flownet [88]和 RAFT [89]等深度学习方法在光流估计方面的最新进展，可以准确和及时地计算稠密流估计。上面章节中的一些公开的方法，比如 ClusterVo，SuMa + + 和 TVL-SLAM，已经考虑到了这个问题，因为他们使用了不同的技术，比如语义分割或者重投影策略来过滤掉不需要的目标。虽然与里程计任务没有直接关系，但几位作者提出了在自动驾驶环境下检测和分割动态目标的方法。其中一个例子是 Chen 等人[90]的工作，他们从 LiDAR 扫描中创建残留图像，并将它们提供给常规的点云分割网络，以识别运动目标。Pfreundschuh 等[91]提出了一种用离线算法识别动态目标的方法，然后使用标注数据训练一个能够实时检测移动障碍物的神经网络。FuseMODNet [92]是一个多模态方法的例子，它使用相机和激光雷达来探测在弱光情况下移动的障碍物。研究机会多模态架构可以在一个传感器补偿另一个传感器失效的情况下提供更强的鲁棒性。然而，多模态方法的进一步发展仍然是必要的和合理的，因为从本车的角度对环境的表征与各自的结果之间存在着强烈的相关性，这种相关性往往更好，表征越完整。此外，多样化和完整的收集数据集总是提供更好的洞察力和可靠性。由于这些原因，视觉里程计算法的部分局限性，特别是关于环境感应，可以通过开发集成多个传感器的系统来减轻，从而产生更准确和可行的估计。然而，复杂场景和概括问题并没有明显的解决办法。在实践中，关于现有的实际传感选项，手工制定可靠的现实世界模型仍然非常具有挑战性，即里程计问题受到许多因素的影响，这些因素非常难以检测，特别是难以推广。考虑到可能遇到的各种各样的情况，从有几十个动态目标的城市景观，到可能只有很少landmarks可以追踪的漫长的沙漠道路，除了传感器和相关噪音的局限性。因此，一个可行的选择是设计深度学习的能力来捕捉数据中更复杂的潜在特征，而传统的方法迄今为止发现这很困难。然而，基于学习的技术仍然远远不能满足需要，至少在自动驾驶的情况下是这样。此外，数据的可用性仍然不够大，现有的数据逻辑结构，如近年来主导计算机视觉的 CNN，在学习顺序数据关系方面效果不佳。反过来，RNN也能够解决这个问题，但是在捕捉图像特征方面却不如CNN擅长的那样。因此，经常发现 CNN 之后是 RNN，因为通常的解决方案倾向于适应现有的结构，而不是从头开始设计和裁剪它们。沿着这条路线，由于深度学习的使用是高度灵活的，[25]确定需要将新的技术和架构引入视觉/激光里程计作为未来的工作机会。此外，最近的工作，如 D3VO 开始接近传统的方法，不是通过端到端架构，其中的学习过程可能太复杂，但通过学习为基础的子模块，旨在补充系统链，如深度预测模块，例如。另一个似乎无人关注的提议是将深度学习算法集成到多模态体系结构中，以努力利用两者的上述优势。虽然新的方法正在出现，但是基于学习的里程计的全景仍然处于非常不成熟的状态，因此需要进展到更先进和更适合在现实世界中使用的状态，因为它已经在其他领域中使用。结论本文介绍了基于视觉和点云的里程计的一些基本要素，并对目前的最新技术进行了广泛的综述。根据 KITTI 数据集获得的结果，讨论了最佳性能技术。此外，在 KITTI-360数据集的一系列具有挑战性的场景中，评估了一组具有代表性的公开可用的方法，包括视觉、点云、多模态和基于学习的方法。结果表明，基于点云的方法在轨迹平移漂移方mask有优势，比视觉方法提高了33.14% 。场景，天气，照明条件，动态障碍和计算成本的高度复杂性和可变性被指数作为里程计算法进展的最大限制因素，因为作者确定了当前传统方法的发展瓶颈。作为解决方案的一部分，本文强调了多模态方法日益增长的稳健性，以及研究和开发更好的基于深度学习的解决方案的必要性，以利用这些方法的数据驱动建模能力，因为目前的方法仍然不具有竞争力。因此，加入深度学习算法和传感器融合也可能是一个有希望的突破性研究，因为它仍然略有待探索。#NeuroNCAP本文提出了一种用于测试自动驾驶（AD）软件系统的多功能基于NeRF的仿真器，其设计重点是传感器真实闭环评估和安全关键场景的创建。仿真器从真实世界的驾驶传感器数据序列中学习，并能够重新配置和渲染新颖的场景。在这项工作中，使用本文提出的仿真器来测试AD模型对安全关键场景的响应。评估表明，尽管最先进的端到端规划器在开环环境中的标称驾驶场景中表现出色，但在闭环环境中导航关键场景时，他们表现出了不可忽略的缺陷。这突出了端到端规划器在安全性和现实可用性方面的进步需求。通过将我们的仿真器和场景作为一个易于运行的评估套件公开发布，并邀请社区在受控但高度可配置且具有挑战性的传感器现实环境中探索、完善和验证他们的端到端模型。开源链接：https://github.com/atonderski/neuro-ncap总结来说，本文的主要贡献如下：发布了一个开源框架，用于自动驾驶的真实感闭环仿真。受行业标准EuroNCAP的启发，构建了无法在现实世界中安全收集的安全关键场景。使用仿真器和我们构建的场景，设计了一个新的评估协议，该协议侧重于碰撞而不是位移度量。本文发现尽管准确地感知了环境，但两个SoTA端到端规划器在安全关键场景中严重失败，这值得社区进一步探索。相关工作回顾端到端驾驶模型：传统上，自动驾驶任务被划分为不同的模块，例如感知、预测和规划，这些模块是单独构建的。胡等人认为，这种划分有很多缺点：跨模块的信息丢失、错误积累和特征错位。姜等人强调，规划模块可能需要访问手工制作的界面中不存在的传感器数据的语义信息。这两项工作继续支持端到端规划。Pomerlau等人的开创性工作提出了这样一种规划器，其中训练单个神经网络将传感器输入映射到输出轨迹。几十年的神经网络进步激发了人们对端到端规划的新兴趣。然而，这些规划者的黑匣子性质使他们难以优化，其结果也难以解释。胡等人和姜等人提出了两种具有中间输出的端到端神经网络规划器，对应于模块化方法。他们的规划者被划分为多个模块，但模块接口是学习的，由深度特征向量组成。端到端规划器的开环评估：Pomerleau等人通过让其驾驶真实世界的测试车辆来评估他们的驾驶模型。这样的设置使得大规模测试成本高昂，并且结果可能难以再现。最近在端到端规划方面的工作改为在开环中进行评估，在该开环中，模型根据记录的传感器数据预测计划。预测的计划从未被执行，相反，行动被固定在记录的内容上。这种设置也被用于目标级规划工作，该工作假设了完美的感知，并将静态环境的地图和动态对象的轨迹输入到模型中。这种开环评估构成了评估与现实部署之间的差距。此外，性能通常被测量为记录中预测的计划和车辆驾驶的轨迹之间的距离。虽然零的误差对应于人类水平的驾驶，但误差越低越好并不一定是真的。这可以通过考虑两个不同轨迹相同好的场景来实现。Codevilla等人对这些问题进行了研究，发现开环评估与实际驾驶质量不一定相关。Dauner等人得出了类似的结论。闭环评估和仿真：考虑到上述开环评估问题，闭环仿真变得很有吸引力。已经提出了几种对象级仿真器。然而，这些仿真器不生成传感器数据，这使得无法在闭环中测试端到端规划器。已经提出了许多手工制作的图形仿真器。这种仿真器面临的挑战有两个：很难创建逼真的图像，也很难创建捕捉真实世界多样性的图形资产。对世界模型的研究表明，场景的未来——例如雅达利游戏——可以在潜在空间中预测，并且潜在空间中的向量可以解码为传感器输入。胡等利用大规模的真实世界汽车数据集建立了一个世界模型。Amini等人提出了VISTA，其中可以通过预测深度取消投影最近的图像并重新投影，在局部轨迹周围合成新的视图。杨等人提出使用神经辐射场（NeRF）来创建场景的真实感传感器输入。该方法随后由Tonderski等人进行了改进。具有更准确的传感器建模和更高的渲染质量，特别是对于此处考虑的360度设置。新车评估计划：新车评估计划（NCAP）由美国交通部国家公路安全管理局于1979年推出，旨在为消费者提供有关汽车相对安全潜力的信息。NCAP对车辆进行了碰撞测试，并根据严重受伤的概率对车辆进行评分。1996年提出了一项类似的欧洲协议，即欧洲新车评估计划（Euro NCAP）。2009年，欧洲NCAP进行了全面改革，以纳入新兴防撞系统的测试。最初，这包括电子稳定控制和速度辅助系统，但后来扩展到包括其他系统，如自动紧急制动和自动紧急转向。在这项工作中，我们从欧洲NCAP自动防撞评估协议中获得了灵感。该协议提供了除非采取措施，否则将发生崩溃的场景。为了获得满分，车辆需要刹车或转向以避免事故发生。如果冲击速度充分降低，则会获得部分分数。方法详解闭环仿真我们的闭环仿真重复执行四个步骤。首先，在给定ego车辆的状态和相机校准的情况下，渲染高质量的相机输入。渲染器是根据驾驶车辆的日志构建的。其次，在给定渲染的相机输入和自车状态的情况下，端到端规划器预测未来自车轨迹。第三，控制器将计划轨迹转换为一组控制输入。第四，在给定控制输入的情况下，车辆模型在时间上向前传播自我状态。此过程如图2所示。接下来，我们详细介绍四个步骤中的每一个。神经渲染器：为了仿真新颖的传感器数据，我们采用了神经渲染器。NeRF从收集的真实世界数据的日志中学习3D环境的隐含表示。一旦经过训练，NeRF就可以从所述场景中渲染传感器逼真的新颖视图。最近的进步增加了通过更改场景中动态对象的相应三维边界框来编辑动态对象的能力。具体来说，参与者可以被移除、添加或设置为遵循新的轨迹，在我们的案例中，这使得能够创建安全关键场景。例如，为了仿真一种罕见但关键的安全场景，可以将原本在相邻车道上行驶的车辆定位为静止，并与自身车辆位于同一车道上。这种新颖的情况需要自车刹车或执行精确的超车动作。有两件事需要注意。首先，最近提出的NeuRAD还支持激光雷达数据的渲染。然而，由于最先进的端到端规划者只消耗相机数据，我们在这项工作中只关注相机数据。其次，正如我们在实验中所示，与真实数据相比，现代NeRF引入的领域差距足够小，端到端计划者的感知部分仍能以高性能运行。然而，我们预计随着神经渲染的未来发展，这一差距将进一步缩小。AD模型：最近关于端到端规划的工作描述了一个消耗（i）原始传感器数据的系统；（ii）自车状态；以及（iii）预测计划轨迹的高级计划。计划的轨迹包括在某个频率和某个时间范围的路点。需要注意的是，虽然我们的主要目标是分析最先进的端到端规划器，但该模块可以用任何类型的规划器取代，例如模块化检测器-跟踪器-规划器管道。控制器：为了应用车辆模型，需要将路点转换为一系列控制信号，对应于一系列转向角（δ）和加速度（a）命令。继Caesar等人之后，我们用线性二次型调节器（LQR）实现了这一点。请注意，虽然我们只分析输出路点的规划器，但规划器可以直接输出一系列控制信号。车辆模型：给定一组由计划轨迹产生的控制信号，车辆状态通过时间传播。为此，我们遵循先前的闭环仿真器，并采用离散版本的运动自行车模型。它可以正式地描述为：评估与常见的评估实践（即大规模数据集的平均性能）相反，我们将评估重点放在一小部分精心设计的安全关键场景上。这些场景经过精心设计，任何无法成功处理所有场景的模型都应被视为不安全。我们从行业标准的欧洲NCAP测试中获得了灵感（见第2节），并定义了三种类型的场景，每种场景的特征都是我们即将碰撞的参与者的行为：静止、正面和侧面。根据欧洲NCAP命名法，我们将此参与者称为目标参与者。其目的是控制自车以避免与目标行为者发生碰撞或至少降低碰撞速度。对于每种场景类型，我们都会创建多个场景。每个场景都基于从真实世界中大约20秒的驾驶中收集的数据。自车和目标参与者状态被初始化，这样，如果保持当前速度和转向角，碰撞将在未来约4秒发生。所有非平稳演员都被从场景中移除，我们随机选择其中一个作为目标演员，考虑到演员是否已经被足够近的观察到，并且在必要的角度下，以产生逼真的渲染。由于我们的渲染器仅限于僵硬的参与者，因此我们将行人排除在该选择之外。最后，我们在特定场景的间隔内随机抖动目标演员的位置、旋转和速度。在评估过程中，我们将每个场景运行大量的运行（使用固定的随机种子），并计算平均结果。接下来，我们将描述每种类型场景的特征。静止：这是一种相对简单的场景，其中一个静止的目标演员被放置在自车车道上。目标车辆可以任意旋转放置，但在整个场景中都将保持静止。这意味着自车可以进行剧烈的刹车或转向操作以避免碰撞。见图3a。正面：正面场景包括一个目标演员，他正朝相反的方向行驶，并在与自车的碰撞路径上漂移到自我车道上。因此，ego车辆不能通过断裂来避免碰撞，只会降低碰撞速度。为了完全避免碰撞，自车必须执行转向操作。见图3b。侧面：侧面碰撞场景的特点是目标演员从垂直方向穿过我们的车道。如果自车的当前速度保持不变，就会发生侧面碰撞。自车可以通过为迎面而来的目标行为者刹车，或者在超速经过目标行为者时进行轻微的转向操纵来避免碰撞。见图3c。NeuroNCAP评分：对于每个场景，都会计算一个评分。只有完全避免碰撞才能获得满分。成功降低冲击速度可获得部分分数。本着五星级欧洲NCAP评级系统的精神，我们将NeuroNCAP评分（NNS）计算为：实验数据集：虽然有许多针对自动驾驶的数据集，但nuScenes在端到端规划方面得到了最广泛的适应。它以具有高度互动场景的城市环境为特色，适用于我们的安全关键场景生成。由于其广泛的适应性，它还允许我们使用我们评估的模型的官方实现和网络权重。NuScenes分为1000个序列，其中150个保留用于验证。从这150个序列中，我们选择了14个不同的序列——根据场景中特工的行为，这些序列被认为是合适的——作为我们安全关键场景的基础。场景：每个场景都是手工设计的，考虑哪些参与者适合给定的序列、最合理的碰撞轨迹，以及定义不同类型随机化的允许范围。在评估过程中，我们将每个场景运行100次（使用固定的随机种子），并对结果进行平均。并不是所有的序列都可以用于所有类型的场景，例如，我们无法仿真一条直线路上的真实侧面碰撞。因此，我们为每种场景类型选择合适的序列。关于每个场景的更多细节和定性示例，我们参考补充材料。神经渲染器：作为我们的渲染器，我们选择使用NeuRAD，这是一款专门为自动驾驶开发的SotA神经渲染器，经验证可与nuScenes很好地配合使用。由于我们希望最大限度地提高重建质量，我们使用更大的配置（NeuRAD-L），并使用默认的超参数训练100k步。由于nuScenes中的姿态信息仅限于鸟瞰平面，我们采用姿态优化来恢复丢失的信息。最后，我们采用了沿对称轴翻转演员的方式，以实现从所有视点对演员的逼真渲染。AD模型：根据我们提出的评估协议，我们评估了目前的两种SotA端到端驱动模型，即UniAD和VAD。在这两种情况下，我们都使用了作者提供的预先训练的权重，这些权重在同一数据集上训练，而不会对所述模型的配置进行任何更改。这两种型号都消耗360°摄像头输入，以及can总线信号和高级命令：右、左或直，并在未来3秒内输出一系列未来路线点。虽然在我们的场景中，这比碰撞的初始时间（TTC）更短，但这不是一个问题，因为规避机动可以而且应该在最终航路点与当前参与者位置相交之前开始。此外，我们的场景设计得相当宽松，因此TTC&lt;3s的计划仍然可以成功避免碰撞。这两个模型之间的一个主要区别是，UniAD将防撞优化后处理步骤应用于它们的预测轨迹。使用具有基于预测占用率和未优化输出轨迹的成本函数的经典求解器来执行优化。当在开环中评估时，这种优化被证明可以显著降低碰撞率，我们现在可以在更有趣的闭环设置中研究它。为了实现更直接的可比分析，我们对VAD实现了相同的防撞优化。然而，由于VAD不能直接预测未来的占用，我们将其预测的未来对象光栅化，并将其用作未来的占用。请注意，这种方法可能高估了占用率，因为所有未来模式都被视为具有同等可能性。为了进行比较，我们基于UniAD/VAD的感知输出实现了一种天真的基线方法。规划逻辑只是一个等速模型，除非我们在自车前方的走廊中观察到物体，在这种情况下，我们会执行制动操作。走廊被定义为横向±2米，纵向范围从0到2维戈米，即如果TTC&lt;2s且前方有物体，我们会刹车。实验结果我们使用图4中每种场景类型的渲染前置摄像头图像，以及计划轨迹的重叠投影来增强定量分析。图4a描绘了一个成功的回避动作，同时也突出了我们呈现复杂实体（如摩托车手）的能力。然而，如果没有后期处理，规划者似乎容易忽视安全关键事件，如图4b所示。限制我们看到以下限制。首先，神经渲染器在场景和场景中受到限制，例如，没有雨，它能够准确渲染。此外，自车轨迹的大偏差和非常近的物体会导致视觉伪影（见图4）。其次，我们采用了一个简化的车辆模型，它不建模，例如延迟、摩擦或悬架。此外，我们不考虑路面方面，如颠簸、坑洞、砾石等。第三，我们对所有车型都采用了单一控制器，即使它们是紧密耦合的。我们的评估协议允许提交直接输出控制信号的AD模型。第四，神经渲染器无法处理可变形对象，例如行人。我们希望神经渲染的进一步进步将解除这一限制，并实现一套新的安全关键场景，重点关注弱势道路使用者。第五，目标行动者遵循预定的轨迹，而不动态地对自车做出反应。虽然这遵循了EuroNCAP的设置，但我们认为，未来有多个参与者的场景将需要反应行为。结论总之，我们的仿真环境提供了一种新的方法来评估自动驾驶模型的安全性，利用真实世界的传感器数据和受欧洲NCAP启发的安全协议。通过NeuroNCAP框架，包括静止、正面和侧面碰撞场景，我们暴露了当前SotA规划者的重大漏洞。这些发现不仅强调了在端到端规划者的安全性方面取得进展的迫切需要，而且为未来的研究提供了有希望的途径。通过向更广泛的研究界公开我们的评估套件，我们的目标是促进更安全的自动驾驶方面的进展。展望未来，我们预计将开发该套件以应对更广泛的场景，集成更精细的车辆模型，并采用先进的神经渲染技术，从而为安全评估设定新的基准。#RoadBEV原标题：RoadBEV: Road Surface Reconstruction in Bird’s Eye View论文链接：https://arxiv.org/pdf/2404.06605.pdf代码链接：https://github.com/ztsrxh/RoadBEV作者单位：清华大学 加州大学伯克利分校论文思路：道路表面状况，尤其是几何轮廓，极大地影响自动驾驶车辆的驾驶性能。基于视觉的在线道路重建有望提前捕获道路信息。现有的解决方案如单目深度估计和立体匹配的性能表现一般。最近的鸟瞰视角（BEV）感知技术为更可靠和精确的重建提供了巨大潜力。本文统一提出了两种简单而有效的BEV道路高程重建(road elevation reconstruction)模型，分别命名为RoadBEV-mono和RoadBEV-stereo，它们分别利用单目和立体图像估计道路高程。前者直接基于从图像视图中查询的体素特征拟合高程值，而后者有效地基于表示左右体素特征差异的BEV体积识别道路高程模式。深入的分析揭示了它们与透视视图的一致性和差异。在真实世界数据集上的实验验证了模型的有效性和优越性。RoadBEV-mono和RoadBEV-stereo的高程误差分别为1.83厘米和0.56厘米。基于单目图像的BEV估计性能提高了50%。本文的模型对实际应用充满希望，为基于视觉的BEV自动驾驶感知提供了宝贵的参考。主要贡献：本文首次从理论和实验两个方面展示了鸟瞰视角下道路表面重建的必要性和优越性。对于单目和立体基础方案，本文分别提出了两个模型，分别命名为RoadBEV-mono和RoadBEV-stereo。本文详细解释了它们的机制。本文全面测试和分析了所提出模型的性能，为未来的研究提供了宝贵的见解和展望。网络设计：近年来，无人地面车辆（UGVs）的快速发展对车载感知系统提出了更高的要求。实时理解驾驶环境和条件对于准确的运动规划和控制至关重要[1]-[3]。对于车辆来说，道路是与物理世界接触的唯一媒介。道路表面状况决定了许多车辆特性和驾驶性能[4]。如图1（a）所示，道路的不平整性，如颠簸和坑洼，会加剧乘用车的乘坐体验，这是直观可感知的。实时道路表面状况感知，特别是几何高程(geometry elevation)，极大地有助于提升乘坐舒适度[5]，[6]。与无人地面车辆（UGVs）中的其他感知任务如分割和检测相比，道路表面重建(road surface reconstruction)（RSR）是一种新兴技术，最近越来越受到关注。与现有的感知流程类似，RSR通常利用车载激光雷达（LiDAR）和摄像头传感器来保留道路表面信息。激光雷达直接扫描道路轮廓并派生出点云[7]，[8]。车辆轨迹上的道路高程可以直接提取，无需复杂算法。然而，激光雷达传感器成本较高，限制了它们在经济型量产车辆上的应用。与车辆和行人等体积较大的交通物体不同，道路的不平整性通常幅度较小，因此点云的准确性至关重要。实时道路扫描上的运动补偿和过滤是必需的，这进一步要求在厘米级别的高精度定位。基于图像的道路表面重建（RSR），作为一个三维视觉任务，在精度和分辨率方面比激光雷达（LiDAR）更有前景。它还保留了道路表面纹理，使得道路感知更加全面。基于视觉的道路高程重建实际上是一个深度估计问题。对于单目相机，可以基于单张图片实施单目深度估计，或者基于序列实施多视角立体（MVS）来直接估计深度[9]。对于双目相机，双目匹配回归视差图，这可以转换为深度[10]，[11]。给定相机参数，就可以恢复相机坐标系中的道路点云。通过初步的后处理流程，最终获得道路结构和高程信息。在真值（GT）标签的指导下，可以实现高精度和可靠的RSR。然而，图像视角下的道路表面重建（RSR）存在固有的缺点。对于特定像素的深度估计实际上是沿着垂直于图像平面方向寻找最优箱体(optimal bins)（如图1（b）中的橙色点所示）。深度方向与道路表面存在一定的角度偏差。道路轮廓特征的变化和趋势与搜索方向上的变化和趋势不一致。在深度视图中关于道路高程变化的信息线索是稀疏的。此外，每个像素的深度搜索范围是相同的，导致模型捕捉到的是全局几何层次结构而不是局部表面结构。由于全局但粗糙的深度搜索，精细的道路高程信息被破坏。由于本文关注的是垂直方向上的高程，因此在深度方向上所做的努力被浪费了。在透视视图中，远距离的纹理细节丢失，这进一步为有效的深度回归带来了挑战，除非进一步引入先验约束[12]。从俯视图（即鸟瞰图，BEV）估计道路高程是一个自然的想法，因为高程本质上描述了垂直方向的振动。鸟瞰图是一种有效的范式，用于以统一坐标表示多模态和多视图数据[13]，[14]。最近在三维目标检测和分割任务上取得的 SOTA 性能是通过基于鸟瞰图的方法实现的[15]，这与透视视图不同，后者通过在视图转换的图像特征上引入估计头部来进行。图1展示了本文的动机。与在图像视图中关注全局结构不同，鸟瞰图中的重建直接在垂直方向上的一个特定小范围内识别道路特征。在鸟瞰图中投影的道路特征密集地反映了结构和轮廓变化，有助于进行有效和精细化的搜索。透视效应的影响也被抑制，因为道路在垂直于观察角度的平面上被统一表示。基于鸟瞰图特征的道路重建有望实现更高的性能。本文重建了BEV下的道路表面，以解决上述识别出的问题。特别地，本文关注道路几何，即高程(elevation)。为了利用单目和双目图像，并展示鸟瞰图感知的广泛可行性，本文提出了两个子模型，分别命名为RoadBEV-mono和RoadBEV-stereo。遵循鸟瞰图的范例，本文定义了覆盖潜在道路起伏的感兴趣体素。这些体素通过3D-2D投影查询像素特征。对于RoadBEV-mono，本文在重塑的体素特征上引入了高程估计头。RoadBEV-stereo的结构与图像视图中的双目匹配保持一致。基于左右体素特征，在鸟瞰图中构建了一个4D代价体积，该体积通过3D卷积进行聚合。高程回归被视为对预定义箱体的分类，以实现更高效的模型学习。本文在本文作者之前发布的真实世界数据集上验证了这些模型，显示出它们比传统的单目深度估计和双目匹配方法有着巨大的优势。图1. 本文的动机。（a）无论是单目还是双目配置，本文在鸟瞰图（BEV）中的重建方法都优于图像视图中的方法。（b）在图像视图中进行深度估计时，搜索方向与道路高程方向存在偏差。在深度视图中，道路轮廓特征是稀疏的。坑洼不容易被识别。（c）在鸟瞰图中，能够精确捕捉到轮廓振动，例如坑洼、路边台阶乃至车辙。垂直方向上的道路高程特征更加密集，也更容易识别。图2. 坐标示意及真值（GT）高程标签的生成。（a）坐标（b）图像视图中的感兴趣区域（ROI）（c）鸟瞰图中的感兴趣区域（ROI）（d）在网格中生成真值（GT）标签图3. 道路图像及真值（GT）高程图的示例。图4. 图像视图中感兴趣的特征体素。位于相同水平位置的堆叠体素的中心被投影到红色线段上的像素点。图5. RoadBEV-mono的架构。本文利用3D到2D的投影来查询像素特征。高程估计头部使用2D卷积在重塑后的鸟瞰图（BEV）特征上提取特征。图6. RoadBEV-mono的机制。体素以侧视图展示。图7. RoadBEV-stereo的架构。定义在左相机坐标系下的体素查询左右特征图的像素特征。本文通过左右体素特征之间的相减，在鸟瞰图（BEV）中构建差异体积。然后，3D卷积对鸟瞰图中的4D体积进行聚合。图8. RoadBEV-stereo的机制。实验结果：图9. (a) RoadBEV-mono和 (b) RoadBEV-stereo的训练损失。图10. 在单目和双目基础上，与SOTA模型的距离方向上的高程误差比较。图11. 由RoadBEV-mono重建的道路表面可视化。图12. 由RoadBEV-stereo重建的道路表面可视化。总结：本文首次在鸟瞰图中重建了道路表面的高程。本文分别提出并分析了基于单目和双目图像的两种模型，分别命名为RoadBEV-mono和RoadBEV-stereo。本文发现，BEV中的单目估计和双目匹配与透视视图中的机制相同，通过缩小搜索范围和直接在高程方向挖掘特征而得到改进。在真实世界数据集上的全面实验验证了所提出的BEV体积、估计头和参数设置的可行性和优越性。对于单目相机，在BEV中的重建性能比透视视图提高了50%。同时，在BEV中，使用双目相机的性能是单目的三倍。本文提供了关于模型的深入分析和指导。本文的开创性探索也为与BEV感知、3D重建和3D检测相关的进一步研究和应用提供了宝贵的参考。#RSRD~首个自动驾驶路面重建数据集作者构建了路面重建数据集（Road Surface Reconstruction Dataset, RSRD），该数据集含有100万张精确标注的路面图像。这是首个专门面向自动驾驶路面感知的高精度、多模态和大规模数据集，可作为诸多计算机视觉和自动驾驶应用的测试基准。数据集主页：https://thu-rsxd.com/rsrd背景近年来，智能和自动驾驶车辆的快速发展对驾乘舒适性也提出了更高的要求。路面作为车辆与物理世界有接触的唯一媒介，对车辆行驶性能有决定性影响。提前感知路面状态，尤其是重建路面几何轮廓信息，能为后续决策规划和动力学控制系统提供关键参考信息。基于此实际背景，我们构建并发布了该路面重建数据集（Road Surface Reconstruction Dataset, RSRD）。这是首个专门面向自动驾驶路面感知的高精度、多模态和大规模数据集，可作为诸多计算机视觉和自动驾驶应用的测试基准。此外，我们于2022年发布了首个大规模路面分类数据集RSCD，含有100万张精确标注的路面图像。此数据集与之结合, 能够提供更加准确、全面的路面状态信息，赋能高阶自动驾驶。数据采集我们搭建了实车数据采集系统，包含IMU、双目摄像头、激光雷达和RTK高精定位单元。不同于现有自动驾驶感知数据集，我们专注于路面区域并保留细致的路面纹理信息。我们在城市和乡村区域开展实验，覆盖众多水泥和沥青路面工况，并包含常见路面不平如凹坑、裂缝和减速带。激光雷达点云经过运动补偿和多帧融合处理，为深度学习模型提供高精度、密集的真实标签。更多细节请参考数据集网页。数据集内容我们提供约2800对含有密集点云标签，和13000对有稀疏标签的样本。具体包含以下数据：精准校正的双目图像。分辨率为1920*1080，路面预瞄距离约在12米。经过准确运动补偿和多帧融合的激光雷达点云。路面区域的点云密度高，保留细节的路面轮廓变化。由点云生成的单目深度和双目视差真值图。运动位姿信息。经过严格筛选，仅保留定位精度在厘米级的片段。标定参数。因为提供的数据均经过准确的预处理流程，仅提供关键的传感器标定参数，研究人员可直接在数据上开发算法。此外，我们提供半分辨率（960*540）的版本，研究人员可根据条件和需求选择。数据集性能上图左侧为点云标签数量的统计直方图。大部分图像有8万~10万个真值标签，对于960*540大小的图像，GT比例在17%左右。右图统计了路面纵向方向上，每40cm间隔内点云扫描线的平均数量。在9米的预瞄距离内，能保证每20cm有一条雷达扫描。路面区域点云密度显著高于现有数据集，为高精度、高可靠的路面感知提供坚实基础。应用和基准该数据集面向路面重建应用，同时作为诸多下游任务的测试基准，例如：单目深度估计和运动恢复结构（SfM）立体匹配和多视立体视觉（MVS）路面点云分割定位与建图路面不平检测与分割（需要额外标注）作为基线，我们开源了基于立体匹配和BEV进行路面重建的代码，更多细节请参考数据集网页。下图为重建的可视化效果：基于单目深度估计的路面重建基于BEV的路面重建#运动规划~搜索算法16-18年做过一阵子无人驾驶，那时候痴迷于移动规划；然而当时可学习的资料非常少，网上的论文也不算太多。基本就是Darpa的几十篇无人越野几次比赛的文章，基本没有成系统的文章和代码讲解实现。所以对移动规划的认识不算全面，这几年随着自动驾驶、无人机的研究和应用的增多，很多的论文课程成体系的开始介绍这方面的内容。对于一个理工男来说机器人并且是能自动的、智能规划的，相信没有多少理工男是可以抗拒不想去做进一步了解的。所以一直在收集资料，筹划这哪一天可以出一个这方面系列，然后在code一个项目出来在机器人上捣腾各种实现。再一次加速本人对这一想法落实是两年前看到fast-lab高飞团队出的一系列飞行走廊解决无人机路径规划的工作视频。第一次看到视频时候真被震惊到，移动规划原来还可以这么玩，如此优美的数学框架。讲了这么多只是想致敬过去的经历，开启这个专题第一讲。这个系列主线就是围绕高飞老师《移动机器人动态规划》课程讲稿，里面会补充一些算法细节和自己的思考。这个课程对移动规划体系框架构建非常棒，内容排布的也非常好，唯一缺憾就是对于动态不确定障碍物的规划会少一些，因为课程本来就是针对无人机设计的。现代机器人学和自动驾驶等领域，路径规划是一个重要的主题. 它涉及到在给定的环境中找到从起点到终点的最优路径. 这个过程通常分为两个部分：前端路径搜索和后端轨迹规划. 前端路径搜索在地图中搜索出一条避开障碍物的轨迹，而后端轨迹规划则对搜索到的轨迹进行优化，使其符合机器人的运动学和动力学约束.实环境中的机器人运动规划是一个比较复杂的问题，对于复杂的问题人类的解法一般都是分步求解：先做个大概、然后在大概轮廓上逐步的复杂精细。机器人运动规划的学院派解法也是如此：1.前端：路径规划基于搜索的方法通用图搜索：深度优先搜索（DFS），广度优先搜索（BFS）Dijkstra 和 A* 搜索跳点搜索基于采样的方法概率路线图（PRM）快速探索随机树（RRT）RRT，有信息的 RRT带动力学约束路径规划状态-状态边界值最优控制问题状态栅格搜索动力学RRT*混合A*2.后端：轨迹生成最小抖动轨迹生成微分平坦性最小抖动优化最小抖动的闭式解时间分配实际应用软硬约束轨迹优化软约束轨迹优化硬约束轨迹优化3.不确定性状态求解：移动障碍物、突变环境、设备建模变化基于马尔可夫决策过程的规划（MDP）规划中的不确定性和马尔可夫决策过程最小最大成本规划和期望成本最小规划值迭代和实时动态规划机器人规划的模型预测控制（MPC）线性模型预测控制非线性模型预测控制前端——搜索路径规划在开始这部分内容介绍前，需要介绍几个概念。介绍这几个概念的目的在于更贴近实际的去理解搜索在业务中应用。搜索路径规划中是把机器人当成一个质点来考虑的，然而实际的机器人是有一定形状和占用空间的，如果把机器人当成质点来考虑很可能是会搜索出一条实际上不可行的（会碰到障碍物的）路径的。为了解决这个问题呢，我们可以简单的物体的形状转移到地图（让地图障碍物区域加上物体占用空间）。在这样的地图里把机器人当成质点来搜索可行路径。在配置空间中规划¹²³机器人在C-space中被表示为一个点，例如，位置（在R3中的一个点），姿态（在 (3)中的一个点），等等⁴⁷⁸障碍物需要在配置空间中表示（在运动规划之前的一次性工作），称为配置空间障碍物，或C-障碍⁴⁵⁶C-space = (C-障碍) ∪ (C-自由)⁴⁵⁶路径规划是在C-自由中找到从起点qstart到目标点qgoal的路径⁹[10]¹⁵在工作空间中机器人有形状和大小（即，难以进行运动规划）在配置空间：C-space中机器人是一个点（即，易于进行运动规划）⁶在进行运动规划之前，障碍物在C-space中表示⁸[10]在C-space中表示障碍物可能非常复杂。因此，在实践中使用近似（但更保守）的表示。如果我们保守地将机器人建模为半径为 _ 的球，那么可以通过在所有方向上膨胀障碍物 _ 来构造C-space1。这是一种常见的机器人碰撞检测方法，通过确保球体中心在膨胀地图的自由空间中来实现碰撞评估1。然而，这种保守的方法并未考虑到机器人的形状和大小。构建地图：在路径规划中，构建搜索地图是一个关键步骤。这通常涉及到将实际环境抽象为一个图（Graph），其中节点（Nodes）代表可能的位置，边（Edges）代表从一个位置到另一个位置的移动。以下是一个详细的例子：假设我们有一个机器人需要在一个室内环境中导航。这个环境可以是一个房间，有一些障碍物，比如桌子和椅子。定义节点（Nodes）：首先，我们需要确定节点的位置。在这个例子中，我们可以将房间的每一个可达的位置定义为一个节点。例如，我们可以创建一个网格（Grid），每一个网格单元都是一个节点。定义边（Edges）：然后，我们需要确定边。如果机器人可以直接从一个节点移动到另一个节点，那么这两个节点之间就有一条边。在我们的例子中，如果两个网格单元相邻，并且没有障碍物阻挡，那么这两个网格单元（即节点）之间就有一条边。定义权重（Weights）：最后，我们需要为每一条边定义一个权重。权重可以根据实际的移动成本来确定。例如，如果从一个节点到另一个节点的距离更远，或者路径上有斜坡，那么这条边的权重就应该更大。地图种类：栅格地图（Grid Map）则是把环境划分成一系列栅格，在数学视角下是由边联结起来的结点的集合，一个基于图块拼接的地图可以看成是一个栅格图，每个图块(tile)是一个结点，图块之间的连接关系如短线。概率图（Cost Map）如果在栅格图的基础上，每一栅格给定一个可能值，表示该栅格被占据的概率，则该图为概率图。特征地图（Feature Map）特征地图用有关的几何特征（如点、直线、面）表示环境。常见于vSLAM（视觉SLAM）技术中。它一般通过如GPS、UWB以及摄像头配合稀疏方式的vSLAM算法产生，优点是相对数据存储量和运算量比较小，多见于最早的SLAM算法中。拓扑地图（Topological Map）是指地图学中一种统计地图, 一种保持点与线相对位置关系正确而不一定保持图形形状与面积、距离、方向正确的抽象地图。包括有有向图和无向图（字面意思）。栅格地图概率图特征地图拓扑地图-有向图拓扑地图-无向图搜索算法介绍有了这么多种的地图，那么对应每种图可以用什么对应的算法来做路径的规划呢？下面是地图对应路径搜索算法：1. 栅格地图 / 概率图1. Dijkstra2. BFS（Best-First-Search）3. A*4. hybrid A*5. D  *6. RRT7. RRT*8. 蚁群算法9. Rectangular Symmetry Reduction (RSR) 10. BUG11. Beam search12. Iterative Deepeningc13. Dynamic weighting14. Bidirectional search15. Dynamic A* and Lifelong Planning A *16. Jump Point Search17. Theta *2. 拓扑地图1. Dijkstra2. BFS（Best-First-Search）3.  A*4. CH5. HH6. CRP图搜索算法结构:::success维护一个容器来存储所有待访问的节点该容器以起始状态XS进行初始化循环根据某个预定义的评分函数从容器中移除一个节点访问一个节点扩展：获取该节点的所有邻居发现所有的邻居将它们（邻居）推入容器扩展：获取该节点的所有邻居结束循环 :::通用搜索算法结构常用的图搜索有3大类的搜索结构，其它算法都是在这三个大的框架之下做改进。深度优先搜索（Depth-First Search, DFS）：原理：DFS是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。优点：实现简单，当目标明确时，搜索效率高。缺点：不保证找到最短路径，有可能会导致搜索陷入无限循环。广度优先搜索（Breadth-First Search, BFS）：原理：BFS是一种广度优先的搜索算法，用于搜索树或图。这个算法从根节点开始，沿着树的宽度遍历树的节点，如果所有节点均被访问，则算法结束。优点：可以找到最短路径，结果可靠。缺点：空间复杂度高，当解空间大时，内存消耗大。贪婪搜索（Greedy Search）：原理：贪婪搜索是一种在每一步选择中都采取在当前看来最好的选择，希望通过一系列的最优选择，能够产生一个全局最优的解决方案。优点：简单，易于实现，计算速度快。缺点：不能保证找到全局最优解，只能保证找到局部最优解。深度优先搜索（DFS）：DFS会沿着一条路径不断往下搜索直到不能再继续为止，然后再折返，开始搜索下一条路径。这种搜索策略可以看作是“先入后出”，因此在实现DFS时通常使用栈（Stack）这种数据结构。DFS的优点是实现简单，当目标明确时，搜索效率高。然而，DFS的缺点是不保证找到最短路径，有可能会导致搜索陷入无限循环。广度优先搜索（BFS）：相比之下，BFS会根据离起点的距离，按照从近到远的顺序对各节点进行搜索。这种搜索策略可以看作是“先入先出”，因此在实现BFS时通常使用队列（Queue）这种数据结构。BFS的优点是可以找到最短路径，结果可靠。然而，BFS的缺点是空间复杂度高，当解空间大时，内存消耗大。算法核心的三个问题是：问题1：何时结束循环？可能的选项：当容器为空时结束循环问题2：如果图是循环的怎么办？当一个节点从容器中移除（扩展/访问）后，它就不应该再被添加回容器问题3：如何移除正确的节点以便尽快到达目标状态，从而减少图节点的扩展。深度优先算法：数据结构维护一个后进先出（LIFO）的容器（即栈），算法移除/扩展容器中最深的节点#生成示例数据
graph = {}
graph["A"] = ["B", "D", "F"]
graph["B"] = ["C", "E"]
graph["D"] = ["C"]
graph["F"] = ["G", "H"]
graph["C"] = []
graph["E"] = []
graph["G"] = []
graph["H"] = []from collections import deque
search_queue = deque()  # 创建一个节点列表
search_queue += graph["A"]  # 表示将"A"的相邻节点都添加到节点列表中
from collections import dequedef search(start_node):search_queue = deque()search_queue += graph[start_node]searched = []  # 这个数组用于记录检查过的节点while search_queue:  # 只要节点列表不为空node = search_queue.pop()     #深度优先#node = search_queue.popleft()  # 广度优先取出节点列表中最左边的节点print(node, end=' ')  # 打印出当前节点if not node in searched:  # 如果这个节点没检查过if node == 'G':  # 检查这个节点是否为终点"G"print("\nfind the destination!")return Trueelse:search_queue += graph[node]  # 将此节点的相邻节点都添加到节点列表中searched.append(node)  # 将这个节点标记为检查过# 如果节点列表为空仍没找到终点，则返回Falsereturn Falseprint(search("A"))广度优先搜索算法：数据结构：维护一个先进先出（FIFO）的容器（即队列），算法操作：移除/扩展容器中最浅的节点。具体代码参考上面深度搜索算法，把“node = search_queue.pop() #深度优先”换成“node = search_queue.popleft() # 广度优先取出节点列表中最左边的节点”即可。可以看出BFS和DFS差别就在于根据“先入”或“后入”的原则，从边界中选择下一个节点。贪婪搜索（Greedy Search）：贪心算法的特点是考虑了从目标节点找到任意点的代价，而一般算法考虑的是从起始节点到任意点的代价。即贪心算法考虑的是如何快速的找到目标节点，使得到达目标节点的时间成本最小；而一般算法考虑的是目标节点到达目标节点的花费代价是最小的，而不是快速找到目标节点。基于贪心策略试图向目标移动尽管这不是正确的路径。由于它仅仅考虑到达目标的代价，而忽略了当前已花费的代价，于是尽管路径变得很长，它仍然继续走下去。贪婪算法中“行动的成本”可以用启发式函数h(n)来算从任意结点n到目标结点的最小代价评估值；启发函数决定了贪婪算法运算书读，所以选择一个好的启发函数很重要。实际的搜索问题中，从一个节点到其邻居有一个“C”的成本可以作为启发函数计算代价的有：长度，时间，能量等当所有权重都为1时，贪婪算法找到最优解对于一般情况，如何尽快找到最小成本路径？Dijkstra算法：Dijkstra算法算是贪心思想实现的，其可以适用与拓扑图或者栅格图，具体实现方法是，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离：策略：扩展/访问具有最低累积成本g(n)的节点g(n)：从起始状态到节点“n”的累积成本的当前最佳估计更新所有未扩展邻居“m”的累积成本g(m)已经被扩展/访问的节点保证具有从起始状态到该节点的最小成本 :::success维护一个优先队列来存储所有待扩展的节点用起始状态XS初始化优先队列设置g(XS)=0, 对图中的其他所有节点设置g(n)=无穷循环:如果队列为空,返回FALSE并退出循环从优先队列中取出g(n)最小的节点“n”将节点“n”标记为已扩展如果节点“n”是目标状态,返回TRUE并退出循环对节点“n”的所有未扩展的邻居节点“m”:如果g(m) = 无穷g(m)= g(n) + Cnm将节点“m”加入队列如果g(m) &gt; g(n) + Cnmg(m)= g(n) + Cnm结束对邻居节点的循环结束主循环 ::: BFS（Best-First-Search）算法BFS（Best-First-Search）算法也是可以看作基于启发式的深度优先算法，其按照和Dijkstra类似的流程运行，不同的是它能够评估任意结点到目标点的代价（即启发式函数）。与选择离初始结点最近的结点不同的是，它选择离目标最近的结点。BFS不能保证找到一条最短路径。但是它比Dijkstra算法快的多，因为它用了一个启发式函数（heuristic ）能快速地导向目标结点。例如，如果目标位于出发点的南方，BFS将趋向于导向南方的路径。在下面的图中，越黄的结点代表越高的启发值（移动到目标的代价高），而越黑的结点代表越低的启发值（移动到目标的代价低）。这表明了与Dijkstra 算法相比，BFS运行得更快。然而，这两个例子都仅仅是最简单的情况——地图中没有障碍物，最短路径是直线的。现在我们来考虑前边描述的凹型障碍物。Dijkstra算法运行得较慢，但确实能保证找到一条最短路径：另一方面，BFS运行得较快，但是它找到的路径明显不是一条好的路径：由于BFS是基于贪心策略的，它试图向目标移动尽管这不是正确的路径。由于它仅仅考虑到达目标的代价，而忽略了当前已花费的代价，于是尽管路径变得很长，它仍然继续走下去。结合两者的优点不是更好吗？1968年发明的A算法就是把启发式方法（heuristic approaches）如BFS，和常规方法如Dijsktra算法结合在一起的算法。有点不同的是，类似BFS的启发式方法经常给出一个近似解而不是保证最佳解。然而，尽管A基于无法保证最佳解的启发式方法，A却能保证找到一条最短路径。A: 带有启发式函数的Dijkstra算法*把Dijkstra算法（靠近初始点的结点）和BFS算法（靠近目标点的结点）的信息块结合起来。在A的标准术语中，g(n)表示从初始结点到任意结点n的代价，h(n)表示从结点n到目标点的启发式评估代价（heuristic estimated cost）。当从初始点向目标点移动时，A* 权衡这两者。每次进行主循环时，它检查f(n)最小的结点n，其中f(n) = g(n) + h(n)。累积成本g(n): 从起始状态到节点“n”的累积成本的当前最佳估计启发式函数h(n): 从节点n到目标状态（即目标成本）的预计最小成本从起始状态到通过节点“n”的目标状态的最小预计成本是 f(n) = g(n) + h(n)策略: 扩展具有最便宜的 f(n) = g(n) + h(n) 的节点更新所有未扩展邻居“m”的节点“n”的累积成本 g(m)已经扩展的节点保证具有从起始状态到该节点的最小成本 :::success维护一个优先队列来存储所有待扩展的节点对所有节点预定义启发函数h(n)用起始状态XS初始化优先队列设置g(XS)=0,对图中的其他节点设置g(n)=无穷循环:如果队列为空,返回FALSE并退出循环从队列中取出f(n)=g(n)+h(n)最小的节点“n”将节点“n”标记为已扩展如果节点“n”是目标状态,返回TRUE并退出循环对节点“n”的所有未扩展邻居节点“m”:如果g(m)=无穷g(m)= g(n) + Cnm将节点“m”加入队列如果g(m)&gt;g(n)+Cnmg(m)= g(n) + Cnm结束对邻居节点循环结束主循环 ::: 通过对启发式函数的调节，可以达成控制A* 的行为：一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A* 演变成Dijkstra算法，这保证能找到最短路径。如果h(n)经常都比从n移动到目标的实际代价小（或者相等），则A保证能找到一条最短路径。h(n)越小，A扩展的结点越多，运行就得越慢。如果h(n)精确地等于从n移动到目标的代价，则A 将会仅仅寻找最佳路径而不扩展别的任何结点，这会运行得非常快。尽管这不可能在所有情况下发生，但是你仍可以在一些特殊情况下让它们精确地相等。只要提供完美的信息，A会运行得很完美，认识这一点很好。如果h(n)有时比从n移动到目标的实际代价高，则A* 不能保证找到一条最短路径，但它运行得更快。另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，A* 就演变成了BFS算法。如果目标的引力太低，会得到最短路径，不过速度变慢了；如果目标引力太高，那就放弃了最短路径，但A运行得更快，所以最优路径和最快搜索在复杂情况下需要有一个取舍/平衡。A的这个特性非常有用。例如，你会发现在某些情况下，你希望得到一条好的路径，而不是一条完美的路径，为了权衡g(n)和h(n)，你可以修改任意一个。如果alpha是0，则改进后的代价函数的值总是1。这种情况下，地形代价被完全忽略，A工作变成简单地判断一个网格可否通过。如果alpha是1，则最初的代价函数将起作用，然后你得到了A的所有优点。你可以设置alpha的值为0到1的任意值。可以考虑对启发式函数的返回值做选择：绝对最小代价或者期望最小代价。例如，如果你的地图大部分地形代价为2，其它一些地方是代价为1的道路，那么你可以考虑让启发式函数不考虑道路，而只返回2距离。速度和精确度之间的选择并不是全局固定对。在地图上的某些区域，精确度是重要的，你可以基于此进行动态选择。例如，假设我们可能在某点停止重新计算路径或者改变方向，则在接近当前位置的地方，选择一条好的路径则是更重要的，对于在地图上的一个安全区域，最短路径也许并不十分重要，但是当从一个危险区域脱离对时候，轨迹的精度是最重要的。同样通过对g(n)或者f(n)的调节，也可以达成A具体动作的控制通过加上障碍物cost function到g(n)或者f(n)（这两个动作是一个意思），可以实现规划路径在障碍物中间。通过加上车辆几何或者轨迹kappa平滑度cost function的到g(n)或者f(n)，可以实现规划出来的路径是平滑变化的。通过加上到way point的cost function的到g(n)或者f(n)，规划出来的路径则倾向于走way points的方向。构造精确启发函数的一种方法是预先计算任意一对结点之间最短路径的长度。有几种方法可以近似模拟这种启发函数：1.  【降采样地图-预计算】在密集栅格图的基础上添加一个分辨率更大的稀疏栅格图。预计算稀疏图中任意两个栅格的最短路径。2.  【waypoings-预计算】在密集栅格图上，预计算任意两个way points的的最短路径。通过以上方法，添加一个启发函数h’用于评估从任意位置到达邻近导航点/中继点（waypoints）的代价。最终的启发式函数可以是：h(n) = h'(n, w1) + distance(w1, w2), h'(w2, goal)网格地图中的启发式算法在网格地图中，有一些众所周知的启发式函数计算方法：1.   曼哈顿距离
2.   对角线距离
3.   欧几里得距离
4.   欧几里德距离平方曼哈顿距离标准的启发式函数是曼哈顿距离（Manhattan distance）。考虑代价函数并找到从一个位置移动到邻近位置的最小代价D。因此，h是曼哈顿距离的D倍：``` H(n) = D \  * (abs ( n.x – goal.x ) + abs ( n.y – goal.y ) ) ```对角线距离如果在地图中允许对角运动那么需要考虑对角线距离。（4 east, 4 north）的曼哈顿距离将变成8D。然而，可以简单地移动（4 northeast）代替，所以启发函数应该是4D。这个函数使用对角线，假设直线和对角线的代价都是D：H(n) = D * max(abs(n.x - goal.x), abs(n.y - goal.y))如果对角线运动的代价不是D，但类似于D2 = sqrt(2) * D，则准确的计算方法如下：h_diagonal(n) = min(abs(n.x - goal.x), abs(n.y - goal.y))h_straight(n) = (abs(n.x - goal.x) + abs(n.y - goal.y))H(n) = D2\* h_diagonal(n) + D\* (h_straight(n) - 2\ *h_diagonal(n)))计算h_diagonal(n)：沿着斜线可以移动的步数；h_straight(n)：曼哈顿距离；然后合并这两项，让所有的斜线步都乘以D2，剩下的所有直线步(注意这里是曼哈顿距离的步数减去2倍的斜线步数)都乘以D。欧几里德距离如果单位可以沿着任意角度移动（而不是网格方向），那么应该使用直线距离：``` H(n) = D* sqrt((n.x-goal.x)^2 + (n.y-goal.y)^2) ```然而，如果是这样的话，直接使用A时将会遇到麻烦，因为代价函数g不匹配启发函数h。因为欧几里得距离比曼哈顿距离和对角线距离都短，你仍可以得到最短路径，不过A将运行得更久一些：欧几里德距离平方还有一个方法是，使用距离的平方替代距离，避免进行平方根开方运算，从而减少计算消耗：``` H(n) = D* ((n.x-goal.x)^2 + (n.y-goal.y)^2) ```不过这样做会明显地导致衡量单位的问题。当A计算f(n) = g(n) + h(n)，距离的平方将比g的代价大很多，并且会因为启发式函数评估值过高而停止。对于更长的距离，这样做会靠近g(n)的极端情况而不再计算任何东西，A退化成BFS：启发函数的启发因子导致A搜索低性能的另外一个原因是启发函数的启发因子。当某些路径具有相同的f值的时候，它们都会被探索，比较函数无法打破比较平衡点，尽管我们这时候只需要搜索其中的一条，下图为没有添加启发因子的效果：为了解决这个问题，我们可以为启发函数添加一个较小的启发因子。启发因子对于每个结点必须是确定的唯一的，而且它必须让f值体现区别。因为A将会对f值进行堆排序，让f值不同，意味着只有一个f值会被检测。一种添加启发因子的方式是稍微改变h的衡量单位。如果我们减少衡量单位，那么当我们朝着目标移动的时候f将逐渐增加。很不幸，这意味着A倾向于扩展到靠近初始点的结点，而不是靠近目标的结点。我们可以稍微的微调h的衡量单位（甚至是0.1%），A就会倾向于扩展到靠近目标的结点。``` heuristic  \  \ *= (1.0 + p) ```其中这里的启发因子需要满足p &lt; 移动一步的最小代价 / 期望的最长路径长度。假设你不希望你的路径超过1000步（step），你可以使p = 1 / 1000。添加这个附加值的结果是，A比以前搜索的结点更少了。如下图所示。当存在障碍物时，当然仍要在它们周围寻找路径，但要意识到，当绕过障碍物以后，A搜索的区域非常少：Steven van Dijk的建议是：直接把h放到比较函数中。当f值相等时，比较函数将会通过比较两个节点h的大小实现启发因子的功能，打破比较平衡点。Cris Fuhrman的建议的启发因子是：给每个节点加一个决定性的任意数，例如所在坐标系中位置的hash值最后一种方法类似于frenet坐标系的做法：对比起点到终点的直连线段的投影距离，计算方法入下：dx1 = current.x - goal.x
dy1 = current.y - goal.y
dx2 = start.x - goal.x
dy2 = start.y - goal.y
cross = abs(dx1*dy2 - dx2*dy1)
heuristic += cross*0.001其目的是：计算初始-&gt;目标向量和当前-&gt;目标向量的向量叉乘（cross-product）。当向量偏离方向后，其叉乘将会提供一个较大的启发因子。结果是，这段代码选择的路径稍微倾向于从初始点到目标点的直线。当没有障碍物时，A不仅搜索很少的区域，而且它找到的路径看起来非常棒：跳点搜索Jump Point Search (JPS) 是一种改进的 A_ 算法，它保留了 A_ 算法的主体框架，但在寻找后继节点的操作上进行了优化。在 A 算法中，会将当前节点的所有未访问邻居节点加入 openlist。而 JPS 则使用一些方法将有“价值”的节点加入 openlist。JPS 的核心就是寻找跳点 (Jump Point)，在 JPS 中，就是将跳点加入 openlist。跳点就是路径的转折点。JPS明智地进行探索，因为它总是根据规则向前看。强调了其在搜索过程中的智能性和前瞻性。JPS 算法的基本流程与 A 一致，代价函数 f(n) 仍然表示如下：f(n)=g(n)+h(n)。JPS 算法的优点在于，由于它只扩展跳点，跳点间的栅格被跳过，不加入 OpenList，因此，它的搜索效率比 A 算法提高了一个等级。在实现JPS前先了解它的规则强迫邻居：节点X的邻居节点有障碍物，且X的父节点P经过X到达N的距离代价，比不经过X到达N的任一路径的距离代价都小，则称N是X的强迫邻居。2. 跳点(Jump Point)：什么样的节点可以作为跳点(1)节点 A 是起点、终点.(2)节点A 至少有一个强迫邻居.(3)父节点在斜方向(斜向搜索)，节点A的水平或者垂直方向上有满足 (1)、(2) 的节点在搜索过程中它可以将水平和垂直方向两个分量，分解为一个方向为(1, 0)的水平搜索，一个方向为(0, 1)的垂直搜索同理斜向有四种方向左上 (-1, 1) ——&gt;对应的水平 (-1, 0)，垂直 ( 0, 1)右上 ( 1, 1) ——&gt;对应的水平 ( 1, 0)，垂直 ( 0, 1)右下 ( 1, -1) ——&gt;对应的水平 ( 1, 0)，垂直 ( 0, -1)左下 (-1, -1) ——&gt;对应的水平 (-1, 0)，垂直 ( 0, -1) 如上所说(3)的情形即为如下递归应用直线剪枝规则，并将 y 识别为 x 的跳点后继。这个节点很有趣，因为它有一个邻居 z，除非通过访问 x 然后 y 的路径，否则无法最优地到达。递归应用对角线剪枝规则，并将 y 识别为 x 的跳点后继。在每次对角线步骤之前，我们首先递归直线。只有当两次直线递归都未能识别出跳点时，我们才再次对角线步进。节点 w，x 的强制邻居，正常扩展。（也推入开放列表，优先队列）。记住:你只能直线跳跃或对角线跳跃;不能分段跳跃。:::success维护一个优先队列来存储所有待扩展的节点对所有节点预先定义启发函数h(n)用起始状态XS初始化优先队列设置g(XS)=0,对图中的其他节点设置g(n)=无穷循环:如果队列为空,返回FALSE并退出循环从队列中取出f(n)=g(n)+h(n)最小的节点“n”将节点“n”标记为已扩展如果节点“n”是目标状态,返回TRUE并退出循环对节点“n”的所有未扩展邻居节点“m”:如果g(m)=无穷g(m)= g(n) + Cnm将节点“m”加入队列如果g(m)&gt;g(n)+Cnmg(m)= g(n) + Cnm结束对邻居节点的循环结束主循环 ::: openlist查找具体流程如下²：初始化起点节点 start ，将起点周围四个角落的空闲节点相对于起点的相对位置加入起点节点的 forced_neighbor_list。创建一个 openlist ，将 start 加入 openlist。while openlist is not empty:node ← openlist.Pop ()从 node 开始跳跃，首先进行直线跳跃，再进行对角线跳跃。用 parent 表示从 node 进行对角线跳跃得到的节点，用 current 表示从 parent 进行直线跳跃得到的节点。如果 current 是跳点，而 parent 与 node 是同一个节点，则将 current 加入 openlist，同时将 current 的父节点指向 node；如果 current 是跳点，而 parent 与 node 不是同一个节点，则将 parent 和 current 加入 openlist，同时将 current 的父节点指向 parent，将 parent 的父节点指向 node；如果 current 是障碍物或者边界，则进行对角线跳跃；如果 parent 是障碍物或者边界，则进入下一轮循环。例子：扩展—&gt;对角线移动最终找到一个关键节点,将其加入开放列表。从开放列表中弹出它(唯一的节点)。垂直扩展,在障碍物处结束。水平扩展,遇到一个具有强制邻居的节点。将其添加到开放列表。对角线扩展,扩展后没有发现任何新的节点。完成当前节点的扩展。对角线移动。先沿垂直和水平方向扩展。没有发现任何新的节点。对角线移动。更详细跳点搜索可以参考下面文章： 也致敬这个大佬~小结：本文介绍了motion plan学院派的框架：前端路径规划后端轨迹生成不确定障碍物预估规划并且详细介绍了前端路径规划常用的搜索规划，介绍了搜索规划的一些前置知识：c-space，为了方便物体质点化处理，建图时把物体形状构建转移到图各种不同图如何构建成适合搜索算法的数据格式，以及不同图适合的搜索算法搜索算法的三个基本框架：深度搜索、广度搜索、贪心搜索详细介绍了了几种贪心搜索算法原理和实现思路：Dijkstra算法：A* 搜索跳点搜索并且介绍了：累计成本，启发函数，以及这两个函数的物理意义；如何调控两个参数来实现计算速度和最优路径的平衡。累积成本g(n): 从起始状态到节点“n”的累积成本的当前最佳估计启发式函数h(n): 从节点n到目标状态（即目标成本）的预计最小成本http://www.ppmy.cn/news/1541510.html相关文章【iOS】YYModel目录 什么是YYModel &amp;#xff1f; 
如何使用YYModel &amp;#xff1f; 
最简单的Model 
与网络请求结合 
属性为容器类的Model 
白名单和黑名单 
Model的嵌套 
结语 什么是YYModel &amp;#xff1f; 
YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架&amp;#xff0c;主要用于对象和…阅读更多...Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:22 +0000</pubDate>
    </item>
    <item>
      <title>【iOS】YYModel</title>
      <link>https://www.ppmy.cn/news/1541509.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【iOS】YYModelnews/2025/11/4 0:22:21/目录什么是YYModel ？如何使用YYModel ？最简单的Model与网络请求结合属性为容器类的Model白名单和黑名单Model的嵌套结语什么是YYModel ？YYModel是一个用于 iOS 和 macOS 开发的高性能的模型框架，主要用于对象和 JSON（JavaScript Object Notation）数据之间的转换。主要特点和功能包括：高性能转换：在对象和 JSON 之间进行转换时速度非常快，能高效地处理大量数据。自动映射：可以自动将 JSON 数据中的键值对映射到模型对象的属性上，无需手动编写大量的映射代码。例如，当 JSON 中的一个键与模型对象的属性名相同时，YYModel可以自动将该键对应的值赋值给这个属性。支持复杂数据结构：能够处理包含嵌套对象、数组等复杂数据结构的 JSON 数据，并且可以将这些复杂结构映射到相应的模型对象结构中。类型安全：确保在转换过程中数据类型的正确性，减少因类型不匹配而导致的错误。可扩展性：可以方便地进行扩展和定制，以满足特定的业务需求。使用YYModel可以极大地简化 iOS 和 macOS 应用程序中数据模型的处理，提高开发效率和代码的可维护性。如何使用YYModel ？YYModel的主体工作就是JSON转模型。最简单的Model定义一个模型类，该类的属性要与 JSON 数据中的键相对应。例如这段YYModel原作者github使用文档里的示例：// JSON:
{"uid":123456,"name":"Harry","created":"1965-07-31T00:00:00+0000"
}// Model:
@interface User : NSObject
@property UInt64 uid;
@property NSString *name;
@property NSDate *created;
@end
@implementation User
@end// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:
User *user = [User yy_modelWithJSON:json];// 将 Model 转换为 JSON 对象:
NSDictionary *json = [user yy_modelToJSONObject];这段代码中JSON数据的字典键与Model中属性名一一对应，最下面几行代码则是调用方法实现Json数据到Model的转换和Model到JSON的转换与网络请求结合void dataload {NSString* urlString = @"https://devapi.qweather.com/v7/weather/3d?location=101010100&amp;key=34e1f7a3ef5544d393fcafaea08f0f1b";NSURL* url = [NSURL URLWithString:urlString];NSURLRequest *request = [NSURLRequest requestWithURL:url];NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {if (!error &amp;&amp; data) {NSError *jsonError;NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;jsonError];if (!jsonError &amp;&amp; [jsonDict isKindOfClass:[NSDictionary class]]) {AModel *model = [AModel yy_modelWithDictionary:jsonDict];NSLog(@"%@",model);}} else {NSLog(@"Error: %@", error);}}];[task resume];
}属性为容器类的Model有时JSON数据中的键对应的是一个容器类，这时我们就需要调用YYModel协议中的方法来告诉这个类它里面放的元素应该是什么类型的这个方法就是+ (NSDictionary *)modelContainerPropertyGenericClass在方法中，我们直接返回元素的类型。{"code": "200","updateTime": "2024-10-20T16:18+08:00","fxLink": "https://www.qweather.com/weather/beijing-101010100.html","daily": [{"fxDate": "2024-10-20","sunrise": "06:31","sunset": "17:29","moonrise": "19:01","moonset": "09:48","moonPhase": "亏凸月","moonPhaseIcon": "805","tempMax": "12","tempMin": "1","iconDay": "305","textDay": "小雨","iconNight": "151","textNight": "多云","wind360Day": "180","windDirDay": "南风","windScaleDay": "1-3","windSpeedDay": "3","wind360Night": "180","windDirNight": "南风","windScaleNight": "1-3","windSpeedNight": "3","humidity": "58","precip": "1.0","pressure": "1016","vis": "25","cloud": "55","uvIndex": "2"},{"fxDate": "2024-10-21","sunrise": "06:32","sunset": "17:28","moonrise": "19:51","moonset": "11:02","moonPhase": "亏凸月","moonPhaseIcon": "805","tempMax": "14","tempMin": "6","iconDay": "101","textDay": "多云","iconNight": "305","textNight": "小雨","wind360Day": "225","windDirDay": "西南风","windScaleDay": "1-3","windSpeedDay": "3","wind360Night": "0","windDirNight": "北风","windScaleNight": "1-3","windSpeedNight": "16","humidity": "48","precip": "0.0","pressure": "1017","vis": "25","cloud": "25","uvIndex": "4"},{"fxDate": "2024-10-22","sunrise": "06:33","sunset": "17:26","moonrise": "20:49","moonset": "12:07","moonPhase": "亏凸月","moonPhaseIcon": "805","tempMax": "16","tempMin": "4","iconDay": "101","textDay": "多云","iconNight": "150","textNight": "晴","wind360Day": "0","windDirDay": "北风","windScaleDay": "1-3","windSpeedDay": "16","wind360Night": "270","windDirNight": "西风","windScaleNight": "1-3","windSpeedNight": "3","humidity": "44","precip": "0.0","pressure": "1014","vis": "24","cloud": "25","uvIndex": "2"}],"refer": {"sources": ["QWeather"],"license": ["CC BY-SA 4.0"]}
}比如这段JSON数据，daily对应的属性是一个数组，而这个数组中包含三个字典，这三个字典其实可以转化成同一种model，因此我们就需要调用方法来告诉model，daily数组中所存放的元素是一个model。注意，在声明 + (NSDictionary *)modelContainerPropertyGenericClass这个方法时，要让该类遵守YYModel协议。然后我们在方法中返回元素的类型+ (NSDictionary *)modelContainerPropertyGenericClass {return @{@"daily":[dailyModel class]};
}在model中 实现这个方法，我们使用一个字典，将daily对应的键值设置为我们要设置的dailyModel属性，这里的dailyModel也就是数组中所存放元素的类型。白名单和黑名单关于黑名单和白名单，其实就是通过两个方法来屏蔽和选中一些属性，让model不要处理或者只处理某些属性。白名单是一个指定的属性列表，只有在这个列表中的属性会被YYModel在映射过程中处理。这意味着当从 JSON 数据转换为模型对象或者从模型对象转换为 JSON 数据时，只有白名单中的属性会被考虑。黑名单与白名单相反，是一个指定的属性列表，这些属性在映射过程中会被YYModel忽略。+ (NSArray&lt;NSString *&gt; *)modelPropertyWhitelist {return @[@"name", @"age"];}
+ (NSArray&lt;NSString *&gt; *)modelPropertyBlacklist {return @[@"secretInfo"];}Model的嵌套关于model的嵌套，其实就是将model的属性设为另一个model，model其实是NSObject的子类，所以不需要多加处理，直接设为属性即可结语关于YYModel，其实还有一些Model和字典之间的转换，以及匹配不到字典对应键时的处理，这些东西之后会再完善。http://www.ppmy.cn/news/1541509.html相关文章Redis的Bin目录文件及常用命令Redis的Bin目录文件 全局命令Redis键/KeyRedis字符串&amp;#xff08;String&amp;#xff09;Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图&amp;#xff08;Bitmap&amp;#xff09;Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编…阅读更多...什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:21 +0000</pubDate>
    </item>
    <item>
      <title>Redis的Bin目录文件及常用命令</title>
      <link>https://www.ppmy.cn/news/1541508.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Redis的Bin目录文件及常用命令news/2025/11/4 0:22:20/Redis的Bin目录文件全局命令Redis键/KeyRedis字符串（String）Redis 哈希(Hash)Redis 列表(List)Redis 集合(Set)Redis 有序集合(sorted set)Redis的位图（Bitmap）Redis HyperLogLogRedis GEOGeoHash编码方式Base32编码标准Base32编码GeoHash的Base32编码可执行文件作用redis-server启动Redisredis-cliredis命令行客户端redis-benchmark基准测试工具redis-check-aofAOF持久化文件检测和修复工具redis-check-rdbRDB持久化文件检测和修复工具redis-sentinel启动哨兵全局命令&gt;redis-cli&gt;ping&gt;dbsize# 显示redis中key的数量&gt;info statsredis的key命名格式：业务名:对象名:id:[属性]Redis常用数据类型：String、Hash、list、set、zset、HyperLogLog、GEORedis键/Key&gt;del key# 删除key&gt;dump key# 序列化指定key，并返回被序列化的值# 示例：&gt;setk1 hello
OK&gt;dump k1"\x00\x05hello\x0b\x00\n\xadb\x05\x98\xab\xc9\x83"&gt;exists key# 检查指定key是否存在&gt;expire key seconds# 给指定key设置过期时间，单位：秒&gt;expireat key timestamp# 以UNIX时间戳格式(秒)设置key的过期时间&gt;pexpire key milliseconds# 给指定key设置过期时间，单位：毫秒&gt;pexpireat key milliseconds-timestamp# 以UNIX时间戳格式（毫秒）设置key的过期时间&gt;keys pattern# 查找所有符合给定正则的key# 示例：&gt;key *# 查看所有key&gt;key a*# 查看a开头的所有key&gt;move key db# 将当前数据库的key移动到指定数据库db中&gt;persist key# 移除key的过期时间&gt;pttl key# 查看key的剩余过期时间，单位：毫秒&gt;ttl key# 查看key的剩余过期时间(TTL, time to live)，单位：秒&gt;randomkey# 随机返回一个key&gt;renamekey newkey# 修改key的名称为newkey&gt;renamenx key newkey# 修改key的名称为newkey，仅当newkey不存在时&gt;scan cursor[match pattern][count count]# 迭代数据库中的键# 示例：&gt;scan0&gt;typekey# 返回key储存的值类型Redis字符串（String）&gt;setkey value# 设置指定key的值为value&gt;get key# 获取指定key的值&gt;getset key value# 将给定key的值设置为value，并返回旧值&gt;getbit key offset# 获取指定偏移量上的位&gt;setbit key offset value# 设置或清除指定偏移量上的位&gt;setrange key offset value# 用value更新key储存的字符串值，从偏移量offset开始&gt;getrange key start end# 获取key中字符串值的子字符串&gt;mset key value[key value...]# 同时设置一个或多个key-value对&gt;mget key1[key2...]# 获取所有给定key（一个或多个）的值。&gt;msetnx key value[key value...]# 同时设置一个或多个key-value对，当且仅当所有给定key都不存在时。&gt;psetex key milliseconds value# 设置key的值为value，并将过期时间设置为milliseconds，单位：毫秒&gt;setex key seconds value# 设置key的值为value，并将过期时间设置为seconds，单位：秒&gt;setnx key value# 在key不存在时设置key的值为value&gt;strlen key# 返回key储存的字符串长度&gt;append key value# 如果key存在且它是一个字符串，将指定的 value 追加到该 key 原来值的末尾&gt;incr key# 将 key 中储存的数字值增一；如果key不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作&gt;decr key# 将key中储存的数字值减一&gt;incrby key increment# 将key中储存的数字值增加指定增量increment&gt;decrby key decrement# 将key中储存的数字值减少指定减量decrement&gt;incrbyfloat key increment# 将key中储存的数字值增加指定浮点增量incrementRedis 哈希(Hash)Redis hash 是一个 string 类型的 field和 value的映射表，hash 特别适合用于存储对象。每个 hash 可以存储2 32 − 1 2^{32} - 1232−1键值对（40多亿）。&gt;hmset key field value[field value...]# 设置哈希表中一个或多个field-value&gt;hmget key field[field...]# 获取所有字段的值&gt;hset key field value# 将哈希表key中的字段field值设为value&gt;hsetnx key field value# 在字段field不存在时，将哈希表key中的字段field值设为value&gt;hkeys key# 获取哈希表中所有字段&gt;hvals key# 获取哈希表中所有值&gt;hlen key# 获取哈希表中字段的数量&gt;hexists key field# 查看哈希表中指定的字段是否存在&gt;hdel key field1[field2...]# 删除哈希表的一个或多个字段&gt;hget key field# 获取哈希表中指定字段的值&gt;hgetall key# 获取哈希表中指定key的所有字段和值&gt;hincrby key field increment# 把哈希表key中指定字段的数值加上整数增量increment&gt;hincrbyfloat key field increment# 把哈希表key中指定字段的数值加上浮点增量increment&gt;hscan key cursor[match pattern][count count]# 迭代哈希表中的键值对Redis 列表(List)Redis列表是简单的字符串列表，按照插入顺序排序。可以添加元素到列表的头部或尾部。一个列表最多可以包含2 3 2 − 1 2^32 - 1232−1个元素（4294967295）。&gt;lpush key value[value...]# 将一个或多个值插入到列表头部&gt;lpushx key value# 将一个值插入到已存在的列表头部&gt;lpop key# 移出并获取列表的第一个元素&gt;rpush key value[value...]# 将一个或多个值插入到列表尾部&gt;rpushx key value# 将一个值插入到已存在的列表尾部&gt;rpop key# 移除并获取列表的最后一个元素&gt;blpop key[key...]timeout# 移出并获取列表的第一个元素，如果列表没元素会阻塞列表直到等待超时或发现可弹出元素为止。&gt;brpop key[key...]timeout# 移出并获取列表的最后一个元素，如果列表没元素会阻塞列表直到等待超时或发现可弹出元素为止。&gt;brpoplpushsourcedestinationtimeout# 从列表移出最后一个元素，并将它插入到另外一个列表中；如果列表没元素会阻塞列表直到等待超时或发现可弹出元素为止。&gt;rpoplpushsourcedestination# 移除列表最后一个元素，并将该元素添加到另一个列表并返回&gt;lindex key index# 通过索引获取列表中的元素&gt;linsert key before|after pivot value# 在列表的元素前或后插入元素&gt;llen key# 获取列表长度&gt;lrange key start stop# 获取列表指定范围内的元素# 示例：&gt;lrange key10-1# -1表示所有&gt;lrem key count value# 移除列表元素&gt;lset key index value# 通过索引设置列表元素的值&gt;ltrim key start stop# 对列表进行修剪，只保留指定区间内的元素，删除其他元素Redis 集合(Set)Redis的Set是String类型的无序集合。Set集合是通过哈希表实现的，添加、删除、查找的复杂度都是O(1)，最大成员数是2 32 − 1 2^{32} - 1232−1。&gt;sadd key member[member...]# 向集合中添加一个或多个成员&gt;scard key# 获取集合的成员数&gt;sdiffkey[key...]# 返回第一个集合与其他集合之间的差异&gt;sdiffstore destination key[key...]# 返回给定集合的差集并存储在目的集合中&gt;sinter key[key...]# 返回给定集合的交集&gt;sinterstore destination key[key...]# 返回给定集合的交集并存储在目的集合中&gt;sismember key member# 判断member元素是否是集合key的成员&gt;smembers key# 获取集合中的所有成员&gt;smovesourcedestination member# 将member元素从源集合移动到目的集合&gt;spop key# 移除并返回集合中的一个随机元素&gt;srandmember key[count]# 返回集合中一个或多个随机元素&gt;srem key member[member...]# 移除集合中的一个或多个元素&gt;sunion key[key...]# 获取给定集合的并集&gt;sunionstore destination key[key...]# 获取给定集合的并集并存储在destination集合中&gt;sscan key cursor[match pattern][count count]# 迭代集合中的元素Redis 有序集合(sorted set)Redis有序集合和集合一样也是String类型元素的集合，且不允许重复的成员。区别是每个元素都会关联一个double类型的分数，而且通过分数来为成员进行从小到大的排序。集合的成员是唯一的，但分数是可以重复的。&gt;zadd key score member[score member...]# 向有序集合添加一个或多个成员，或更新已存在成员的分数&gt;zcard key# 获取有序集合的成员数&gt;zcount key min max# 计算有序集合中指定区间分数的成员数&gt;zincrby key increment member# 有序集合中对指定成员的分数增加增量increment&gt;zinterstore destination numkeys key[key...]# 计算给定的一个或多个有序集合的交集，并将结果存储在新的有序集合中&gt;zlexcount key min max# 计算有序集合中指定字典区间内成员数量&gt;zrange key start stop[withscores]# 通过索引区间返回有序集合指定区间内的成员# 示例：&gt;zrangebyscore z126withscores&gt;zrangebyscore z1 -inf +inf withscores&gt;zrangebylex key min max[limit offset count]# 通过字典区间返回有序集合的成员&gt;zrangebyscore key min max[withscores][limit]# 通过分数返回有序集合指定区间内的成员&gt;zrank key member# 返回有序集合中指定成员的索引&gt;zrem key member[member...]# 移除有序集合中的一个或多个成员&gt;zremrangebylex key min max# 移除有序集合中给定的字典区间的所有成员&gt;zremrangebyrank key start stop# 移除有序集合中给定的排名区间的所有成员&gt;zremrangebyscore key min max# 移除有序集合中给定的分数区间的所有成员&gt;zrevrange key start stop[withscores]# 返回有序集合中指定区间内的成员，通过索引，分数从高到低&gt;zrevrangebyscore key max min[withscores]# 返回有序集合中指定分数区间内的成员，分数从高到低排序&gt;zrevrank key member# 查询有序集合中指定成员的排名，有序集合成员按分数值递减排序&gt;zscore key member# 查询有序集合中指定成员的分数值&gt;zunionstore destination numkeys key[key...]# 计算给定的一个或多个有序集合的并集，并存储在新的key中&gt;zscan key cursor[match pattern][count count]# 迭代有序集合中的元素Redis的位图（Bitmap）Bitmap是一种特殊的字符串数据类型，它利用字符串类型键来存储一系列连续的二进制位（bits），每个位可以独立地表示一个布尔值（0或1）。非常适合用于存储和操作大量二值状态的数据，尤其在需要高效空间利用率和特定位操作场景中表现出色。&gt;setbit key offset value# 设置或清除指定偏移量上的位值&gt;getbit key offset# 返回指定偏移量上的位值&gt;bitcount key[start end]# 计算键指定范围内为1的位的数量&gt;bitop operation destkey key[key...]# 对一个或多个键执行位操作，并将结果保存到destkey。支持的操作包括AND/OR/XOR/NOT&gt;bitpos key bit[start][end]# 查找指定键内第一个值为bit的位的偏移量Redis HyperLogLogRedis HyperLogLog是用来做基数统计的算法，它的优点是在输入元素的数量或体积非常大时，计算基数所需要的空间总是固定的、并且是很小的。HyperLogLog提供不精确的去重计数方案，虽然不精确但也不是非常不精确，其标准误差是0.81%。常用于统计大型网站每个网页每天的UV数据（独立访客，Unique Visitor）。什么是基数：比如数据集{1, 3, 5, 5, 7, 7, 8}的基数集为{1, 3, 5, 7, 8}，基数（不重复元素个数）为5。基数估计就是在误差可接受的范围内，快速计算基数。&gt;pfadd key element[element...]# 添加指定元素到HyperLogLog中&gt;pfcount key[key...]# 返回给定HyperLogLog的基数估算值&gt;pfmerge destkey sourcekey[sourcekey...]# 将多个HyperLogLog合并为一个HyperLogLog基于概率论中伯努利试验并结合了极大似然估算方法，并做了分桶优化。Redis GEORedis GEO主要用于存储地理位置信息，并对存储的信息进行操作。&gt;help@geo# 查看GEO相关的命令&gt;geoadd key longitude latitude member[longitude latitude member...]# 添加地址位置到GEO中# 示例：&gt;geoadd city116.2839.54beijing117.1039.10tianjin114.2638.03sjz118.0939.37tangshan&gt;geopos key member[member...]# 获取地理位置的坐标# 示例：&gt;geopos city beijing tianjin&gt;geodist key member1 member2[M|KM]# 计算两个位置之间的距离# 示例：&gt;geodist city beijing tianjin KM&gt;georadius# 根据给定的坐标获取指定范围内的位置集合# 示例：&gt;georadius city11040500KM&gt;georadiusbymember key member radius unit# 根据存储在位置集合中的某个位置获取指定范围内的位置集合# 示例：&gt;georadiusbymember city beijing100KM WITHDIST&gt;geohash key member# 返回一个或多个位置对象的geohashGeoHash编码方式经度范围是东经180度到西经180度，纬度范围是南纬90度到北纬90度。假设西经为负，东经为正，南纬为负，北纬为正，即[-180, 180]，[-90, 90]。如果以本初子午线、赤道为界，地球可以分成四个部分。上述操作其实是把经度、纬度做一次二分操作，如果做两次二分操作，结果如下：实际应用中，可以继续做二分操作，通常二分操作的次数记为N，它是可以自定义的。这相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区。每个方格覆盖了一定范围内的经纬度值，分区越多，每个方格能覆盖到的地理空间就越小，也就越精准。这个方法的基本原理就是“二分区间，区间编码”。下面，以北京坐标(116.28, 39.54)进行五次分区来阐述算法具体的实现：经度116.28分区过程：分区次数左分区右分区经度116.28所在的分区编码1[-180,0)[0,180][0,180]12[0,90)[90,180][90,180]13[90,135)[135,180][90,135)04[90,112.5)[112.5,135)[112.5,135)15[112.5,123.75)[123.75,135)[112.5,123.75)0经度116.28编码为：11010纬度39.54分区过程：分区次数左分区右分区纬度39.54所在的分区编码1[-90,0)[0,90][0,90]12[0,45)[45,90][0,45)03[0,22.5)[22.5,45)[22.5,45)14[22.5,33.75)[33.75,45)[33.75,45)15[33.75,39.375)[39.375,45)[39.375,45)1纬度39.54编码为：10111合并编码是把上述经度编码、纬度编码依次合并而来，如下：序号0123456789经度编码11010纬度编码10111合并编码1110011101经过上述过程，我们算出了GeoHash合并经度、纬度的编码值1110011101，然后使用Base32算法进行编码即可。编码过程是将每5位一组，进行转化。5位二进制刚好就是0-31。由1110011101进行base32编码即可得到结果wx，这就是geohash值。Base32编码标准Base32编码标准Base32编码起源于1987年，它采用5位二进制数表示一个字符，共有32个字符，包括26个字母A-Z和6个数字2-7。索引0123456789101112131415字符ABCDEFGHIJKLMNOP索引16171819202122232425262728293031字符QRSTUVWXYZ234567GeoHash的Base32编码GEO功能中使用的Base32编码与标准Base32编码有所不同。它使用了一个自定义的Base32编码，包括10个数字和22个字母（a-z，去掉a/i/l/o）。它在标准Base32编码的基础上做了一些修改，主要是为了避免混淆，提高编码值的可读性。数字 0 和字母 O：数字 0 和字母 O 容易混淆。数字 1 和字母 i、字母L：数字 1 和字母 i 、字母L容易混淆。数字 8 和字母 B：数字 8 和字母 B 容易混淆。数字 9 和字母 S：数字 9 和字母 S 也容易混淆。索引0123456789101112131415字符0123456789bcdefg索引16171819202122232425262728293031字符hjkmnpqrstuvwxyzhttp://www.ppmy.cn/news/1541508.html相关文章什么是凸二次规划问题我们从凸二次规划的基本概念出发&amp;#xff0c;然后解释它与支持向量机的关系。 
一、凸二次规划问题的详细介绍 
凸二次规划问题是优化问题的一类&amp;#xff0c;目标是最小化一个凸的二次函数&amp;#xff0c;受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题&amp;#xff0c;其…阅读更多...【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:20 +0000</pubDate>
    </item>
    <item>
      <title>什么是凸二次规划问题</title>
      <link>https://www.ppmy.cn/news/1541507.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维什么是凸二次规划问题news/2025/11/4 0:22:19/我们从凸二次规划的基本概念出发，然后解释它与支持向量机的关系。一、凸二次规划问题的详细介绍凸二次规划问题是优化问题的一类，目标是最小化一个凸的二次函数，受一组线性约束的限制。凸二次规划是一类特殊的二次规划问题，其中目标函数是凸的。凸函数意味着在函数的任何两点之间，函数的值总是在这两点连接的线段之下，这保证了有唯一的全局最优解。凸二次规划问题的通用形式min ⁡ 1 2 x T Q x + c T x \min \quad \frac{1}{2} \mathbf{x}^T Q \mathbf{x} + \mathbf{c}^T \mathbf{x}min21​xTQx+cTx其中：x \mathbf{x}x是决策变量向量，需要优化的目标。Q QQ是对称的正定矩阵，定义了二次项。如果Q QQ是正定的（即y T Q y &gt; 0 \mathbf{y}^T Q \mathbf{y} &gt; 0yTQy&gt;0对于任何y ≠ 0 \mathbf{y} \neq 0y=0），则优化问题是凸的。c \mathbf{c}c是线性项的系数向量。目标是最小化上述二次函数。线性约束除了目标函数外，凸二次规划问题还受到一些线性约束的限制。约束条件通常可以有两类：不等式约束：A x ≤ b A \mathbf{x} \leq \mathbf{b}Ax≤b其中A AA是矩阵，b \mathbf{b}b是约束向量，约束条件要求某些线性组合不能超过某个值。等式约束：E x = d E \mathbf{x} = \mathbf{d}Ex=d其中E EE是矩阵，d \mathbf{d}d是约束向量，表示某些线性组合必须等于某个值。解决凸二次规划问题的目标是找到最优的x \mathbf{x}x，使得目标函数值最小化，并满足这些约束条件。二、凸二次规划在支持向量机中的应用SVM 中的目标：最大化间隔支持向量机的核心思想是找到一个最佳的分类超平面，使得不同类别的数据点被最大间隔地分开。我们希望找到这样的超平面：w T x + b = 0 \mathbf{w}^T \mathbf{x} + b = 0wTx+b=0其中w \mathbf{w}w是法向量，b bb是偏置项。在SVM中，我们要最大化分类间隔，即最小化超平面法向量w \mathbf{w}w的范数∥ w ∥ 2 \|\mathbf{w}\|^2∥w∥2。这个过程可以转化为一个优化问题。软间隔支持向量机的目标函数在软间隔 SVM 中，我们允许一些数据点有一定的误分类，但同时我们会引入“松弛变量”ξ i \xi_iξi​来表示每个样本的误分类程度。目标函数变成了：min ⁡ 1 2 ∥ w ∥ 2 + C ∑ i = 1 n ξ i \min \quad \frac{1}{2} \|\mathbf{w}\|^2 + C \sum_{i=1}^{n} \xi_imin21​∥w∥2+Ci=1∑n​ξi​其中：第一项1 2 ∥ w ∥ 2 \frac{1}{2} \|\mathbf{w}\|^221​∥w∥2是希望最小化法向量的长度，从而最大化分类的间隔。第二项C ∑ i = 1 n ξ i C \sum_{i=1}^{n} \xi_iC∑i=1n​ξi​是用于控制误分类点的惩罚。C CC是一个正则化参数，平衡间隔最大化和误分类惩罚之间的权重。约束条件SVM 的分类结果还必须满足线性可分性约束（允许误差的情况下是软约束）：y i ( w T x i + b ) ≥ 1 − ξ i , ∀ i = 1 , 2 , … , n y_i (\mathbf{w}^T \mathbf{x}_i + b) \geq 1 - \xi_i, \quad \forall i = 1, 2, \ldots, nyi​(wTxi​+b)≥1−ξi​,∀i=1,2,…,nξ i ≥ 0 , ∀ i \xi_i \geq 0, \quad \forall iξi​≥0,∀i这意味着每个数据点x i \mathbf{x}_ixi​的分类结果要满足其真实类别标签y i y_iyi​（为1或-1）所期望的约束，允许误差由ξ i \xi_iξi​控制。二次规划形式现在，我们可以看到 SVM 的优化问题已经转化为一个标准的凸二次规划问题：min ⁡ 1 2 w T w + C ∑ i = 1 n ξ i \min \quad \frac{1}{2} \mathbf{w}^T \mathbf{w} + C \sum_{i=1}^{n} \xi_imin21​wTw+Ci=1∑n​ξi​subject to y i ( w T x i + b ) ≥ 1 − ξ i \text{subject to} \quad y_i (\mathbf{w}^T \mathbf{x}_i + b) \geq 1 - \xi_isubject toyi​(wTxi​+b)≥1−ξi​ξ i ≥ 0 , ∀ i \xi_i \geq 0, \quad \forall iξi​≥0,∀i这里，目标函数有一个凸的二次项（1 2 w T w \frac{1}{2} \mathbf{w}^T \mathbf{w}21​wTw），同时伴随着一组线性约束，因此这是一个典型的凸二次规划问题。三、求解凸二次规划问题求解凸二次规划问题可以使用各种算法，包括：拉格朗日乘子法：用于处理带有约束的优化问题。在 SVM 中，通过引入拉格朗日乘子，我们可以将原问题转化为其对偶问题，通过求解对偶问题来获得最优解。内点法：是一类求解凸规划问题的高效算法。序列最小优化算法（SMO）：专门用于求解 SVM 中的二次规划问题，通过分解问题为多个较小的子问题来逐步优化。在 SVM 中，拉格朗日对偶形式被广泛使用，它将原始问题的复杂度降低，使得问题可以更高效地求解。总结凸二次规划问题是指最小化一个二次函数（目标函数是凸的），受一组线性约束限制的优化问题。**支持向量机（SVM）**的目标是找到一个最大化分类间隔的超平面，这个问题可以通过凸二次规划的形式来解决。二次项对应于优化超平面法向量的长度，而线性约束则确保数据点的分类结果符合要求。http://www.ppmy.cn/news/1541507.html相关文章【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】文章目录 实例详解 fdisk -l第一部分&amp;#xff1a;磁盘 /dev/sda详细解释&amp;#xff1a; 第二部分&amp;#xff1a;环回设备 /dev/loop8详细解释&amp;#xff1a; 总结 实例详解 fdisk -l 
在 Linux 系统中执行 fdisk -l 命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每…阅读更多...嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:20 +0000</pubDate>
    </item>
    <item>
      <title>【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】</title>
      <link>https://www.ppmy.cn/news/1541506.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【存储设备专栏 2.2 -- linux 下 fdisk -l 命令详细介绍2 】news/2025/11/4 0:22:19/文章目录实例详解 fdisk -l第一部分：磁盘 `/dev/sda`详细解释：第二部分：环回设备 `/dev/loop8`详细解释：总结实例详解 fdisk -l在 Linux 系统中执行fdisk -l命令会输出详细的磁盘和分区信息。下面我们具体解释一下下面的log每一行输出的含义。Disk/dev/sda: 500 GB,500107862016 bytes,976773168 sectors 
Disk model: Lenovo X800 SATA
Units = sectors of 1*512 = 512 bytes 
Sector size(logical/physical): 512 bytes/512 bytes 
I/O size(minimum/optimal): 512 bytes/512 bytes 
Disk labeltype: dos 
Disk identifier: 0xa03e4da1Disk/dev/loop8: 349.7 MiB,366682112 bytes,716176 sectors
Units: sectors of 1*512 = 512 bytes
Sector size(logical/physical): 512 bytes/512 bytes
I/O size(minimum/optimal): 512 bytes/512 bytes第一部分：磁盘/dev/sdaDisk /dev/sda: 500 GB, 500107862016 bytes, 976773168 sectors
Disk model: Lenovo X800 SATA
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xa03e4da1详细解释：Disk /dev/sda: 500 GB, 500107862016 bytes, 976773168 sectors/dev/sda: 指定设备文件，代表第一个 SCSI/SATA 磁盘。500 GB: 磁盘的总容量。500107862016 bytes: 磁盘的总字节数。976773168 sectors: 磁盘的总扇区数。Disk model: Lenovo X800 SATA磁盘型号和接口类型信息，表明这是一个 Lenovo X800 型号的 SATA 磁盘。Units = sectors of 1 * 512 = 512 bytes扇区单位的定义，每个扇区包含 512 字节。Sector size (logical/physical): 512 bytes / 512 byteslogical: 逻辑扇区大小，即操作系统看到的扇区大小。physical: 物理扇区大小，磁盘实际存储的扇区大小。在现代磁盘中，这两个大小通常是相同的。I/O size (minimum/optimal): 512 bytes / 512 bytesminimum: 最小 I/O 大小，通常与扇区大小相同。optimal: 最优 I/O 大小，在进行读写操作时可以获得最佳性能的块大小。Disk label type: dos磁盘分区表类型，dos表示使用传统的 MBR (Master Boot Record) 分区表。Disk identifier: 0xa03e4da1磁盘标识符，一个唯一的标识符用于识别该磁盘。第二部分：环回设备/dev/loop8Disk /dev/loop8: 349.7 MiB, 366682112 bytes, 716176 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes详细解释：Disk /dev/loop8: 349.7 MiB, 366682112 bytes, 716176 sectors/dev/loop8: 指定设备文件，这里是一个环回设备（loop device），通常用于挂载光盘映像或其他文件系统映像。349.7 MiB: 环回设备的总容量，使用 Mebibyte 单位。366682112 bytes: 环回设备的总字节数。716176 sectors: 环回设备的总扇区数。Units: sectors of 1 * 512 = 512 bytes扇区单位的定义，每个扇区包含 512 字节。Sector size (logical/physical): 512 bytes / 512 bytes逻辑和物理扇区大小，和上面的磁盘输出类似。I/O size (minimum/optimal): 512 bytes / 512 bytes最小和最优 I/O 大小，与上面的磁盘输出类似。总结fdisk -l命令为每个磁盘和分区提供了详细的信息，帮助用户了解系统中的存储设备配置。这些信息对于系统管理和故障排查非常有用，特别是在配置和管理多种存储设备时。http://www.ppmy.cn/news/1541506.html相关文章嵌套div导致子区域margin失效问题解决嵌套div导致子区域margin失效问题解决 现象原因解决方法 现象 
&lt;div class"prev"&gt;&lt;/div&gt;
&lt;div class"parent"&gt;&lt;div class"child"&gt;&lt;/div&gt;&lt;div class"child"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div cl…阅读更多...数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:19 +0000</pubDate>
    </item>
    <item>
      <title>嵌套div导致子区域margin失效问题解决</title>
      <link>https://www.ppmy.cn/news/1541505.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维嵌套div导致子区域margin失效问题解决news/2025/11/4 0:22:18/嵌套div导致子区域margin失效问题解决现象原因解决方法现象&lt;divclass="prev"&gt;&lt;/div&gt;&lt;divclass="parent"&gt;&lt;divclass="child"&gt;&lt;/div&gt;&lt;divclass="child"&gt;&lt;/div&gt;&lt;/div&gt;&lt;divclass="next"&gt;&lt;/div&gt;.prev{width:300px;height:50px;background-color:red;}.parent{width:300px;height:300px;background-color:aqua;}.child{width:100px;height:100px;background-color:blueviolet;margin-top:10px;}.next{width:300px;height:50px;background-color:red;}原因给子元素child设置的margin-top: 10px;没有作用在子元素和父元素之间产生间距，而是作用在了父元素及其相邻元素之间产生了间距，原因是两个嵌套的div，如果外层div的padding值为0，那么内层div的margin-top或margin-bottom的值会“转移”给外层div。解决方法给父元素parent加样式overflow: hidden给父元素parent添加值大于0的padding-top样式给父元素parent添加样式position: absolutehttp://www.ppmy.cn/news/1541505.html相关文章数字孪生城市：智慧城市的未来蓝图在当今数字化时代&amp;#xff0c;智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向&amp;#xff0c;数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术&amp;#xff0c;通过网络空间与物理世界之间的实时数据交换和仿真分…阅读更多...重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:18 +0000</pubDate>
    </item>
    <item>
      <title>数字孪生城市：智慧城市的未来蓝图</title>
      <link>https://www.ppmy.cn/news/1541504.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维数字孪生城市：智慧城市的未来蓝图news/2025/11/4 0:22:17/在当今数字化时代，智能技术的广泛应用正在改变人们的生活和工作方式。数字孪生城市作为未来新型智慧城市演进的重要方向，数字孪生城市是一种将城市物理世界的各个方面转化为数字形式的技术，通过网络空间与物理世界之间的实时数据交换和仿真分析，实现对城市运行状态的全面监控、预测和优化。一、引擎技术智慧城市数字孪生操作系统的引擎技术主要依赖于大数据、云计算、物联网和人工智能等先进技术手段。这些技术为构建与物理世界高度一致的虚拟映射提供了可能，使得数字孪生技术成为城市规划和基础设施建设的智慧引擎。1.数据整合与分析：通过高精度传感器、无人机航拍、卫星遥感等多种手段，收集城市空间、交通流量、环境质量等多维度、多尺度的数据。利用大数据和云计算技术，对这些数据进行整合和分析，为规划者提供全面、细致的信息支撑。2.模拟分析：通过建立城市或基础设施的数字模型，模拟不同规划方案或运行条件下的城市形态、交通状况、环境质量等。这些模拟结果可以帮助规划者预见可能出现的问题，并为优化方案提供科学依据。3.预测能力：通过对历史数据的分析和学习，数字孪生技术可以预测城市发展趋势、交通流量变化、环境质量演变等，为决策者提供前瞻性信息，以便提前采取应对措施。二、行业应用智慧城市数字孪生操作系统在多个行业领域有着广泛的应用，包括但不限于以下几个方面：城市规划与建设：通过对城市进行三维建模，可以更加直观地展示城市规划方案，并在虚拟环境中模拟城市建设过程，预测可能出现的问题，从而优化规划方案，降低建设风险。此外，还可以对城市的交通、环境、能源等基础设施进行模拟和优化，提高城市运行效率。1.智慧园区：建设安全、便捷、节能、舒适的新型智慧园区，实现园区与产业发展、城市管理的高度融合。2.智慧文旅：构建智慧文旅核心能力体系，整合文旅信息资源和联通大数据能力，满足文旅管理机构、游客、文旅企业等不同主体的多样化需求。3.应急管理：打造应急综合管理平台，对城市进行综合感知，精确、实时掌握各类风险动态，提供贯穿“事前一事中一事后”全流程的应急一体化服务。4.工业互联网：聚焦工业全场景智能，利用5G和光网作为神经系统，通过终端、边缘和中心云平台的分布式智能协同，实现工业全场景数据感知智能、连接控制智能和分析决策智能。5.智慧医疗：面向医院、卫健、医保等市场，打造区域健康医疗大数据平台、医疗资源数据可视化平台等大数据应用，以及5G远程超声、远程会诊、VR示教等5G远程协同应用。三、数字孪生在智慧城市建设中的作用1、精准模拟与预测数字孪生技术通过实时采集和处理城市运行数据，构建城市各个系统的数字模型。这些模型不仅精确地反映了城市的实时状态，而且能够预测未来的发展趋势。这为城市管理者和规划者提供了宝贵的决策依据，助力城市实现可持续发展。2、优化资源配置数字孪生技术通过对城市运行数据的分析，能够精准地识别出城市资源的需求和分布情况。这有助于优化资源配置，提高资源利用效率，减少浪费，降低能耗，实现城市的绿色发展。3、提高应急响应能力借助数字孪生技术，城市管理者可以实时监控城市的运行状态，及时发现潜在的安全隐患。一旦发生紧急情况，管理者可以迅速调动资源，制定有效的应急响应方案，降低灾害损失，保障市民的生命财产安全。随着信息技术进步、城市数字化转型需求提升以及政策的持续加持，数字孪生技术将改变城市生活，为我们带来崭新体验。http://www.ppmy.cn/news/1541504.html相关文章重构手法整理提示&amp;#xff1a;文章 文章目录 文章目录 文章目录 前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c实现 三、3.1 总结 前言 
前期疑问&amp;#xff1a; 本文目标&amp;#xff1a; 一、背景 
最近 
二、重构手法 
2.1 以委托取代继承 
以委托取代继承是指我们常常为了一时的便利而…阅读更多...【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:17 +0000</pubDate>
    </item>
    <item>
      <title>重构手法整理</title>
      <link>https://www.ppmy.cn/news/1541503.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维重构手法整理news/2025/11/4 0:22:17/提示：文章文章目录文章目录文章目录前言一、背景二、重构手法2.1 以委托取代继承2.2 使用c++实现三、3.1总结前言前期疑问：本文目标：一、背景最近二、重构手法2.1 以委托取代继承以委托取代继承是指我们常常为了一时的便利而错误地在代码中使用到了继承机制。我们知道，继承可以使得子类获得了父类的非私有方法、属性，而我们却正好是看中了这种无形中的便利而不正当地在逻辑上几乎不相关的类之间使用了继承，实质上这种为追求便利的继承是无意义的。具体请看下面的代码。// 重构前
class Sanitation {public String washHands() {return "Cleaned ...";}
}class Child extends Sanitation {}在这里，卫生设备 Sanitation 类（假设为水龙头）具有给人们洗手的方法 washHands() ，但是这里的 Child 类想要具有 washHands() 的方法，但是完全不可以像上面那样子去 extends Sanitation 类啊，这两个类之间完全没有一点支持继承的联系。为了打破我们这种无意义的继承，以及消除这种带来不良影响的便利，我们应该进行重构，利用委托来实现。重构第一步，先保留 extends 关系，这样便于一点点地检测我们的重构是否出错，如下：classSanitation{publicStringwashHands(){return"Cleaned ...";}}// 重构是一小步一小步进行的，先保留 extends 关系classChildextends Sanitation{// 具有委托对象 Sanitation 的实例privateSanitation sanitation;publicChild(){// 为委托对象赋值为当前对象，// 因为我们还保留了 extends 关系this.sanitation=this;}publicStringwashHands(){// 这里使用委托获得  washHands() 方法return(this.sanitation.washHands());}}当我们编译发现没有错误时（这时还不能运行，会发生栈溢出！），立即将上面 Child 类中的extends 去掉，并记得将构造函数中的 this 引用改成真正的创建一个 Sanitation 对象。重构第二步：classChild{// 具有委托对象 Sanitation 的实例privateSanitation sanitation;publicChild(){// 删除 extends 关系this.sanitation=newSanitation();}publicStringwashHands(){// 这里使用委托获得  washHands() 方法return(this.sanitation.washHands());}}至此，重构成功了！这才可以运行测试了。小结：用委托取代这种“莫名其妙”的继承关系，是比较符合逻辑的。像 Child 和 Sanitation 两个类，根本就不是一个继承树上的，原先代码结构表现出来的也是毫无意义的。此外，个人认为，《重构》这本书上对于每个重构的步骤讲得比较详细，但是《31天重构》这本书的这一篇文章中的这个例子比《重构》中的似乎更合理些，因为这里的代码是用了一个逻辑上没有继承关系的例子，就想上文。2.2 使用c++实现尝试使用c++实现，下面进过自己调试后的代码// Sanitation.h文件#ifndefTESTPROJ_LOCAL_WITHOUT_LIBRARY_REFACTOR_H#defineTESTPROJ_LOCAL_WITHOUT_LIBRARY_REFACTOR_H#include&lt;iostream&gt;classSanitation{public:std::stringwashHands(){std::cout&lt;&lt;"Cleaned ..."&lt;&lt;std::endl;return"Cleaned ...";}public:intsanitationCount;// 这边假设子类不需要继承这些成员};classChild:publicSanitation{};classChildReflactor:publicSanitation{// 具有委托对象 Sanitation 的实例private:Sanitation*sanitation;public:ChildReflactor(){// 为委托对象赋值为当前对象，// 因为我们还保留了 extends 关系this-&gt;sanitation=this;}public:std::stringwashHands(){// 这里使用委托获得  washHands() 方法return(this-&gt;sanitation-&gt;washHands());}};#endif//TESTPROJ_LOCAL_WITHOUT_LIBRARY_REFACTOR_H// Sanitation.cpp文件#include"sanitation.h"intmain(){Child child;child.washHands();ChildReflactor childReflactor;childReflactor.washHands();}打印结果：Cleaned...
Cleaned...在上述代码中，如果按照实例写成this.sanitation = this; 会报错，改成指针就行。查了下c++的this是指针。而且上述代码运行时没有出现栈溢出的情况，不知道是不是因为我的Sanitation成员是指针。三、3.1总结未完待续http://www.ppmy.cn/news/1541503.html相关文章【VUE】v-show 和 v-if 的区别v-show 始终会保留对应的 HTML 元素&amp;#xff0c;只是在隐藏时通过 CSS 样式控制元素不可见&amp;#xff1b;而 v-if 会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换&amp;#xff0c;切换速度相对较快&amp;#xff0c;但对页面的渲染效率影响较大&amp;#xff1b;…阅读更多...MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:17 +0000</pubDate>
    </item>
    <item>
      <title>【VUE】v-show 和 v-if 的区别</title>
      <link>https://www.ppmy.cn/news/1541502.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【VUE】v-show 和 v-if 的区别news/2025/11/4 0:22:16/v-show 始终会保留对应的 HTML 元素，只是在隐藏时通过 CSS 样式控制元素不可见；而 v-if会根据表达式的值条件地渲染或销毁对应的 HTML 元素。v-show 是基于 CSS 的切换，切换速度相对较快，但对页面的渲染效率影响较大；而 v-if 是基于 JavaScript的条件渲染，渲染效率相对较高，但在频繁切换时会创建和销毁 HTML 元素，对页面的性能影响要高于 v-show。v-show 不支持 元素，也不支持 v-else，而 v-if 可以和 元素，v-else指令一起使用。v-show 在初始渲染时会立即渲染出 HTML 元素，而 v-if 只有在表达式的值为 true 时才会进行渲染，因此在一开始时v-show 的性能要优于 v-if。v-show 适用于频繁切换元素可见性的场景，而 v-if 适用于需要根据条件动态渲染或销毁元素的场景。综上所述，v-show 和 v-if 在实现机制和使用场景上有所不同，开发者在具体应用时，需要根据实际情况选择使用哪一个。http://www.ppmy.cn/news/1541502.html相关文章MySQL中的最左前缀匹配原则最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则&amp;#xff0c;尤其在涉及到组合索引&amp;#xff08;联合索引&amp;#xff09;时。 
最左前缀匹配原则指的是在使用组合索引时&amp;#xff0c;MySQL 会从最左边的索引列开始匹配&amp;#xff0c;直到遇到第一个无法继续匹配的列为止。这意味…阅读更多...LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:16 +0000</pubDate>
    </item>
    <item>
      <title>MySQL中的最左前缀匹配原则</title>
      <link>https://www.ppmy.cn/news/1541501.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQL中的最左前缀匹配原则news/2025/11/4 0:22:15/最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则，尤其在涉及到组合索引（联合索引）时。最左前缀匹配原则指的是在使用组合索引时，MySQL 会从最左边的索引列开始匹配，直到遇到第一个无法继续匹配的列为止。这意味着，如果你想使用组合索引来加速查询，你的查询条件必须遵循 “最左前缀” 的要求，即必须从组合索引最左边的字段开始匹配，逐步向右，不能跳过任何列。在MySQL中，我们可以为多个字段创建组合索引，例如：CREATEINDEXidx_userONusers(first_name,last_name,age);我们为users表创建了一个组合索引idx_user，包含了三个列：first_name、last_name和age。这个索引可以帮助加快查询速度，但是遵循最左前缀匹配的规则，具体体现在以下几个方面：完全匹配最左前缀：当你查询条件完全包含最左边的字段，MySQL可以使用这个索引。例如：SELECT*FROMusersWHEREfirst_name='John';在这种情况下，查询完全匹配索引中的第一个字段first_name，因此可以使用idx_user索引。匹配多个最左前缀的字段：如果查询条件包含索引中前面多个字段，那么MySQL也会使用索引。例如：SELECT*FROMusersWHEREfirst_name='John'ANDlast_name='Doe';这时，查询匹配了first_name和last_name，MySQL仍然可以使用组合索引idx_user。部分前缀匹配：如果查询条件只匹配索引的前几个字段中的一部分，MySQL仍然可以利用索引。例如：SELECT*FROMusersWHEREfirst_name='John'ANDage=25;在这种情况下，由于中间的last_name被跳过了（而first_name后面直接是age），索引无法很好地工作，只能利用first_name的部分匹配部分，而不会利用age。继续以users表和组合索引(first_name, last_name, age)为例，看看不同的查询能否使用索引：可以使用索引：SELECT*FROMusersWHEREfirst_name='Alice';只使用了第一个字段，符合最左前缀原则。SELECT*FROMusersWHEREfirst_name='Alice'ANDlast_name='Smith';使用了前两个字段，符合最左前缀原则。SELECT*FROMusersWHEREfirst_name='Alice'ANDlast_name='Smith'ANDage=30;使用了所有字段，符合最左前缀原则。不能使用索引：SELECT*FROMusersWHERElast_name='Smith';last_name不是最左前缀的第一个字段，MySQL不会使用索引idx_user。SELECT*FROMusersWHEREage=30;age不是最左前缀的第一个字段，同样不会使用组合索引。部分使用索引：SELECT*FROMusersWHEREfirst_name='Alice'ANDage=30;这里查询中间跳过了last_name，只会对first_name部分使用索引，而无法有效地对age进行索引加速。LIKE查询在进行LIKE查询时，最左前缀原则也同样适用。例如，对于一个索引(first_name)：查询SELECT * FROM users WHERE first_name LIKE 'A%'会利用索引，因为查询从最左边开始匹配。而SELECT * FROM users WHERE first_name LIKE '%A'则无法利用索引，因为它并不是从最左边匹配，而是存在前缀通配符。覆盖索引在某些情况下，使用最左前缀匹配还可以带来覆盖索引的好处。当所查询的字段全部包含在组合索引中时，MySQL 可以直接通过索引获取结果，而不需要访问数据行。这种现象称为覆盖索引（Covering Index），它可以极大地提高查询效率。例如：SELECTfirst_name,last_nameFROMusersWHEREfirst_name='Alice'ANDlast_name='Smith';在这个查询中，所有被查询的字段都在索引中，所以可以直接从索引中获取这些数据，而不需要再回到表中读取数据行。http://www.ppmy.cn/news/1541501.html相关文章LeetCode 1750.删除字符串两端相同字符后的最短长度题目&amp;#xff1a; 
给你一个只包含字符 a&amp;#xff0c;b 和 c 的字符串 s &amp;#xff0c;你可以执行下面这个操作&amp;#xff08;5 个步骤&amp;#xff09;任意次&amp;#xff1a; 
选择字符串 s 一个 非空 的前缀&amp;#xff0c;这个前缀的所有字符都相同。选择字符串 s 一个 非空 的后缀&amp;#…阅读更多...linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:15 +0000</pubDate>
    </item>
    <item>
      <title>LeetCode 1750.删除字符串两端相同字符后的最短长度</title>
      <link>https://www.ppmy.cn/news/1541500.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维LeetCode 1750.删除字符串两端相同字符后的最短长度news/2025/11/4 0:22:14/题目：给你一个只包含字符'a'，'b'和'c'的字符串s，你可以执行下面这个操作（5 个步骤）任意次：选择字符串s一个非空的前缀，这个前缀的所有字符都相同。选择字符串s一个非空的后缀，这个后缀的所有字符都相同。前缀和后缀在字符串中任意位置都不能有交集。前缀和后缀包含的所有字符都要相同。同时删除前缀和后缀。请你返回对字符串s执行上面操作任意次以后（可能 0 次），能得到的最短长度。思路：代码：class Solution {public int minimumLength(String s) {int n = s.length();int left = 0, right = n - 1;while (left &lt; right &amp;&amp; s.charAt(left) == s.charAt(right)) {char c = s.charAt(left);while (left &lt;= right &amp;&amp; s.charAt(left) == c) {left++;}while (left &lt;= right &amp;&amp; s.charAt(right) == c) {right--;}}return right - left + 1;}
}性能：时间复杂度o（n）空间复杂度o（1）http://www.ppmy.cn/news/1541500.html相关文章linux,socket编程，select,poll,epoll学习#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#inc…阅读更多...Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:14 +0000</pubDate>
    </item>
    <item>
      <title>linux,socket编程，select,poll,epoll学习</title>
      <link>https://www.ppmy.cn/news/1541499.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维linux,socket编程，select,poll,epoll学习news/2025/11/4 0:22:14/#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#include &lt;pthread.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/epoll.h&gt;void *handle_client(void *arg)
{int clientfd = *(int *)arg;char buf[1024];printf("clientfd:%d\n", clientfd);while (1){memset(buf, 0, sizeof(buf));int ret = recv(clientfd, buf, sizeof(buf), 0);if (ret &lt;= 0){printf("客户端断开连接\n");break;}printf("recv:%s\n", buf);char ans[] = "yesmefasrefas";int len = sizeof(ans);send(clientfd, ans, len, 0);}close(clientfd);
}
int main()
{// 创建socket_fd;printf("创建socket\n");int socketfd = socket(AF_INET, SOCK_STREAM, 0);if (socketfd &lt; 0){perror("socket");return -1;}// 绑定ip地址printf("绑定ip\n");struct sockaddr_in serveraddr;memset(&amp;serveraddr, 0, sizeof(serveraddr));serveraddr.sin_family = AF_INET;serveraddr.sin_port = htons(9999);serveraddr.sin_addr.s_addr = inet_addr("0.0.0.0");if (bind(socketfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0){perror("bind");return -1;}listen(socketfd, 10);printf("等待客户端连接\n");struct sockaddr_in clientaddr;int len = sizeof(clientaddr);printf("sockfd:%d\n", socketfd);#if 0int clientfd = accept(socketfd, (struct sockaddr *)&amp;clientaddr, &amp;len);printf("客户端连接成功\n");char client_ip[INET_ADDRSTRLEN];inet_ntop(AF_INET, &amp;(clientaddr.sin_addr), client_ip, INET_ADDRSTRLEN);printf("Client connected from IP: %s\n", client_ip);#endif#if 0//多线程while (1){int clientfd = accept(socketfd, (struct sockaddr *)&amp;clientaddr, &amp;len);printf("客户端连接成功\n");pthread_t pid_t;pthread_create(&amp;pid_t, NULL, handle_client, &amp;clientfd);}
#endif
#if 0// select();fd_set rfds, rset;FD_ZERO(&amp;rfds);          // 全部置0FD_SET(socketfd, &amp;rfds); // sockfd 置1int maxfd = socketfd;while (1){rset = rfds;int ready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);if (FD_ISSET(socketfd, &amp;rset)) // 判断是否在里面{int clientfd = accept(socketfd, (struct sockaddr *)&amp;clientaddr, &amp;len);printf("有情况！clientfd: %d\n", clientfd);FD_SET(clientfd, &amp;rfds);maxfd = clientfd;}int i = 0;for (i = socketfd + 1; i &lt;= maxfd; i++){if (FD_ISSET(i, &amp;rset)){printf("有数据到达了，fd:%d\n", i);char buf[1024];// printf("clientfd:%d\n", clientfd);memset(buf, 0, sizeof(buf));int ret = recv(i, buf, sizeof(buf), 0);if (ret &lt;= 0){printf("客户端断开连接\n");break;}printf("recv:%s\n", buf);char ans[] = "yesmefasrefas";int len = sizeof(ans);send(i, ans, len, 0);FD_CLR(i, &amp;rfds);close(i);}}}#endif#if 0// poll();struct pollfd fds[1024];fds[socketfd].fd = socketfd;fds[socketfd].events = POLLIN;int maxfd = socketfd;while (1){poll(fds, 1024, socketfd);if (fds[socketfd].revents &amp; POLLIN){int clientfd = accept(socketfd, (struct sockaddr *)&amp;clientaddr, &amp;len);printf("有情况！clientfd: %d\n", clientfd);fds[clientfd].fd = clientfd;fds[clientfd].events = POLLIN;maxfd = clientfd;}int i = 0;for (i = socketfd + 1; i &lt;= maxfd; i++){if (fds[i].revents &amp; POLLIN){printf("有数据到达了，fd:%d\n", i);char buf[1024];// printf("clientfd:%d\n", clientfd);memset(buf, 0, sizeof(buf));int ret = recv(i, buf, sizeof(buf), 0);if (ret &lt;= 0){printf("客户端断开连接\n");fds[i].fd = -1;fds[i].events = 0;close(i);}else{printf("recv:%s\n", buf);char ans[] = "yesmefasrefas";int len = sizeof(ans);send(i, ans, len, 0);}}}}#endif#if 1// epollint epfd = epoll_create(1024);struct epoll_event ev;ev.events = EPOLLIN;ev.data.fd = socketfd;epoll_ctl(epfd, EPOLL_CTL_ADD, socketfd, &amp;ev);struct epoll_event events[1024];while (1){int ready = epoll_wait(epfd, events, 1024, -1);int i = 0;for (i = 0; i &lt; ready; i++){int connfd = events[i].data.fd;if (connfd == socketfd){int clientfd = accept(socketfd, (struct sockaddr *)&amp;clientaddr, &amp;len);printf("有情况！clientfd: %d\n", clientfd);ev.data.fd = clientfd;ev.events = EPOLLIN;epoll_ctl(epfd, EPOLL_CTL_ADD, clientfd, &amp;ev);}else if (events[i].events &amp; EPOLLIN){printf("有数据到达了，fd:%d\n", connfd);char buf[1024];// printf("clientfd:%d\n", clientfd);memset(buf, 0, sizeof(buf));int l = sizeof(buf);int ret = recv(connfd, buf, 5, 0);if (ret &lt;= 0){printf("客户端断开连接\n");epoll_ctl(epfd, EPOLL_CTL_DEL, connfd, NULL);close(connfd);}else{printf("recv:%s\n", buf);char ans[] = "yesmefasrefas";int len = sizeof(ans);send(connfd, ans, len, 0);}}}}
#endifclose(socketfd);return 0;
}client代码#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt; // 添加这一行
#include &lt;string.h&gt;    // 添加这一行
#include &lt;pthread.h&gt;int main(int argc, char *argv[])
{int sockfd;struct sockaddr_in servaddr;char buf[1024];int n;sockfd = socket(AF_INET, SOCK_STREAM, 0);servaddr.sin_family = AF_INET;servaddr.sin_port = htons(9999);servaddr.sin_addr.s_addr = inet_addr("113.45.173.146");connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));char buffrecv[] = "123456789123456789123456789";send(sockfd, buffrecv, sizeof(buffrecv), 0);recv(sockfd, buf, 1024, 0);printf("recv:%s\n", buf);sleep(3);close(sockfd);return 0;
}http://www.ppmy.cn/news/1541499.html相关文章Java知识巩固(四)目录 线程的生命周期 
一、新建状态&amp;#xff08;New&amp;#xff09; 
二、就绪状态&amp;#xff08;Runnable&amp;#xff09; 
三、运行状态&amp;#xff08;Running&amp;#xff09; 
四、阻塞状态&amp;#xff08;Blocked&amp;#xff09; 
五、死亡状态&amp;#xff08;Dead&amp;#xff09; 
什么是双亲委派 
…阅读更多...QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:14 +0000</pubDate>
    </item>
    <item>
      <title>Java知识巩固(四)</title>
      <link>https://www.ppmy.cn/news/1541498.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java知识巩固(四)news/2025/11/4 0:22:13/目录线程的生命周期一、新建状态（New）二、就绪状态（Runnable）三、运行状态（Running）四、阻塞状态（Blocked）五、死亡状态（Dead）什么是双亲委派continue、break和return的区别是什么？线程的生命周期一、新建状态（New）当程序使用new关键字或其他线程创建方法（如Win32的API或.NET框架的API）创建了一个线程对象后，该线程就处于新建状态。此时，线程对象已经分配了必要的内存空间并初始化了成员变量，但它还没有开始执行，即没有表现出任何动态特征。在这个阶段，线程的执行体（通常是run方法）还没有被启动，线程对象仅仅是一个普通的Java对象（或其他编程语言的相应对象）。二、就绪状态（Runnable）当调用线程的start方法后，线程就进入了就绪状态。此时，线程已经做好了执行准备，表示可以运行了，但还不是正在运行的线程。就绪状态的线程已经分配了线程ID和线程上下文（包括特定于CPU的寄存器信息等），并且已经创建和初始化了用户态栈和内核态栈。在这个阶段，线程还没有获得CPU的调度权，因此不会立即执行。线程需要等待JVM（Java虚拟机）中的线程调度器将其调度到运行状态。三、运行状态（Running）当就绪状态的线程获得JVM中线程调度器的调度时，线程就进入了运行状态。此时，线程开始执行其执行体（run方法）中的代码。线程在运行过程中可能会因为时间片用完、主动让出CPU资源（如调用yield方法）或其他原因（如等待I/O操作完成、等待同步锁等）而进入阻塞状态或就绪状态。在多CPU的机器上，可能会有多个线程同时处于运行状态；但在单CPU的机器上，任何时刻只有一条线程处于运行状态。四、阻塞状态（Blocked）线程在运行过程中可能会因为各种原因而进入阻塞状态。阻塞状态是线程暂时停止执行并等待某个条件满足的状态。线程阻塞的原因可能包括：调用sleep方法主动放弃CPU资源、等待I/O操作完成、等待同步锁（如试图获取一个已被其他线程持有的同步监视器）等。被阻塞的线程会在合适的时候（如阻塞条件解除后）重新进入就绪状态，并等待线程调度器再次调度它执行。五、死亡状态（Dead）当线程的run方法执行完成或线程抛出未捕获的异常时，线程就会进入死亡状态。此时，线程已经完成了其生命周期并终止执行。线程死亡后，其占用的资源（如用户态栈、内核态栈等）将被释放。同时，线程的引用计数将减1，当引用计数变为0时，线程内核对象将被销毁。综上所述，线程的生命周期包括新建状态、就绪状态、运行状态、阻塞状态和死亡状态。这些状态之间的转换通常是由线程的调度、执行和阻塞等操作引起的。了解线程的生命周期有助于更好地理解线程的并发执行机制和资源管理策略。什么是双亲委派双亲委派模式是指Java虚拟机在加载类时采用的一种加载策略。具体来说，当一个类加载器收到类加载的请求时，它并不会自己先去加载该类，而是将这个请求委托给父类的加载器去执行。这个过程会一直递归进行，直到达到顶层的引导类加载器（Bootstrap ClassLoader）。如果父类加载器能够完成类加载任务，就成功返回；如果父类加载器无法完成类加载任务，子加载器才会尝试自己去加载。双亲委派模式的主要目的是：避免重复加载：通过双亲委派模式，可以确保同一个类只被加载一次，从而避免重复加载导致的资源浪费和潜在的问题。保护核心类库：双亲委派模式还可以防止恶意代码通过自定义类加载器来篡改Java的核心类库。例如，在加载jdbc.jar用于实现数据库连接的时候，因为jdbc.jar是基于Java中rt.jar中的SPI接口进行实现的，所以在加载的时候，由于SPI接口会调用实现类中的方法，所以这里jdbc.jar中的方法会被加载到内存中，此时就会进行双亲委派进行类加载。最终从Bootstrap ClassLoader类加载器中加载SPI核心类，然后加载SPI接口的实现类，此时Bootstrap ClassLoader会进行反向委派，通过线程上下文类加载器进行jdbc.jar的加载，从而避免类的重复加载并保护程序安全。因此，“双清委派”并非一个标准的计算机科学或Java领域的术语，而“双亲委派模式”才是Java虚拟机在类加载过程中采用的一种重要机制。continue、break和return的区别是什么？在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：continue：指跳出当前的这一次循环，继续下一次循环。break：指跳出整个循环体，继续执行循环下面的语句。return用于跳出所在方法，结束该方法的运行。return 一般有两种用法：return;：直接使用 return 结束方法执行，用于没有返回值函数的方法return value;：return 一个特定值，用于有返回值函数的方法public static void main(String[] args) {boolean flag = false;for (int i = 0; i &lt;= 3; i++) {if (i == 0) {System.out.println("0");} else if (i == 1) {System.out.println("1");continue;} else if (i == 2) {System.out.println("2");flag = true;} else if (i == 3) {System.out.println("3");break;} else if (i == 4) {System.out.println("4");}System.out.println("xixi");}if (flag) {System.out.println("haha");return;}System.out.println("heihei");
}运行的结果是：0
xixi
1
2
xixi
3
hahahttp://www.ppmy.cn/news/1541498.html相关文章QGraphics类型学习使用【Qt】【C++】QGraphics类型学习使用 需求过程全部完整代码 首先已知&amp;#xff0c;QGraphicsView&amp;#xff0c;QGraphicsScene, QGraphicsItem&amp;#xff0c;分别称为&amp;#xff1a;视图&amp;#xff0c;场景&amp;#xff0c;图元&amp;#xff0c;图表就是各种各样的元素&amp;#xff0c;图片元素&amp;#xff0c;线条元…阅读更多...【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:13 +0000</pubDate>
    </item>
    <item>
      <title>QGraphics类型学习使用【Qt】【C++】</title>
      <link>https://www.ppmy.cn/news/1541497.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维QGraphics类型学习使用【Qt】【C++】news/2025/11/4 0:22:12/QGraphics类型学习使用需求过程全部完整代码首先已知，QGraphicsView，QGraphicsScene, QGraphicsItem，分别称为：视图，场景，图元，图表就是各种各样的元素，图片元素，线条元素，等等，场景就是容纳图元的一个容器，场景不会显示出来,这句话很关键。若是想将其显示到屏幕上，需要将场景设置到视图中，由视图负责显示。需求利用QGraphics家族类成员实现将图片显示出来，并对图片进行旋转，伸缩等操作。以下是完成后的结果图：过程首先创建了项目，并将图片添加进qrc资源文件（不添加也行，不影响）:代码如下：#include"widget.h"Widget::Widget(QWidget*parent):QWidget(parent){QPixmap*pm=newQPixmap("://earth.jpg");QGraphicsView*view=newQGraphicsView(this);QGraphicsScene*scene=new QGraphicsScene;QGraphicsPixmapItem*pixmap=newQGraphicsPixmapItem(*pm);setGeometry({300,300,800,600});view-&gt;resize(pixmap-&gt;pixmap().width(),pixmap-&gt;pixmap().height());scene-&gt;addItem(pixmap);view-&gt;setScene(scene);QVBoxLayout*vLayout=new QVBoxLayout;QSlider*s1=newQSlider(Qt::Horizontal);QSlider*s2=newQSlider(Qt::Horizontal);vLayout-&gt;addWidget(s1);vLayout-&gt;addWidget(s2);QHBoxLayout*hLayout=newQHBoxLayout(this);hLayout-&gt;addWidget(view);hLayout-&gt;addLayout(vLayout);}Widget::~Widget(){}可以看到只显示的图片的一部分，根据下面和右边的滚动条知道可以通过滑动来展示图片，溯源可知，由于QGraphicsView继承自QAbstractScrollArea,顾名思义，它的父类具有滚动功能，具体不深究，知道是因为那个部分带来的滚动条即可。但是我们的目的是显示所有图片的细节，可以放大图片：#include"widget.h"Widget::Widget(QWidget*parent):QWidget(parent){QPixmap*pm=newQPixmap("://earth.jpg");QPixmap newPm=pm-&gt;scaled(pm-&gt;width()/1.5,pm-&gt;height()/1.5);QGraphicsView*view=newQGraphicsView(this);QGraphicsScene*scene=new QGraphicsScene;QGraphicsPixmapItem*pixmap=newQGraphicsPixmapItem(newPm);setGeometry({500,500,pixmap-&gt;pixmap().width()+100,pixmap-&gt;pixmap().height()});view-&gt;resize(pixmap-&gt;pixmap().width(),pixmap-&gt;pixmap().height()-100);scene-&gt;addItem(pixmap);view-&gt;setScene(scene);QVBoxLayout*vLayout=new QVBoxLayout;QSlider*s1=newQSlider(Qt::Horizontal);QSlider*s2=newQSlider(Qt::Horizontal);vLayout-&gt;addWidget(s1);vLayout-&gt;addWidget(s2);QHBoxLayout*hLayout=newQHBoxLayout(this);hLayout-&gt;addWidget(view);hLayout-&gt;addLayout(vLayout);}Widget::~Widget(){}得到：将右侧滚动条大小进行调整，整体大小进行调整：#include"widget.h"Widget::Widget(QWidget*parent):QWidget(parent){QPixmap*pm=newQPixmap("://earth.jpg");QPixmap newPm=pm-&gt;scaled(pm-&gt;width()/1.5,pm-&gt;height()/1.5);QGraphicsView*view=new QGraphicsView;QGraphicsScene*scene=new QGraphicsScene;QGraphicsPixmapItem*pixmap=newQGraphicsPixmapItem(newPm);setGeometry({500,500,pixmap-&gt;pixmap().width()+100,pixmap-&gt;pixmap().height()});view-&gt;resize(pixmap-&gt;pixmap().width(),pixmap-&gt;pixmap().height()-100);scene-&gt;addItem(pixmap);view-&gt;setScene(scene);QVBoxLayout*vLayout=new QVBoxLayout;QSlider*s1=newQSlider(Qt::Horizontal);QSlider*s2=newQSlider(Qt::Horizontal);QHBoxLayout*gbox1=new QHBoxLayout;QHBoxLayout*gbox2=new QHBoxLayout;QLabel*label1=newQLabel("旋转:");QLabel*label2=newQLabel("伸缩:");gbox1-&gt;addWidget(label1);gbox1-&gt;addWidget(s1);gbox2-&gt;addWidget(label2);gbox2-&gt;addWidget(s2);vLayout-&gt;addLayout(gbox1);vLayout-&gt;addLayout(gbox2);QHBoxLayout*hLayout=newQHBoxLayout(this);hLayout-&gt;addWidget(view);hLayout-&gt;addLayout(vLayout);}Widget::~Widget(){}接下来就可以设置旋转和缩放的槽函数了，两种方式：旋转视图：voidWidget::rotate(intvalue){view-&gt;rotate(value);update();}旋转图元：voidWidget::rotate(intvalue){pixmap-&gt;setRotation(value);update();}此时发现问题：旋转中心点是左上角：这是因为，在两种旋转函数中：rotate: 旋转原点是以中心点为基准进行旋转的。setRotation: 旋转原点是以左上角为基准进行旋转的。所以需要修改旋转原点：setTransformOriginPoint：这个函数通常用于设置QGraphicItem及其子类的变换中心点，可作为旋转，伸缩时的中心点。所以：voidWidget::rotate(intvalue){pixmap-&gt;setTransformOriginPoint(pixmap-&gt;pixmap().width()/2,pixmap-&gt;pixmap().height()/2);pixmap-&gt;setRotation(value);update();}发现旋转没有一圈，设置一下滚动条的范围即可：s1-&gt;setRange(0,360);接下来实现伸缩：voidWidget::scale(intvalue){pixmap-&gt;setTransformationMode(Qt::SmoothTransformation);pixmap-&gt;setScale(value);update();}运行后：发现伸缩大小比例不对，将滚动条的范围设置为一个合适的范围：s2-&gt;setRange(0,2);,设置后运行：发现slider的步长太大，但是我们需要的是0.1级别的调整，查询发现slider设置步长的函数为setSingleStep(int)，只能设置最小为1的步长，因此我们重新调整，将范围设置为：s2-&gt;setRange(0,20);voidWidget::scale(intvalue){pixmap-&gt;setTransformationMode(Qt::SmoothTransformation);pixmap-&gt;setScale(value*1.0/10);update();}运行后发现;第1点是期望伸缩中心点是在图片的中心点，但是实际上是在图片左上角进行伸缩的，所以需要修该一下：pixmap-&gt;setTransformOriginPoint(pixmap-&gt;pixmap().width()/2, pixmap-&gt;pixmap().height()/2);其实也就是将rotate函数里面的这个setTransformOriginPoint放到构造函数中。第2点就是伸缩的时候是从slider的值改变的第一个量伸缩的，我们期待的是从当前值进行伸缩，接下来进行修改：因为涉及到缩小和放大，我们可以将slider的初始值设置为10，进过变换也就是1，即没有伸缩过的图片：s2-&gt;setValue(10);slider位于中间，向左缩小，向右放大：自此代码简单完成。是自己学习路上的过程笔记，知识浅薄，或许不具备学习来使用。全部完整代码// widget.h#ifndefWIDGET_H#defineWIDGET_H#include&lt;QWidget&gt;#include&lt;QGraphicsView&gt;#include&lt;QGraphicsScene&gt;#include&lt;QGraphicsPixmapItem&gt;#include&lt;QPixmap&gt;#include&lt;QVBoxLayout&gt;#include&lt;QHBoxLayout&gt;#include&lt;QSlider&gt;#include&lt;QGroupBox&gt;#include&lt;QLabel&gt;class Widget:public QWidget{Q_OBJECTpublic:Widget(QWidget*parent=nullptr);~Widget();private:QGraphicsView*view;QGraphicsPixmapItem*pixmap;QGraphicsScene*scene;private slots:voidrotate(int);voidscale(int);};#endif// WIDGET_H// widget.cpp#include"widget.h"Widget::Widget(QWidget*parent):QWidget(parent){QPixmap*pm=newQPixmap("://earth.jpg");QPixmap newPm=pm-&gt;scaled(pm-&gt;width()/1.5,pm-&gt;height()/1.5);view=new QGraphicsView;scene=new QGraphicsScene;pixmap=newQGraphicsPixmapItem(newPm);setGeometry({500,500,pixmap-&gt;pixmap().width()+100,pixmap-&gt;pixmap().height()});view-&gt;resize(pixmap-&gt;pixmap().width(),pixmap-&gt;pixmap().height()-100);scene-&gt;addItem(pixmap);view-&gt;setScene(scene);QVBoxLayout*vLayout=new QVBoxLayout;QSlider*s1=newQSlider(Qt::Horizontal);s1-&gt;setRange(0,360);QSlider*s2=newQSlider(Qt::Horizontal);s2-&gt;setRange(0,20);s2-&gt;setValue(10);QHBoxLayout*gbox1=new QHBoxLayout;QHBoxLayout*gbox2=new QHBoxLayout;QLabel*label1=newQLabel("旋转:");QLabel*label2=newQLabel("伸缩:");gbox1-&gt;addWidget(label1);gbox1-&gt;addWidget(s1);gbox2-&gt;addWidget(label2);gbox2-&gt;addWidget(s2);vLayout-&gt;addLayout(gbox1);vLayout-&gt;addLayout(gbox2);QHBoxLayout*hLayout=newQHBoxLayout(this);hLayout-&gt;addWidget(view);hLayout-&gt;addLayout(vLayout);pixmap-&gt;setTransformOriginPoint(pixmap-&gt;pixmap().width()/2,pixmap-&gt;pixmap().height()/2);connect(s1,SIGNAL(valueChanged(int)),this,SLOT(rotate(int)));connect(s2,SIGNAL(valueChanged(int)),this,SLOT(scale(int)));}Widget::~Widget(){}voidWidget::rotate(intvalue){pixmap-&gt;setTransformOriginPoint(pixmap-&gt;pixmap().width()/2,pixmap-&gt;pixmap().height()/2);pixmap-&gt;setRotation(value);update();}voidWidget::scale(intvalue){pixmap-&gt;setTransformationMode(Qt::SmoothTransformation);pixmap-&gt;setScale(value*1.0/10);update();}新人创作不易，你的点赞和关注都是对我莫大的鼓励，再次感谢您的观看。http://www.ppmy.cn/news/1541497.html相关文章【橙子老哥】C# 实操分布式事务解决方案hello&amp;#xff0c;大家好&amp;#xff0c;今天来到橙子老哥的分享时间&amp;#xff0c;希望大家一起学习&amp;#xff0c;一起进步。 
欢迎加入.net意社区&amp;#xff0c;第一时间了解我们的动态&amp;#xff0c;文章第一时间分享至社区 
社区官方地址&amp;#xff1a;https://ccnetcore.com (上千.net…阅读更多...【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:12 +0000</pubDate>
    </item>
    <item>
      <title>【橙子老哥】C# 实操分布式事务解决方案</title>
      <link>https://www.ppmy.cn/news/1541496.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【橙子老哥】C# 实操分布式事务解决方案news/2025/11/4 0:22:11/hello，大家好，今天来到橙子老哥的分享时间，希望大家一起学习，一起进步。欢迎加入.net意社区，第一时间了解我们的动态，文章第一时间分享至社区社区官方地址：https://ccnetcore.com(上千.neter聚集地)官方微信公众号：搜索意.Net添加橙子老哥微信加入官方微信群：chengzilaoge520上一篇我们实操了高并发分布式缓存的解决方案， 这篇我们接着分布式的话题，使用c#去实操了一下分布式事务问题的解决方案相信很多人已经对分布式事务这种面试八股文很熟悉了，说个七七八八不成问题，网上也有很多教程，但是多偏向于理论，没有实操，今天橙子老哥使用c#，带大家把整个流程落地一遍希望下次遇到这个问题，能回想到橙子老哥的这篇文章，就是这篇文章的意义了1、事务-ACID长话短说，理论知识不能少：一个事务有四个基本特性，也就是我们常说的（ACID）。Atomicity（原子性） ：事务是一个不可分割的整体，事务内所有操作要么全做成功，要么全失败。Consistency（一致性） ：务执行前后，数据从一个状态到另一个状态必须是一致的（A向B转账，不能出现A扣了钱，B却没收到）。Isolation（隔离性）：多个并发事务之间相互隔离，不能互相干扰。Durablity（持久性） ：事务完成后，对数据库的更改是永久保存的，不能回滚。以上这些特征相信大家在使用数据库的时候，已经了如指掌了，这里也不再过多赘述。2、不处理分布式事务通常的，如果是在单体架构中，为了保持数据的一致性，只需要在批量执行数据库操作的时候，开启事务，在最终完成操作的时候，再提交事务即可但是如果各各操作是分布在不同的程序/数据库/服务器上，我们还按照原先的方式会怎么样呢？废话少说，我们直接实操，准备代码：这里我们模拟一个经典场景，订单服务和库存服务，用户创建订单，订单数+1，库存数量-1，像这种场景，我们必须要确保数据的一致性，如果出现了订单加的多了，库存减的少了，那不就产生了超卖的严重生产事故？//情况1，无分布式事务处理//订单服务客户端varorderServiceClient=newOrderServiceClient();//库存服务客户端varstoreServiceClient=newStoreServiceClient();//模拟执行10次下单vari=10;while(i&gt;0){try{//入口，用户进行创建订单orderServiceClient.CreateOrder(storeServiceClient);}catch(Exceptione){Console.WriteLine(e.Message);}finally{//打印数据库订单和库存数量Console.WriteLine($"当前订单数量：{OrderServiceClient.Order}，库存数量：{StoreServiceClient.Store}");i--;}}Console.WriteLine("完成");classOrderServiceClient{publicstaticintOrder{get;privateset;}=10;privateAction?_tran;//新增订单到数据库(不会真正执行，返回委托，事务预处理，执行委托就是提交事务)ActionAddOrderToDb(){return()=&gt;Order+=1;}//业务代码publicvoidCreateOrder(StoreServiceClientstoreClient){//订单服务开启事务_tran=AddOrderToDb();storeClient.UpdateStore();//订单提交事务_tran.Invoke();}}//同理classStoreServiceClient{publicstaticintStore{get;privateset;}=20;privateAction?_tran;//新增订单ActionDecreaseStoreToDb(){return()=&gt;Store-=1;}publicvoidUpdateStore(){//库存服务开启事务_tran=DecreaseStoreToDb();_tran.Invoke();}}在上面的例子中，我们在订单服务，调用了自己的数据库，同时又远程调用了库存服务，双方各自执行事务操作当没有一方出现错误、网络完美、服务器稳定、内存够用，好像怎么执行也不会有任何问题CAP：我又来了，分布式中要满足分区容错，一致性和可用性就不能同时抓上面执行中，很明显有个地方容易出问题，如果在库存服务事务已经提交，返回的时候，网络波动订单服务没有收到结果，订单报错了，取消事务，库存执行完了，新增库存，导致数据不一致//业务代码publicvoidCreateOrder(StoreServiceClientstoreClient){//订单服务开启事务_tran=AddOrderToDb();storeClient.UpdateStore();//情况1thrownewException("订单服务网络波动，无法收到库存服务的回应，或者收到回应，但是事务没有提交宕机");//订单提交事务_tran.Invoke();}//初始数据当前订单数量：10，库存数量：20//结果当前订单数量：10，库存数量：10为了解决这种分布式事务问题，行业内提出了非常多的方案，比较经典常用的是以下4个2PC （悲观锁）3PC （悲观锁）TCC （乐观锁）消息队列 （异步）其中，3PC是对2PC的补充，2PC和3PC是更针对与资源（多数据库）事务的情况，TCC增对应用接口接下来，我们实操一下，这几个到底是个啥3、2PC想到分布式的一致性，那肯定离不开中心化，我们是否可以将多个服务的事务通过一个中心化的事务协调器进行统一管理？每个执行操作，都先问问这个事务协调器，所有人说可以，我们就执行，有人执行失败了，其他成功的全部回滚，简单好记，无脑粗暴那就整一个中心的事务协调器，然后执行的业务的时候，先让各各服务预执行事务，都没问题，再让他们都提交事务即可流程图：分为两步：Prepare预执行，Commit提交我们代码实现下：情况2，2pc  悲观并发控制varorderServiceClient=newOrderServiceClient();varstoreServiceClient=newStoreServiceClient();//我们引入一个新的客户端，专门来协调各各服务之间的事务vartranServiceClient=newTranServiceClient();vari=10;while(i&gt;0){try{//用户触发事务动作，通过事务协调者统一调度tranServiceClient.CreateOrder(orderServiceClient,storeServiceClient);}catch(Exceptione){Console.WriteLine(e.Message);}finally{Console.WriteLine($"当前订单数量：{OrderServiceClient.Order}，库存数量：{StoreServiceClient.Store}");i--;}}Console.WriteLine("完成");classOrderServiceClient{publicstaticintOrder{get;privateset;}=10;privateAction?_tran;//订单服务预执行方法publicboolPrepare(){_tran=AddOrderToDb();returntrue;}//订单服务提交方法publicboolCommit(){_tran.Invoke();returntrue;}//落库ActionAddOrderToDb(){return()=&gt;Order+=1;}}//同理classStoreServiceClient{publicstaticintStore{get;privateset;}=20;privateAction?_tran;publicboolPrepare(){_tran=DecreaseStoreToDb();returntrue;}publicboolCommit(){_tran.Invoke();returntrue;}//新增订单ActionDecreaseStoreToDb(){return()=&gt;Store-=1;}}//事务协调者classTranServiceClient{publicvoidCreateOrder(OrderServiceClientclient1,StoreServiceClientclient2){//调用两个服务接口，预执行，只有都成功才走下一步if(Prepare(client1,client2)){//预执行都成功了，再全部统一提交if(Commit(client1,client2)){Console.WriteLine("事务全部完成提交");}else{thrownewException("执行Commit存在有一方失败，成功一方进行回滚");}}else{thrownewException("准备失败存在失败，不执行Commit");}}//预先执行事务内容boolPrepare(OrderServiceClientclient1,StoreServiceClientclient2){varres1=client1.Prepare();varres2=client2.Prepare();returnres1&amp;&amp;res2;}//真正提交事务boolCommit(OrderServiceClientclient1,StoreServiceClientclient2){varres1=client1.Commit();varres2=client2.Commit();returnres1&amp;&amp;res2;}}这里，我们探究下原理，是靠什么保持的一致性？在事务协调者分别去调用两个服务的方法，只有等2个服务都返回了结果，才能进入下一个阶段！答案，就在等字，意味着事务协调者认为任何请求都可能失败，不相信他们会成功，只有锁住了，都返回了结果，才允许走下一步，这就是悲观锁，虽然能保持一致性，但会一定程度降低吞吐量同时，上面也可以看出，太依赖了这个中心的事务协调者，如果它蹦了，那全玩完了另外，2pc还有个严重的问题，因为我们只有2个阶段，当我们预提交的时候，虽然没有实际提交，但是也很消耗资源如果我们分布式的2个服务，库存其实早就已经没有了，每次都去预执行事务，最后又不提交回滚，对订单服务会有一个连带效应，它也要每次去预执行事务，特别是微服务中，拆的非常细，很浪费资源4、3PC3PC，本质上就是为了解决上面浪费资源的问题相比于2pc，它多了一个步骤，先把各各服务询问一下，准备好了没有，这里只是做一个基础的校验，如果库存都没有，那后面事务也不需要去提交再回滚的操作分为三步：CanCommit准备，Prepare预执行，Commit提交情况3，3pcvarorderServiceClient=newOrderServiceClient();varstoreServiceClient=newStoreServiceClient();vartranServiceClient=newTranServiceClient();vari=10;while(i&gt;0){try{tranServiceClient.CreateOrder(orderServiceClient,storeServiceClient);}catch(Exceptione){Console.WriteLine(e.Message);}finally{Console.WriteLine($"当前订单数量：{OrderServiceClient.Order}，库存数量：{StoreServiceClient.Store}");i--;}}Console.WriteLine("完成");classOrderServiceClient{publicstaticintOrder{get;privateset;}=10;privateAction?_tran;publicboolCanCommit(){returntrue;}publicboolPrepare(){_tran=AddOrderToDb();returntrue;}publicboolCommit(){_tran.Invoke();returntrue;}//新增订单ActionAddOrderToDb(){return()=&gt;Order+=1;}}classStoreServiceClient{publicstaticintStore{get;privateset;}=20;privateAction?_tran;publicboolCanCommit(){returntrue;}publicboolPrepare(){_tran=DecreaseStoreToDb();returntrue;}publicboolCommit(){_tran.Invoke();returntrue;}//新增订单ActionDecreaseStoreToDb(){return()=&gt;Store-=1;}}classTranServiceClient{publicvoidCreateOrder(OrderServiceClientclient1,StoreServiceClientclient2){//多了一步是否能执行的步骤if(CanCommit(client1,client2)){//预执行事务if(Prepare(client1,client2)){//真正去执行事务if(Commit(client1,client2)){Console.WriteLine("事务全部完成提交");}else{thrownewException("执行Commit存在有一方失败，成功一方进行回滚");}}else{thrownewException("准备失败存在失败，不执行Commit");}}else{thrownewException("是否能提交阶段存在失败，通知之后，啥也不做");}}boolCanCommit(OrderServiceClientclient1,StoreServiceClientclient2){varres1=client1.CanCommit();varres2=client2.CanCommit();returnres1&amp;&amp;res2;}//预先执行事务内容boolPrepare(OrderServiceClientclient1,StoreServiceClientclient2){varres1=client1.Prepare();varres2=client2.Prepare();returnres1&amp;&amp;res2;}//真正提交事务boolCommit(OrderServiceClientclient1,StoreServiceClientclient2){varres1=client1.Commit();varres2=client2.Commit();returnres1&amp;&amp;res2;}}上面的代码，和2pc区别不大，只是对了一个判断是否能执行的询问阶段5、TCC2pc和3pc都是悲观锁的实现，而TCC是乐观锁的实现，它的全称是Try-Confirm-Cancel，看到这个是否很熟悉？对，这个跟数据库的事务一样TCC认为大部分请求都是ok的，直接通过，不进行等待，如果小部分请求出现问题，那我们去回滚取消它就好了分为三步：Try尝试，Confirm确认，Cancel取消//情况4，TCC  ，Try、Confirm、CancelvarorderServiceClient=newOrderServiceClient();varstoreServiceClient=newStoreServiceClient();vari=10;while(i&gt;0){try{orderServiceClient.CreateOrder(storeServiceClient);}catch(Exceptione){Console.WriteLine(e.Message);}finally{Console.WriteLine($"当前订单数量：{OrderServiceClient.Order}，库存数量：{StoreServiceClient.Store}");i--;}}Console.WriteLine("完成");classOrderServiceClient{publicstaticintOrder{get;privateset;}=10;privateAction?_tran;publicvoidCreateOrder(StoreServiceClientstoreClient){//订单服务开启事务-如果这里失败，直接拦截_tran=AddOrderToDb();try{//如果这里失败，catch进行回滚storeClient.TryUpdateStore();}catch(Exceptione){storeClient.Cancel();//当前事务也取消，所有操作回滚_tran=null;return;}//如果没有任何异常，确认执行try{storeClient.Confirm();}catch(Exceptione){_tran=null;return;}//上方如果库存服务执行成功，没报错，订单服务也提交_tran.Invoke();//订单提交事务}//新增订单ActionAddOrderToDb(){return()=&gt;Order+=1;}}classStoreServiceClient{publicstaticintStore{get;privateset;}=20;privateAction?_tran;//新增订单ActionDecreaseStoreToDb(){return()=&gt;Store-=1;}publicvoidTryUpdateStore(){//库存服务开启事务_tran=DecreaseStoreToDb();}publicvoidConfirm(){_tran.Invoke();}publicvoidCancel(){_tran=null;}}上述代码我们2个服务交互，可以不需要中心服务共用，本质上原理是将自己服务的事务和另一个服务的事务绑定在一块，我们都先去尝试，有一方失败了，我们都去回滚。5、消息队列另外，还有一种方案也很常见，大部分分布式中出问题，都是网络出的问题，导致多个请求响应不一致，那我们如何去避免这种问题？答案还是一个重试前面的方案给的答案是算执行失败，全部回滚如果业务允许，只是网络这种偶发性问题，我们通过将消息存放到消息队列中，反复重试，直到成功，能确保一定成功，确保最终一致性就不需要回滚操作了还是前面的例子，我们即将开启双11的秒杀活动，先把库存总数缓存放到订单服务中，每次下单全无脑塞给消息队列，一个消息算一个任务，库存服务去消费，就算有网络中断等意外情况，那就重试，最后减少了库存再通知用户这种方案，库存服务虽然存在短暂时间不一致，但能够确保最终一致性，就算是消费者出了问题，反正我们消息持久化了，自己搂出来，人工处理都行（主要还有一点，简单~）都说到这里了，不得不提我们.net一个著名的解决分布式事务问题的开源项目CAP：https://github.com/dotnetcore/CAP最后的最后 - 意.Net 小程序即将上线 啦！各位敬请期待！–爱你们的橙子老哥http://www.ppmy.cn/news/1541496.html相关文章【Hive】8-Hive性能优化及Hive3新特性Hive性能优化及Hive3新特性 
Hive表设计优化 
Hive查询基本原理 
Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表 
基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时&amp;#xff0c;默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行…阅读更多...RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:11 +0000</pubDate>
    </item>
    <item>
      <title>【Hive】8-Hive性能优化及Hive3新特性</title>
      <link>https://www.ppmy.cn/news/1541495.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Hive】8-Hive性能优化及Hive3新特性news/2025/11/4 0:22:10/Hive性能优化及Hive3新特性Hive表设计优化Hive查询基本原理Hive的设计思想是通过元数据解析描述将HDFS上的文件映射成表基本的查询原理是当用户通过HQL语句对Hive中的表进行复杂数据处理和计算时，默认将其转换为分布式计算 MapReduce程序对HDFS中的数据进行读取处理的过程。分区表结构设计createtablet_all_hero_part(idint,name string,hp_maxint,mp_maxint,attack_maxint,defense_maxint,attack_range string,role_main string,role_assist string)partitionedby(role string)rowformat delimitedfieldsterminatedby"\t";-- 分区表   先基于分区过滤，再查询；基于分区扫描，避免全表扫描，大大提高查询效率；若查询时使用的不是分区字段，将无任何意义explainextendedselectcount(*)fromt_all_hero_partwhererole="sheshou"andhp_max&gt;6000;分桶表结构设计Hive中Join的问题默认情况下，Hive底层是通过MapReduce来实现的;MapReduce在处理数据之间join的时候有两种方式：MapJoin、ReduceJoin，其中MapJoin效率较高;如果有两张非常大的表要进行Join，底层无法使用MapJoin提高Join的性能，只能走默认的ReduceJoin;而ReduceJoin必须经过Shuffle过程，相对性能比较差，而且容易产生数据倾斜。分桶表设计如果有两张表按照相同的划分规则【比如按照Join的关联字段】将各自的数据进行划分;在Join时，就可以实现Bucket与Bucket的Join，避免不必要的比较，减少笛卡尔积数量。-- 开启分桶SMB(Sort-Merge-Bucket) joinsethive.optimize.bucketmapjoin=true;sethive.auto.convert.sortmerge.join=true;sethive.optimize.bucketmapjoin.sortedmerge=true;select*fromt_usa_covid19_bucket;-- 分桶表创建createtabletb_emp02(empno string,ename string,job string,managerid string,hiredate string,salarydouble,jiangjindouble,deptno string)clusteredby(deptno)sortedby(deptnoasc)into3bucketsrowformat delimitedfieldsterminatedby'\t';createtabletb_dept02(deptno string,dname string,loc string)clusteredby(deptno)sortedby(deptnoasc)into3bucketsrowformat delimitedfieldsterminatedby',';索引的设计及注意事项Hive中的索引在传统的关系型数据库例如MySQL、0racle中，为了提高数据的查询效率，可以为表中的字段单独构建索引，查询时，可以基于字段的索引快速的实现查询、过滤等操作。Hive中也同样提供了索引的设计,允许用户为字段构建索引，提高数据的査询效率，但是Hive的索引与关系型数据库中的索引并不相同，比如，Hive不支持主键或者外键索引。Hive索引可以建立在表中的某些列上，以提升一些操作的效率。在可以预见到分区数据非常庞大的情况下，分桶和索引常常是优于分区的；而分桶由于SMB Join对关联键（join字段）要求严格，所以并不是总能生效；注意：官方明确表示，索引功能支持是从Hive0.7版本开始，到Hive3.0不再支持。Hive中索引的基本原理​ 当为某张表的某个字段创建索引时，Hive中会自动创建一张索引表，该表记录了该字段的每个值与数据实际物理位置之间的关系，例如数据所在的HDFS文件地址，以及所在文件中偏移量offset等信息Hive索引目的​ 提高Hive表指定列的查询速度。没有索引时，类似WHERE tab1.col1 = 10的查询，Hive会加载整张表或分区，然后处理所有的行，但是如果在字段col1上面存在索引时，那么只会加载和处理文件的一部分。-- 为表中的userid构建索引createindexidx_user_id_loginontabletb_login_part(userid)-- 索引类型为Compact，Hive支持Compact和Bitmap类型，存储的索引内容不同as'COMPACT'-- 延迟构建索引withdeferred rebuild;-- 构建索引alterindexidx_user_id_loginontb_login_part rebuild;-- 查看索引结构descdefault__tb_login_part_idx_user_id_login__;-- 查看索引内容select*fromdefault__tb_login_part_idx_user_id_login__;Hive索引的问题Hive构建索引的过程是通过一个MapReduce程序来实现的每次Hive中原始数据表的数据发生更新时，索引表不会自动更新;必须手动执行一个alter index命令来实现通过MapReduce更新索引表，导致整体性能较差，维护相对繁琐实际工作场景中，一般不推荐使用HiveIndex，推荐使用0RC文件格式中的索引、物化视图来代替Hive Index提高查询性能。Hive表数据优化文件格式概述Hive数据存储的本质还是HDFS，所有的数据读写都基于HDFS的文件来实现;为了提高对HDFS文件读写的性能，Hive提供了多种文件存储格式：TextFile、SequenceFile、0RC、Parquet等不同的文件存储格式具有不同的存储特点，有的可以降低存储空间，有的可以提高查询性能。Hive的文件格式在建表时指定，默认是TextFile。官方文档：Apache Hive - Storage Formats除了文件格式TextFile可以额外使用load命令插入数据外，其余格式均只能采用insert+select动态插入数据文件格式-TextFileTextFile是Hive中默认的文件格式，存储形式为按行存储。工作中最常见的数据文件格式就是TextFile文件，几乎所有的原始数据生成都是TextFile格式，所以Hive设计时考虑到为了避免各种编码及数据错乱的问题，选用了TextFile作为默认的格式。建表时不指定存储格式即为TextFile，导入数据时把数据文件拷贝至HDFS不进行处理。文件格式-SequenceFileSequenceFile是Hadoop里用来存储序列化的键值对即二进制的一种文件格式。SequenceFile文件也可以作为MapReduce作业的输入和输出，hive也支持这种格式。文件格式-ParquetParquet是一种支持嵌套结构的列式存储文件格式，最早是由Twitter和Cloudera合作开发，2015年5月从Apache孵化器里毕业成为Apache顶级项目。是一种支持嵌套数据模型对的列式存储系统，作为大数据系统中0LAP查询的优化方案，它已经被多种查询引擎原生支持，并且部分高性能引擎将其作为默认的文件存储格式。通过数据编码和压缩，以及映射下推和谓词下推功能，Parquet的性能也较之其它文件格式有所提升。文件格式-ORC0RC(0ptimizedRc File)文件格式也是一种Hadoop生态圈中的列式存储格式；它的产生早在2013年初，最初产生自Apache Hive，用于降低Hadoop数据存储空间和加速Hive查询速度；2015年0RC项目被Apache项目基金会提升为Apache顶级项目。0RC不是一个单纯的列式存储格式，仍然是首先根据行组分割整个表，在每一个行组内进行按列存储。0RC文件是自描述的，它的元数据使用Protocol Buffers序列化，并且文件中的数据尽可能的压缩以降低存储空间的消耗，目前也被Hive、Spark SQL、Presto等查询引擎支持。数据压缩概述Hive底层运行llapReduce程序时，磁盘I/O操作、网络数据传输、shuffle和merge要花大量的时间，尤其是数据规模很大和工作负载密集的情况下，鉴于磁盘I/0和网络带宽是Hadoop的宝贵资源，数据压缩对于节省资源、最小化磁盘I/0和网络传输非常有帮助。Hive压缩实际上说的就是MapReduce的压缩。压缩的优点减小文件存储所占空间加快文件传输效率，从而提高系统的处理速度降低IO读写的次数压缩的缺点使用数据时需要先对文件解压，加重CPU负荷，压缩算法越复杂，解压时间越长Hive中压缩Hive中的压缩就是使用了Hadoop中的压缩实现的，所以Hadoop中支持的压缩在Hive中都可以直接使用。Hadoop中支持的压缩算法：要想在Hive中使用压缩，需要对MapReduce和Hive进行相应的配置。Hadoop中各种压缩算法性能对比Hive中压缩配置-- 开启hive中间传输数据压缩功能-- 1)开启hive中间传输数据压缩功能sethive.exec.compress.intermediate=true;-- 2)开启mapreduce中map输出压缩功能setmapreduce.map.output.compress=true;-- 3)设置mapreduce中map输出数据的压缩方式setmapreduce.map.output.compress.codec=org.apache.hadoop.io.compress.SnappyCodec;-- 开启Reduce输出阶段压缩-- 1)开启hive最终输出数据压缩功能sethive.exec.compress.output=true;-- 2)开启mapreduce最终输出数据压缩setmapreduce.output.fileoutputformat.compress=true;-- 3)设置mapreduce最终数据输出压缩方式setmapreduce.output.fileoutputformat.compress.codec=org.apache.hadoop.io.compress.SnappyCodec;-- 4)设置mapreduce最终数据输出压缩为块压缩setmapreduce.output.fileoutputformat.compress.type=BLOCK;Hive中压缩测试测试1：测试2：存储优化避免小文件生成Hive的存储本质还是HDFS，HDFS是d不利于小文件存储的，因为每个小文件会产生一条元数据信息，并且不利用MapReduce的处理，MapReduce中每个小文件会启动一个MapTask计算处理，导致资源的浪费，所以在使用Hive进行处理分析时，要尽量避免小文件的生成。Hive中提供了一个特殊的机制，可以自动的判断是否是小文件，如果是小文件可以自动将小文件进行合并。-- 如果hive的程序，只有maptask，将MapTask产生的所有小文件进行合并sethive.merge.mapfiles=true;-- 如果hive的程序，有Map和ReduceTask,将ReduceTask产生的所有小文件进行合并sethive.merge.mapredfiles=true;-- 每一个合并的文件的大小(244M)sethive.merge.size.per.task=256000000-- 平均每个文件的大小，如果小于这个值就会进行合并(15M)sethive.merge.smallfiles.avgsize=16000000;合并小文件如果遇到数据处理的输入是小文件的情况，怎么解决呢？Hive中也提供一种输入类CombineHiveInputFormat，用于将小文件合并以后，再进行处理。-- 设置Hive中底层MapReduce读取数据的输入类：将所有文件合并为一个大文件作为输入sethive.input.format=org.apache.hadoop.hive.gl.io.CombineHiveInputFormat;ORC文件索引在使用ORC文件时，为了加快读取0RC文件中的数据内容，0RC提供了两种索引机制：Row Group Index和Bloom Filter Index可以帮助提高查询0RC文件的性能。当用户写入数据时，可以指定构建索引当用户查询数据时，可以根据索引提前对数据进行过滤，避免不必要的数据扫描。Row Group Index一个ORC文件包含一个或多个stripes(groups ofrow data)，每个stripe中包含了每个column的min/max值的索引数据;当查询中有大于等于小于的操作时，会根据min/max值，跳过扫描不包含的stripes。而其中为每个stripe建立的包含min/max值的索引，就称为Row Group Index行组索引，也叫min-maxIndex大小对比索引，或者Storage Index。建立ORC格式表时，指定表参数orc.create.index=true之后，便会建立Row Group Index；为了使Row Group Index有效利用，向表中加载数据时，必须对需要使用索引的字段进行排序Bloom Filter Index建表时候通过表参数orc.bloom.fllter.columns=columnName...来指定为哪些字段建立BloomFilter索引，在生成数据的时候，会在每个stripe中，为该字段建立BloomFilter的数据结构;当查询条件中包含对该字段的等值过滤时候，先从BloomFilter中获取以下是否包含该值，如果不包含，则跳过该stripe。ORC矢量化查询Hive的默认查询执行引擎一次处理一行，而矢量化査询执行是一种Hive针对ORC文件操作的特性，目的是按照每批1024行读取数据，并且一次性对整个记录整合（而不是对单条记录）应用操作，提升了像过滤、联合、聚合等等操作的性能。注意：要使用矢量化查询执行，就必须以ORC格式存储数据。-- 开启矢量化查询sethive.vectorized.execution.enabled=true;sethive.vectorized.execution.reduce.enabled=true;Job作业执行优化Explain查询计划HiveQL是一种类SQL的语言，从编程语言规范来说是一种声明式语言，用户会根据査询需求提交声明式的HQL查询而Hive会根据底层计算引警将其转化成Mapreduce/Tez/Spark的job;explain命令可以帮助用户了解一条HQL语句在底层的实现过程。通俗来说就是Hive打算如何去做这件事。explain会解析HQL语句，将整个HQL语句的实现步骤、依赖关系、实现过程都会进行解析返回,可以了解一条HQL语句在底层是如何实现数据的查询及处理的过程，辅助用户对Hive进行优化。官网：https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Explain常用语法命令如下：EXPLAIN[FORMATTED|EXTENDED|DEPENDENCY|AUTHORIZATION]queryFORMATTED：对执行计划进行格式化，返回JSON格式的执行计划EXTENDED：提供一些额外的信息，比如文件的路径信息DEPENDENCY：以JSON格式返回查询所依赖的表和分区的列表AUTHORIZATION：列出需要被授权的条目，包括输入与输出每个查询计划由以下几个部分组成The Abstract Syntax Tree for the query抽象语法树(AST):Hive使用Antlr解析生成器，可以自动地将HQL生成为抽象语法树The dependencies between the different stages of the planStage依赖关系:会列出运行查询划分的stage阶段以及之间的依赖关系The description of each of the stagesStage内容:包含了每个stage非常重要的信息，比如运行时的operator和sort orders等具体的信息示例：explainselectcount(*)ascntfromtb_empwheredeptno='10';MapReduce属性优化本地模式使用Hive的过程中，有一些数据量不大的表也会转换为MapReduce处理，提交到集群时，需要申请资源，等待资源分配，启动J进程，再运行Task，一系列的过程比较繁琐，本身数据量并不大，提交到YARN运行返回会导致性能较差的问题。Hive为了解决这个问题，延用了MapReduce中的设计，提供本地计算模式，允许程序不提交给YARN，直接在本地运行，以便于提高小数据量程序的性能。开启本地模式-- 开启本地模式sethive.exec.mode.local.auto=true;JVM重用Hadoop默认会为每个Task启动一个JVM来运行，而在JVM启动时内存开销大;Job数据量大的情况，如果单个Task数据量比较小，也会申请JVM，这就导致了资源紧张及浪费的情况;JVM重用可以使得JVM实例在同一个job中重新使用N次，当一个Task运行结束以后，IM不会进行释放，而是继续供下一个Task运行，直到运行了N个Task以后，就会释放;N的值可以在Hadoop的mapred-site.xml文件中进行配置，通常在10-20之间。-- Hadoop3之前的配置，在mapred-site.xml中添加以下参数-- Hadoop3中已不再支持该选项mapreduce.job.jvm.numtasks=10并行执行Hive在实现HQL计算运行时，会解析为多个Stage，有时候Stage彼此之间有依赖关系，只能挨个执行，但是在一些别的场景下，很多的Stage之间是没有依赖关系的；例如Union语句，Join语句等等，这些Stage没有依赖关系，但是Hive依旧默认挨个执行每个Stage，这样会导致性能非常差，我们可以通过修改参数，开启并行执行，当多个Stage之间没有依赖关系时，允许多个Stage并行执行，提高性能。-- 开启Stage并行化，默认为falseSEThive.exec.parallel=true;-- 指定并行化线程数，默认为8SEThive.exec.parallel.thread.number=16;Join查询优化Join是数据分析处理过程中必不可少的操作，Hive同样支持Join的语法;Hive Join的底层是通过MapReduce来实现的，Hive实现Join时，为了提高MapReduce的性能，提供了多种Join方案来实现;例如适合小表Join大表的Map Join，大表Join大表的Reduce Join，以及大表Join的优化方案Bucket Join等。Map Join应用场景：适合于小表join大表或者小表Join小表原理：将小的那份数据给每个MapTask的内存都放一份完整的数据，大的数据每个部分都可以与小数据的完整数据进行join；底层不需要经过shuffle，需要占用内存空间存放小的数据文件使用：尽量使用Map Join来实现Join过程，Hive中默认自动开启了Map Join：hive.auto.convert.join=trueHive中小表的大小限制-- 2.0版本之前的控制属性hive.mapjoin.smalltable.filesize=25M-- 2.0版本开始由以下参数控制hive.auto.convert.join.noconditionaltask.size=512000000Reduce Join应用场景：适合于大表join大表原理：将两张表的数据在shuffle阶段利用shuffle的分组来将数据按照关联字段进行合并；必须经过shuffle，利用Shuffle过程中的分组来实现关联使用：Hive会自动判断是否满足Map Join，如果不满足Map Join，则自动执行Reduce JoinBucket Join应用场景：适合于大表Join大表原理：将两张表按照相同的规则将数据划分，根据对应的规则的数据进行join，减少了比较次数，提高了性能使用Bucket Join语法：clustered by colName参数：set hive.optimize.bucketmapjoin = true;要求：分桶字段 = Join字段，桶的个数相等或者成倍数使用Sort Merge Bucket Join(SMB)基于有序的数据Join语法：clustered by colName sorted by(colName)参数set hive.optimize.bucketmapjoin = true, set hive.auto.convert.sortmerge.join=true, set hive.optimize.bucketmapjoin.sortedmerge = true; set hive.auto.convert.sortmerge.join.noconditionaltask=true;要求：分桶字段=Join字段=排序字段，桶的个数相等或者成倍数优化器关联优化当一个程序中如果有一些操作彼此之间有关联性，是可以在一个MapReduce中实现的，但是Hive会不智能的选择，Hive会使用两个MapReduce来完成这两个操作。例如：当我们执行 select. from table group by id order by id desc。该SQL语句转换为MapReduce时我们可以有两种方案来实现：方案一第一个MapReduce做group by，经过shuffle阶段对id做分组第二个MapReduce对第一个MapReduce的结果做order by，经过shuffle阶段对id进行排序方案二因为都是对id处理，可以使用一个MapReduce的shuffle既可以做分组也可以排序在这种场景下，Hive会默认选择用第一种方案来实现，这样会导致性能相对较差；可以在Hive中开启关联优化，对有关联关系的操作进行解析时，可以尽量放在同一个MapReduce中实现。配置：set hive.optimize.correlation=true;优化器引擎Hive默认的优化器在解析一些聚合统计类的处理时，底层解析的方案有时候不是最佳的方案。例如当前有一张表【共1000条数据】，id构建了索引，id =100值有900条需求：查询所有id =100的数据，SQL语句为：select * from table where id = 100;方案一由于id这一列构建了索引，索引默认的优化器引擎RBO，会选择先从索引中査询id = 100的值所在的位置，再根据索引记录位置去读取对应的数据，但是这并不是最佳的执行方案。方案二有id=100的值有900条，占了总数据的90%，这时候是没有必要检索索引以后再检索数据的，可以直接检索数据返回，这样的效率会更高，更节省资源，这种方式就是CBO优化器引擎会选择的方案。CBO优化器RBO：rule basic optimise，基于规则的优化器，根据设定好的规则来对程序进行优化CBO：cost basic optimise，基于代价的优化器，根据不同场景所需要付出的代价来合适选择优化的方案对数据的分布的信息【数值出现的次数，条数，分布】来综合判断用哪种处理的方案是最佳方案Hive中支持RBO与CBO这两种引擎，默认使用的是RBO优化器引擎。很明显CBO引擎更加智能，所以在使用Hive时，我们可以配置底层的优化器引擎为CBO引擎set hive.cbo.enable=true;set hive.compute.query.using.stats=true;set hive.stats.fetch.column.stats=true;CBO引擎是基于代价的优化引擎，那么CBO如何知道每种方案的计算代价的呢 ?答：如下的分析器。Analyze分析器功能：用于提前运行一个MapReduce程序将表或者分区的信息构建一些元数据【表的信息、分区信息、列的信息】，搭配CBO引擎一起使用。语法：示例：-- Analyze分析优化器analyzetabletb_emp02computestatistics;analyzetabletb_emp02computestatisticsforcolumnsempno;descformatted tb_emp02 empno;谓词下推（PPD）谓词：用来描述或判定客体性质、特征或者客体之间关系的词项。比如"3 大于 2"中"大于"是一个谓词。谓词下推Predicate Pushdow(PPD)基本思想：将过滤表达式尽可能移动至靠近数据源的位置，以使真正执行时能直接跳过无关的数据。简单点说就是在不影响最终结果的情况下，尽量将过滤条件提前执行。Hive中谓词下推后，过滤条件会下推到map端，提前执行过滤，减少map到reduce的传输数据，提升整体性能。开启参数【默认开启】：hive.optimize.ppd=true;例子：推荐形式1的方式，先过滤再join。规则1、对于Join(Inner Join)、Full outer Join，条件写在on后面，还是where后面，性能上面没有区别；2、对于Left outer Join，右侧的表写在on后面、左侧的表写在where后面，性能上有提高；3、对Right outer Join，左侧的表写在on后面、右侧的表写在where后面，性能上有提高；4、当条件分散在两个表时，谓词下推可按上述结论2和3自由组合。数据倾斜分布式计算中最常见的，最容易遇到的问题就是数据倾斜；数据倾斜的现象是，当提交运行一个程序时，这个程序的大多数的Task都已经运行结束了，只有某一个 Task一直在运行，迟迟不能结束，导致整体的进度卡在99%或者100%，这时候就可以判定程序出现了数据倾斜的问题。数据倾斜的原因：数据分配。Group By倾斜优化当程序中出现group by或者count(distinct)等分组聚合的场景时，如果数据本身是倾斜的，根据MapReduce的Hash分区规则，肯定会出现数据倾斜的现象。根本原因是因为分区规则导致的，所以可以通过以下几种方案来解决group by导致的数据倾斜的问题方案一：开启Map端聚合hive.map.aggr=true;通过减少shuffle数据量和Reducer阶段的执行时间，避免每个Task数据差异过大导致数据倾斜方案二：实现随机分区select * from table distribute by rand();distribute by用于指定底层按照哪个字段作为Key实现分区、分组等通过rank函数随机值实现随机分区，避免数据倾斜方案三：数据倾斜时自动负载均衡hive.groupby.skewindata=true;开启该参数以后，当前程序会自动通过两个MapReduce来运行第一个MapReduce自动进行随机分布到Reducer中，每个Reducer做部分聚合操作，输出结果第二个MlapReduce将上一步聚合的结果再按照业务(group by key)进行处理，保证相同的分布到一起，最终聚合得到结果Join倾斜优化Join操作时，如果两张表比较大，无法实现Map Join，只能走Reduce Join，那么当关联字段中某一种值 过多的时候依旧会导致数据倾斜的问题面对Join产生的数据倾斜，核心的思想是尽量避免Reduce Join的产生，优先使用Map Join来实现；但往往很多的Join场景不满足Map Join的需求，那么可以以下几种方案来解决Join产生的数据倾斜问题方案一：提前过滤，将大数据变成小数据，实现Map Join方案二：使用Bucket Join如果使用方案一，过滤后的数据依旧是一张大表，那么最后的Join依旧是一个Reduce Join这种场景下，可以将两张表的数据构建为桶表，实现Bucket Map Join，避免数据倾斜方案三：使用Skew JoinSkew Join是Hive中一种专门为了避免数据倾斜而设计的特殊的Join过程这种Join的原理是将Map Join和Reduce Join进行合并，如果某个值出现了数据倾斜，就会将产生数据倾斜的数据单独使用Map Join来实现其他没有产生数据倾斜的数据由Reduce Join来实现，这样就避免了Reduce Join中产生数据倾斜的问题最终将Map Join的结果和Reduce Join的结果进行Union合并开启配置：-- 开启运行过程中skewjoinsethive.optimize.skewjoin=true,-- 如果这个key的出现的次数超过这个范围sethive.skewjoin.key=100000.-- 在编译时判断是否会产生数据倾斜sethive.optimize.skewjoin.compiletime=true;-- 不合并，提升性能sethive.optimize.union.remove=true;-- 如果Hive的底层走的是MapReduce，必须开启这个属性，才能实现不合并setmapreduce.input.fileinputformat.input.dir.recursive=true;Hive3新特性执行引擎Hive执行引擎Hive底层的计算由分布式计算框架实现，目前支持三种计算引擎，分别是MapReduce、Tez、Spark。Hive中默认的计算引擎是MapReduce，由hive.execution.engine参数属性控制。Hive从2.x版本开始就提示不推荐使用MR，未来的版本可能不能使用了，推荐使用Tez或者Spark引擎来代替MapReduce计算。如果依旧要使用MapReduce，需要使用Hive的1.x版本。通过实测发现，当下Hive3.1.2版本默认引擎依然是MapReduce。在实际使用Hive的过程中，建议将Hive的底层计算引擎更改为Tez或者Spark引擎。Hive On TezTez是Apache社区中的一种支持DAG作业的开源计算框架；可以将多个有依赖的作业转换为一个作业从而大幅提升DAG作业的性能，最终Tez也会将程序提交给YARN来实现运行。Tez并不直接面向最终用户，事实上它允许开发者为最终用户构建性能更快、扩展性更好的应用程序。Tezt特点：灵活的数据流定义灵活的输入、输出、运行时模型与数据类型无关部署方便简洁高性能执行:最佳资源管理计划配置动态更新动态物理数据流决策官网:http://tez.apache.org/Tez整体的执行过程如图所示：Hive编译SQLTez执行查询YARN分配资源，支撑Tez执行Hive表数据文件默认存储在HDFSTez执行完毕返回查询结果给Hive（1）Tez下载目前官方http://archive.apache.org/dist/tez/最新版本为0.9系列版本，0.9系列版本为针对Hadoop2.x系列的版本，我们使用的Hadoop为3.x版本，可以使用GitHub中已发布的0.10版本的tez。（2）Tez编译0.10不是正式版本，针对Hadoop3需要单独手动编译、可以使用提前编译好的安装包，也可以参考编译文档进行编译。【可参考末尾资料】编译结果如下：（3）Tez安装编译完成之后，提取Tez的安装包进行安装，并在Hadoop中和Hive中配置【可参考末尾资料】tez-0.10.1-SNAPSHOT-minimal.tar.gz：程序安装包tez-0.10.1-SNAPSHOT.tar.gz：程序依赖包相关资料下载：https://pan.baidu.com/s/1IzsMte_sCj2zaFqfxyw_Hg 提取码: hdq5-- 设置执行引擎为Tezsethive.execution.engine=tez;sethive.tez.container.size=1024;如果想一直使用tez执行 可以把上述参数添加在hive-site.xml中：&lt;property&gt;&lt;name&gt;hive.execution.engine&lt;/name&gt;&lt;value&gt;tez&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;hive.tez.container.size&lt;/name&gt;&lt;value&gt;1024&lt;/value&gt;&lt;/property&gt;LLAP特性更新LLAP是hive 2.0版本就引入的特性，在Hive 3中与Tez集成的应用更加成熟Hive官方称之为实时长期处理(Live long and process)，实现将数据预取、缓存到基于yarn运行的守护进程中，降低和减少系统IO和与HDFS DataNode的交互，以提高程序的性能，LLAP 目前只支持tez引擎。LLAP提供了一种混合执行模型。它由一个长期存在的守护进程(该守护进程替换了与 HDFS DataNode 的直接交互)以及一个紧密集成的基于 DAG 的框架组成。诸如缓存，预取，某些查询处理和访问控制之类的功能已移至守护程序中。此守护程序直接直接处理小/短查询，而任何繁重的工作都将在标准 YARN 容器中执行。与DataNode相似，LLAP 守护程序也可以由其他应用程序使用。Tez AM 统筹整体执行，查询的初始阶段被推送到 LLAP 中，在还原阶段，将在单独的容器中执行大型Shuffle，多个查询和应用程序可以同时访问 LLAP。LLAP 在现有的Hive基于流程的执行中工作，以保持ive的可伸缩性和多功能性。它不会替代现有的执行模型，而是对其进行了增强。它有如下的几个特点:LLAP守护程序是可选的Hive可以在没有LLAP的情况下工作，并且即使已经部署并启动运行LLAP也可以绕过不执行LLAP不是执行引擎不同于MapReduce 或 Tez，整个执行由现有的 Hive 执行引擎(例如 Tez)在 LLAP 节点以及常规容器上透明地调度和监控。显然，LLAP的支持级别取决于单独的执行引擎。不计划支持 MapReduce，但以后可能会添加其他引擎，例如Pig等其他框架也可以选择使用 LLAP 守护程序。部分执行LLAP守护程序执行的工作结果可以构成 Hive 查询结果的一部分资源源ManagementYARN仍然负责资源的管理和分配Hive3增强了在多租户场景下的LLAP负载管理，主要通过resource plan的方式进行实现划分LLAP资源为多个pool，比如dept_A池、dept_B池和其他池;自动映射applications到对应的池可以设置触发条件，实现自动从一个池到另一个池，比如自动把长时间运行的application移动到其它池可以根据需要启用/禁用这些资源池Metastore独立模式Hive中的所有对象如数据库、表、函数等，他们的定义都叫做metadata元数据。metastore是元数据存储服务，用于操作访问元数据。Hive或者其他执行引擎在运行时会使用这些元数据来决定如何解析、授权和有效地执行用户查询metadata元数据可以存储配置为嵌入式的Apache Derby RDBMS或连接到外部RDBMS。Metastore本身可以完全嵌入到用户进程中，也可以作为服务运行，供其他进程连接从Hive 3.0开始，Metastore可以在不安装Hive其他部分的情况下单独运行，作为一个单独的发行版提供，用于实现允许其他非Hive的系统，例如Spark、Impala等轻松地与Metastore集成。目前来说为了方便起见，依旧建议将Metastore放在Hive中，一起安装部署。从Hive 3.0开始，Metastore作为一个单独的包发布，可以在没有Hive其他部分的情况下运行。这称为独立模式。但是在默认情况下Metastore配置为与Hive一起使用，因此在这个配置中需要修改一些配置参数。要使Metastore成为一个独立的服务,需要修改大量的参数，目前Hive官方为了最大限度地向后兼容，所有旧的配置参数仍然有效。Hive的Metastore服务将读取metastore-site.xml，同时也会从Hive的配置文件目录中读取hive-site.xml或者hive-memstoresite.xml女件配置参数后，可以使用start-metastore.sh来启动metastore服务。安装metastore独立安装包修改metastore配置文件conf/metastore-site.xml添加hive-site.xml以及MySQL连接驱动删除冲突guava19包，添加Hive中的guava27包启动独立metastorehttp://www.ppmy.cn/news/1541495.html相关文章RabbitMQ进阶_可靠性文章目录 一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback 二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化 2.2、 …阅读更多...HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:11 +0000</pubDate>
    </item>
    <item>
      <title>RabbitMQ进阶_可靠性</title>
      <link>https://www.ppmy.cn/news/1541494.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维RabbitMQ进阶_可靠性news/2025/11/4 0:22:09/文章目录一、 发送者的可靠性1.1、 生产者重试机制1.2、 生产者确认机制1.2.1、确认机制理论1.2.2、确认机制实现1.2.2.1、定义ReturnCallback1.2.2.2、定义ConfirmCallback二、 MQ的可靠性2.1、 数据持久化2.1.1、 交换机持久化2.1.2、 队列持久化2.1.3、 消息持久化2.2、 LazyQueue三、 消费者的可靠性3.1、 消费者确认机制3.2、 失败重试机制3.3、 失败处理策略3.4、 业务幂等性3.4.1、 唯一消息ID3.4.2、 业务判断3.5、 兜底方案消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：消息从生产者到消费者的每一步都可能导致消息丢失：1.发送消息时丢失生产者发送消息时连接MQ失败。生产者发送消息到达MQ后未找到Exchange。生产者发送消息到达MQ的Exchange后，未找到合适的Queue。消息到达MQ后，处理消息的进程发生异常。2.MQ导致消息丢失消息到达MQ，保存到队列后，尚未消费就突然宕机。3.消费者处理消息时消息接收后尚未处理突然宕机。消息接收后处理过程中抛出异常。综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：确保生产者一定把消息发送到MQ。确保MQ不会将消息弄丢。确保消费者一定要处理消息。一、 发送者的可靠性1.1、 生产者重试机制生产者发送消息时，出现了网络故障，导致与MQ的连接中断。为了解决这个问题，SpringAMQP提供了消息发送时的重试机制。即：当RabbitTemplate与MQ连接超时后，多次重试，可以在配置文件中添加如下配置：spring:rabbitmq:connection-timeout:1s# 设置MQ的连接超时时间template:retry:enabled:true# 开启超时重试机制initial-interval:1000ms# 失败后的初始等待时间multiplier:1# 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multipliermax-attempts:3# 最大重试次数当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的，无法执行后面逻辑。如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。1.2、 生产者确认机制1.2.1、确认机制理论一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：MQ内部处理消息的进程发生了异常。生产者发送消息到达MQ后未找到Exchange。生产者发送消息到达MQ的Exchange后，未找到合适的Queue，因此无法路由。针对上述情况，RabbitMQ提供了生产者消息确认机制，包括Publisher Confirm和Publisher Return两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执：总结如下：当消息投递到MQ，但是路由失败时，通过Publisher Return返回异常信息，同时返回ack的确认信息，代表投递成功（图中的exchange2，一般情况下路由失败都是由开发人员编码导致的，所以一般不用开启此机制）。临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功（图中queue1）。持久消息投递到了MQ，并且入队完成持久化(保存到磁盘，图中queue2)，返回ACK ，告知投递成功。其它情况都会返回NACK，告知投递失败（实际开发中，如果业务场景对可靠性有较高要求，只关注返回nack的情况即可，可以采取重新发送等方式）。其中ack和nack属于Publisher Confirm机制，ack是投递成功，nack是投递失败。而return则属于Publisher Return机制。默认两种机制都是关闭状态，需要通过配置文件来开启。1.2.2、确认机制实现开启生产者确认：spring:rabbitmq:publisher-confirm-type:correlated# 开启publisher confirm机制，并设置confirm类型publisher-returns:true# 开启publisher return机制这里publisher-confirm-type有三种模式可选：none：关闭confirm机制。simple：同步阻塞等待MQ的回执。correlated：MQ异步回调返回回执。一般我们推荐使用correlated回调机制。1.2.2.1、定义ReturnCallback每个RabbitTemplate只能配置一个ReturnCallback，因此我们可以在配置类中统一设置：@Slf4j@AllArgsConstructor@ConfigurationpublicclassMqConfig{privatefinalRabbitTemplaterabbitTemplate;@PostConstructpublicvoidinit(){rabbitTemplate.setReturnsCallback(newRabbitTemplate.ReturnsCallback(){@OverridepublicvoidreturnedMessage(ReturnedMessagereturned){log.error("触发return callback,");log.debug("exchange: {}",returned.getExchange());log.debug("routingKey: {}",returned.getRoutingKey());log.debug("message: {}",returned.getMessage());log.debug("replyCode: {}",returned.getReplyCode());log.debug("replyText: {}",returned.getReplyText());}});}}1.2.2.2、定义ConfirmCallback由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数CorrelationData：CorrelationData中包含两个核心的东西：id：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆SettableListenableFuture：回执结果的Future对象将来MQ的回执就会通过这个Future来返回，我们可以提前给CorrelationData中的Future添加回调函数来处理消息回执：@TestvoidtestPublisherConfirm(){// 1.创建CorrelationDataCorrelationDatacd=newCorrelationData();// 2.给Future添加ConfirmCallbackcd.getFuture().addCallback(newListenableFutureCallback&lt;CorrelationData.Confirm&gt;(){@OverridepublicvoidonFailure(Throwableex){// 2.1.Future发生异常时的处理逻辑，基本不会触发log.error("send message fail",ex);}@OverridepublicvoidonSuccess(CorrelationData.Confirmresult){// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容if(result.isAck()){// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执log.debug("发送消息成功，收到 ack!");}else{// result.getReason()，String类型，返回nack时的异常描述log.error("发送消息失败，收到 nack, reason : {}",result.getReason());}}});// 3.发送消息rabbitTemplate.convertAndSend("hmall.direct","q","hello",cd);}注意：开启生产者确认比较消耗MQ性能，一般不建议开启。路由失败：一般是因为RoutingKey错误导致，往往是编程导致。交换机名称错误：同样是编程错误导致。MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。二、 MQ的可靠性在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟消息。这样就会导致两个问题：一旦MQ宕机，内存中的消息就会丢失。内存空间有限，当消费者故障或者处理过慢时，会导致消息积压，引发MQ阻塞。针对以上两种问题，可以分别采用数据持久化和LazyQueue的解决办法。2.1、 数据持久化为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，可以配置数据持久化（这个是MQ3.6之前使用的方式），包括：交换机持久化队列持久化消息持久化我们以控制台界面为例来说明。2.1.1、 交换机持久化在控制台的Exchanges页面，添加交换机时可以配置交换机的Durability参数：2.1.2、 队列持久化在控制台的Queues页面，添加队列时，同样可以配置队列的Durability参数：2.1.3、 消息持久化在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个properties：delivery_mode注意：使用spring发送消息到MQ时，这几个持久化都是默认的。在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。2.2、 LazyQueue在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：消费者宕机或出现网络故障。消息发送量激增，超过了消费者处理速度。消费者处理业务发生阻塞。一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为PageOut。PageOut会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：接收到消息后直接存入磁盘而非内存。消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）。支持数百万条的消息存储。而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。如果版本较老，可以：@RabbitListener(queuesToDeclare=@Queue(name="lazy.queue",durable="true",arguments=@Argument(name="x-queue-mode",value="lazy")))publicvoidlistenLazyQueue(Stringmsg){log.info("接收到 lazy.queue的消息：{}",msg);}三、 消费者的可靠性当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：消息投递的过程中出现了网络故障。消费者接收到消息后突然宕机。消费者接收到消息后，因处理不当导致异常。…一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态。3.1、 消费者确认机制为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：ack：成功处理消息，RabbitMQ从队列中删除该消息。nack：消息处理失败，RabbitMQ需要再次投递消息。reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息。一般reject方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过try catch机制捕获，消息处理成功时返回ack，处理失败时返回nack。由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：none：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用。manual：手动模式。需要自己在业务代码中调用api，发送ack或reject，存在业务入侵，但更灵活。auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回ack.。当业务出现异常时，根据异常判断返回不同结果：如果是业务异常，会自动返回nack。如果是消息处理或校验异常，自动返回reject。通过下面的配置可以修改SpringAMQP的ACK处理方式：spring:rabbitmq:listener:simple:acknowledge-mode:none# 不做处理3.2、 失败重试机制当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力。当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况，Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。修改consumer服务的application.yml文件，添加内容：spring:rabbitmq:listener:simple:retry:enabled:true# 开启消费者失败重试initial-interval:1000ms# 初识的失败等待时长为1秒multiplier:1# 失败的等待时长倍数，下次等待时长 = multiplier * last-intervalmax-attempts:3# 最大重试次数stateless:true# true无状态；false有状态。如果业务中包含事务，这里改为false重启consumer服务，重复之前的测试。可以发现：消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次。本地重试3次以后，抛出了AmqpRejectAndDontRequeueException异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是reject。结论：开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试。重试达到最大次数后，Spring会返回reject，消息会被丢弃。3.3、 失败处理策略在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由MessageRecovery接口来定义的，它有3个不同实现：RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式 。ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 。RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机 。比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。其实后面这部分在实际业务开发中还是很有用的。在实际工作中存在kafka to ES的场景，有时会出现同一作业并行跑的异常，这时就需要保证业务幂等性了，这种场景下用的是唯一ID的解决方案。另外也有定时任务跑批作业的场景，有时由于数据异常等原因导致本批次失败，就需要由调度作业跑下一次，是采用业务逻辑保证业务幂等性的。兜底方案在实际开发中也有用到，有时业务数据来源非联机，中间经过数据组处理后才回到我们系统，有时会存在数据准确度的延迟问题，这时也需要有“补偿作业”主动联机获取数据，并更新到我们系统中。3.4、 业务幂等性幂等是一个数学概念，用函数表达式来描述是这样的：f(x) = f(f(x))，例如求绝对值函数。在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：根据id删除数据查询数据新增数据但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况。退款业务。重复退款对商家而言会有经济损失。然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：页面卡顿时频繁刷新导致表单重复提交。服务间调用的重试。MQ消息的重复投递。我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。举例：假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为已支付状态。由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后重新投递给交易服务。但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了已退款状态。退款完成后，新投递的消息才被消费，那么订单状态会被再次改为已支付。业务异常。因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：唯一消息ID业务状态判断3.4.1、 唯一消息ID这个思路非常简单：每一条消息都生成一个唯一的id，与消息一起投递给消费者。消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。我们该如何给消息添加唯一ID呢？其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。以Jackson的消息转换器为例：@BeanpublicMessageConvertermessageConverter(){// 1.定义消息转换器Jackson2JsonMessageConverterjjmc=newJackson2JsonMessageConverter();// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息jjmc.setCreateMessageIds(true);returnjjmc;}3.4.2、 业务判断业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。可以用下面的SQL来解释业务判断的实现逻辑：UPDATE`order`SETstatus=?,pay_time=?WHEREid=?ANDstatus=1在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。3.5、 兜底方案虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？有没有其它兜底方案，能够确保订单的支付状态一致呢？其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己主动去查询支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。那么问题来了，我们到底该在什么时间主动查询支付状态呢？这个时间是无法确定的，因此，通常我们采取的措施就是利用定时任务定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。综上，支付服务与交易服务之间的订单状态一致性是如何保证的？首先，支付服务会在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。http://www.ppmy.cn/news/1541494.html相关文章HTTP安全么？如何更好的保护您的网站在互联网飞速发展的今天&amp;#xff0c;网络安全问题日益严峻。HTTP作为最常见的网络通信协议&amp;#xff0c;虽然在传输效率方面表现优异&amp;#xff0c;但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时&amp;#xff0c;可能忽视了其中潜在的风险。那么&amp;#xff0c;…阅读更多...kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:09 +0000</pubDate>
    </item>
    <item>
      <title>HTTP安全么？如何更好的保护您的网站</title>
      <link>https://www.ppmy.cn/news/1541493.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维HTTP安全么？如何更好的保护您的网站news/2025/11/4 0:22:08/在互联网飞速发展的今天，网络安全问题日益严峻。HTTP作为最常见的网络通信协议，虽然在传输效率方面表现优异，但其安全性却常常令人担忧。许多企业和个人网站在使用HTTP进行数据传输时，可能忽视了其中潜在的风险。那么，HTTP真的安全吗？我们应该采取哪些措施来更好地保护自己的网站呢？HTTP的安全性问题HTTP（HyperText Transfer Protocol）是互联网中最常见的协议，用于网页浏览器和服务器之间的数据交换。然而，它的最大弱点是数据传输时没有加密。这意味着在网络上传输的数据可以被黑客轻易拦截、篡改或盗取，尤其是在公共Wi-Fi环境下，风险更是成倍增加。例如，用户的登录信息、敏感文件或财务数据都有可能在HTTP传输过程中被恶意攻击者截获。相比之下，HTTPS则是HTTP的安全版，通过SSL/TLS加密层确保数据在传输过程中的安全。HTTPS不仅可以防止数据被篡改，还能验证服务器的身份，防止钓鱼攻击。因此，从安全的角度来看，HTTP确实存在较大的隐患。HTTP和HTTPS的对比为了更清晰地理解HTTP和HTTPS的区别，我们可以通过以下几个方面进行对比：数据加密：HTTP传输的数据是明文的，而HTTPS使用了SSL/TLS协议来加密数据，即使黑客拦截了通信数据，也无法轻易解密。身份验证：HTTP无法验证通信双方的身份，而HTTPS通过数字证书来确保访问的是合法的服务器，减少钓鱼攻击风险。SEO优化：搜索引擎如Google更倾向于HTTPS网站，使用HTTPS的网站在排名上有明显的优势。因此，从SEO的角度来说，HTTPS也更有利。由此可见，HTTPS在各个方面都比HTTP更具优势，尤其在当前安全需求日益增加的背景下，选择HTTPS已经成为主流。WAF：为您的网站提供额外的安全层即便我们知道HTTPS可以提高网站的安全性，但面对日益复杂的网络攻击，仅仅依赖HTTPS可能还不足以完全防御各种威胁。特别是对于中小型网站，频繁的DDoS攻击、SQL注入、跨站脚本攻击等，依然是无法忽视的安全隐患。这时，云WAF（Web应用防火墙）便成为保护网站的另一道重要屏障。云WAF通过对网络流量进行智能分析，实时检测并拦截恶意请求，帮助企业和个人网站应对各种常见的网络攻击。相比传统的安全方案，云WAF不仅能够自动更新防护规则，还能根据不同用户的需求灵活扩展防护策略。这对于那些无法投入大量资源搭建安全体系的中小企业来说，尤为重要。目前，市面上有很多WAF服务商，但并不是所有的WAF都适合每个网站。尤其对于初创企业或个人站长来说，选择一个合适的、性价比高的WAF至关重要。与一些收费的云WAF服务不同，我们的WAF服务提供免费接入，让您无需担心高昂的安全成本。同时，我们的WAF还具备以下几点优势：快速接入：仅需简单几步，您即可将网站接入云WAF，享受实时防护。灵活扩展：根据您的业务增长，我们的WAF服务可以轻松升级，满足日益复杂的安全需求。自动更新防护规则：我们持续监控最新的网络安全威胁，并及时更新防护规则，确保您的网站免受新型攻击。通过免费的WAF服务，您不仅可以有效提高网站的安全性，还能将更多资源用于业务的扩展和优化。总结HTTP虽然在网络通信中使用广泛，但其安全性并不足以应对当前多变的网络威胁。HTTPS和WAF的结合能够为您的网站提供更全面的防护，确保数据的安全传输以及网站的正常运行。如果您还在担忧网站的安全问题，不妨尝试使用免费的云WAF，为您的网站保驾护航。HTTP安全吗？或许在一些低风险场景中可以勉强接受，但为了更好地保护您的业务和用户，升级为HTTPS并搭配云WAF，才是最为稳妥的选择。http://www.ppmy.cn/news/1541493.html相关文章kafka自定义配置信息踩坑org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer 
场景描述&amp;#xff1a; 单个kafka使用springboot框架自带的 yml 配置完全OK&amp;#xff08;因为底层会帮我们处理好类…阅读更多...探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:08 +0000</pubDate>
    </item>
    <item>
      <title>kafka自定义配置信息踩坑</title>
      <link>https://www.ppmy.cn/news/1541492.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维kafka自定义配置信息踩坑news/2025/11/4 0:22:08/org.apache.kafka.common.config.ConfigException: Invalid value 0 for configuration acks: Expected value to be a string, but it was a java.lang.Integer场景描述：单个kafka使用springboot框架自带的 yml 配置完全OK（因为底层会帮我们处理好类型）但是我用到了多个kafka，并且kafka的信息都是从远端获取的，那么我创建消费者和创建生产者都是动态的，但是当我使用其中一个生产者发送消息的时候爆出上述错误；根本原因 acks的配置值希望是 string，但是我写的是integer源码解释一下：getstring测试一下发现会报错：修改后：/*** 构造生产者配置* @param ip* @param port* @return*/privateMap&lt;String,Object&gt;buildDefaultKafkaProducerMap(Stringip,Integerport){Map&lt;String,Object&gt;propertiesMap=newHashMap&lt;&gt;();propertiesMap.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,ip+":"+port);propertiesMap.put(ProducerConfig.RETRIES_CONFIG,0);propertiesMap.put(ProducerConfig.BATCH_SIZE_CONFIG,20960);//单独批次发送数据量propertiesMap.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,ByteArraySerializer.class.getName());propertiesMap.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,ByteArraySerializer.class.getName());propertiesMap.put(ProducerConfig.ACKS_CONFIG,"0");propertiesMap.put(ProducerConfig.BUFFER_MEMORY_CONFIG,67108864);//发送数据缓存propertiesMap.put(ProducerConfig.LINGER_MS_CONFIG,10);//超过10ms未发送则强制发送returnpropertiesMap;}/*** 构造消费者配置* @param ip* @param port* @return*/privateMap&lt;String,Object&gt;buildDefaultKafkaConsumerMap(Stringip,Integerport){Map&lt;String,Object&gt;propertiesMap=newHashMap&lt;&gt;();propertiesMap.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,ip+":"+port);//earliest：如果消费者组没有已提交的偏移量（即新的消费者组），则从主题的最早消息开始消费//latest：如果消费者组没有已提交的偏移量，则从最新的消息开始消费（即从消费者启动之后生成的消息）propertiesMap.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,consumerAutoOffsetReset);//propertiesMap.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 20);//自动提交时间间隔propertiesMap.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,false);//不自动提交偏移量 手动提交propertiesMap.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,ByteArrayDeserializer.class.getName());propertiesMap.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,ByteArrayDeserializer.class.getName());propertiesMap.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG,60000);//在时间内没有收到心跳，则该消费者会被剔除组propertiesMap.put(ConsumerConfig.GROUP_ID_CONFIG,consumerGroupId);propertiesMap.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG,50);//单次拉取50条数据returnpropertiesMap;}http://www.ppmy.cn/news/1541492.html相关文章探索 JavaScript 事件机制（一）：从基础概念到实战应用前言 
在现代前端开发中&amp;#xff0c;JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入&amp;#xff0c;这些用户操作都会触发特定的事件&amp;#xff0c;从而使网页变得更加动态和响应式。然而&amp;#xff0c;许多初学者对事件的概念和使用方法感到困惑…阅读更多...上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:08 +0000</pubDate>
    </item>
    <item>
      <title>探索 JavaScript 事件机制（一）：从基础概念到实战应用</title>
      <link>https://www.ppmy.cn/news/1541491.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维探索 JavaScript 事件机制（一）：从基础概念到实战应用news/2025/11/4 0:22:07/前言在现代前端开发中，JavaScript 事件是实现用户交互的核心机制之一。无论是按钮点击、鼠标移动还是键盘输入，这些用户操作都会触发特定的事件，从而使网页变得更加动态和响应式。然而，许多初学者对事件的概念和使用方法感到困惑。本文将通过详细的讲解和实际示例，帮助你全面理解 JavaScript 事件的工作原理及其在开发中的具体应用。什么是 JavaScript 事件？简单来说，JavaScript 事件就是用户或浏览器执行某种操作时触发的信号。这些操作可以是点击按钮、移动鼠标、键盘输入等。事件系统让我们可以在特定的操作发生时执行特定的 JavaScript 代码，从而实现动态和交互式的网页。常见的 JavaScript 事件在我们深入了解如何利用这些事件之前，先来看看常见的几种 JavaScript 事件：点击事件（click）：当用户点击某个元素时触发。鼠标悬停事件（mouseover）：当用户鼠标悬停在某个元素上时触发。键盘按下事件（keydown）：当用户按下键盘某个键时触发。页面加载事件（load）：当网页完全加载时触发。使用事件监听器我们可以通过两种主要方式来添加事件监听器：使用 HTML 属性和使用 JavaScript。使用 HTML 属性最简单的方式是直接在 HTML 元素中添加事件处理代码。例如：&lt;buttononclick="alert('按钮被点击了！')"&gt;点击我&lt;/button&gt;这里，我们在按钮元素中添加了 onclick 属性，当按钮被点击时，会弹出一个警告框。使用 JavaScript更推荐的方式是使用 JavaScript 来添加事件监听器，这样可以更灵活地管理代码。我们可以使用 addEventListener 方法：&lt;buttonid="myButton"&gt;点击我&lt;/button&gt;&lt;script&gt;document.getElementById('myButton').addEventListener('click',function(){alert('按钮被点击了！');});&lt;/script&gt;在这个例子中，我们首先获取了按钮元素，然后使用 addEventListener 方法为该按钮添加了一个点击事件监听器。事件对象当事件被触发时，浏览器会创建一个事件对象，这个对象包含了有关事件的各种信息，例如事件类型、目标元素、鼠标位置等。我们可以在事件处理函数中访问这个对象：&lt;buttonid="myButton"&gt;点击我&lt;/button&gt;&lt;script&gt;document.getElementById('myButton').addEventListener('click', function(event){console.log('事件类型:', event.type);console.log('事件目标:', event.target);});&lt;/script&gt;在这个例子中，event 对象包含了点击事件的所有相关信息，我们可以通过访问它的属性来获取更多细节。事件传播JavaScript 事件在 DOM 树中传播有两个阶段：捕获阶段和冒泡阶段。默认情况下，事件处理是在冒泡阶段进行的，这意味着事件首先从最内部的元素开始，然后逐层向外传播。停止事件传播有时候，我们可能希望阻止事件传播。我们可以使用 event.stopPropagation() 方法来实现：&lt;divid="parent"&gt;&lt;buttonid="myButton"&gt;点击我&lt;/button&gt;&lt;/div&gt;&lt;script&gt;document.getElementById('myButton').addEventListener('click', function(event){event.stopPropagation();alert('按钮被点击了！');});document.getElementById('parent').addEventListener('click',function(){alert('容器被点击了！');});&lt;/script&gt;在这个例子中，如果你点击按钮，只会弹出“按钮被点击了”的警告框，而不会触发容器的点击事件。事件委托事件委托是一种有效管理事件监听器的方法，特别适用于处理大量子元素的事件。为什么使用事件委托？假设我们有一个包含许多列表项的 ul 元素，并且我们希望在点击任意一个列表项时触发某个操作。一个办法是为每个 li 元素分别添加点击事件监听器，但这显然不是最有效的做法。事件委托的思想是：利用事件冒泡机制，把事件监听器添加到父元素上，通过判断事件目标来处理子元素的事件。事件委托示例&lt;ulid="myList"&gt;&lt;li&gt;项1&lt;/li&gt;&lt;li&gt;项2&lt;/li&gt;&lt;li&gt;项3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;document.getElementById('myList').addEventListener('click', function(event){if(event.target.tagName==='LI'){alert('你点击了: '+ event.target.textContent);}});&lt;/script&gt;在这个例子中，我们只为 ul 元素添加了一个点击事件监听器，然后通过检查 event.target 来确定用户点击的是哪个 li 元素。这种方法不仅简化了代码，还提高了性能，特别是在列表项动态增加或减少的情况下。总结事件系统是前端开发的核心之一，理解并学会灵活运用它将让你的网页更加生动和高效。通过这篇文章，我们不仅了解了 JavaScript 事件的基本概念和使用方法，还深入探讨了事件委托及高效事件处理的技巧。希望这些内容能帮助你在实际开发中更好地掌握和利用事件。http://www.ppmy.cn/news/1541491.html相关文章上拉电阻和下拉电阻在电路中的作用（一）上拉电阻和下拉电阻在电路中的作用&amp;#xff08;一&amp;#xff09; 1.什么是上下拉电阻2.上下拉电阻的作用&amp;#xff1a;2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路&amp;#xff08;Open Collector集电极开路、Open Drain漏电极开路&amp;#xf…阅读更多...基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:07 +0000</pubDate>
    </item>
    <item>
      <title>上拉电阻和下拉电阻在电路中的作用（一）</title>
      <link>https://www.ppmy.cn/news/1541490.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维上拉电阻和下拉电阻在电路中的作用（一）news/2025/11/4 0:22:06/上拉电阻和下拉电阻在电路中的作用（一）1.什么是上下拉电阻2.上下拉电阻的作用：2.1.维持输入引脚处于稳定状态。2.2.配合三极管和MOS进行电平转换电路设计2.3.OC、OD电路（Open Collector集电极开路、Open Drain漏电极开路）2.4.总线的IO接口上下拉电阻2.5.增加输出引脚的驱动能力2.6.电平标准匹配2.7.增强电路抗干扰能力1.什么是上下拉电阻上拉电阻是把信号通过一个电阻接到电源（VCC），下拉电阻是把信号通过电阻接到地（GND）。我们经常听说的“强上拉”“弱上拉”，其实强弱只是电阻阻值不同，没有太严格的区分。例如：50Ω上拉电阻称为强上拉电阻，100kΩ上拉电阻成为弱上拉电阻。强拉电阻的极端就是0欧姆电阻，直接将信号线与电源或地相连接。2.上下拉电阻的作用：用途广泛，很少有教材对上下拉电阻的应用方法进行总结。下面是一些常用的使用方法。2.1.维持输入引脚处于稳定状态。芯片引脚有3种类型，输出引脚（output，O），输入引脚（input，I），输入输出引脚（input/output，I/O）。输入引脚有3个状态，高电平，低电平和高阻状态。当输入是高阻，即输入引脚悬空时，可能造成输入结果的不定态，引起输出振荡。有些应用场合不希望出现高阻状态，可以通过上拉电阻或下拉电阻时输入引脚处于稳定状态。输入引脚的上拉电阻按键电路设计、复位电路设计等都是这种上下拉电阻，至于具体上拉还是下拉，则取决于需要的默认状态。在CMOS芯片上，为了防止静电造成损坏，不用的引脚不能悬空，一般通过接上拉电阻来降低输入阻抗，提供泄放电荷的通道。2.2.配合三极管和MOS进行电平转换电路设计三极管和MOS管的基本原理当Ube小于0.7V时，三极管处于截止状态，不导通，此时输出为高电平当三极管处于放大或饱和状态时，Ube=0.7V，R1属于限流电阻，当三极管处于放大或饱和状态时，Ube=0.7V，根据输入电压计算基极的电流，Ib=(U=0.7V)/R1若不接限流电阻R1，则当输入电压大于0.7V时，基极的电流大，会烧毁三极管。R1的电阻阻值大小，需要根据三极管的特性进行计算。例如，三极管放大倍数β为100.输出电压Vout=Vcc-Ic*RcVout在Ic等于0时，Vout=Vcc=12V，由于是数字电路，Vout需要到达0V附近，，实现低电平的效果。如果R2选1kΩ，Ic=(Vcc-0)/R2=12V/1kΩ=12mA 实际上还要考虑Vce之间大约0.3V的压降。三极管的通流能力有限，根据datasheet进行参考如果R2选值太小，会导致Ic太大导致三极管烧毁。根据公式理解饱和的概念会更容易，即集电极电阻越大（或者Ib电流大），越容易饱和。饱和的现象是:两个PN结均正确，Ic不受Ib的控制了，因为Vcc接近GND了，不可能凭空产生负压。如果要求输入电压为3.3V，设计时三极管处于饱和状态，则Ic(饱和)=12mA ,Ib(min)=Ic(饱和)/β=0.12mA基极限流电阻R1(max)=（3.3-0.7）/Ib=21.75KΩ。如果要求输入电压为3.3V，设计时三极管处于饱和状态，并且要考虑三极管放大倍数β、电阻、Vcc电压的离散型、精度、波动等因素，则阻值选择需要留出足够的余量。此时，一般可能选择R1为1KΩ，让三极管足够饱和。另外R1的阻值不能太小，需要考虑Ib的额定电流。另外R1、R2都不能太小的原因是要考虑功耗和节能。如果把NPN三极管换成NMOS的原理也是一样的，不同的是需要注意GS的电压不同于三极管BE之间的0.7V，一般GS在2V以上，具体设计看datasheet的数据说明。上图所示的电路是一个反向逻辑电路。可以连续用两个三极管把逻辑做成正向逻辑电路。此时，R2成为下一级的R1，这种情况下，R2既不能太大，也不能太小，如图所示：当输入为3.3V时，三极管Q2饱和时，Q2集电极电压为0.3V，小于Q3三极管BE间导通电压0.7V，所以Q3截至，输出为12V为高。当输入为0V时，三极管Q2截至，Q3基极电压为0.7V，三极管Q3到导通，Q3处于饱和状态，输出通过Q3的CE下拉至0.3V为低。注意：考虑到三极管的寄生电容，文章中的电路只能做一个对开关速度要求不高的电平转换电路，如果要求转换速度高，建议在三极管的BE端，增加一个2kΩ的电阻并联在BE端2.3.OC、OD电路（Open Collector集电极开路、Open Drain漏电极开路）对于OC、OD电路，上拉电阻的功能主要是为集电极开路输出型电路提供输出电流通道。有些芯片的输出引脚继承了三极管或MOS管，但是没有集成上拉电阻到VCC。典型的OC电路，这些引脚其实就是一个集电极，而且是开路，所以称为OC引脚。而之所以有OC和OD电路，是为了便于“线与”设计。两个或多个输出信号连接在一起可以实现“线与”的功能，是要一个输入引脚为低电平，就可以使输出为低电平。2.4.总线的IO接口上下拉电阻一些总线总有输入和输出接口，其本质就是OC和OD的接口。IIC（Inter-Integrated Circuit,内部集成电路）总线就是典型的开漏输出结构。IIC接口的SCL（时钟线）和SDA（数据线）都是OD输出结构，这样可以用作双向数据线。有些双向的IO口，其实就是把输入和输出短接到一起，然后把输入和输出做成OC和OD。这样处理不但用一根线实现了双向数据通信，还解决了双向数据同时发送信号带来的数据冲突。一般来说，芯片的输出是推挽结构，但是当两个芯片同时输出，一个为高，一个为低的时候，会出现短路情况。工作中称为总线冲突。用OC、OD电路可以避免短路，所以IIC、LPC、PCI等总线采用此电路。当然，有一些IO口不需要外接，因为其芯片中内置了上拉电阻。对于IIC总线，当总线上有多个芯片时，不管各个芯片的引脚输出什么状态，都不会因为短路引起数据冲突。利用各自芯片内部的数据识别电路及仲裁系统，各个芯片都可以主动给另一方发送消息。任何一方都可以将总线拉低，不拉低时就是释放总线。2.5.增加输出引脚的驱动能力芯片的输出引脚本身不是OC、OD电路，但有时候也会增加一个上拉或者下拉电阻，通过上拉或下拉来增加或减小驱动电流。例如，一个单片机的IO口内部有一个几十千欧的电阻，其最大输出电流也就250uA。因此，当增加一个上拉电阻时，可以形成和内部上拉电阻并联的结构，增加高电平时电流的输出能力。在负载增大时，能保持足够的电压。2.6.电平标准匹配用于不同标准之间电平的匹配，最常见的就是TTL和CMOS电平之间的匹配。当TTL电路驱动CMOS电路时，若TTL电路的高电平低于CMOS电路的最低高电平（一般为3.5V），这时就需要在TTL的输出端加上拉电阻，以提高输出高电平值。需要注意的是，此时上拉电阻连接的电压值应不低于CMOS电路的最低高电压，同时要考虑TTL电路的电流（如某端口最大输入或输出电流）的影响。2.7.增强电路抗干扰能力芯片的引脚加上拉电阻可以提高输出电平，从而提高芯片输入信号的噪声容限，增强抗干扰能力。在长线传输中，电阻不匹配容易引起反射波干扰，可以通过加上拉或下拉电阻进行匹配，从而有效地抑制反射波干扰。在总线传输过程中，悬空引脚比较容易受外界的电磁干扰，加上拉电阻可以提高总线的抗干扰能力。http://www.ppmy.cn/news/1541490.html相关文章基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:06 +0000</pubDate>
    </item>
    <item>
      <title>基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现</title>
      <link>https://www.ppmy.cn/news/1541489.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维基于SpringBoot+Vue+uniapp的电影信息推荐APP的详细设计和实现news/2025/11/4 0:22:05/详细视频演示请联系我获取更详细的演示视频项目运行截图技术框架后端采用SpringBoot框架Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念，提供了一套默认的配置，让开发者可以更专注于业务逻辑而不是配置文件。Spring Boot 通过自动化配置和约定大于配置的方式，大大简化了应用程序的配置工作。开发者不再需要手动配置大量的 XML 文件或繁琐的注解，框架提供了默认的配置，根据项目的依赖关系和约定，自动完成配置。Spring Boot 使用Maven或 Gradle 进行构建，自动下载项目依赖，并提供了许多插件简化构建过程。开发者可以使用 Spring Initializr 来生成一个基础的项目结构，然后根据需要选择所需的依赖。前端框架VueVue.js的设计目标之一是使其尽可能简单、易于理解和上手。Vue 提供了直观的 API，使开发者能够轻松地构建交互式的用户界面。Vue.js 提供了简单而强大的数据绑定机制，通过使用指令（例如 v-model）可以实现视图和数据的双向绑定。当数据发生变化时，视图会自动更新，反之亦然，使得开发者不必手动处理 DOM 操作。Vue.js 提供了一组生命周期钩子函数，允许开发者在组件的不同阶段执行自定义逻辑。这包括创建、挂载、更新和销毁等阶段，为开发者提供了更多灵活性。可行性分析可行性分析是每开发一个项目必不可少的一部分，可行性分析可以直接影响一个系统的存活问题，针对开发意义进行分析，还有就是是否可以通过所开发的系统来弥补传统手工统计模式的不足，是否能够更好的解决阿博图书馆管理系统存在的问题等，通过对该阿博图书馆管理系统的开发设计，不仅能够逐步减少工作人员的工作量，而且还可以进行高效工作和管理。所以该系统的开发实现了最大的意义和价值，在系统完成后，利益是否大过于成本，是否能够达到预期效果，这些方面都要进行可行性分析，再通过分析之后，就可以决定是否开发此系统。该阿博图书馆管理系统的开发设计中，以下几点进行了可行性分析：技术可行性：通过Java技术的采用，由于该技术不断成熟，所以使用该技术设计阿博图书馆管理系统是具有可行性的。经济可行性：在开发过程中，系统完成后的利益是否大过于开发成本。操作可行性：阿博图书馆管理系统的开发设计中，方便用户的可操作性和实用性。系统测试从多个角度进行测试找到系统中存在的问题是本系统首要的测试目的，通过功能测试寻找出系统缺陷并改正，确保系统没有缺陷。在测试过程中证明系统满足客户需求，发现问题和不足及时改正。测试完成之后得出测试结论。系统测试的目的系统测试是必不可少且考验耐心的过程。其重要性在于，它是保证系统质量和牢靠性的最后一道关，也是整个系统开发过程的最后一次检查。系统测试主要是为了避免用户在使用时发生问题，增强用户体验感，为了不影响用户的使用，我们需要从多角度、多思路去考虑系统可能遇到的问题，通过不同的模拟场景来发现缺陷并解决问题。在测试的过程中也可以了解到该系统的质量情况，系统功能是否健全，系统逻辑是否顺畅。一个合格的系统测试过程完成后将大大提升系统质量和使用感。测试的目标是验证系统是否符合需求规格说明书的定义，并找出与需求规格说明书不符合或与之冲突的内容。测试过程中一定站在用户的角度考虑问题，避免一些不切实际的场景，浪费测试时间，从而可能会引起问题导致预期结果与实际结果不符。系统功能测试对系统功能模块进行测试，通过点击、输入边界值和必填项非必填项的验证等方法进行一系列的黑盒测试。通过编写测试用例，根据测试用例中的内容进行测试，最后得出测试结论。登录功能测试方案：当需要登入该系统时，通过账户密码等功能点进行验证，用户在输入时需要输入与数据库内存储的数据匹配的内容，当其中某项输入错误时系统将提示输入错误。此界面对角色权限也有相应的校验，当用户角色的帐号选择管理员角色登录时，也会报错。登录功能测试用例如下表所示。输入数据预期结果实际结果结果分析用户名：guanliyuan 密码：123456 验证码：正确输入登入系统成功登入系统和估算结果一样用户名：guanliyuan 密码：111111 验证码：正确输入密码错误密码错误，请重新输入密码和估算结果一样用户名：guanliyuan 密码：123456 验证码：错误输入验证码错误验证码信息错误和估算结果一样用户名：空 密码：123456 验证码：正确输入用户名必填请输入用户名和估算结果一样用户名：guanliyuan 密码：空 验证码：正确输入密码错误密码错误，请重新输入密码和估算结果一样用户管理功能测试方案：用户管理主要有添加、编辑、删除、查找用户功能。添加用户时，必填项不填，检验系统是否有非空检验；添加已有的用户信息，检验是否提示用户名已被使用；删除用户信息，系统将检验是否进行此操作；更改用户信息，更改用户信息后页面是否可以展示出来。用户管理测试用例如下表所示。输入数据预期结果实际结果结果分析填入用户基本信息添加成功，在用户列表中显示该用户出现在在列表中和估算结果一样修改用户信息编辑成功，修改信息成功被修改用户信息被修改和估算结果一样选中删除用户系统询问是否删除用户，确认后用户被删除系统询问是否删除用户，确认后查找不到用户信息和估算结果一样添加用户时不填用户名提示用户名不能为空提示用户名不能为空和估算结果一样填入已有用户名添加失败，提示用户名重复添加失败，提示用户名重复和估算结果一样数据库表设计列名数据类型长度约束idint11PRIMARY KEYaddtime行2内容行2内容DEFAULT NULLjieyuedanhaovarchar64DEFAULT NULLtushubianhaovarchar64DEFAULT NULLtushumingchengvarchar12DEFAULT NULLfakuanshuomingvarchar64DEFAULT NULLfakuanjinevarchar64DEFAULT NULLfakuanriqivarchar64DEFAULT NULLyonghumingvarchar64DEFAULT NULLshoujivarchar64DEFAULT NULL代码参考/*** 通用接口*/
@RestController
public class CommonController{@Autowiredprivate CommonService commonService;@Autowiredprivate ConfigService configService;private static AipFace client = null;private static String BAIDU_DITU_AK = null;@RequestMapping("/location")public R location(String lng,String lat) {if(BAIDU_DITU_AK==null) {BAIDU_DITU_AK = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "baidu_ditu_ak")).getValue();if(BAIDU_DITU_AK==null) {return R.error("请在配置管理中正确配置baidu_ditu_ak");}}Map&lt;String, String&gt; map = BaiduUtil.getCityByLonLat(BAIDU_DITU_AK, lng, lat);return R.ok().put("data", map);}/*** 人脸比对* * @param face1 人脸1* @param face2 人脸2* @return*/@RequestMapping("/matchFace")public R matchFace(String face1, String face2) {if(client==null) {/*String AppID = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "AppID")).getValue();*/String APIKey = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "APIKey")).getValue();String SecretKey = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "SecretKey")).getValue();String token = BaiduUtil.getAuth(APIKey, SecretKey);if(token==null) {return R.error("请在配置管理中正确配置APIKey和SecretKey");}client = new AipFace(null, APIKey, SecretKey);client.setConnectionTimeoutInMillis(2000);client.setSocketTimeoutInMillis(60000);}JSONObject res = null;try {File file1 = new File(ResourceUtils.getFile("classpath:static/upload").getAbsolutePath()+"/"+face1);File file2 = new File(ResourceUtils.getFile("classpath:static/upload").getAbsolutePath()+"/"+face2);String img1 = Base64Util.encode(FileUtil.FileToByte(file1));String img2 = Base64Util.encode(FileUtil.FileToByte(file2));MatchRequest req1 = new MatchRequest(img1, "BASE64");MatchRequest req2 = new MatchRequest(img2, "BASE64");ArrayList&lt;MatchRequest&gt; requests = new ArrayList&lt;MatchRequest&gt;();requests.add(req1);requests.add(req2);res = client.match(requests);System.out.println(res.get("result"));} catch (FileNotFoundException e) {e.printStackTrace();return R.error("文件不存在");} catch (IOException e) {e.printStackTrace();} return R.ok().put("data", com.alibaba.fastjson.JSONObject.parse(res.get("result").toString()));}数据库脚本CREATE TABLE `yonghu` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`yonghuming` varchar(200) NOT NULL COMMENT '用户名',`mima` varchar(200) NOT NULL COMMENT '密码',`xingming` varchar(200) DEFAULT NULL COMMENT '姓名',`xingbie` varchar(200) DEFAULT NULL COMMENT '性别',`touxiang` varchar(200) DEFAULT NULL COMMENT '头像',`shouji` varchar(200) DEFAULT NULL COMMENT '手机',`shenfenzheng` varchar(200) DEFAULT NULL COMMENT '身份证',PRIMARY KEY (`id`),UNIQUE KEY `yonghuming` (`yonghuming`)
) ENGINE=InnoDB AUTO_INCREMENT=1616222324596 DEFAULT CHARSET=utf8mb3 COMMENT='用户';
CREATE TABLE `messages` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`userid` bigint NOT NULL COMMENT '留言人id',`username` varchar(200) DEFAULT NULL COMMENT '用户名',`content` longtext NOT NULL COMMENT '留言内容',`reply` longtext COMMENT '回复内容',PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1616222424131 DEFAULT CHARSET=utf8mb3 COMMENT='留言板';
CREATE TABLE `token` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`userid` bigint NOT NULL COMMENT '用户id',`username` varchar(100) NOT NULL COMMENT '用户名',`tablename` varchar(100) DEFAULT NULL COMMENT '表名',`role` varchar(100) DEFAULT NULL COMMENT '角色',`token` varchar(200) NOT NULL COMMENT '密码',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '新增时间',`expiratedtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '过期时间',PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3 COMMENT='token表';获取源码我们有上万多套源码，欢迎咨询。可定制、修改、部署、讲解、代写文档、PPT。获取源码查看底部卡片或者顶部名字http://www.ppmy.cn/news/1541489.html相关文章c++ STL标准模板库-算法C Standard Template Library&amp;#xff08;STL&amp;#xff09;算法是一组泛型算法&amp;#xff0c;它们可以在各种容器上操作。这些算法被设计为与容器无关&amp;#xff0c;因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别&amp;#xff1a; 
非修改算法Non-modifyi…阅读更多...【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:05 +0000</pubDate>
    </item>
    <item>
      <title>c++ STL标准模板库-算法</title>
      <link>https://www.ppmy.cn/news/1541488.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维c++ STL标准模板库-算法news/2025/11/4 0:22:04/C++ Standard Template Library（STL）算法是一组泛型算法，它们可以在各种容器上操作。这些算法被设计为与容器无关，因此可以在任何提供必要迭代器接口的容器上使用。STL算法分为以下几个主要类别：非修改算法Non-modifying sequence operations：不改变容器内容，主要用于搜索和排序。修改算法Modifying sequence operations：改变容器内容，如替换元素或改变元素顺序。杂项算法：包括设置操作、堆操作等。由于算法数量较多，我将按照分类逐一列出所有算法的详细介绍和函数原型，以及相应的简单示例。Non-modifying sequence operationsstd::all_of函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; bool all_of(InputIterator first, InputIterator last, UnaryPredicate pred);示例：检查范围内所有元素是否满足条件std::vector&lt;int&gt;v={1,2,3,4,5};boolall_positive=std::all_of(v.begin(),v.end(),[](inti){returni&gt;0;});std::any_of函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; bool any_of(InputIterator first, InputIterator last, UnaryPredicate pred);示例：检查范围内是否有元素满足条件boolhas_positive=std::any_of(v.begin(),v.end(),[](inti){returni&gt;0;});std::none_of函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; bool none_of(InputIterator first, InputIterator last, UnaryPredicate pred);示例：检查范围内是否没有元素满足条件boolno_negative=std::none_of(v.begin(),v.end(),[](inti){returni&lt;0;});std::for_each函数原型：template &lt;class InputIterator, class Function&gt; Function for_each(InputIterator first, InputIterator last, Function f);示例：对每个元素应用函数对象std::vector&lt;int&gt;v={1,2,3,4,5};std::for_each(v.begin(),v.end(),[](inti){std::cout&lt;&lt;i&lt;&lt;' ';});std::find函数原型：template &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; value);示例：查找特定值的第一个匹配项std::vector&lt;int&gt;v={1,2,3,4,5};autoit=std::find(v.begin(),v.end(),3);std::find_if函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);示例：查找第一个满足条件的元素autoit=std::find_if(v.begin(),v.end(),[](inti){returni&gt;3;});std::find_if_not函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; InputIterator find_if_not(InputIterator first, InputIterator last, UnaryPredicate pred);示例：查找第一个不满足条件的元素autoit=std::find_if_not(v.begin(),v.end(),[](inti){returni&gt;3;});std::find_end函数原型：template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt; ForwardIterator1 find_end(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);示例：查找最后一个子序列的匹配项std::vector&lt;int&gt;v1={1,2,3,4,5,1,2};std::vector&lt;int&gt;v2={4,5,1};autoit=std::find_end(v1.begin(),v1.end(),v2.begin(),v2.end());std::find_first_of函数原型：template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt; InputIterator1 find_first_of(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred);示例：查找第一个来自另一个范围的元素std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4,5,6};autoit=std::find_first_of(v1.begin(),v1.end(),v2.begin(),v2.end());std::adjacent_find函数原型：template &lt;class ForwardIterator, class BinaryPredicate&gt; ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);示例：查找第一个相邻的匹配项std::vector&lt;int&gt;v={1,2,3,2,4};autoit=std::adjacent_find(v.begin(),v.end());std::count函数原型：template &lt;class InputIterator, class T&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count(InputIterator first, InputIterator last, const T&amp; value);示例：计算特定值的出现次数std::vector&lt;int&gt;v={1,2,2,3,2,4};intcount=std::count(v.begin(),v.end(),2);std::count_if函数原型：template &lt;class InputIterator, class UnaryPredicate&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count_if(InputIterator first, InputIterator last, UnaryPredicate pred);示例：计算满足条件的元素数量intcount=std::count_if(v.begin(),v.end(),[](inti){returni&gt;3;});std::mismatch函数原型：template &lt;class InputIterator1, class InputIterator2, class BinaryPredicate&gt; std::pair&lt;InputIterator1, InputIterator2&gt; mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred);示例：查找第一个不匹配的元素对std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={1,2,4,4,5};autopair=std::mismatch(v1.begin(),v1.end(),v2.begin());std::equal函数原型：template &lt;class InputIterator1, class InputIterator2&gt; bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);示例：比较两个范围是否相等std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={1,2,3,4,5};boolis_equal=std::equal(v1.begin(),v1.end(),v2.begin());std::is_permutation函数原型：template &lt;class ForwardIterator1, class ForwardIterator2&gt; bool is_permutation(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);示例：检查一个范围是否是另一个范围的排列std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={5,4,3,2,1};boolis_perm=std::is_permutation(v1.begin(),v1.end(),v2.begin());std::search函数原型：template &lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt; ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);示例：搜索子序列std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;pat={3,4};autoit=std::search(v.begin(),v.end(),pat.begin(),pat.end());std::search_n函数原型：template &lt;class ForwardIterator, class Size, class T, class BinaryPredicate&gt; ForwardIterator search_n(ForwardIterator first, ForwardIterator last, Size count, const T&amp; value, BinaryPredicate pred);示例：搜索特定数量的连续元素autoit=std::search_n(v.begin(),v.end(),3,2);Modifying sequence operationsstd::copy函数原型：template &lt;class InputIterator, class OutputIterator&gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result);示例：复制范围的元素到新位置std::vector&lt;int&gt;src={1,2,3,4,5};std::vector&lt;int&gt;dest(src.size());std::copy(src.begin(),src.end(),dest.begin());std::copy_n函数原型：template &lt;class InputIterator, class Size, class OutputIterator&gt; OutputIterator copy_n(InputIterator first, Size count, OutputIterator result);示例：复制指定数量的元素到新位置std::vector&lt;int&gt;src={1,2,3,4,5};std::vector&lt;int&gt;dest(src.size());std::copy_n(src.begin(),src.size(),dest.begin());std::copy_if函数原型：template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt; OutputIterator copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);示例：复制满足条件的元素到新位置std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;dest(v.size());std::copy_if(v.begin(),v.end(),dest.begin(),[](inti){returni&gt;2;});std::copy_backward函数原型：template &lt;class BidirectionalIterator1, class BidirectionalIterator2&gt; BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);示例：反向复制范围的元素到新位置std::vector&lt;int&gt;src={1,2,3,4,5};std::vector&lt;int&gt;dest(src.size());std::copy_backward(src.begin(),src.end(),dest.end());std::move函数原型：template &lt;class InputIterator, class OutputIterator&gt; OutputIterator move(InputIterator first, InputIterator last, OutputIterator result);示例：移动范围的元素到新位置std::vector&lt;int&gt;src={1,2,3,4,5};std::vector&lt;int&gt;dest(src.size());std::move(src.begin(),src.end(),dest.begin());std::move_backward函数原型：template &lt;class BidirectionalIterator1, class BidirectionalIterator2&gt; BidirectionalIterator2 move_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result);示例：反向移动范围的元素到新位置std::vector&lt;int&gt;src={1,2,3,4,5};std::vector&lt;int&gt;dest(src.size());std::move_backward(src.begin(),src.end(),dest.end());std::swap函数原型：template &lt;class T&gt; void swap(T&amp; a, T&amp; b);示例：交换两个对象的值inta=1,b=2;std::swap(a,b);std::swap_ranges函数原型：template &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);示例：交换两个范围的元素std::vector&lt;int&gt;v1={1,2,3};std::vector&lt;int&gt;v2={4,5,6};std::swap_ranges(v1.begin(),v1.end(),v2.begin());std::iter_swap函数原型：template &lt;class Iterator&gt; void iter_swap(Iterator a, Iterator b);示例：交换两个迭代器指向的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::iter_swap(v.begin(),v.begin()+2);std::transform函数原型：template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt; OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);示例：对每个元素应用函数并存储结果// 创建一个包含整数的向量std::vector&lt;int&gt;numbers={1,4,9,16,25};// 创建一个空向量，用于存储转换后的结果std::vector&lt;double&gt;roots;// 使用 std::transform 计算每个元素的平方根std::transform(numbers.begin(),numbers.end(),std::back_inserter(roots),[](intx)-&gt;double{returnstd::sqrt(x);});std::replace函数原型：template &lt;class ForwardIterator, class T&gt; void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);示例：替换范围内的值std::vector&lt;int&gt;v={1,2,3,2,4};std::replace(v.begin(),v.end(),2,5);std::replace_if函数原型：template &lt;class ForwardIterator, class UnaryPredicate, class T&gt; void replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value);示例：替换满足条件的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::replace_if(v.begin(),v.end(),[](inti){returni&gt;3;},0);std::replace_copy函数原型：template &lt;class InputIterator, class OutputIterator, class T&gt; OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; old_value, const T&amp; new_value);示例：复制范围并替换值std::vector&lt;int&gt;v={1,2,3,2,4};std::vector&lt;int&gt;dest(v.size());std::replace_copy(v.begin(),v.end(),dest.begin(),2,5);std::replace_copy_if函数原型：template &lt;class InputIterator, class OutputIterator, class UnaryPredicate, class T&gt; OutputIterator replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred, const T&amp; new_value);示例：复制范围并替换满足条件的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;dest(v.size());std::replace_copy_if(v.begin(),v.end(),dest.begin(),[](inti){returni&gt;3;},0);std::fill函数原型：template &lt;class ForwardIterator, class T&gt; void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：用给定值填充范围std::vector&lt;int&gt;v(5);std::fill(v.begin(),v.end(),1);std::fill_n函数原型：template &lt;class OutputIterator, class Size, class T&gt; OutputIterator fill_n(OutputIterator first, Size n, const T&amp; value);示例：用给定值填充指定数量的元素std::vector&lt;int&gt;v(5);std::fill_n(v.begin(),v.size(),1);std::generate函数原型：template &lt;class ForwardIterator, class Generator&gt; void generate(ForwardIterator first, ForwardIterator last, Generator gen);示例：用生成器函数填充范围std::vector&lt;int&gt;v(5);std::generate(v.begin(),v.end(),[](){staticinti=0;return++i;});std::generate_n函数原型：template &lt;class OutputIterator, class Size, class Generator&gt; OutputIterator generate_n(OutputIterator first, Size n, Generator gen);示例：用生成器函数填充指定数量的元素std::vector&lt;int&gt;v(5);std::generate_n(v.begin(),v.size(),[](){staticinti=0;return++i;});std::remove函数原型：template &lt;class ForwardIterator, class T&gt; ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：移除特定值的元素std::vector&lt;int&gt;v={1,2,3,2,4};autonew_end=std::remove(v.begin(),v.end(),2);v.erase(new_end,v.end());std::remove_if函数原型：template &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);示例：移除满足条件的元素std::vector&lt;int&gt;v={1,2,3,4,5};autonew_end=std::remove_if(v.begin(),v.end(),[](inti){returni&gt;3;});v.erase(new_end,v.end());std::remove_copy函数原型：template &lt;class InputIterator, class OutputIterator, class T&gt; OutputIterator remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T&amp; value);示例：复制范围并移除特定值std::vector&lt;int&gt;v={1,2,3,2,4};std::vector&lt;int&gt;dest(v.size());std::remove_copy(v.begin(),v.end(),dest.begin(),2);std::remove_copy_if函数原型：template &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt; OutputIterator remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred);示例：复制范围并移除满足条件的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;dest(v.size());std::remove_copy_if(v.begin(),v.end(),dest.begin(),[](inti){returni&gt;3;});std::unique函数原型：template &lt;class ForwardIterator&gt; ForwardIterator unique(ForwardIterator first, ForwardIterator last);示例：移除连续重复的元素std::vector&lt;int&gt;v={1,2,2,3,4,4,5};autonew_end=std::unique(v.begin(),v.end());v.erase(new_end,v.end());std::unique_copy函数原型：template &lt;class InputIterator, class OutputIterator&gt; OutputIterator unique_copy(InputIterator first, InputIterator last, OutputIterator result);示例：复制范围并移除连续重复的元素std::vector&lt;int&gt;v={1,2,2,3,4,4,5};std::vector&lt;int&gt;dest(v.size());std::unique_copy(v.begin(),v.end(),dest.begin());std::reverse函数原型：template &lt;class BidirectionalIterator&gt; void reverse(BidirectionalIterator first, BidirectionalIterator last);示例：反转范围内元素的顺序std::vector&lt;int&gt;v={1,2,3,4,5};std::reverse(v.begin(),v.end());std::reverse_copy函数原型：template &lt;class BidirectionalIterator, class OutputIterator&gt; OutputIterator reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);示例：复制范围并反转顺序std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;dest(v.size());std::reverse_copy(v.begin(),v.end(),dest.begin());std::rotate函数原型：template &lt;class ForwardIterator&gt; void rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);示例：向左旋转范围内的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::rotate(v.begin(),v.begin()+2,v.end());std::rotate_copy函数原型：template &lt;class ForwardIterator, class OutputIterator&gt; OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);示例：复制并旋转范围的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;dest(v.size());std::rotate_copy(v.begin(),v.begin()+2,v.end(),dest.begin());std::random_shuffle函数原型：template &lt;class RandomAccessIterator&gt; void random_shuffle(RandomAccessIterator first, RandomAccessIterator last);示例：随机打乱范围内元素的顺序（已在上文展示）std::shuffle函数原型：template &lt;class RandomAccessIterator, class UniformRandomBitGenerator&gt; void shuffle(RandomAccessIterator first, RandomAccessIterator last, UniformRandomBitGenerator&amp;&amp; g);示例：随机打乱范围内元素的顺序std::vector&lt;int&gt;v={1,2,3,4,5};std::shuffle(v.begin(),v.end(),std::default_random_engine(std::random_device{}()));Sorting operationsstd::is_sorted函数原型：template &lt;class ForwardIterator&gt; bool is_sorted(ForwardIterator first, ForwardIterator last);示例：检查范围是否已排序std::vector&lt;int&gt;v={1,2,3,4,5};boolis_sorted=std::is_sorted(v.begin(),v.end());std::is_sorted_until函数原型：template &lt;class ForwardIterator&gt; ForwardIterator is_sorted_until(ForwardIterator first, ForwardIterator last);示例：找到第一个未排序的元素std::vector&lt;int&gt;v={1,2,3,4,5};autoit=std::is_sorted_until(v.begin(),v.end());std::sort函数原型：template &lt;class RandomAccessIterator&gt; void sort(RandomAccessIterator first, RandomAccessIterator last);示例：对范围内的元素进行排序（已在上文展示）std::stable_sort函数原型：template &lt;class RandomAccessIterator&gt; void stable_sort(RandomAccessIterator first, RandomAccessIterator last);示例：稳定排序范围内的元素std::vector&lt;int&gt;v={1,2,3,4,5};std::stable_sort(v.begin(),v.end());std::partial_sort函数原型：template &lt;class RandomAccessIterator, class T&gt; void partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp = Compare());示例：部分排序范围内的元素std::vector&lt;int&gt;v={5,3,4,2,1};std::partial_sort(v.begin(),v.begin()+2,v.end());std::partial_sort_copy函数原型：template &lt;class InputIterator, class RandomAccessIterator, class Compare&gt; RandomAccessIterator partial_sort_copy(InputIterator first, InputIterator last, RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp = Compare());示例：复制并部分排序范围的元素std::vector&lt;int&gt;v={5,3,4,2,1};std::vector&lt;int&gt;dest(2);std::partial_sort_copy(v.begin(),v.end(),dest.begin(),dest.end());std::nth_element函数原型：template &lt;class RandomAccessIterator, class T&gt; void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp = Compare());示例：对范围内的元素进行部分排序，确保第n个元素处于正确的位置std::vector&lt;int&gt;v={5,3,4,2,1};std::nth_element(v.begin(),v.begin()+2,v.end());Binary search operationsstd::lower_bound函数原型：template &lt;class ForwardIterator, class T&gt; ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：在有序范围内找到元素的下界（已在上文展示）std::upper_bound函数原型：template &lt;class ForwardIterator, class T&gt; ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：在有序范围内找到元素的上界std::vector&lt;int&gt;v={1,2,3,4,5};autoit=std::upper_bound(v.begin(),v.end(),3);std::equal_range函数原型：template &lt;class ForwardIterator, class T&gt; std::pair&lt;ForwardIterator, ForwardIterator&gt; equal_range(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：找到范围内与给定值相等的子范围std::vector&lt;int&gt;v={1,2,2,3,4,4,5};autopair=std::equal_range(v.begin(),v.end(),2);std::binary_search函数原型：template &lt;class ForwardIterator, class T&gt; bool binary_search(ForwardIterator first, ForwardIterator last, const T&amp; value);示例：测试给定值是否存在于已排序的序列中std::vector&lt;int&gt;v={1,2,3,4,5};boolfound=std::binary_search(v.begin(),v.end(),3);Set operationsstd::includes函数原型：template &lt;class InputIterator1, class InputIterator2&gt; bool includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);示例：测试一个有序序列是否包含另一个有序序列std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4};boolincludes=std::includes(v1.begin(),v1.end(),v2.begin(),v2.end());std::set_union函数原型：template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt; OutputIterator set_union(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);示例：计算两个有序序列的并集std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4,5,6,7};std::vector&lt;int&gt;dest(v1.size()+v2.size());std::set_union(v1.begin(),v1.end(),v2.begin(),v2.end(),dest.begin());std::set_intersection函数原型：template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt; OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);示例：计算两个有序序列的交集std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4,5,6,7};std::vector&lt;int&gt;dest(v1.size()+v2.size());std::set_intersection(v1.begin(),v1.end(),v2.begin(),v2.end(),dest.begin());std::set_difference函数原型：template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt; OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);示例：计算两个有序序列的差集std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4,5,6,7};std::vector&lt;int&gt;dest(v1.size()+v2.size());std::set_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),dest.begin());std::set_symmetric_difference函数原型：template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt; OutputIterator set_symmetric_difference(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);示例：计算两个有序序列的对称差集std::vector&lt;int&gt;v1={1,2,3,4,5};std::vector&lt;int&gt;v2={3,4,5,6,7};std::vector&lt;int&gt;dest(v1.size()+v2.size());std::set_symmetric_difference(v1.begin(),v1.end(),v2.begin(),v2.end(),dest.begin());Heap operationsstd::push_heap函数原型：template &lt;class RandomAccessIterator&gt; void push_heap(RandomAccessIterator first, RandomAccessIterator last);示例：将元素推入最大堆std::vector&lt;int&gt;v={1,2,3,4,5};std::push_heap(v.begin(),v.end());std::pop_heap函数原型：template &lt;class RandomAccessIterator&gt; void pop_heap(RandomAccessIterator first, RandomAccessIterator last);示例：从最大堆中弹出最大元素std::vector&lt;int&gt;v={1,2,3,4,5};std::pop_heap(v.begin(),v.end());v.pop_back();std::make_heap函数原型：template &lt;class RandomAccessIterator&gt; void make_heap(RandomAccessIterator first, RandomAccessIterator last);示例：从范围创建最大堆std::vector&lt;int&gt;v={1,2,3,4,5};std::make_heap(v.begin(),v.end());std::sort_heap函数原型：template &lt;class RandomAccessIterator&gt; void sort_heap(RandomAccessIterator first, RandomAccessIterator last);示例：将最大堆排序为升序范围std::vector&lt;int&gt;v={1,2,3,4,5};std::sort_heap(v.begin(),v.end());std::is_heap函数原型：template &lt;class RandomAccessIterator&gt; bool is_heap(RandomAccessIterator first, RandomAccessIterator last);示例：检查范围是否为最大堆std::vector&lt;int&gt;v={1,2,3,4,5};boolis_heap=std::is_heap(v.begin(),v.end());std::is_heap_until函数原型：template &lt;class RandomAccessIterator&gt; RandomAccessIterator is_heap_until(RandomAccessIterator first, RandomAccessIterator last);示例：找到最大堆中的首个元素，它不是堆序的std::vector&lt;int&gt;v={1,2,3,4,5};autoit=std::is_heap_until(v.begin(),v.end());Minimum/maximum operationsstd::min函数原型：template &lt;class T1, class T2&gt; constexpr decltype(auto) min(T1&amp;&amp; a, T2&amp;&amp; b);示例：返回两个值中较小的一个inta=5,b=10;intmin_val=std::min(a,b);std::max函数原型：template &lt;class T1, class T2&gt; constexpr decltype(auto) max(T1&amp;&amp; a, T2&amp;&amp; b);示例：返回两个值中较大的一个inta=5,b=10;intmax_val=std::max(a,b);std::min_element函数原型：template &lt;class ForwardIterator&gt; ForwardIterator min_element(ForwardIterator first, ForwardIterator last);示例：返回范围内最小元素的迭代器std::vector&lt;int&gt;v={5,3,4,2,1};autoit=std::min_element(v.begin(),v.end());std::max_element函数原型：template &lt;class ForwardIterator&gt; ForwardIterator max_element(ForwardIterator first, ForwardIterator last);示例：返回范围内最大元素的迭代器std::vector&lt;int&gt;v={5,3,4,2,1};autoit=std::max_element(v.begin(),v.end());std::minmax函数原型：template &lt;class T1, class T2&gt; constexpr std::pair&lt;decay_t&lt;T1&gt;, decay_t&lt;T2&gt;&gt; minmax(T1&amp;&amp; a, T2&amp;&amp; b);示例：返回两个值中较小和较大的一对inta=5,b=10;autoresult=std::minmax(a,b);std::minmax_element函数原型：template &lt;class ForwardIterator&gt; std::pair&lt;ForwardIterator, ForwardIterator&gt; minmax_element(ForwardIterator first, ForwardIterator last);示例：返回范围内最小和最大元素的迭代器对std::vector&lt;int&gt;v={5,3,4,2,1};autoresult=std::minmax_element(v.begin(),v.end());std::clamp函数原型：template &lt;class T&gt; constexpr const T&amp; clamp(const T&amp; v, const T&amp; lo, const T&amp; hi);示例：将值限制在指定范围内intvalue=5,lo=2,hi=8;intclamped=std::clamp(value,lo,hi);numericstd::accumulate函数原型：template &lt;class InputIterator, class T&gt; T accumulate(InputIterator first, InputIterator last, T init);示例：计算范围内元素的总和std::vector&lt;int&gt;v={1,2,3,4,5};intsum=std::accumulate(v.begin(),v.end(),0);std::inner_product函数原型：template &lt;class InputIterator1, class InputIterator2, class T&gt; T inner_product(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, T init);示例：计算两个范围的内积std::vector&lt;int&gt;v1={1,2,3};std::vector&lt;int&gt;v2={4,5,6};intproduct=std::inner_product(v1.begin(),v1.end(),v2.begin(),0);std::adjacent_difference函数原型：template &lt;class InputIterator, class OutputIterator&gt; OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);示例：计算范围内相邻元素的差std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;diff(v.size());std::adjacent_difference(v.begin(),v.end(),diff.begin());std::partial_sum函数原型：template &lt;class InputIterator, class OutputIterator&gt; OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);示例：计算范围内元素的前缀和std::vector&lt;int&gt;v={1,2,3,4,5};std::vector&lt;int&gt;sums(v.size());std::partial_sum(v.begin(),v.end(),sums.begin());std::iota函数原型：template &lt;class ForwardIterator, class T&gt; void iota(ForwardIterator first, ForwardIterator last, T value);示例：填充范围内的序列值（已在上文展示）std::gcd函数原型：template &lt;class M, class N&gt; constexpr M gcd(M m, N n);示例：计算两个整数的最大公约数（已在上文展示）std::lcm函数原型：template &lt;class M, class N&gt; constexpr common_type_t&lt;M, N&gt; lcm(M m, N n);示例：计算两个整数的最小公倍数inta=48,b=18;intresult=std::lcm(a,b);functionalstd::function函数原型：template &lt;class&gt; class function;示例：创建一个可调用对象的封装（已在上文展示）std::bind函数原型：template &lt;class&gt; class bind;示例：创建一个可调用对象，其行为类似于函数或成员函数的绑定版本（已在上文展示）std::hash函数原型：template &lt;class T&gt; class hash;示例：计算给定值的哈希值// 创建一个字符串std::string str="Hello, World!";// 使用 std::hash 生成哈希值std::hash&lt;std::string&gt;hasher;size_t hash_value=hasher(str);std::equal_to函数原型：struct equal_to { constexpr bool operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：比较两个值是否相等std::vector&lt;int&gt;v1={1,2,3};std::vector&lt;int&gt;v2={1,2,3};boolis_equal=std::equal_to&lt;&gt;()(v1.begin(),v1.end(),v2.begin());std::not_equal_to函数原型：struct not_equal_to { constexpr bool operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：比较两个值是否不相等std::vector&lt;int&gt;v1={1,2,3};std::vector&lt;int&gt;v2={1,2,4};boolis_not_equal=std::not_equal_to&lt;&gt;()(v1.begin(),v1.end(),v2.begin());std::greater函数原型：struct greater { constexpr bool operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：比较两个值是否满足a &gt; bstd::vector&lt;int&gt;v={1,2,3,4,5};std::sort(v.begin(),v.end(),std::greater&lt;&gt;());std::less函数原型：struct less { constexpr bool operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：比较两个值是否满足a &lt; bstd::vector&lt;int&gt;v={5,3,4,2,1};std::sort(v.begin(),v.end(),std::less&lt;&gt;());std::plus函数原型：struct plus { constexpr T operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：计算两个值的和intresult=std::plus&lt;int&gt;()(2,3);std::minus函数原型：struct minus { constexpr T operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：计算两个值的差intresult=std::minus&lt;int&gt;()(5,2);std::multiplies函数原型：struct multiplies { constexpr T operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：计算两个值的积intresult=std::multiplies&lt;int&gt;()(3,4);std::divides函数原型：struct divides { constexpr T operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：计算两个值的商intresult=std::divides&lt;int&gt;()(6,2);std::modulus函数原型：struct modulus { constexpr T operator()(const T&amp; a, const T&amp; b) const noexcept; };示例：计算两个值的模intresult=std::modulus&lt;int&gt;()(9,2);std::negate函数原型：struct negate { constexpr T operator()(const T&amp; a) const noexcept; };示例：计算值的相反数intresult=std::negate&lt;int&gt;()(3);这些是C++ STL中、和头文件中定义的算法。每个算法都有其特定的用途，覆盖了从搜索、排序到数值计算等多种操作。http://www.ppmy.cn/news/1541488.html相关文章【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师一、ABR 
SW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0 R6查看OSPF路由： 二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA 但是有区域间路由就可以看到3类LSA阅读更多...Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:05 +0000</pubDate>
    </item>
    <item>
      <title>【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师</title>
      <link>https://www.ppmy.cn/news/1541487.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【华为HCIP实战课程十三】OSPF网络中3类LSA及区域间负载均衡，网络工程师news/2025/11/4 0:22:04/一、ABRSW1查看OSPF ABR为R4而非R3，因为R4连接骨干区域0，R3没有连接到区域0R6查看OSPF路由：二、查看3类LSA，由于R6不是ABR因此自身不会产生3类LSA但是有区域间路由就可以看到3类LSAhttp://www.ppmy.cn/news/1541487.html相关文章Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数感谢uu们的观看&amp;#xff0c;话不多说开始~ 
对于这个问题&amp;#xff0c;我们需要先来了解一下~ 
海量数据都可以用bitmap来存储&amp;#xff0c;因为占得内存小&amp;#xff0c;速度也很快 
我大概计算了一下~ 
完全够&amp;#xff1a;String类型512M 
1byte  8个bit位  8个状态 
512M1024byt…阅读更多...深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:04 +0000</pubDate>
    </item>
    <item>
      <title>Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数</title>
      <link>https://www.ppmy.cn/news/1541486.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java面试场景题（1）---如何使用redis记录上亿用户连续登陆天数news/2025/11/4 0:22:03/感谢uu们的观看，话不多说开始~对于这个问题，我们需要先来了解一下~海量数据都可以用bitmap来存储，因为占得内存小，速度也很快我大概计算了一下~完全够：String类型=512M1byte = 8个bit位 = 8个状态512M=1024byte*1024*512*8=4294967296个状态，所以呢，用bitmap我们的内存是可以存下的bitmap0 0 0 0 0 0 0 0 0 0   0   0  00 1 2 3 4 5 6 7 8 9 10 11 12 ....4294967296主要怎么使用呢？连续签到或者连续登陆？可以用每天或者用户Id两个维度来存储bitmap但是存储方式不一样，统计的方式也不一样如：（根据每天）（适用用户量多的）前提（Id是唯一的数字，比如id为5），那么你第一天用户5登录了，你可以存储为一...第二天...二...以此类推，到最后一天，以当天为起点，然后往前面推算，凡是碰到1的，就把他给统计，碰到0，就不再给用户继续统计，即可！但缺点（如图所示），不建议统计超过30天（如游戏签到）因为统计太长内存变多数量增加，30天就设置key为30，过期就结束~http://www.ppmy.cn/news/1541486.html相关文章深入理解Qt中的QTableView、Model与Delegate机制文章目录 显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使…阅读更多...鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:03 +0000</pubDate>
    </item>
    <item>
      <title>深入理解Qt中的QTableView、Model与Delegate机制</title>
      <link>https://www.ppmy.cn/news/1541485.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深入理解Qt中的QTableView、Model与Delegate机制news/2025/11/4 0:22:02/文章目录显示效果QTableViewModel(模型)Delegate(委托)ITEM控件主函数调用项目下载在Qt中，视图(View)、模型(Model)和委托(Delegate)机制是一种非常强大的架构，它们实现了MVC(模型-视图-控制器)设计模式。这种架构分离了数据存储(模型)、数据展示(视图)和数据操作(委托)，使得应用程序更加灵活和可维护。下面以QTableView为例介绍一下如何在QT中使用MVC机制。显示效果QTableViewQTableView是Qt中用于显示二维表格数据的视图组件。它可以与模型结合，动态显示和编辑数据。QTableView本身不存储数据，而是通过模型来获取数据并显示。//mytableview.h#ifndefMYTABLEVIEW_Hhttp://www.ppmy.cn/news/1541485.html相关文章鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例1. 服务端数字证书验证的问题 
在鸿蒙客户端对服务端发起HTTPS请求时&amp;#xff0c;如果使用HttpRequest的request发起请求&amp;#xff0c;那么就存在服务端数字证书的验证问题&amp;#xff0c;你只有两个选择&amp;#xff0c;一个是使用系统的CA&amp;#xff0c;一个是使用自己选定的CA&amp;#xf…阅读更多...MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:02 +0000</pubDate>
    </item>
    <item>
      <title>鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例</title>
      <link>https://www.ppmy.cn/news/1541484.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维鸿蒙网络编程系列27-HTTPS服务端证书的四种校验方式示例news/2025/11/4 0:22:01/1. 服务端数字证书验证的问题在鸿蒙客户端对服务端发起HTTPS请求时，如果使用HttpRequest的request发起请求，那么就存在服务端数字证书的验证问题，你只有两个选择，一个是使用系统的CA，一个是使用自己选定的CA，在上文鸿蒙网络编程系列26-HTTPS证书自选CA校验示例中，对此进行了介绍。但是，还有一些更常见的问题难以解决：可不可以跳过对服务端数字证书的验证可不可以自定义验证规则，比如，只验证数字证书的公玥，忽略有效期，就是说失效了也可以继续用如果你还是使用HttpRequest的话，答案是否定的。但是，鸿蒙开发者很贴心的推出了远场通信服务，可以使用rcp模块的方法发起请求，并且在请求时指定服务端证书的验证方式，关键点就在SecurityConfiguration接口上，该接口的remoteValidation属性支持远程服务器证书的四种验证模式：'system'：使用系统CA，默认值'skip'：跳过验证CertificateAuthority：选定CAValidationCallback：自定义证书校验Talk is cheap, show you the code！2. 实现HTTPS服务端证书四种校验方式示例本示例运行后的界面如下所示：选择证书验证模式，在请求地址输入要访问的https网址，然后单击“请求”按钮，就可以在下面的日志区域显示请求结果。下面详细介绍创建该应用的步骤。步骤1：创建Empty Ability项目。步骤2：在module.json5配置文件加上对权限的声明："requestPermissions": [{"name": "ohos.permission.INTERNET"}]这里添加了获取互联网信息的权限。步骤3：在Index.ets文件里添加如下的代码：import util from '@ohos.util';
import picker from '@ohos.file.picker';
import fs from '@ohos.file.fs';
import { BusinessError } from '@kit.BasicServicesKit';
import { rcp } from '@kit.RemoteCommunicationKit';
​
@Entry
@Component
struct Index {//连接、通讯历史记录@State msgHistory: string = ''//请求的HTTPS地址@State httpsUrl: string = "https://47.**.**.***:8081/hello"//服务端证书验证模式，默认系统CA@State certVerifyType: number = 0//是否显示选择CA的组件@State selectCaShow: Visibility = Visibility.None//选择的ca文件@State caFileUri: string = ''scroller: Scroller = new Scroller()
​build() {Row() {Column() {Text("远场通讯HTTPS证书校验示例").fontSize(14).fontWeight(FontWeight.Bold).width('100%').textAlign(TextAlign.Center).padding(10)
​Flex({ justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {Text("选择服务器HTTPS证书的验证模式：").fontSize(14).width(90).flexGrow(1)}.width('100%').padding(10)
​Flex({ justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {Column() {Text('系统CA').fontSize(14)Radio({ value: '0', group: 'rgVerify' }).checked(true).height(50).width(50).onChange((isChecked: boolean) =&gt; {if (isChecked) {this.certVerifyType = 0}})}
​Column() {Text('指定CA').fontSize(14)Radio({ value: '1', group: 'rgVerify' }).checked(false).height(50).width(50).onChange((isChecked: boolean) =&gt; {if (isChecked) {this.certVerifyType = 1}})}
​Column() {Text('跳过验证').fontSize(14)Radio({ value: '2', group: 'rgVerify' }).checked(false).height(50).width(50).onChange((isChecked: boolean) =&gt; {if (isChecked) {this.certVerifyType = 2}})}
​Column() {Text('自定义验证').fontSize(14)Radio({ value: '3', group: 'rgVerify' }).checked(false).height(50).width(50).onChange((isChecked: boolean) =&gt; {if (isChecked) {this.certVerifyType = 3}})}}.width('100%').padding(10)
​Flex({ justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {Text("服务端证书CA").fontSize(14).width(90).flexGrow(1)
​Button("选择").onClick(() =&gt; {this.selectCA()}).width(70).fontSize(14)}.width('100%').padding(10).visibility(this.certVerifyType == 1 ? Visibility.Visible : Visibility.None)
​Flex({ justifyContent: FlexAlign.Start, alignItems: ItemAlign.Center }) {Text("请求地址：").fontSize(14).width(80)TextInput({ text: this.httpsUrl }).onChange((value) =&gt; {this.httpsUrl = value}).width(110).fontSize(12).flexGrow(1)Button("请求").onClick(() =&gt; {this.doHttpRequest()}).width(60).fontSize(14)}.width('100%').padding(10)
​Scroll(this.scroller) {Text(this.msgHistory).textAlign(TextAlign.Start).padding(10).width('100%').backgroundColor(0xeeeeee)}.align(Alignment.Top).backgroundColor(0xeeeeee).height(300).flexGrow(1).scrollable(ScrollDirection.Vertical).scrollBar(BarState.On).scrollBarWidth(20)}.width('100%').justifyContent(FlexAlign.Start).height('100%')}.height('100%')}
​//自定义证书验证方式selfDefServerCertValidation: rcp.ValidationCallback = (context: rcp.ValidationContext) =&gt; {//此处编写证书有效性判断逻辑return true;}
​//生成rcp配置信息buildRcpCfg() {let caCert: rcp.CertificateAuthority = {content: this.getCAContent()}//服务器端证书验证模式let certVerify: 'system' | 'skip' | rcp.CertificateAuthority | rcp.ValidationCallback = "system"
​if (this.certVerifyType == 0) { //系统验证certVerify = 'system'} else if (this.certVerifyType == 1) { //选择CA证书验证certVerify =caCert} else if (this.certVerifyType == 2) { //跳过验证certVerify = 'skip'} else if (this.certVerifyType == 3) { //自定义证书验证certVerify = this.selfDefServerCertValidation}let secCfg: rcp.SecurityConfiguration = { remoteValidation: certVerify }let reqCfg: rcp.Configuration = { security: secCfg }let sessionCfg: rcp.SessionConfiguration = { requestConfiguration: reqCfg }return sessionCfg}
​//发起http请求doHttpRequest() {let rcpCfg = this.buildRcpCfg()let rcpSession: rcp.Session = rcp.createSession(rcpCfg)rcpSession.get(this.httpsUrl).then((response) =&gt; {if (response.body != undefined) {let result = buf2String(response.body)this.msgHistory += '请求响应信息： ' + result + "\r\n";}}).catch((err: BusinessError) =&gt; {this.msgHistory += `err: err code is ${err.code}, err message is ${JSON.stringify(err)}\r\n`;})}
​//选择CA证书文件selectCA() {let documentPicker = new picker.DocumentViewPicker();documentPicker.select().then((result) =&gt; {if (result.length &gt; 0) {this.caFileUri = result[0]this.msgHistory += "select file: " + this.caFileUri + "\r\n";}}).catch((e: BusinessError) =&gt; {this.msgHistory += 'DocumentViewPicker.select failed ' + e.message + "\r\n";});}
​//加载CA文件内容getCAContent(): string {let caContent = ""try {let buf = new ArrayBuffer(1024 * 4);let file = fs.openSync(this.caFileUri, fs.OpenMode.READ_ONLY);let readLen = fs.readSync(file.fd, buf, { offset: 0 });caContent = buf2String(buf.slice(0, readLen))fs.closeSync(file);} catch (e) {this.msgHistory += 'readText failed ' + e.message + "\r\n";}return caContent}
}
​
​
//ArrayBuffer转utf8字符串
function buf2String(buf: ArrayBuffer) {let msgArray = new Uint8Array(buf);let textDecoder = util.TextDecoder.create("utf-8");return textDecoder.decodeWithStream(msgArray)
}步骤4：编译运行，可以使用模拟器或者真机。步骤5：选择默认“系统CA”，输入请求网址（假设web服务端使用的是自签名证书），然后单击“请求”按钮，这时候会出现关于数字证书的错误信息，如图所示：步骤6：选择“指定CA”类型，然后单击出现的“选择”按钮，可以在本机选择CA证书文件，然后单击“请求”按钮：可以看到，得到了正确的请求结果。步骤7：选择“跳过验证”类型，然后然后单击“请求”按钮：也得到了正确的请求结果。步骤8：选择“自定义验证”类型，然后然后单击“请求”按钮：也得到了正确的请求结果。3. 关键功能分析关键点主要有两块，第一块是设置验证模式：//服务器端证书验证模式let certVerify: 'system' | 'skip' | rcp.CertificateAuthority | rcp.ValidationCallback = "system"
​if (this.certVerifyType == 0) { //系统验证certVerify = 'system'} else if (this.certVerifyType == 1) { //选择CA证书验证certVerify =caCert} else if (this.certVerifyType == 2) { //跳过验证certVerify = 'skip'} else if (this.certVerifyType == 3) { //自定义证书验证certVerify = this.selfDefServerCertValidation}let secCfg: rcp.SecurityConfiguration = { remoteValidation: certVerify }let reqCfg: rcp.Configuration = { security: secCfg }let sessionCfg: rcp.SessionConfiguration = { requestConfiguration: reqCfg }return sessionCfg}这个比较好理解，第二块是自定义证书验证的方法：//自定义证书验证方式selfDefServerCertValidation: rcp.ValidationCallback = (context: rcp.ValidationContext) =&gt; {//此处编写证书有效性判断逻辑return true;}这里为简单起见，自定义规则是所有的验证都通过，读者可以根据自己的需要来修改，比如不验证证书的有效期。（本文作者原创，除非明确授权禁止转载）本文源码地址：https://gitee.com/zl3624/harmonyos_network_samples/tree/master/code/rcp/RCPCertVerify本系列源码地址：https://gitee.com/zl3624/harmonyos_network_sampleshttp://www.ppmy.cn/news/1541484.html相关文章MySQL8.0主从同步报ERROR 13121错误解决方法由于平台虚拟机宿主机迁移&amp;#xff0c;导致一套MySQL主从库从节点故障&amp;#xff0c;从节点服务终止&amp;#xff0c;在服务启动后&amp;#xff0c;恢复从节点同步服务&amp;#xff0c;发现了如下报错&amp;#xff1a; 
mysql&gt; show slave status\G; *************************** 1. row *****…阅读更多...Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:01 +0000</pubDate>
    </item>
    <item>
      <title>MySQL8.0主从同步报ERROR 13121错误解决方法</title>
      <link>https://www.ppmy.cn/news/1541483.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQL8.0主从同步报ERROR 13121错误解决方法news/2025/11/4 0:22:01/由于平台虚拟机宿主机迁移，导致一套MySQL主从库从节点故障，从节点服务终止，在服务启动后，恢复从节点同步服务，发现了如下报错：mysql&gt; show slave status\G;*************************** 1. row ***************************Slave_IO_State: Waiting for master to send eventMaster_Host: XXXXMaster_User: cdbsyncMaster_Port: 3366Connect_Retry: 60Master_Log_File: mysql-bin.007843Read_Master_Log_Pos: 78338072Relay_Log_File: nxscjdtsjkmysqlzc-mysql-master-2-367f7-0-relay-bin.023264Relay_Log_Pos: 78930577Relay_Master_Log_File: mysql-bin.007841Slave_IO_Running: YesSlave_SQL_Running: NoReplicate_Do_DB:Replicate_Ignore_DB:Replicate_Do_Table:Replicate_Ignore_Table:Replicate_Wild_Do_Table:Replicate_Wild_Ignore_Table:Last_Errno: 13121Last_Error: Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master's binary log is corrupted (you can check this by running 'mysqlbinlog' on the binary log), the slave's relay log is corrupted (you can check this by running 'mysqlbinlog' on the relay log), a network problem, the server was unable to fetch a keyring key required to open an encrypted relay log file, or a bug in the master's or slave's MySQL code. If you want to check the master's binary log or slave's relay log, you will be able to know their names by issuing 'SHOW SLAVE STATUS' on this slave.Skip_Counter: 0Exec_Master_Log_Pos: 78930363Relay_Log_Space: 300215564Until_Condition: NoneUntil_Log_File:Until_Log_Pos: 0Master_SSL_Allowed: NoMaster_SSL_CA_File:Master_SSL_CA_Path:Master_SSL_Cert:Master_SSL_Cipher:Master_SSL_Key:Seconds_Behind_Master: NULLMaster_SSL_Verify_Server_Cert: NoLast_IO_Errno: 0Last_IO_Error:Last_SQL_Errno: 13121Last_SQL_Error: Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master's binary log is corrupted (you can check this by running 'mysqlbinlog' on the binary log), the slave's relay log is corrupted (you can check this by running 'mysqlbinlog' on the relay log), a network problem, the server was unable to fetch a keyring key required to open an encrypted relay log file, or a bug in the master's or slave's MySQL code. If you want to check the master's binary log or slave's relay log, you will be able to know their names by issuing 'SHOW SLAVE STATUS' on this slave.Replicate_Ignore_Server_Ids:Master_Server_Id: 2887743427Master_UUID: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5eMaster_Info_File: mysql.slave_master_infoSQL_Delay: 0SQL_Remaining_Delay: NULLSlave_SQL_Running_State:Master_Retry_Count: 86400Master_Bind:Last_IO_Error_Timestamp:Last_SQL_Error_Timestamp: 241016 02:50:23Master_SSL_Crl:Master_SSL_Crlpath:Retrieved_Gtid_Set: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5e:1-9339028Executed_Gtid_Set: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5e:1-9337179Auto_Position: 1Replicate_Rewrite_DB:Channel_Name:Master_TLS_Version:Master_public_key_path:Get_master_public_key: 1Network_Namespace:1 row in set (0.00 sec)ERROR:No query specifiedmysql&gt;查看报错信息，提示由于日志损坏、网络问题或bug导致无法获取中继日志中的事件信息。在尝试了跳过从节点错误方法后，依旧不能正常同步，报错还是一样。于是，就计划reset slave，重新从中断的日志及position开始复制，整个操作流程如下：确认Relay_Master_Log_File和Exec_Master_Log_Pos信息：Relay_Master_Log_File: mysql-bin.007841Exec_Master_Log_Pos: 78930363STOP SLAVE;RESET SLAVE;CHANGE MASTER TO master_log_file='mysql-bin.007841', master_log_pos=78930363;START SLAVE;操作过程：mysql&gt; stop slave;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; RESET SLAVE;Query OK, 0 rows affected (0.10 sec)mysql&gt; CHANGE MASTER TO master_log_file='mysql-bin.007841', master_log_pos=78930363;ERROR 1776 (HY000): Parameters MASTER_LOG_FILE, MASTER_LOG_POS, RELAY_LOG_FILE and RELAY_LOG_POS cannot be set when MASTER_AUTO_POSITION is active.根据提示信息，在从节点上设置master_auto_position为0：mysql&gt; change master to master_auto_position=0;Query OK, 0 rows affected (0.08 sec)mysql&gt; CHANGE MASTER TO master_log_file='mysql-bin.007841', master_log_pos=78930363;Query OK, 0 rows affected (0.06 sec)重新启动slave：mysql&gt;mysql&gt; start slave;Query OK, 0 rows affected (0.01 sec)mysql&gt; stop slave;Query OK, 0 rows affected (0.03 sec)同步正常后，将master_auto_position修改为1并重新启动同步：mysql&gt; change master to master_auto_position=-&gt; 1;Query OK, 0 rows affected (0.05 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.02 sec)mysql&gt; show slave status\G;*************************** 1. row ***************************Slave_IO_State: Waiting for master to send eventMaster_Host: XXXXMaster_User: cdbsyncMaster_Port: 3366Connect_Retry: 60Master_Log_File: mysql-bin.007843Read_Master_Log_Pos: 79142894Relay_Log_File: nxscjdtsjkmysqlzc-mysql-master-2-367f7-0-relay-bin.000002Relay_Log_Pos: 10529Relay_Master_Log_File: mysql-bin.007843Slave_IO_Running: YesSlave_SQL_Running: YesReplicate_Do_DB:Replicate_Ignore_DB:Replicate_Do_Table:Replicate_Ignore_Table:Replicate_Wild_Do_Table:Replicate_Wild_Ignore_Table:Last_Errno: 0Last_Error:Skip_Counter: 0Exec_Master_Log_Pos: 79142894Relay_Log_Space: 10772Until_Condition: NoneUntil_Log_File:Until_Log_Pos: 0Master_SSL_Allowed: NoMaster_SSL_CA_File:Master_SSL_CA_Path:Master_SSL_Cert:Master_SSL_Cipher:Master_SSL_Key:Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: NoLast_IO_Errno: 0Last_IO_Error:Last_SQL_Errno: 0Last_SQL_Error:Replicate_Ignore_Server_Ids:Master_Server_Id: 2887743427Master_UUID: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5eMaster_Info_File: mysql.slave_master_infoSQL_Delay: 0SQL_Remaining_Delay: NULLSlave_SQL_Running_State: Slave has read all relay log; waiting for more updatesMaster_Retry_Count: 86400Master_Bind:Last_IO_Error_Timestamp:Last_SQL_Error_Timestamp:Master_SSL_Crl:Master_SSL_Crlpath:Retrieved_Gtid_Set: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5e:9339373-9339378Executed_Gtid_Set: e4a6bc6b-9de0-11eb-b5e2-fa163e5aaa5e:1-9339378Auto_Position: 1Replicate_Rewrite_DB:Channel_Name:Master_TLS_Version:Master_public_key_path:Get_master_public_key: 1Network_Namespace:1 row in set (0.00 sec)ERROR:No query specifiedmysql&gt;至此，整个同步报错处理完成。http://www.ppmy.cn/news/1541483.html相关文章Android中的SSL/TLS加密及其作用Android中的SSL/TLS加密及其作用 
SSL/TLS&amp;#xff08;Secure Sockets Layer/Transport Layer Security&amp;#xff09;加密技术是保护网络通信安全的关键技术之一&amp;#xff0c;广泛应用于各种网络通信场景&amp;#xff0c;包括Android应用开发。在Android中&amp;#xff0c;SSL/TLS加密技术…阅读更多...【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:01 +0000</pubDate>
    </item>
    <item>
      <title>Android中的SSL/TLS加密及其作用</title>
      <link>https://www.ppmy.cn/news/1541482.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Android中的SSL/TLS加密及其作用news/2025/11/4 0:22:00/Android中的SSL/TLS加密及其作用SSL/TLS（Secure Sockets Layer/Transport Layer Security）加密技术是保护网络通信安全的关键技术之一，广泛应用于各种网络通信场景，包括Android应用开发。在Android中，SSL/TLS加密技术主要用于确保应用与服务器之间传输的数据的安全性、完整性和真实性。以下将详细解释Android中的SSL/TLS加密及其作用。一、SSL/TLS加密技术概述SSL（Secure Sockets Layer，安全套接字层）最初由Netscape公司开发，用于在Web服务器和客户端之间提供安全通信。后来，IETF（互联网工程任务组）对SSL进行了标准化，并发布了其后续版本TLS（Transport Layer Security，传输层安全）。目前，TLS已经成为主流，并被广泛应用于各种网络通信场景。SSL/TLS加密技术基于公钥和私钥加密算法，通过握手阶段的密钥交换和身份验证，以及加密通信阶段的数据加密，确保数据传输的安全性和完整性。在SSL/TLS协议中，客户端和服务器之间会建立一个安全通道，该通道使用共享密钥进行加密和解密，从而保护传输的数据不被窃听、篡改或泄露。二、Android中的SSL/TLS加密实现在Android开发中，实现SSL/TLS加密通常涉及以下几个步骤：生成密钥对和证书：开发者需要生成一个密钥对，包括私钥和公钥。私钥用于解密数据，公钥用于加密数据。同时，开发者还需要生成一个数字证书，该证书包含公钥和其他身份验证信息，并由认证机构（CA）颁发。配置服务器：服务器需要配置SSL/TLS证书，以便在与客户端建立连接时提供身份验证和数据加密。服务器还需要配置支持的加密算法和密钥长度等参数。客户端实现：在Android客户端中，开发者需要使用HttpsURLConnection或OkHttp等库来建立HTTPS连接。客户端会向服务器发送请求，并接收服务器的响应。在建立连接的过程中，客户端会验证服务器的证书是否有效，并协商出一个共享密钥用于后续的数据加密和解密。数据传输：一旦连接建立成功，客户端和服务器之间就可以使用共享密钥进行加密和解密数据传输了。在传输过程中，数据会被加密成密文，只有持有私钥的服务器才能解密并读取原始数据。三、SSL/TLS加密在Android中的作用SSL/TLS加密技术在Android中发挥着至关重要的作用，主要体现在以下几个方面：数据加密：SSL/TLS加密技术可以对传输的数据进行加密，确保数据在传输过程中不被窃听或泄露。这对于保护用户的隐私和敏感信息至关重要，如信用卡号码、密码等。身份验证：SSL/TLS协议使用数字证书验证服务器的身份，确保客户端与正确的服务器建立连接。这可以防止中间人攻击，即攻击者伪装成服务器或客户端，在两端之间进行数据传输，从而窃取数据或篡改数据。完整性保护：SSL/TLS协议使用数字签名技术保护传输的数据完整性。数字签名使用服务器的私钥对数据进行签名，客户端使用服务器的公钥对数据进行验证，以确保数据没有被篡改或损坏。防止中间人攻击：如前所述，SSL/TLS协议通过验证服务器的身份来防止中间人攻击。这确保了客户端与服务器之间的通信是安全的，不会被第三方窃取或篡改。兼容性：SSL/TLS协议是一种通用的加密技术，可以用于各种不同的网络应用程序和操作系统。这使得Android应用可以轻松地与其他支持SSL/TLS协议的系统进行通信，而无需担心兼容性问题。四、Android中SSL/TLS加密的常见问题和解决方案尽管SSL/TLS加密技术在Android中发挥着重要作用，但在实际应用中仍可能遇到一些常见问题。以下是一些常见的问题及其解决方案：证书验证失败：问题原因：客户端无法验证服务器的证书的有效性。解决方案：确保服务器的证书是由受信任的认证机构颁发的，并且证书链是完整的。同时，检查客户端的信任库是否包含受信任的根证书。握手失败：问题原因：客户端和服务器在握手阶段无法协商出一个共同的加密算法或密钥长度。解决方案：确保客户端和服务器都支持相同的加密算法和密钥长度。同时，检查服务器的SSL/TLS配置是否正确。性能问题：问题原因：SSL/TLS加密会增加网络通信的延迟，特别是在使用复杂的加密算法时。解决方案：根据实际需求选择合适的加密算法和密钥长度。在性能要求较高的场景中，可以考虑使用硬件加速或优化加密算法来提高性能。私钥泄露：问题原因：私钥被未经授权的人员或机构获取。解决方案：妥善保管私钥文件，避免将其泄露给未经授权的人员或机构。同时，定期更换私钥密码，增加私钥的安全性。五、Android中SSL/TLS加密的最佳实践为了确保Android应用中SSL/TLS加密的有效性和安全性，以下是一些最佳实践建议：使用最新的SSL/TLS版本：始终使用最新的SSL/TLS版本，并及时更新安全补丁以修复已知漏洞。选择合适的加密算法和密钥长度：根据实际需求选择合适的加密算法和密钥长度。一般来说，AES-256和RSA-2048等较新的算法和较长的密钥长度提供了更高的安全性。启用证书验证：在客户端中启用证书验证功能，确保只与受信任的服务器建立连接。避免使用自签名证书：尽量避免在生产环境中使用自签名证书。如果必须使用自签名证书，请确保客户端信任该证书并了解相关的安全风险。定期更新和审计：定期更新SSL/TLS配置和相关的安全补丁。同时，对SSL/TLS加密的使用情况进行审计和监控，以确保其符合安全标准和最佳实践。使用硬件加速：在性能要求较高的场景中，可以考虑使用硬件加速来优化SSL/TLS加密的性能。例如，使用支持SSL/TLS硬件加速的网络处理器或安全芯片等。用户教育和意识提升：对用户进行安全教育和意识提升，让他们了解SSL/TLS加密的重要性以及如何使用安全的网络连接。综上所述，SSL/TLS加密技术在Android中发挥着至关重要的作用，可以保护用户的数据安全、隐私和完整性。然而，在实际应用中仍需注意一些常见问题和最佳实践建议，以确保SSL/TLS加密的有效性和安全性。通过遵循这些建议和实践，开发者可以构建更加安全、可靠的Android应用。http://www.ppmy.cn/news/1541482.html相关文章【Next.js 项目实战系列】03-查看 Issue原文链接 CSDN 的排版/样式可能有问题&amp;#xff0c;去我的博客查看原文系列吧&amp;#xff0c;觉得有用的话&amp;#xff0c;给我的库点个star&amp;#xff0c;关注一下吧  上一篇【Next.js 项目实战系列】02-创建 Issue 
查看 Issue 
展示 Issue​ 
本节代码链接 
首先使用 prisma 获取所有…阅读更多...如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:22:00 +0000</pubDate>
    </item>
    <item>
      <title>【Next.js 项目实战系列】03-查看 Issue</title>
      <link>https://www.ppmy.cn/news/1541481.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Next.js 项目实战系列】03-查看 Issuenews/2025/11/4 0:21:59/原文链接CSDN 的排版/样式可能有问题，去我的博客查看原文系列吧，觉得有用的话，给我的库点个star，关注一下吧上一篇【Next.js 项目实战系列】02-创建 Issue查看 Issue展示 Issue​本节代码链接首先使用 prisma 获取所有的 issues，然后添加一个 Radix UI 中的 Table 组件# /app/issues/page.tsximport { Button, Table, TableColumnHeaderCell } from "@radix-ui/themes";import Link from "next/link";
+ import prisma from "@/prisma/client";const IssuesPage = async () =&gt; {
+   const issues = await prisma.issue.findMany();return (&lt;div&gt;&lt;div className="mb-5"&gt;&lt;Button&gt;&lt;Link href="/issues/new"&gt;New Issue&lt;/Link&gt;&lt;/Button&gt;&lt;/div&gt;{/* Radix UI 中的 Table 组件 */}
+       &lt;Table.Root variant="surface"&gt;
+         &lt;Table.Header&gt;
+           &lt;Table.Row&gt;
+             &lt;TableColumnHeaderCell&gt;Issue&lt;/TableColumnHeaderCell&gt;
+             &lt;TableColumnHeaderCell&gt;Status&lt;/TableColumnHeaderCell&gt;
+             &lt;TableColumnHeaderCell&gt;Created&lt;/TableColumnHeaderCell&gt;
+           &lt;/Table.Row&gt;
+         &lt;/Table.Header&gt;
+         &lt;Table.Body&gt;
+           {issues.map((issue) =&gt; (
+             &lt;Table.Row key={issue.id}&gt;
+               &lt;Table.Cell&gt;{issue.title}&lt;/Table.Cell&gt;
+               &lt;Table.Cell&gt;{issue.status}&lt;/Table.Cell&gt;
+               &lt;Table.Cell&gt;{issue.createdAt.toDateString()}&lt;/Table.Cell&gt;
+             &lt;/Table.Row&gt;
+           ))}
+         &lt;/Table.Body&gt;
+       &lt;/Table.Root&gt;&lt;/div&gt;);};export default IssuesPage;然后我们可以给不同的列添加显示选项，以适配不同的屏幕大小# /app/issues/page.tsx...
const IssuesPage = async () =&gt; {...return (&lt;div&gt;...&lt;Table.Root variant="surface"&gt;&lt;Table.Header&gt;&lt;Table.Row&gt;&lt;TableColumnHeaderCell&gt;Issue&lt;/TableColumnHeaderCell&gt;&lt;TableColumnHeaderCell className="hidden md:table-cell"&gt;Status&lt;/TableColumnHeaderCell&gt;&lt;TableColumnHeaderCell className="hidden md:table-cell"&gt;Created&lt;/TableColumnHeaderCell&gt;&lt;/Table.Row&gt;&lt;/Table.Header&gt;&lt;Table.Body&gt;{issues.map((issue) =&gt; (&lt;Table.Row key={issue.id}&gt;&lt;Table.Cell&gt;{issue.title}&lt;div className="block md:hidden"&gt;{issue.status}&lt;/div&gt;&lt;/Table.Cell&gt;&lt;Table.Cell className="hidden md:table-cell"&gt;{issue.status}&lt;/Table.Cell&gt;&lt;Table.Cell className="hidden md:table-cell"&gt;{issue.createdAt.toDateString()}&lt;/Table.Cell&gt;&lt;/Table.Row&gt;))}&lt;/Table.Body&gt;&lt;/Table.Root&gt;&lt;/div&gt;);
};
export default IssuesPage;显示效果如下​​制作 Badge​本节代码链接在 Prisma 中添加的 Model 会自动为我们生成 Type ，方便拿来做 Interface​这里有一些技巧。首先，对于一些固定值的映射(比如这里 Issue 状态对 Badge 颜色/内容的映射)，我们可以使用一个 Record 来记录，其本质为一个键值对，我们可以使用&lt; &gt;来定义键和值的数据类型# /app/components/IssueStatusBadge.tsximport { Status } from "@prisma/client";
import { Badge } from "@radix-ui/themes";const statusMap: Record&lt;Status,{ label: string; color: "green" | "violet" | "red" }
&gt; = {OPEN: { label: "Open", color: "green" },IN_PROGRESS: { label: "In Progress", color: "violet" },CLOSED: { label: "Closed", color: "red" },
};const IssueStatusBadge = ({ status }: { status: Status }) =&gt; {return (&lt;Badge color={statusMap[status].color}&gt;{statusMap[status].label}&lt;/Badge&gt;);
};
export default IssueStatusBadge;最终效果如下​Loading Skeleton​本节代码链接本节我们想要实现一个如下的加载动画​安装delay包用于模拟网速较慢情况，react-loading-skeleton包用于添加骨架动画npm i delay
npm i react-loading-skeleton首先，我们应该在页面中把不需要加载的部分(指不需要从外部获取数据的部分，一些写死的 Text, Link, Button 之类的)封装起来，# /app/issues/IssueAction.tsximport { Button } from "@radix-ui/themes";
import Link from "next/link";const IssueActions = () =&gt; {return (&lt;div className="mb-5"&gt;&lt;Button&gt;&lt;Link href="/issues/new"&gt;New Issue&lt;/Link&gt;&lt;/Button&gt;&lt;/div&gt;);
};
export default IssueActions;然后在page.tsx同目录下创建loading.tsx(注意文件名必须是这个，大小写也不能改)。将 page.tsx 中 return 的内容都复制到里面，把需要加载的字段换为 Skeleton 标签即可# /app/issues/loading.tsximport { Table, TableColumnHeaderCell } from "@radix-ui/themes";// import Skeleton
+ import Skeleton from "react-loading-skeleton";
+ import "react-loading-skeleton/dist/skeleton.css";import IssueActions from "./IssueActions";const LoadingIssuesPage = () =&gt; {// 显示 5 行 skeleton
+   const issues = [1, 2, 3, 4, 5];return (...&lt;Table.Body&gt;{issues.map((issue) =&gt; ({/* 将所有需要数据的字段换为 &lt;Skeleton /&gt;即可 */}
-         &lt;Table.Row key={issue.id}&gt;
+         &lt;Table.Row key={issue}&gt;&lt;Table.Cell&gt;
-             {issue.title}
+             &lt;Skeleton /&gt;&lt;div className="block md:hidden"&gt;
-               &lt;IssueStatusBadge status={issue.status} /&gt;
+               &lt;Skeleton /&gt;&lt;/div&gt;&lt;/Table.Cell&gt;&lt;Table.Cell className="hidden md:table-cell"&gt;
-             &lt;IssueStatusBadge status={issue.status} /&gt;
+             &lt;Skeleton /&gt;&lt;/Table.Cell&gt;&lt;Table.Cell className="hidden md:table-cell"&gt;
-             {issue.createdAt.toDateString()}
+             &lt;Skeleton /&gt;&lt;/Table.Cell&gt;&lt;/Table.Row&gt;))}&lt;/Table.Body&gt;...);};export default LoadingIssuesPage;我们可以在 page.tsx 中添加一个delay(2000)来模拟# /app/issues/page.tsx...
const IssuesPage = async () =&gt; {const issues = await prisma.issue.findMany();await delay(2000);...Issue Detail Page​本节代码链接首先创建一个页面用于展示 Issue 细节/app/issues/[id]/page.tsx# /app/issues/[id]/page.tsximport prisma from "@/prisma/client";
import { notFound } from "next/navigation";
interface Props {params: { id: string };
}
const IssueDeatilPage = async ({ params }: Props) =&gt; {// 判断 url 中的 id 是不是 number，比如 'issues/abc' 就直接404if (typeof params.id !== "number") notFound();// 获取 issueconst issue = await prisma.issue.findUnique({where: { id: parseInt(params.id) },});// 如果 issue 不存在，也404if (!issue) notFound();return (&lt;div&gt;&lt;p&gt;{issue.title}&lt;/p&gt;&lt;p&gt;{issue.description}&lt;/p&gt;&lt;p&gt;{issue.status}&lt;/p&gt;&lt;p&gt;{issue.createdAt.toDateString()}&lt;/p&gt;&lt;/div&gt;);
};
export default IssueDeatilPage;然后在/app/issues/page.tsx中渲染表格时，添加一个 Link，用于跳转到 detail 页面# /app/issues/page.tsxconst IssuesPage = async () =&gt; {return (...&lt;Table.Cell&gt;
+       &lt;Link href={`/issues/${issue.id}`}&gt;{issue.title}&lt;/Link&gt;&lt;div className="block md:hidden"&gt;&lt;IssueStatusBadge status={issue.status} /&gt;&lt;/div&gt;&lt;/Table.Cell&gt;...);};最后，我们应该为 "/app/issues" 下的每一个page都提供一个loading.tsx，否则刚刚的 "/app/issues/loading.tsx" 会应用到 "/app/issues" 下的所有页面添加样式​本节代码链接此处大量使用了 Radix UI 中的组件# /app/issues/[id]/page.tsxconst IssueDeatilPage = async ({ params }: Props) =&gt; {...return (&lt;div&gt;&lt;Heading as="h2"&gt;{issue.title}&lt;/Heading&gt;&lt;Flex gap="3" my="5"&gt;&lt;IssueStatusBadge status={issue.status}&gt;&lt;/IssueStatusBadge&gt;&lt;Text&gt;{issue.createdAt.toDateString()}&lt;/Text&gt;&lt;/Flex&gt;&lt;Card&gt;{issue.description}&lt;/Card&gt;&lt;/div&gt;);
};效果如下​MarkDown 渲染​本节代码链接首先，安装以下两个 packagenpm i react-markdown
npm install -D @tailwindcss/typography在 "/app/issues/[id]/page.tsx" 中，将 issue.description 用ReactMarkdown组件包起来即可# /app/issues/[id]/page.tsxconst IssueDeatilPage = async ({ params }: Props) =&gt; {...return (...
-     &lt;Card&gt;{issue.description}&lt;/Card&gt;
+     &lt;Card className="prose"&gt;
+       &lt;ReactMarkdown&gt;{issue.description}&lt;/ReactMarkdown&gt;
+     &lt;/Card&gt;...);};在 Tailwind 中，默认 h1, h2, ul, ol, strong 这些标签都是无样式的，我们需要手动进行设置。刚刚安装的tailwindcss/typography就是这个作用。首先，在tailwind.config.ts中，添加 plugin，然后在需要用到这些样式的 container 的className中添加prose即可# tailwind.config.tsimport type { Config } from "tailwindcss";const config: Config = {content: ["./pages/**/*.{js,ts,jsx,tsx,mdx}","./components/**/*.{js,ts,jsx,tsx,mdx}","./app/**/*.{js,ts,jsx,tsx,mdx}",],theme: {extend: {backgroundImage: {"gradient-radial": "radial-gradient(var(--tw-gradient-stops))","gradient-conic":"conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",},},},// 在这里添加 @tailwindcss/typography"
+   plugins: [require("@tailwindcss/typography")],};export default config;最终实现效果如下​自定义 Link Component​本节代码链接我们想要同时应用 Next.js 中 Link 的客户端导航功能，和 Radix UI 中 Link 的样式，就可以进行如下改装，后期直接使用即可# /app/components/link.tsximport NextLink from "next/link";
import { Link as RadixLink } from "@radix-ui/themes";interface Props {href: string;children: string;
}const Link = ({ href, children }: Props) =&gt; {return (&lt;NextLink href={href} passHref legacyBehavior&gt;&lt;RadixLink&gt;{children}&lt;/RadixLink&gt;&lt;/NextLink&gt;);
};
export default Link;效果如下，其中 Link 的颜色会随着 Theme 的改变而改变​Loading Skeletons​本节代码链接# /app/issues/[id]/loading.tsximport IssueStatusBadge from "@/app/components/IssueStatusBadge";
import { Box, Card, Flex, Heading } from "@radix-ui/themes";
import ReactMarkdown from "react-markdown";
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";const LoadingIssueDetailPage = () =&gt; {return (&lt;Box className="max-w-xl"&gt;&lt;Skeleton /&gt;&lt;Flex gap="3" my="5"&gt;&lt;Skeleton width="5rem" /&gt;&lt;Skeleton width="8rem" /&gt;&lt;/Flex&gt;&lt;Card className="prose"&gt;&lt;Skeleton count={3} /&gt;&lt;/Card&gt;&lt;/Box&gt;);
};
export default LoadingIssueDetailPage;# /app/issues/new/loading.tsximport { Box } from "@radix-ui/themes";
import Skeleton from "react-loading-skeleton";
import "react-loading-skeleton/dist/skeleton.css";const LoadingNewIssuePage = () =&gt; {return (&lt;Box className="max-w-xl"&gt;&lt;Skeleton /&gt;&lt;Skeleton height="20rem" /&gt;&lt;/Box&gt;);
};
export default LoadingNewIssuePage;显示效果如下​​动态导入(关闭 SSR)​本节代码链接SSR(Server Side Render) 相关内容可参考组件的渲染# /app/issues/new/page.tsx- import SimpleMDE from "react-simplemde-editor";
+ import dynamic from "next/dynamic";+ const SimpleMDE = dynamic(() =&gt; import("react-simplemde-editor"), {
+   ssr: false,
+ });整理 imports​本节代码链接我们可以在 Components 文件夹下添加index.ts，将该文件夹下所有组件都注册到其中# /app/components/index.tsexport { default as Link } from "./Link";
export { default as ErrorMessage } from "./ErrorMessage";
export { default as IssueStatusBadge } from "./IssueStatusBadge";
export { default as Spinner } from "./Spinner";
export { default as Skeleton } from "./Skeleton";然后在其他页面，直接使用以下 import 语句即可import { ErrorMessage, Spinner } from "@/app/components";CSDN 的排版/样式可能有问题，去我的博客查看原文系列吧，觉得有用的话，给我的库点个star，关注一下吧下一篇讲修改 Issue下一篇【Next.js 项目实战系列】04-修改 Issue​​​​​​​http://www.ppmy.cn/news/1541481.html相关文章如何选择适合TikTok直播的IP节点在数字化时代&amp;#xff0c;直播平台如TikTok正在迅速崛起&amp;#xff0c;成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播&amp;#xff0c;选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点&amp;#xff0c;帮助你优化直播质量并…阅读更多...【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:59 +0000</pubDate>
    </item>
    <item>
      <title>如何选择适合TikTok直播的IP节点</title>
      <link>https://www.ppmy.cn/news/1541480.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维如何选择适合TikTok直播的IP节点news/2025/11/4 0:21:58/在数字化时代，直播平台如TikTok正在迅速崛起，成为内容创作者与观众之间互动的主要渠道之一。要想在TikTok上成功直播，选择合适的IP节点是一个至关重要的环节。本文将深入探讨如何选择适合TikTok直播的IP节点，帮助你优化直播质量并提升用户体验。一、什么是IP节点？IP节点是指连接到互联网的设备或服务的地址。在直播过程中，IP节点的稳定性、速度和地理位置都会直接影响到直播的流畅度和观看体验。对于TikTok这样的短视频平台，用户对实时互动的要求非常高，因此，选择合适的IP节点显得尤为重要。二、选择IP节点的关键因素在选择IP节点时，有几个关键因素需要考虑：1. 地理位置IP节点的地理位置直接影响到观众的观看体验。如果你的主要观众群体在某个特定的地区，选择距离该地区更近的IP节点可以降低延迟，提高直播流畅度。例如，如果大多数观众在美国，选择美国本地的IP节点将有助于提升直播质量。2. 网络带宽网络带宽决定了数据传输的速度和稳定性。在进行直播时，较高的上传带宽是必须的，因为直播需要将视频数据实时传输到服务器。如果带宽不足，可能会导致画面卡顿、延迟增加等问题。因此，在选择IP节点时，要确保该节点的网络带宽足够支持高质量直播。3. 服务器稳定性一个稳定的服务器是保证直播质量的关键。如果服务器不稳定，可能会导致直播中断或画面质量下降。因此，选择知名的、经过验证的IP节点提供商至关重要。查看提供商的历史性能记录和用户反馈，可以帮助你评估其稳定性。4. 网络延迟网络延迟是指数据包从一个节点传输到另一个节点所需的时间。在直播过程中，低延迟意味着实时互动效果更佳，观众体验更流畅。使用网络监测工具可以帮助你测量不同IP节点的延迟情况，从而选择合适的节点。三、如何选择合适的IP节点选择合适的IP节点需要综合考虑多个因素，以下是一些具体的步骤：1. 确定目标受众首先，你需要明确自己的目标受众是谁，他们主要位于哪些地区。这将帮助你在选择IP节点时做出更有针对性的决定。2. 测试不同的IP节点在选择IP节点时，最好进行测试。你可以使用网络测速工具，测试不同IP节点的速度和延迟。通常情况下，选择那些提供低延迟和高带宽的节点。3. 考虑使用CDN内容分发网络（CDN）可以帮助提高直播质量。CDN通过将内容缓存到离用户更近的服务器上，降低延迟和提高加载速度。如果你的直播观众分布在不同地区，使用CDN可以显著改善观众的观看体验。4. 选择合适的服务提供商选择一个信誉良好的IP节点提供商至关重要。你可以参考其他直播者的推荐，查看网络评价，选择那些有稳定服务记录和良好客户支持的提供商。四、IP节点选择的常见误区在选择IP节点时，很多直播者常常会犯一些错误：1. 只关注价格虽然成本是选择IP节点的重要考虑因素，但不应仅仅依赖价格。价格低廉的IP节点可能无法提供所需的稳定性和速度，导致直播质量下降。2. 忽视地理位置有些直播者可能会忽视IP节点的地理位置，只关注带宽和价格。地理位置对直播质量的影响不可小觑，因此必须将其纳入考虑范围。3. 不定期测试网络环境是动态变化的，IP节点的表现也可能随之变化。因此，定期测试你所使用的IP节点是一个好习惯，以确保你始终使用最佳的节点进行直播。五、总结选择合适的IP节点对于TikTok直播的成功至关重要。通过综合考虑地理位置、网络带宽、服务器稳定性和网络延迟等因素，你可以找到最适合自己需求的IP节点，提升直播质量与观众体验。记住，投资于一个优质的IP节点将直接影响你的直播效果，从而帮助你在竞争激烈的内容创作市场中脱颖而出。希望本文能为你的TikTok直播提供有价值的参考与帮助！http://www.ppmy.cn/news/1541480.html相关文章【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget文章目录 QtQt多元素控件List WidgetTable WidgetTree Widget Qt Qt多元素控件 
List Widget 使用 QListWidget 能够显示一个纵向的列表。 属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素…阅读更多...软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:58 +0000</pubDate>
    </item>
    <item>
      <title>【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widget</title>
      <link>https://www.ppmy.cn/news/1541479.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Qt】控件——Qt多元素控件、常见的多元素控件、多元素控件的使用、List Widget、Table Widget、Tree Widgetnews/2025/11/4 0:21:58/文章目录QtQt多元素控件List WidgetTable WidgetTree WidgetQtQt多元素控件List Widget使用 QListWidget 能够显示一个纵向的列表。属性说明currentRow当前被选中的是第几行。count一共有多少行。sortingEnabled是否允许排序。isWrapping是否允许换行。itemAlignment元素的对齐方式。selectRectVisible被选中的元素矩形是否可见。spacing元素之间的间隔。方法说明addItem(const QString&amp; label)、addItem(QListWidgetItem *item)列表中添加元素。currentItem()返回 QListWidgetItem*，表示当前选中的元素。setCurrentItem(QListWidgetItem* item)设置选中哪个元素。setCurrentRow(int row)设置选中第几行的元素。insertItem(const QString&amp; label, int row)、insertItem(QListWidgetItem *item, int row)在指定的位置插入元素。item(int row)返回 QListWidgetItem*，表示第 row 行的元素。takeItem(int row)删除指定行的元素，返回 QListWidgetItem*，表示是哪个元素被删除了。信号说明currentItemChanged(QListWidgetItem* current, QListWidgetItem* old)选中不同元素时会触发。参数是当前选中的元素和之前选中的元素。currentRowChanged(int)选中不同元素时会触发。参数是当前选中元素的行数。itemClicked(QListWidgetItem* item)点击某个元素时触发。itemDoubleClicked(QListWidgetItem* item)双击某个元素时触发。itemEntered(QListWidgetItem* item)鼠标进入元素时触发。在上述介绍中，涉及到一个关键的类 ——QListWidgetItem。这个类表示 QListWidget 中的一个元素。其核心方法本质上是由 “文本 + 图标” 构成的。方法说明setFont设置字体。setIcon设置图标。setHidden设置隐藏。setSizeHint设置尺寸。setSelected设置是否选中。setText设置文本。setTextAlignment设置文本对齐方式。代码示例：创建一个 QListWidget，并且我们可以在里面进行添加元素和删除元素的操作。连接槽函数，addItem()的作用就是向 QListWidget 控件中添加 QListWidgteItem 元素；takeItem 作用是删除控件中的元素。Table WidgetTable Widget 使用 QTableWidget 表示一个表格控件。一个表格中包含若干行，每一行又包含若干列。表格中的每个单元格，是一个 QTableWidgetItem 对象。方法说明item(int row, int column)根据行数和列数获取指定的 QTableWidgetItem*。setItem(int row, int column, QTableWidget*)根据行数和列数设置表格中的元素。currentItem()返回被选中的元素 QTableWidgetItem*。currentRow()返回被选中元素是第几行。currentColumn()返回被选中元素是第几列。row(QTableWidgetItem*)获取指定 item 是第几行。column(QTableWidgetItem*)获取指定 item 是第几列。rowCount()获取行数。columnCount()获取列数。insertRow(int row)在第 row 行处插入新行。insertColumn(int column)在第 column 列插入新列。removeRow(int row)删除第 row 行。removeColumn(int column)删除第 column 列。setHorizontalHeaderItem(int column, QTableWidget*)设置指定列的表头。setVerticalHeaderItem(int row, QTableWidget*)设置指定行的表头。QTableWidgetItem 核心方法：方法说明row()获取当前是第几行。column()获取当前是第几列。setText(const QString&amp;)设置文本。setTextAlignment(int)设置文本对齐。setIcon(const QIcon&amp;)设置图标。setSelected(bool)设置被选中。setSizeHints(const QSize&amp;)设置尺寸。setFont(const QFont&amp;)设置字体。信号说明cellClicked(int row, int column)点击单元格时触发。cellDoubleClicked(int row, int column)双击单元格时触发。cellEntered(int row, int column)鼠标进入单元格时触发。currentCellChanged(int row, int column, int previousRow, int previousColumn)选中不同单元格时触发。创建表格控件QTableWidget。使用setItem向表格控件中添加元素。Tree WidgetTree Widget 使用 QTreeWidget 表示一个树形控件。里面的每个元素都是一个 QTreeWidgetItem，每个 QTreeWidgetItem 可以包含多个文本和图标，每个文本 / 图标为一个列。可以给 QTreeWidget 设置顶层节点（顶层节点可以有多个），然后再给顶层节点添加子节点，从而构成树形结构。这种结构非常适合展示具有层次关系的数据，比如文件系统目录结构、组织结构图等。方法说明clear清空所有子节点addTopLevelItem(QTreeWidgetItem* item)新增顶层节点topLevelItem(int index)获取指定下标的顶层节点.topLevelItemCount()获取顶层节点个数indexOfTopLevelItem(QTreeWidgetItem* item)查询指定节点是顶层节点中的下标takeTopLevelItem(int index)删除指定的顶层节点. 返回 QTreeWidgetItem* 表示被删除的元素currentItem()获取到当前选中的节点, 返回 QTreeWidgetItem*setCurrentItem(QTreeWidgetItem* item)选中指定节点setExpanded(bool)展开/关闭节点setHeaderLabel(const QString&amp; text)设置 TreeWidget 的 header 名称。信号说明currentItemChanged (QTreeWidgetItem* current, QTreeWidgetItem* old)切换选中元素时触发itemClicked (QTreeWidgetItem* item, int col)点击元素时触发itemDoubleClicked (QTreeWidgetItem* item, int col)双击元素时触发itemEntered (QTreeWidgetItem* item, int col)鼠标标进⼊时触发itemExpanded (QTreeWidgetItem* item)元素被展开时触发itemCollapsend (QTreeWidgetItem* item)元素被折叠时触发。QTreeWidgetItem 核心属性属性说明text持有的文本textAlignment文本对齐方式icon持有的图表font文本字体hidden是否隐藏disabled是否禁用expand是否展开sizeHint尺寸大小selected是否选中QTreeWidgetItem 核心方法方法说明addChild (QTreeWidgetItem* child)新增子节点childCount ()子节点的个数child (int index)获取指定下标的子节点，返回 QTreeWidgetItem*takeChild (int index)删除对应下标的子节点removeChild (QTreeWidgetItem* child)删除对应的子节点parent ()获取该元素的父节点创建QTreeWidget树形控件。添加树形控件的层级元素。http://www.ppmy.cn/news/1541479.html相关文章软考（网工）——网络规划设计文章目录 &amp;#x1f550;综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图 &amp;#x1f551;网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价 &amp;#x1f552;网络结构与功能1️⃣局域网结构类型2️⃣三层架构…阅读更多...sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:58 +0000</pubDate>
    </item>
    <item>
      <title>软考（网工）——网络规划设计</title>
      <link>https://www.ppmy.cn/news/1541478.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维软考（网工）——网络规划设计news/2025/11/4 0:21:57/文章目录🕐综合布线1️⃣结构化布线系统2️⃣综合布线六大子系统3️⃣综合布线物理结构图🕑网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价🕒网络结构与功能1️⃣局域网结构类型2️⃣三层架构（各层次功能）🕓广域网接入技术1️⃣广域网接入技术2️⃣广域网互联技术 SDH🕔网络故障诊断与排查1️⃣问题解决模型2️⃣网络故障排查命令3️⃣专用故障排查工具4️⃣层次化故障排查🕐综合布线1️⃣结构化布线系统网络规划和设计是一个迭代和优化的过程。结构化综合布线系统是基于现代计算机技术的通信物理平台，集成了语音、数据、图像和视频的传输功能，消除了原有通信线路在传输介质上的差别。2️⃣综合布线六大子系统结构化布线系统包含6个子系统：工作区子系统、水平子系统、干线子系统、设备间子系统、管理子系统和建筑群子系统。3️⃣综合布线物理结构图🕑网络分析与设计1️⃣网络规划设计模型2️⃣网络流量分析3️⃣网络安全技术措施表4️⃣技术评价在进行网络技术选择时，考虑：通信带宽、技术成熟性、连接服务类型、可扩展性、高投资产出比等因素。对于大型网络工程来说，项目本身不能成为新技术的试验田。尽量使用较成熟、拥有较多案例的技术。🕒网络结构与功能1️⃣局域网结构类型2️⃣三层架构（各层次功能）🕓广域网接入技术1️⃣广域网接入技术1.PSTN公用电话网络56kb/s。2.ISDN : BRI=2B+D=144K PRI=30B+D=2.048M。3.线缆调制解调器接入HFC主干光纤，光纤到小区，铜缆接入。4.数字用户线路远程接入xDSL。5.PON无源光网络，上行是TDMA,下行是广播。2️⃣广域网互联技术 SDH🕔网络故障诊断与排查1️⃣问题解决模型2️⃣网络故障排查命令show/display:监测系统的安装情况与网络的正常运行状况，也可以用千对故障区域的定位。debug:帮助分析协议和配置问题（生产环境不用）。ping:用于检测网络上不同设备之间的连通性。tracert:用于确定数据包在从一个设备到另一个设备直至目的地的过程中所经过的路径。网络管理工具（如CiscoWorks、HPOpenView等）都含有监测以及故障排除功能，这有助于对网络互联环境的管理和故障的及时排除。3️⃣专用故障排查工具欧姆表、数字万用表及电缆测试器：利用这些参数可以检测电缆的物理连通性。测试并报告电缆状况，其中包括近端串音、信号衰减及噪音。时域反射计与光时域反射计时域反射器(TDR):能够快速定位金属线缆中的短路、断路、阻抗等问题。光时域反射器(OTDR):精确测量光纤的长度、断裂位置、信号衰减等。网络监测器：分析统计网络状态。网络分析仪：科来。4️⃣层次化故障排查http://www.ppmy.cn/news/1541478.html相关文章sealed class-kotlin中的封闭类在 Kotlin 中&amp;#xff0c;sealed class&amp;#xff08;密封类&amp;#xff09;是一种特殊的类&amp;#xff0c;用于限制继承的类的数量。密封类可以被用来表示一组有限的类型&amp;#xff0c;通常用于状态管理或表达多种可能的错误类型。 
密封类用 sealed 关键字定义&amp;#xff0c;这意味着只能…阅读更多...CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:57 +0000</pubDate>
    </item>
    <item>
      <title>sealed class-kotlin中的封闭类</title>
      <link>https://www.ppmy.cn/news/1541477.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维sealed class-kotlin中的封闭类news/2025/11/4 0:21:56/在 Kotlin 中，sealed class（密封类）是一种特殊的类，用于限制继承的类的数量。密封类可以被用来表示一组有限的类型，通常用于状态管理或表达多种可能的错误类型。密封类用sealed关键字定义，这意味着只能在同一个文件中声明其子类。它有助于确保类型的安全性，因为编译器能够知道所有可能的子类类型。sealed class Error : Exception() {data class NetworkError(val message: String) : Error() // 网络错误data class TimeoutError(val duration: Long) : Error() // 超时错误object UnknownError : Error() // 未知错误
}fun handleError(error: Error) {when (error) {is Error.NetworkError -&gt; println("Network error: ${error.message}")is Error.TimeoutError -&gt; println("Timeout after ${error.duration} ms")Error.UnknownError -&gt; println("An unknown error occurred")}
}fun main() {val error1: Error = Error.NetworkError("Unable to connect to server")val error2: Error = Error.TimeoutError(5000)val error3: Error = Error.UnknownErrorhandleError(error1) // 输出: Network error: Unable to connect to serverhandleError(error2) // 输出: Timeout after 5000 mshandleError(error3) // 输出: An unknown error occurred
}子类:NetworkError和TimeoutError是Error的子类，表示具体的错误类型。UnknownError是一个对象表示特定的错误状态。类型安全: 使用when表达式处理错误时，编译器会确保覆盖所有可能的子类，减少了遗漏处理某些错误的风险。扩展性: 如果需要增加新的错误类型，只需在同一文件中添加新的子类，保持代码结构的清晰性。http://www.ppmy.cn/news/1541477.html相关文章CentOS7安装RabbitMQ-3.13.7、修改端口号本文安装版本&amp;#xff1a; Erlang&amp;#xff1a;26.0 官网下载地址  Erlang RabbitMQ&amp;#xff1a;3.13.7 官网下载地址  RabbitMQ RabbitMQ和Erlang对应关系查看&amp;#xff1a;https://www.rabbitmq.com/which-erlang.html 注&amp;#xff1a;安装erlang之前先安装下依赖文件&amp;#xff0…阅读更多...rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:56 +0000</pubDate>
    </item>
    <item>
      <title>CentOS7安装RabbitMQ-3.13.7、修改端口号</title>
      <link>https://www.ppmy.cn/news/1541476.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维CentOS7安装RabbitMQ-3.13.7、修改端口号news/2025/11/4 0:21:55/本文安装版本：Erlang：26.0官网下载地址  ErlangRabbitMQ：3.13.7官网下载地址  RabbitMQRabbitMQ和Erlang对应关系查看：https://www.rabbitmq.com/which-erlang.html注：安装erlang之前先安装下依赖文件（这一步不要忘掉了，不然后面./configure的时候要报错）yum install gcc glibc-devel make ncurses-devel openssl-devel xmlto安装Erlang1、下载erlang安装包并解压wget https://erlang.org/download/otp_src_26.0.tar.gztar -zxvf otp_src_26.0.tar.gz2、编译安装，路径自定义cd otp_src_26.0/./configure --prefix=/usr/local/erlangmake &amp;&amp; make install3、测试是否安装成功cd /usr/local/erlang/bin/./erl若出现以下界面，则说明Erlang配置OK了输入halt().退出控制台，注意后面有个点4、配置环境变量vim /etc/profile# 加入如下配置
export PATH=$PATH:/usr/local/erlang/bin# 保存退出后，使该配置文件即刻生效
source /etc/profile安装RabbitMQ1、下载RabbitMQ安装包并解压wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.13.7/rabbitmq-server-generic-unix-3.13.7.tar.xzxz -d rabbitmq-server-generic-unix-3.13.7.tar.xztar -xvf rabbitmq-server-generic-unix-3.13.7.tar2、 配置环境变量vim /etc/profile# 加入如下配置
export PATH=$PATH:/home/RabbitMQ/rabbitmq_server-3.13.7/sbin# 保存退出后，使该配置文件即刻生效
source /etc/profile3、RabbitMQ的基本操作# 启动
rabbitmq-server -detached# 关闭
rabbitmqctl stop# 查看状态
rabbitmqctl status4、配置RabbitMQ网页管理插件# 启用插件
rabbitmq-plugins enable rabbitmq_management# 默认来宾用户：guest， 来宾用户密码：guest5、开启RabbitMQ远程访问# 添加用户
rabbitmqctl add_user Arvin Arvin888# 添加权限
rabbitmqctl set_permissions -p "/" Arvin ".*" ".*" ".*"# 修改用户角色
rabbitmqctl set_user_tags Arvin administrator修改RabbitMQ默认端口，开启远程访问RabbitMQ默认开启的端口：4369：erlang发现口5672：client端通信口，客户端要连接RabbitMQ服务时要用到15672：后台管理界面ui端口，进入管理后台时访问url如：http://localhost:15672/25672：server间内部通信口在生产环境下，出于安全等原因希望修改掉默认的端口号。安装RabbitMQ后发现找不到配置文件；事实上RabbitMQ在某个版本后（具体哪个暂不清楚）并没有生成配置文件，需要手动添加配置文件。官方建议配置文件的位置：https://www.rabbitmq.com/docs/configure#config-locationvim /home/RabbitMQ/rabbitmq_server-3.13.7/etc/rabbitmq/rabbitmq.conf#AMQP 0-9-1 and 1.0 port，默认5672
listeners.tcp.default = 0.0.0.0:8620#web管理，默认15672
management.tcp.port = 8621
management.tcp.ip   = 0.0.0.0# 保存，并重启RabbitMQ服务。使用netstat -lntp查看端口监听情况http://www.ppmy.cn/news/1541476.html相关文章rabbitmq 工作队列模式工作队列模式 
一、原理流程图 二、基本知识 
工作队列模式&amp;#xff08;Work Queue Model&amp;#xff09;是一种消息队列模型&amp;#xff0c;生产者将任务分发到队列中&amp;#xff0c;多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡&amp;#xff0c;确保任务能够均匀分配给…阅读更多...VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:55 +0000</pubDate>
    </item>
    <item>
      <title>rabbitmq 工作队列模式</title>
      <link>https://www.ppmy.cn/news/1541475.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维rabbitmq 工作队列模式news/2025/11/4 0:21:54/工作队列模式一、原理流程图二、基本知识工作队列模式（Work Queue Model）是一种消息队列模型，生产者将任务分发到队列中，多个消费者从队列中按顺序获取并处理任务。该模式主要用于负载均衡，确保任务能够均匀分配给不同的消费者，提升系统的处理能力。基本特点：消息分发：生产者发送的每个消息只会被一个消费者处理。消息持久化：队列可以设置为持久化，以保证在服务重启后，未处理的消息不会丢失。负载均衡：多个消费者可以并发消费队列中的消息，实现负载分摊。三、代码1. 生产者代码packagecom.lucifer.rabbitmq.workQueues;importcom.lucifer.rabbitmq.utils.RabbitMqUtils;importcom.rabbitmq.client.Channel;importjava.util.Scanner;/*** @Author：丁浩然* @Package：com.lucifer.rabbitmq.workQueues* @Project：rabbitMq_learning* @Filename：task01* @Date：2024/10/18* @Purpose：生产者，用于产生大量的消息*/publicclassTask01{// 定义队列名称publicstaticfinalStringQUEUE_NAME="hello";publicstaticvoidmain(String[]args)throwsException{// 获取通道Channelchannel=RabbitMqUtils.getChannel();// 声明队列channel.queueDeclare(QUEUE_NAME,false,false,false,null);// 从控制台接受输入Scannersc=newScanner(System.in);System.out.println("请输入消息，按回车发送（输入exit退出）：");while(sc.hasNext()){Stringmessage=sc.next();if("exit".equals(message)){break;}// 发送消息到队列channel.basicPublish("",QUEUE_NAME,null,message.getBytes());System.out.println("已发送消息："+message);}sc.close();channel.close();}}2. 消费者代码packagecom.lucifer.rabbitmq.workQueues;importcom.lucifer.rabbitmq.utils.RabbitMqUtils;importcom.rabbitmq.client.Channel;importcom.rabbitmq.client.DeliverCallback;/*** @Author：丁浩然* @Package：com.lucifer.rabbitmq.workQueues* @Project：rabbitMq_learning* @Filename：worker* @Date：2024/10/18* @Purpose：消费者，接收并处理消息*/publicclassWorker{publicstaticfinalStringQUEUE_NAME="hello";publicstaticvoidmain(String[]args)throwsException{// 获取通道Channelchannel=RabbitMqUtils.getChannel();// 消费者回调函数，用于处理消息DeliverCallbackdeliverCallback=(consumerTag,message)-&gt;{System.out.println("接收到消息："+newString(message.getBody(),"UTF-8"));};// 消费消息channel.basicConsume(QUEUE_NAME,true,deliverCallback,consumerTag-&gt;{});}}四、结果生产者发送消息，消费者接收消息的结果如下：生产者控制台输出：消费者控制台输出：注意：由于直接打印的是对象而非内容，所以输出格式可能看起来比较奇怪。可以使用new String(message.getBody(), "UTF-8")来将消息转换为字符串形式。http://www.ppmy.cn/news/1541475.html相关文章VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版分文件编写遇到的问题 
分文件编写例子如下所示&amp;#xff1a;  但是直接使用 Run Code 或者 调试C/C文件 会报错如下&amp;#xff1a; 正在执行任务: C/C: g.exe 生成活动文件 正在启动生成… cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g.exe -fdiagnostics-col…阅读更多...九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:54 +0000</pubDate>
    </item>
    <item>
      <title>VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版</title>
      <link>https://www.ppmy.cn/news/1541474.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维VScode分文件编写报错 | 如何进行VScode分文件编写 | 小白也能轻松解决版news/2025/11/4 0:21:54/分文件编写遇到的问题分文件编写例子如下所示：但是直接使用 Run Code 或者 调试C/C++文件 会报错如下：正在执行任务: C/C++: g++.exe 生成活动文件正在启动生成…cmd /c chcp 65001&gt;nul &amp;&amp; D:\Librarys\mingw64\bin\g++.exe -fdiagnostics-color=always -g “E:\VSCode Projects\main.cpp” -o “E:\VSCode Projects\main.exe”D:/Librarys/mingw64/bin/…/lib/gcc/x86_64-w64-mingw32/13.1.0/…/…/…/…/x86_64-w64-mingw32/bin/ld.exe: C:\Users\beyou\AppData\Local\Temp\cc05WNEh.o: in functionmain': E:/VSCode Projects/main.cpp:9: undefined reference toswap(int, int)’collect2.exe: error: ld returned 1 exit status生成已完成，但出现错误终端进程已终止，退出代码: -1。终端将被任务重用，按任意键关闭。解决办法vscode 的 .vscode 的配置遵循父类文件夹优先的原则，也就是说父文件夹的 .vscode 和子文件夹的 .vscode ，优先访问父文件夹最原始的 tasks.json 内容为这样，只适合于单文件生成。不过你在你的项目文件夹下新建子文件夹，再把你的文件移动到子文件夹下，对于单文件而言，下面的内容仍然不用改变。也能正常编译运行。（因为 fileDirname 就是装你的代码文件所在的位置）"args": ["-fdiagnostics-color=always","-g","${file}","-o","${fileDirname}\\${fileBasenameNoExtension}.exe"],对于分文件编写的程序，需要改 tasks.json 里面的东西为下面的样子，同理，这样已经是正确的了，即使你递归地建了100个子文件夹把程序放在里面，下面的路径也不需要从根文件夹 \ 到 100 个子文件夹后的位置。也就是说，只要是分文件编写的项目，按下面这样写就行了。（因为 fileDirname 就是装你的代码文件所在的位置）"args": ["-fdiagnostics-color=always","-g","${fileDirname}\\*.cpp","-o","${fileDirname}\\${fileBasenameNoExtension}.exe"],之后使用调试C/C++文件和运行C/C++文件都没有问题，但是Run Code会报错，别管 Run Code ，这个修改很复杂，而且违背初心了，原因如下：大型项目使用 调试C/C++文件，不要选择 Run Code，因为 Run Code 是一个快捷工具，主要由 Code Runner 插件提供。它执行一个预定义的命令，通常是针对单个文件进行快速编译和运行。调试C/C++文件 运行的是 VSCode 的 任务构建系统，这需要通过 tasks.json 文件进行配置。所以我们可以在里面灵活地修改。其实最好还是了解 c++ 编译过程，会对上面为什么这样写有更深的感悟，但是小白可能只想着快点解决错误。特别鸣谢：bmg的远程操作与指导特别批评：QuantumDusk的不作为http://www.ppmy.cn/news/1541474.html相关文章九、pico+Unity交互开发——触碰抓取一、VR交互的类型 
Hover&amp;#xff08;悬停&amp;#xff09; 定义&amp;#xff1a;发起交互的对象停留在可交互对象的交互区域。例如&amp;#xff0c;当手触摸到物品表面&amp;#xff08;可交互区域&amp;#xff09;时&amp;#xff0c;视为触发了Hover。 Grab&amp;#xff08;抓取&amp;#xff09; 概念&amp;#xff…阅读更多...word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:54 +0000</pubDate>
    </item>
    <item>
      <title>九、pico+Unity交互开发——触碰抓取</title>
      <link>https://www.ppmy.cn/news/1541473.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维九、pico+Unity交互开发——触碰抓取news/2025/11/4 0:21:53/一、VR交互的类型Hover（悬停）定义：发起交互的对象停留在可交互对象的交互区域。例如，当手触摸到物品表面（可交互区域）时，视为触发了Hover。Grab（抓取）概念：把物品抓起来。Use（使用）基于“抓取”。例如抓取一把枪后，按下枪的扳机发射子弹则视为Use。三、发起交互的对象（Interactor）XR Direct Interactor脚本为了让双手成为发起交互的对象，在LeftHand Controller和RightHand Controller下分别创建Direct Interactor子物体，并添加XR Direct Interactor脚本。添加可交互区域XR Direct Interactor需要一个Trigger类型的碰撞体作为可交互区域，且需和它挂载在同一游戏物体上。如在左手和右手的Direct Interactor上分别添加Sphere Collider，调整Radius并勾选Is Trigger。当可交互对象进入该区域后，可进行交互。 ，并设置合适的参数。四、可交互的对象（Interactable）创建一个3d对象，比如立方体添加刚体因为手与物品的交互基于物理效果，所以要为可交互物体添加刚体。XR Simple Interactable脚本为方块添加XR Simple Interactable脚本，但是它没有自带抓取的功能。物体有刚体后该脚本才生效，且挂载脚本的物体还需一个碰撞体。如果是创建的3d对象不需要额外加，如果是自定义模型的话，别忘了手动添加碰撞体2.1、可交互事件实现功能：手触碰到方块时，方块颜色改变（模拟Hover，即悬停在可交互区域）。触碰方块后按下手柄Grip键，方块颜色变成蓝色。触碰方块后按住Grip键再按Trigger键，方块颜色变回红色。实现方法：使用XR Simple Interactable脚本中的Interactable Events，其中Hover Entered对应开始悬停在可交互区域触发的事件，可手动设置更改方块材质。Select Entered和Activated事件分别对应上述第二、三个功能。在Inspector面板中手动绑定事件，Select动作绑定“按下Grip键抓取键”，Activate动作绑定“按下Trigger键扳机键”。 Activate动作以Select动作为前提，Interactable Events中的所有事件以“与可交互对象发生交互”为前提。XR Grab Interactable脚本、和XR Simple Interactable脚本脚本类似，但是有抓取效果；所以需要移除刚刚的XR Simple Interactable脚本Movement Type 移动类型Instantaneous：物体移动位置和姿态完全跟随手的移动，无延迟但无物理刚体效果，物体可穿过碰撞体且碰撞效果非物理。Kinematic：通过Kinematic Rigidbody移动，有延迟，移动中不受力和碰撞作用，但可对其他刚体施加物理效果。Velocity Tracking：通过设置刚体速度和角速度移动，有延迟，有刚体物理效果，可与碰撞体碰撞并对其他刚体产生力的效果。Attach Transform 抓取点XR Grab Interactable脚本中有Attach Transform变量可赋值作为抓取点，若未赋值，默认以物体position为抓取点。如抓取枪时，抓取点应在枪柄；实现功能：可创建枪的子物体Attach Point并赋值给Attach Transform，然后调整其Position位置和Rotation以优化抓取效果。但仅设置Attach Transform会有穿模现象，若要实现精细抓取，可参考相关教程。代码实现Use功能（制作简易手枪）核心脚本创建GunController脚本挂载到枪的游戏物体上。获取XRGrabInteractable中的activated事件，通过AddListener绑定FireBullet函数。制作子弹预制体创建子弹Prefab（需刚体和碰撞体），并将子弹Rigidbody的Collision Detection设为Continous Dynamic，防止高速运动时检测不到碰撞。制作子弹发射位置创建枪的子物体Spawn Point作为子弹生成位置，其z轴箭头方向对应子弹发射方向，将子弹和Spawn Point赋给Gun Controller。usingSystem.Collections;usingSystem.Collections.Generic;usingUnityEngine;usingUnityEngine.XR.Interaction.Toolkit;// 枪支控制器类publicclassGunController:MonoBehaviour{// 子弹预制体publicGameObjectbullet;// 子弹发射位置的变换组件publicTransformspawnPoint;// 子弹发射速度publicfloatfireSpeed=40;voidStart(){// 获取当前物体上的 XRGrabInteractable 组件XRGrabInteractablegrabbable=GetComponent&lt;XRGrabInteractable&gt;();// 为 grabbable 的 activated 事件添加监听器，当该事件触发时调用 FireBullet 方法grabbable.activated.AddListener(FireBullet);}privatevoidFireBullet(ActivateEventArgsarg){// 在 spawnPoint 的位置和旋转处实例化子弹预制体GameObjectspawnBullet=Instantiate(bullet,spawnPoint.position,spawnPoint.rotation);// 设置实例化出的子弹的刚体速度，使其沿着 spawnPoint 的前方以 fireSpeed 的速度飞行spawnBullet.GetComponent&lt;Rigidbody&gt;().velocity=spawnPoint.forward*fireSpeed;// 在 5 秒后销毁这个子弹对象Destroy(spawnBullet,5);}}优化一：左右手抓取（判断哪只手与物体交互）方法一（不推荐）在GunController脚本中，给XRGrabInteractable的SelectEntered事件绑定ChangeAttachTransform函数，通过判断Interactor是左手还是右手控制器来切换Attach Transform。也就是创建两个抓取点，并进行监听ChangeAttachTransform判断左右手、来重新设置抓取点usingSystem;usingSystem.Collections;usingSystem.Collections.Generic;usingUnityEngine;usingUnityEngine.XR.Interaction.Toolkit;// 枪支控制器类publicclassGunController:MonoBehaviour{// 子弹游戏对象publicGameObjectbullet;// 子弹发射位置的变换组件publicTransformspawnPoint;// 子弹发射速度publicfloatfireSpeed=40;// 左手抓取点的变换组件privateTransformleftHandAttachPoint;// 右手抓取点的变换组件privateTransformrightHandAttachPoint;// 当前物体上的可抓取交互组件privateXRGrabInteractablegrabbable;voidStart(){// 在当前物体下查找名为"LeftHand Attach Point"的子物体，获取其变换组件leftHandAttachPoint=transform.Find("LeftHand Attach Point");// 在当前物体下查找名为"RightHand Attach Point"的子物体，获取其变换组件rightHandAttachPoint=transform.Find("RightHand Attach Point");// 获取当前物体上的 XRGrabInteractable 组件grabbable=GetComponent&lt;XRGrabInteractable&gt;();// 为可抓取交互组件的 selectEntered 事件添加监听器，当该事件触发时调用 ChangeAttachTransform 方法grabbable.selectEntered.AddListener(ChangeAttachTransform);// 为可抓取交互组件的 activated 事件添加监听器，当该事件触发时调用 FireBullet 方法grabbable.activated.AddListener(FireBullet);}privatevoidChangeAttachTransform(SelectEnterEventArgsarg){// 获取触发 selectEntered 事件的交互器的变换组件Transforminteractor=arg.interactorObject.transform;// 如果交互器的父物体名称为"Left Controller"，表示是左手控制器if(interactor.transform.parent.name=="Left Controller"){// 将当前物体的抓取点设置为左手抓取点grabbable.attachTransform=leftHandAttachPoint;}elseif(interactor.transform.parent.name=="Right Controller"){// 如果交互器的父物体名称为"Right Controller"，表示是右手控制器// 将当前物体的抓取点设置为右手抓取点grabbable.attachTransform=rightHandAttachPoint;}}privatevoidFireBullet(ActivateEventArgsarg){// 在 spawnPoint 的位置和旋转处实例化子弹游戏对象GameObjectspawnBullet=Instantiate(bullet,spawnPoint.position,spawnPoint.rotation);// 获取实例化出的子弹的刚体组件RigidbodybulletRigidbody=spawnBullet.GetComponent&lt;Rigidbody&gt;();// 设置子弹的速度，使其沿着 spawnPoint 的前方以 fireSpeed 的速度飞行bulletRigidbody.velocity=spawnPoint.forward*fireSpeed;// 在 5 秒后销毁这个子弹对象Destroy(spawnBullet,5);}}方法二减少耦合性新建脚本XRGrabInteractableTwoAttach继承XRGrabInteractable，重写OnSelectEntered方法，根据Interactor的Tag判断是左手还是右手，切换相应的Attach Transform。usingSystem.Collections;usingSystem.Collections.Generic;usingUnityEngine;usingUnityEngine.XR.Interaction.Toolkit;// 自定义的可抓取交互类，继承自 XRGrabInteractablepublicclassXRGrabInteractableTwoAttach:XRGrabInteractable{// 左手的抓取点变换publicTransformleftAttachTransform;// 右手的抓取点变换publicTransformrightAttachTransform;// 重写 OnSelectEntered 方法，在选择进入时触发protectedoverridevoidOnSelectEntered(SelectEnterEventArgsargs){// 如果交互对象的标签是“Left Hand”（左手）if(args.interactorObject.transform.CompareTag("Left Hand")){// 将当前物体的抓取点设置为左手抓取点attachTransform=leftAttachTransform;}// 如果交互对象的标签是“Right Hand”（右手）elseif(args.interactorObject.transform.CompareTag("Right Hand")){// 将当前物体的抓取点设置为右手抓取点attachTransform=rightAttachTransform;}// 调用基类的 OnSelectEntered 方法base.OnSelectEntered(args);}}将枪上的XRGrabInteractable抓取脚本替换为XRGrabInteractableTwoAttach，并在编辑器中为左右手Attach Transform赋值并给Direct Interactor添加Tag。第一次抓取或第一次切换抓取位置错误解决方法-方法一- 在可抓取物体Gun被抓取物体上添加XRSingleGrabFreeTransformer脚本，游戏运行时会自动添加到XRGrabInteractableTwoAttach脚本。方法二- 重写刚刚新建的XRGrabInteractableTwoAttach脚本的GetAttachTransform方法，而不是OnSelectEntered方法。根据Interactor的Tag返回相应的Attach Transform，若Tag不匹配则返回基类的GetAttachTransform结果。usingSystem.Collections;usingSystem.Collections.Generic;usingUnityEngine;usingUnityEngine.XR.Interaction.Toolkit;publicclassXRGrabInteractableTwoAttach:XRGrabInteractable{publicTransformleftAttachTransform;publicTransformrightAttachTransform;publicoverrideTransformGetAttachTransform(IXRInteractorinteractor){Transformi_attachTransform=null;if(interactor.transform.CompareTag("Left Hand")){i_attachTransform=leftAttachTransform;}if(interactor.transform.CompareTag("Right Hand")){i_attachTransform=rightAttachTransform;}returni_attachTransform!=null?i_attachTransform:base.GetAttachTransform(interactor);}}因为之前学的射线交互层级是Everything层级比较高和物体交互层级有重复，所以也能实现射线抓取；然后将与传送有关的 XR Ray Interactor 和 Teleport Area 的 Interaction Layer Mask 改成 Teleport，就可以避免出现这类问题其他功能一：将与物体接触的地方作为抓取点（Dynamic Attach），也就是碰哪里抓哪里，没有固定抓取点创建细长Cube作为测试物体，添加碰撞体、刚体和XR Grab Interactable脚本，勾选Use Dynamic Attach后，可根据需求设置Match Position、Match Rotation、Snap To Collider等选项，实现手抓在物体接触部位的效果。Match Position（匹配位置）：当启用相关功能时，确保被抓取物体的位置与抓取点的位置相匹配。例如在使用特定的抓取方式时，可使被抓取物体在被抓取瞬间其位置与抓取点重合，以实现更真实的抓取效果。Match Rotation（匹配旋转）：类似 “匹配位置”，当启用此选项时，被抓取物体的旋转会与抓取点的旋转相匹配。这样可以确保被抓取物体在抓取过程中以合适的角度呈现，增强真实感和交互性。Snap To Collider（吸附到碰撞体）：当开启这个功能后，抓取操作会使被抓取物体吸附到抓取点所在的碰撞体上。这可以使抓取更加精准，并且在抓取过程中物体与抓取点的连接更加紧密，避免出现不合理的位置偏差。五、XR Tint Interactable Visual脚本功能：可挂载到可交互对象上，当Interactor悬停（Hover）或选中（Select动作触发）可交互对象时，能暂时改变其颜色。.2. 设置：调整Tint Color设置颜色，勾选Tint On Hover在Hover时改变颜色，勾选Tint On Selection在Select时改变颜色。注意要把使用的XR Grab Interactable放置到最上层。六、取消身体和可抓取物体的物理碰撞设置Layer：将XR Origin的Layer设为Player（仅设置Character Controller所在物体Layer，子物体选No），将所有可抓取物体Layer设为Interactable。配置Physics：打开Unity编辑器上方菜单栏的Edit编辑 -&gt; Project Settings项目设置-&gt; Physics物理，找到Layer Collision Matrix图层碰撞器，将Player和Interactable的交叉点取消勾选，避免身体与可抓取物体发生物理碰撞。七、XR Interaction Group功能：XR Interaction Toolkit 2.3新组件，可管理多个Interactor。当其中一个Interactor生效时，Group内其他Interactor会暂时失效。应用示例：如在Left/RightHand Controller物体上添加XR Interaction Group组件，将Direct Interactor物体和UI Ray Interactor物体拖到Group中，可实现在抓取物体时让UI射线暂时失效。八、XR Direct Interactor脚本中的Select Action Trigger参数说明Toggle：以抓取为例，选择Toggle后，靠近物体按下手柄抓取键，物体会被抓在手上，松开抓取键物体仍在手上，下次按下抓取键才会释放。Sticky：按下手柄抓取键物体被抓手上，松开抓取键物体仍在手上，下次按下并松开抓取键物体才会释放。State和State Change的区别（在可抓取物体Select Mode选择Single时）State：可能出现一只手无法接管另一只手抓取权的情况，只有先松开当前抓取手的抓取键才会进行切换抓取。State Change：可以随意切换抓取，推荐在抓取功能上使用State Change。http://www.ppmy.cn/news/1541473.html相关文章word中的内容旋转90度在vsto、Aspose.Words 中&amp;#xff0c;默认没有直接的 API 可以让表格整体旋转 90 度。然而&amp;#xff0c;我们可以通过一些方式来实现类似的效果&amp;#xff0c;具体思路如下&amp;#xff1a; 将表格插入到一个形状&amp;#xff08;Shape&amp;#xff09;或文本框中&amp;#xff0c;然后旋转该形状。…阅读更多...基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:53 +0000</pubDate>
    </item>
    <item>
      <title>word中的内容旋转90度</title>
      <link>https://www.ppmy.cn/news/1541472.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维word中的内容旋转90度news/2025/11/4 0:21:52/在vsto、Aspose.Words 中，默认没有直接的 API 可以让表格整体旋转 90 度。然而，我们可以通过一些方式来实现类似的效果，具体思路如下：将表格插入到一个形状（Shape）或文本框中，然后旋转该形状。将表格内容旋转，这通过设置文本方向为垂直来模拟旋转效果。using Aspose.Words;
using Aspose.Words.Tables;
using Aspose.Words.Drawing;class Program
{static void Main(){// 创建文档和 DocumentBuilderDocument doc = new Document();DocumentBuilder builder = new DocumentBuilder(doc);// 创建 Shape（文本框）Shape shape = new Shape(doc, ShapeType.TextBox);shape.Width = 200;  // 设置文本框的宽度shape.Height = 400; // 设置文本框的高度shape.WrapType = WrapType.None;// 旋转 Shape 90 度shape.Rotation = 90;// 将 Shape 添加到文档中builder.InsertNode(shape);// 创建一个新的 DocumentBuilder 用于 Shape 内部DocumentBuilder shapeBuilder = new DocumentBuilder(doc);shapeBuilder.MoveTo(shape.FirstParagraph);// 在 Shape 内部添加一个表格Table table = shapeBuilder.StartTable();shapeBuilder.InsertCell();shapeBuilder.Write("Cell 1");shapeBuilder.InsertCell();shapeBuilder.Write("Cell 2");shapeBuilder.EndRow();shapeBuilder.InsertCell();shapeBuilder.Write("Cell 3");shapeBuilder.InsertCell();shapeBuilder.Write("Cell 4");shapeBuilder.EndTable();// 保存文档doc.Save("RotatedTable.docx");}
}http://www.ppmy.cn/news/1541472.html相关文章基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)详细视频演示 请联系我获取更详细的演示视频 项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不…阅读更多...|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:52 +0000</pubDate>
    </item>
    <item>
      <title>基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)</title>
      <link>https://www.ppmy.cn/news/1541471.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维基于SpringBoot+Vue+uniapp的诗词学习系统的详细设计和实现(源码+lw+部署文档+讲解等)news/2025/11/4 0:21:51/详细视频演示请联系我获取更详细的演示视频项目运行截图技术框架后端采用SpringBoot框架Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念，提供了一套默认的配置，让开发者可以更专注于业务逻辑而不是配置文件。Spring Boot 通过自动化配置和约定大于配置的方式，大大简化了应用程序的配置工作。开发者不再需要手动配置大量的 XML 文件或繁琐的注解，框架提供了默认的配置，根据项目的依赖关系和约定，自动完成配置。Spring Boot 使用Maven或 Gradle 进行构建，自动下载项目依赖，并提供了许多插件简化构建过程。开发者可以使用 Spring Initializr 来生成一个基础的项目结构，然后根据需要选择所需的依赖。前端框架VueVue.js的设计目标之一是使其尽可能简单、易于理解和上手。Vue 提供了直观的 API，使开发者能够轻松地构建交互式的用户界面。Vue.js 提供了简单而强大的数据绑定机制，通过使用指令（例如 v-model）可以实现视图和数据的双向绑定。当数据发生变化时，视图会自动更新，反之亦然，使得开发者不必手动处理 DOM 操作。Vue.js 提供了一组生命周期钩子函数，允许开发者在组件的不同阶段执行自定义逻辑。这包括创建、挂载、更新和销毁等阶段，为开发者提供了更多灵活性。可行性分析可行性分析是每开发一个项目必不可少的一部分，可行性分析可以直接影响一个系统的存活问题，针对开发意义进行分析，还有就是是否可以通过所开发的系统来弥补传统手工统计模式的不足，是否能够更好的解决阿博图书馆管理系统存在的问题等，通过对该阿博图书馆管理系统的开发设计，不仅能够逐步减少工作人员的工作量，而且还可以进行高效工作和管理。所以该系统的开发实现了最大的意义和价值，在系统完成后，利益是否大过于成本，是否能够达到预期效果，这些方面都要进行可行性分析，再通过分析之后，就可以决定是否开发此系统。该阿博图书馆管理系统的开发设计中，以下几点进行了可行性分析：技术可行性：通过Java技术的采用，由于该技术不断成熟，所以使用该技术设计阿博图书馆管理系统是具有可行性的。经济可行性：在开发过程中，系统完成后的利益是否大过于开发成本。操作可行性：阿博图书馆管理系统的开发设计中，方便用户的可操作性和实用性。系统测试从多个角度进行测试找到系统中存在的问题是本系统首要的测试目的，通过功能测试寻找出系统缺陷并改正，确保系统没有缺陷。在测试过程中证明系统满足客户需求，发现问题和不足及时改正。测试完成之后得出测试结论。系统测试的目的系统测试是必不可少且考验耐心的过程。其重要性在于，它是保证系统质量和牢靠性的最后一道关，也是整个系统开发过程的最后一次检查。系统测试主要是为了避免用户在使用时发生问题，增强用户体验感，为了不影响用户的使用，我们需要从多角度、多思路去考虑系统可能遇到的问题，通过不同的模拟场景来发现缺陷并解决问题。在测试的过程中也可以了解到该系统的质量情况，系统功能是否健全，系统逻辑是否顺畅。一个合格的系统测试过程完成后将大大提升系统质量和使用感。测试的目标是验证系统是否符合需求规格说明书的定义，并找出与需求规格说明书不符合或与之冲突的内容。测试过程中一定站在用户的角度考虑问题，避免一些不切实际的场景，浪费测试时间，从而可能会引起问题导致预期结果与实际结果不符。系统功能测试对系统功能模块进行测试，通过点击、输入边界值和必填项非必填项的验证等方法进行一系列的黑盒测试。通过编写测试用例，根据测试用例中的内容进行测试，最后得出测试结论。登录功能测试方案：当需要登入该系统时，通过账户密码等功能点进行验证，用户在输入时需要输入与数据库内存储的数据匹配的内容，当其中某项输入错误时系统将提示输入错误。此界面对角色权限也有相应的校验，当用户角色的帐号选择管理员角色登录时，也会报错。登录功能测试用例如下表所示。输入数据预期结果实际结果结果分析用户名：guanliyuan 密码：123456 验证码：正确输入登入系统成功登入系统和估算结果一样用户名：guanliyuan 密码：111111 验证码：正确输入密码错误密码错误，请重新输入密码和估算结果一样用户名：guanliyuan 密码：123456 验证码：错误输入验证码错误验证码信息错误和估算结果一样用户名：空 密码：123456 验证码：正确输入用户名必填请输入用户名和估算结果一样用户名：guanliyuan 密码：空 验证码：正确输入密码错误密码错误，请重新输入密码和估算结果一样用户管理功能测试方案：用户管理主要有添加、编辑、删除、查找用户功能。添加用户时，必填项不填，检验系统是否有非空检验；添加已有的用户信息，检验是否提示用户名已被使用；删除用户信息，系统将检验是否进行此操作；更改用户信息，更改用户信息后页面是否可以展示出来。用户管理测试用例如下表所示。输入数据预期结果实际结果结果分析填入用户基本信息添加成功，在用户列表中显示该用户出现在在列表中和估算结果一样修改用户信息编辑成功，修改信息成功被修改用户信息被修改和估算结果一样选中删除用户系统询问是否删除用户，确认后用户被删除系统询问是否删除用户，确认后查找不到用户信息和估算结果一样添加用户时不填用户名提示用户名不能为空提示用户名不能为空和估算结果一样填入已有用户名添加失败，提示用户名重复添加失败，提示用户名重复和估算结果一样数据库表设计列名数据类型长度约束idint11PRIMARY KEYaddtime行2内容行2内容DEFAULT NULLjieyuedanhaovarchar64DEFAULT NULLtushubianhaovarchar64DEFAULT NULLtushumingchengvarchar12DEFAULT NULLfakuanshuomingvarchar64DEFAULT NULLfakuanjinevarchar64DEFAULT NULLfakuanriqivarchar64DEFAULT NULLyonghumingvarchar64DEFAULT NULLshoujivarchar64DEFAULT NULL代码参考/*** 通用接口*/
@RestController
public class CommonController{@Autowiredprivate CommonService commonService;@Autowiredprivate ConfigService configService;private static AipFace client = null;private static String BAIDU_DITU_AK = null;@RequestMapping("/location")public R location(String lng,String lat) {if(BAIDU_DITU_AK==null) {BAIDU_DITU_AK = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "baidu_ditu_ak")).getValue();if(BAIDU_DITU_AK==null) {return R.error("请在配置管理中正确配置baidu_ditu_ak");}}Map&lt;String, String&gt; map = BaiduUtil.getCityByLonLat(BAIDU_DITU_AK, lng, lat);return R.ok().put("data", map);}/*** 人脸比对* * @param face1 人脸1* @param face2 人脸2* @return*/@RequestMapping("/matchFace")public R matchFace(String face1, String face2) {if(client==null) {/*String AppID = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "AppID")).getValue();*/String APIKey = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "APIKey")).getValue();String SecretKey = configService.selectOne(new EntityWrapper&lt;ConfigEntity&gt;().eq("name", "SecretKey")).getValue();String token = BaiduUtil.getAuth(APIKey, SecretKey);if(token==null) {return R.error("请在配置管理中正确配置APIKey和SecretKey");}client = new AipFace(null, APIKey, SecretKey);client.setConnectionTimeoutInMillis(2000);client.setSocketTimeoutInMillis(60000);}JSONObject res = null;try {File file1 = new File(ResourceUtils.getFile("classpath:static/upload").getAbsolutePath()+"/"+face1);File file2 = new File(ResourceUtils.getFile("classpath:static/upload").getAbsolutePath()+"/"+face2);String img1 = Base64Util.encode(FileUtil.FileToByte(file1));String img2 = Base64Util.encode(FileUtil.FileToByte(file2));MatchRequest req1 = new MatchRequest(img1, "BASE64");MatchRequest req2 = new MatchRequest(img2, "BASE64");ArrayList&lt;MatchRequest&gt; requests = new ArrayList&lt;MatchRequest&gt;();requests.add(req1);requests.add(req2);res = client.match(requests);System.out.println(res.get("result"));} catch (FileNotFoundException e) {e.printStackTrace();return R.error("文件不存在");} catch (IOException e) {e.printStackTrace();} return R.ok().put("data", com.alibaba.fastjson.JSONObject.parse(res.get("result").toString()));}数据库脚本CREATE TABLE `yonghu` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`yonghuming` varchar(200) NOT NULL COMMENT '用户名',`mima` varchar(200) NOT NULL COMMENT '密码',`xingming` varchar(200) DEFAULT NULL COMMENT '姓名',`xingbie` varchar(200) DEFAULT NULL COMMENT '性别',`touxiang` varchar(200) DEFAULT NULL COMMENT '头像',`shouji` varchar(200) DEFAULT NULL COMMENT '手机',`shenfenzheng` varchar(200) DEFAULT NULL COMMENT '身份证',PRIMARY KEY (`id`),UNIQUE KEY `yonghuming` (`yonghuming`)
) ENGINE=InnoDB AUTO_INCREMENT=1616222324596 DEFAULT CHARSET=utf8mb3 COMMENT='用户';
CREATE TABLE `messages` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`userid` bigint NOT NULL COMMENT '留言人id',`username` varchar(200) DEFAULT NULL COMMENT '用户名',`content` longtext NOT NULL COMMENT '留言内容',`reply` longtext COMMENT '回复内容',PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1616222424131 DEFAULT CHARSET=utf8mb3 COMMENT='留言板';
CREATE TABLE `token` (`id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',`userid` bigint NOT NULL COMMENT '用户id',`username` varchar(100) NOT NULL COMMENT '用户名',`tablename` varchar(100) DEFAULT NULL COMMENT '表名',`role` varchar(100) DEFAULT NULL COMMENT '角色',`token` varchar(200) NOT NULL COMMENT '密码',`addtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '新增时间',`expiratedtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '过期时间',PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3 COMMENT='token表';获取源码我们有上万多套源码，欢迎咨询。可定制、修改、部署、讲解、代写文档、PPT。获取源码查看底部卡片或者顶部名字http://www.ppmy.cn/news/1541471.html相关文章|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61目录 
系统展示 
开发背景 
代码实现 
项目案例  
获取源码 博主介绍&amp;#xff1a;CodeMentor毕业设计领航者、全网关注者30W群落&amp;#xff0c;InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者&amp;#xff0c;博客领航之星、开发者头条/腾讯云/AW…阅读更多...Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:51 +0000</pubDate>
    </item>
    <item>
      <title>|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61</title>
      <link>https://www.ppmy.cn/news/1541470.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维|人口分析|007_django基于Python的广东省人口流动数据分析2024_92306i61news/2025/11/4 0:21:50/目录系统展示开发背景代码实现项目案例获取源码博主介绍：CodeMentor毕业设计领航者、全网关注者30W+群落，InfoQ特邀专栏作家、技术博客领航者、InfoQ新星培育计划导师、Web开发领域杰出贡献者，博客领航之星、开发者头条/腾讯云/AWS/Wired等平台优选内容创作者、深耕Web开发与学生毕业设计实战指导，与高校教育者/资深讲师/行业专家深度对话🤝技术专长：Spring Framework、Angular、MyBatis、HTML5+CSS3、Servlet、Ruby on Rails、Node.js、Rust、网络爬虫、数据可视化、微信小程序、iOS应用开发、云计算、边缘计算、自然语言处理等项目的规划与实施。核心服务：无偿功能蓝图构思、项目启动报告、任务规划书、阶段评估演示文稿、系统功能落地、代码实现与优化、学术论文定制指导、论文精炼与重组、长期答辩筹备咨询、Zoom在线一对一深度解析答辩要点、模拟答辩实战彩排、以及代码逻辑与架构设计深度剖析。🍅文末获取源码联系🍅👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟Java项目精品实战案例《100套》Java微信小程序项目实战《100套》大数据项目实战《100套》Python项目实战《100套》感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人系统展示开发背景基于Python的广东省人口流动数据分析的开发背景是多方面的，主要包括技术需求、政策支持、经济影响以及社会需求等。以下详细介绍这些开发背景：技术需求：随着大数据和人工智能技术的发展，对数据的处理和分析能力提出了更高的要求。Python作为一种高效、易学且功能强大的编程语言，在数据科学领域得到了广泛应用。Python提供了丰富的数据处理库（如Pandas、NumPy）和可视化工具（如Matplotlib、Seaborn），非常适合进行复杂的数据分析和结果展示。政策支持：政府对于优化人口结构和促进地区均衡发展有着明确的政策导向，这需要准确的人口流动数据作为决策支持。通过技术手段提高人口管理的科学性和精准性，是当前政府工作的一部分，这也为基于Python的人口流动数据分析提供了政策背景。经济影响：人口流动与经济发展之间存在密切的联系。研究显示，广东省人口流动与经济发展之间有着显著的双向影响，经济规模与人口流动的相关性高于经济结构。利用Python进行人口流动数据分析，可以更好地理解人口流动对经济的影响，为制定相应的经济政策提供依据。社会需求：社会公众对于了解人口流动趋势和特点有着较高的兴趣，这有助于公众更好地理解社会发展动态。媒体和研究机构也需要准确的人口流动数据来支撑其分析和报道，Python的数据分析能力可以满足这一需求。教育科研：学术界对于人口流动的研究不断深入，需要使用先进的技术手段来处理和分析数据。Python在学术领域的普及使得其在人口流动数据分析中的应用成为可能，同时也促进了相关教育和科研工作的开展。公共卫生：特别是在新冠疫情期间，人口流动成为了疫情传播的关键风险来源之一。利用Python进行人口流动数据分析，可以帮助公共卫生部门更有效地监控和管理疫情，制定科学的防控策略。城市化进程：随着城市化进程的加快，城市间的人口流动日益频繁，这对城市规划和管理提出了新的挑战。Python的数据分析能力可以帮助城市规划者更好地理解人口流动模式，优化城市资源配置。国际交流：在全球化背景下，国际间的人口流动也日益增多，这对广东省等沿海发达地区的影响尤为显著。通过Python进行人口流动数据分析，可以更好地理解和应对国际人口流动带来的机遇和挑战。综上所述，基于Python的广东省人口流动数据分析的开发背景是多方面的，涵盖了技术进步、政策需求、经济影响、社会关注等多个层面。通过这一项目的实施，不仅能够提升广东省乃至全国的人口管理水平，还能为相关政策的制定和实施提供科学依据，促进社会经济的健康发展。代码实现/*** 登录相关*/
@RequestMapping("users")
@RestController
public class UserController{@Autowiredprivate UserService userService;@Autowiredprivate TokenService tokenService;/*** 登录*/@IgnoreAuth@PostMapping(value = "/login")public R login(String username, String password, String role, HttpServletRequest request) {UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username));if(user != null){if(!user.getRole().equals(role)){return R.error("权限不正常");}if(user==null || !user.getPassword().equals(password)) {return R.error("账号或密码不正确");}String token = tokenService.generateToken(user.getId(),username, "users", user.getRole());return R.ok().put("token", token);}else{return R.error("账号或密码或权限不对");}}/*** 注册*/@IgnoreAuth@PostMapping(value = "/register")public R register(@RequestBody UserEntity user){
//        ValidatorUtils.validateEntity(user);if(userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", user.getUsername())) !=null) {return R.error("用户已存在");}userService.insert(user);return R.ok();}/*** 退出*/@GetMapping(value = "logout")public R logout(HttpServletRequest request) {request.getSession().invalidate();return R.ok("退出成功");}/*** 密码重置*/@IgnoreAuth@RequestMapping(value = "/resetPass")public R resetPass(String username, HttpServletRequest request){UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username));if(user==null) {return R.error("账号不存在");}user.setPassword("123456");userService.update(user,null);return R.ok("密码已重置为：123456");}/*** 列表*/@RequestMapping("/page")public R page(@RequestParam Map&lt;String, Object&gt; params,UserEntity user){EntityWrapper&lt;UserEntity&gt; ew = new EntityWrapper&lt;UserEntity&gt;();PageUtils page = userService.queryPage(params, MPUtil.sort(MPUtil.between(MPUtil.allLike(ew, user), params), params));return R.ok().put("data", page);}/*** 信息*/@RequestMapping("/info/{id}")public R info(@PathVariable("id") String id){UserEntity user = userService.selectById(id);return R.ok().put("data", user);}/*** 获取用户的session用户信息*/@RequestMapping("/session")public R getCurrUser(HttpServletRequest request){Integer id = (Integer)request.getSession().getAttribute("userId");UserEntity user = userService.selectById(id);return R.ok().put("data", user);}/*** 保存*/@PostMapping("/save")public R save(@RequestBody UserEntity user){
//        ValidatorUtils.validateEntity(user);if(userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", user.getUsername())) !=null) {return R.error("用户已存在");}userService.insert(user);return R.ok();}/*** 修改*/@RequestMapping("/update")public R update(@RequestBody UserEntity user){
//        ValidatorUtils.validateEntity(user);userService.updateById(user);//全部更新return R.ok();}/*** 删除*/@RequestMapping("/delete")public R delete(@RequestBody Integer[] ids){userService.deleteBatchIds(Arrays.asList(ids));return R.ok();}
}项目案例获取源码大家点赞、收藏、关注、评论啦 、查看👇🏻获取联系方式👇🏻http://www.ppmy.cn/news/1541470.html相关文章Python数据类型详解：10个你必须掌握的类型Python 是一种动态类型语言&amp;#xff0c;这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型&amp;#xff0c;用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型&amp;#xff0c;每个类型都附有示例代码。 
1. 数字类型&amp;#xff08;Numeric Typ…阅读更多...2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:50 +0000</pubDate>
    </item>
    <item>
      <title>Python数据类型详解：10个你必须掌握的类型</title>
      <link>https://www.ppmy.cn/news/1541469.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python数据类型详解：10个你必须掌握的类型news/2025/11/4 0:21:50/Python 是一种动态类型语言，这意味着变量的类型是在运行时确定的。Python 提供了多种内置数据类型，用于存储和操作不同类型的数据。以下是 10 个你必须掌握的 Python 数据类型，每个类型都附有示例代码。1. 数字类型（Numeric Types）整数（Integer）a=10print(type(a))# &lt;class 'int'&gt;浮点数（Float）b=3.14print(type(b))# &lt;class 'float'&gt;复数（Complex）c=1+2jprint(type(c))# &lt;class 'complex'&gt;2. 字符串（String）s="Hello, World!"print(type(s))# &lt;class 'str'&gt;3. 布尔类型（Boolean）is_valid=Trueprint(type(is_valid))# &lt;class 'bool'&gt;4. 列表（List）lst=[1,2,3,"a","b","c"]print(type(lst))# &lt;class 'list'&gt;5. 元组（Tuple）tpl=(1,2,3)print(type(tpl))# &lt;class 'tuple'&gt;6. 集合（Set）set1={1,2,3,4}print(type(set1))# &lt;class 'set'&gt;7. 字典（Dictionary）d={"name":"Alice","age":25,"city":"New York"}print(type(d))# &lt;class 'dict'&gt;8. 冻结集合（Frozenset）冻结集合是不可变的集合，因此可以作为字典的键或集合的元素。frz=frozenset([1,2,3])print(type(frz))# &lt;class 'frozenset'&gt;9. 字节（Bytes）字节是不可变的字节序列，用于存储二进制数据。b_data=b"Hello, World!"print(type(b_data))# &lt;class 'bytes'&gt;10. 字节数组（Bytearray）字节数组是可变的字节序列，用于存储二进制数据。ba_data=bytearray(b"Hello, World!")print(type(ba_data))# &lt;class 'bytearray'&gt;示例代码汇总# 数字类型a=10b=3.14c=1+2j# 字符串s="Hello, World!"# 布尔类型is_valid=True# 列表lst=[1,2,3,"a","b","c"]# 元组tpl=(1,2,3)# 集合set1={1,2,3,4}# 字典d={"name":"Alice","age":25,"city":"New York"}# 冻结集合frz=frozenset([1,2,3])# 字节b_data=b"Hello, World!"# 字节数组ba_data=bytearray(b"Hello, World!")# 打印所有变量的类型print(type(a),type(b),type(c),type(s),type(is_valid),type(lst),type(tpl),type(set1),type(d),type(frz),type(b_data),type(ba_data))这些数据类型是 Python 编程中最常用的，掌握它们对于编写高效和灵活的代码至关重要。希望这些示例代码能帮助你更好地理解每种数据类型的使用。http://www.ppmy.cn/news/1541469.html相关文章2024年【焊工（高级）】新版试题及焊工（高级）试题及解析题库来源&amp;#xff1a;安全生产模拟考试一点通公众号小程序 
焊工&amp;#xff08;高级&amp;#xff09;新版试题是安全生产模拟考试一点通总题库中生成的一套焊工&amp;#xff08;高级&amp;#xff09;试题及解析&amp;#xff0c;安全生产模拟考试一点通上焊工&amp;#xff08;高级&amp;#xff09;作业手机…阅读更多...MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:50 +0000</pubDate>
    </item>
    <item>
      <title>2024年【焊工（高级）】新版试题及焊工（高级）试题及解析</title>
      <link>https://www.ppmy.cn/news/1541468.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维2024年【焊工（高级）】新版试题及焊工（高级）试题及解析news/2025/11/4 0:21:49/题库来源：安全生产模拟考试一点通公众号小程序焊工（高级）新版试题是安全生产模拟考试一点通总题库中生成的一套焊工（高级）试题及解析，安全生产模拟考试一点通上焊工（高级）作业手机同步练习。2024年【焊工（高级）】新版试题及焊工（高级）试题及解析1、【单选题】( )不是压力容器焊接时防止冷裂纹的措施。（  C  ）A、正确选择焊接工艺参数B、后热及焊后热处理C、焊条角度不正确D、选用低氢型焊条2、【单选题】( )不是埋弧焊机电源参数的测试内容。（  B  ）A、输出电流的调节范围B、小车行走性能C、输出电压的调节范围D、电流和电压变化的均匀性3、【单选题】( )不是防锈铝合金的性能。（  A  ）A、强度太低B、耐腐蚀性好C、高的塑性D、抛光性好4、【单选题】( )中的碳是以片状石墨的形式分布于金属基体中。（  C  ）A、高碳钢B、中碳钢C、灰铸铁D、可锻铸铁5、【单选题】( )可以用来焊接纯铝或要求不高的铝合金。（  C  ）A、SAlMg-5B、SAlMnC、SAl-3D、SAlCu6、【单选题】( )容器为《容规》适用范围内的第二类压力容器。（  C  ）A、超高压B、高压C、中压D、低压7、【单选题】( )容器的设计压力为0.1MPa≤P＜1.6MPa。（  D  ）A、超高压B、高压C、中压D、低压8、【单选题】( )属于钨极氩弧焊机的调试内容。（  A  ）A、供气系统的完好性B、焊丝的校直C、小车的行走速度D、钨极的直径9、【单选题】( )接头受力较均匀，因此常用于筒体与封头等重要部件的连接。（  B  ）A、搭接B、对接C、十字D、端接10、【单选题】( )是斜Y形坡口对接裂纹试验规定的每次试验的试件数量。（  B  ）A、1件B、2件C、3件D、4件11、【单选题】( )是铁素体和渗碳体的机械混合物。（  D  ）A、马氏体B、奥氏体C、莱氏体D、珠光体12、【单选题】( )是铝合金焊丝。（  C  ）A、RZC-1B、HSCuC、SAlMg-1D、H08Mn2SiA13、【单选题】( )焊接方法不能满足钛及钛合金焊接质量要求。（  C  ）A、真空电子束焊B、熔化极氩弧焊C、焊条电弧焊D、钨极氩弧焊14、【单选题】( )的对接接头不能用焊接接头拉伸试验国家标准进行。（  B  ）A、焊条电弧焊B、火焰钎焊C、钨极氩弧焊D、电阻焊15、【单选题】( )裂纹率需要将斜Y形坡口对接裂纹试件采用适当的方法着色后拉断或弯断，然后进行检测并计算的。（  C  ）A、断面B、中心C、根部D、表面16、【单选题】( )适合于焊接铝及铝合金的薄板、全位置焊接。（  D  ）A、熔化极氩弧焊B、CO2气体保护焊C、焊条电弧焊D、钨极脉冲氩弧焊17、【单选题】下列焊丝中，( )是铸铁焊丝。（  B  ）A、H08Mn2SiAB、RZC-1C、HS311D、HSCu18、【单选题】为了抑制碳在熔合区的扩散，焊接珠光体钢和奥氏体不锈钢时，应该提高焊接填充材料的( )的含量。（  D  ）A、铬B、钼C、钒D、镍19、【单选题】为了防止气孔，铝合金焊接时采取的主要措施有( )等。（  B  ）A、采用小的焊接电流B、严格清理焊件和焊丝表面C、合理选用焊丝D、选用热量集中的焊接方法20、【单选题】为了防止铸铁焊接时产生CO气孔而采取的措施中没有( )。（  B  ）A、气焊时使用溶剂B、烘干焊条C、采用石墨型药皮焊条D、用中性焰或弱碳化焰气焊21、【单选题】以下( )不是锅炉的主要参数。（  B  ）A、压力B、使用寿命C、出力D、温度22、【单选题】以下属于异种金属焊接的是( )。（  C  ）A、Q235钢与低碳钢，采用E4303焊条B、Q345钢与16锰钢，采用J507焊条C、Q235钢与1Cr18Ni9，采用E309-15焊条D、在20号钢上采用J422焊条堆焊23、【单选题】企业信誉的基础是( )。（  C  ）A、较低的价格B、较高的产量C、良好的产品质量和服务D、较多的社会关系24、【单选题】凡承受流体介质压力的( )设备称为压力容器。（  B  ）A、耐腐蚀B、密封C、耐热D、耐磨25、【单选题】高处作业吊篮安全锁必须在标定有效期内使用，有效标定期限不大于（）年。（  D  ）A、4B、3C、2D、126、【单选题】压力容器( )前，对受压元件之间的对接焊接接头和要求全焊透的T形接头等，都应进行焊接工艺评定。（  B  ）A、设计B、施焊C、热处理D、无损检测27、【单选题】压力容器专用钢材( )的质量分数不应大于0.020%。（  A  ）A、硫B、磷C、碳D、硅28、【单选题】压力容器专用钢材磷的质量分数( )。（  D  ）A、应大于0.020%B、不应大于0.020%C、应大于0.030%D、不应大于0.030%29、【单选题】变压器是利用电磁感应原理工作，无论是升压或降压，变压器( )。（  C  ）A、只能改变频率，而不能改变电流的大小B、能改变电压，而且能改变电流的频率C、只能改变电压，而不能改变电流的频率D、能改变电流的频率，而且能改变电压的频率30、【单选题】在TIG焊过程中，破坏和清除氧化膜的措施是( )。（  D  ）A、焊丝中加锰和硅脱氧B、采用直流正接焊C、提高焊接电流D、采用交流焊31、【单选题】在两种母材熔化量相同的情况下，焊接1Cr18Ni9不锈钢和Q235低碳钢时，如( )，焊缝会得到马氏体组织。（  C  ）A、采用HOCr26Ni21焊丝B、采用E310-15焊条C、不加填充材料D、采用E310-16焊条32、【单选题】在压力容器中，封头与筒体连接时只广泛采用( )封头。（  B  ）A、球形或平盖B、球形或椭圆形C、方形或球形D、平盖或椭圆形33、【单选题】在电路中有两个以上的电阻一个接一个的依次连接，且( )，这就是电阻串联。（  A  ）A、流过这些电阻的电流相同B、流过这些电阻的电流不相同C、这些电阻两端的电压相同D、这些电阻两端的电压近似相等34、【单选题】埋弧焊机控制系统的调试不包括测试( )。（  B  ）A、小车行走速度B、焊剂的铺撒和回收C、引弧操作性能D、焊丝的送丝速度35、【单选题】如果电流的( )变化，就是恒定直流电流。（  C  ）A、方向和大小都随时间B、方向不变和大小随时间C、方向和大小都不随时间D、大小不变方向随时间36、【单选题】对接管水平固定位置向上焊接( )进行。（  B  ）A、按整圆B、分两个半圆C、分四个半圆D、分六个半圆37、【单选题】异种钢焊接接头中会产生较大的热应力，其原因是珠光体钢和奥氏体不锈钢的线膨胀系数和( )不同。（  C  ）A、熔点B、导电率C、热导率D、碳当量38、【单选题】异种钢焊接时，选择焊接方法的着眼点是应该尽量( )。（  B  ）A、提高生产率B、减小熔合比C、增加线能量D、加强保护39、【单选题】弯曲试验时，( )的试样数量不少于2个。（  C  ）A、正弯B、背弯C、纵弯D、侧弯40、【单选题】当采用非铸铁型焊接材料焊补灰铸铁时，焊缝也会产生( )。（  C  ）A、冷裂纹B、层状撕裂C、热裂纹D、再热裂纹41、【单选题】数控气割机在气割前，应该( )。（  D  ）A、制作样板B、进行划线C、进行放样D、输入指令42、【单选题】斜Y形坡口对接裂纹试件两端的拘束焊缝注意不要产生( )缺陷。（  D  ）A、咬边B、气孔C、夹渣D、未焊透43、【单选题】斜Y形坡口对接裂纹试件坡口表面加工应采用机械切削加工方法的原因之一是( )。（  D  ）A、避免产生表面裂纹B、避免产生表面夹渣C、避免产生表面气孔D、避免气割表面硬化44、【单选题】斜Y形坡口对接裂纹试件焊完后，应( )进行裂纹的检测和解剖。（  B  ）A、立即B、经48小时后C、经24小时后D、经12小时后45、【单选题】斜Y形坡口对接裂纹试验适用于碳素钢和低合金钢抗( )的性能试验。（  D  ）A、热裂纹B、再热裂纹C、弧坑裂纹D、冷裂纹46、【单选题】气焊铝及铝合金用的熔剂是( )。（  A  ）A、CJ401B、HJ431C、HJ250D、CJ10147、【单选题】水压试验应在无损检测合格后进行；若需要作热处理的容器，则应( )进行。（  C  ）A、在热处理前B、在热处理过程中C、在热处理后D、与热处理同时48、【单选题】水压试验是用来对锅炉压力容器和管道进行( )。（  B  ）A、内部缺陷和强度检验B、整体严密性和强度检验C、表面缺陷和韧性检验D、整体严密性和塑性检验49、【单选题】水压试验的试'安全生产 模拟 考试一点 通'验压力一般为( )。（  C  ）A、设计压力的1.25～1.5倍B、设计压力的1.5～2倍C、工作压力的1.25～1.5倍D、工作压力的1.5～2倍50、【单选题】渗透探伤包括( )两种方法。（  C  ）A、磁粉探伤和声发射探伤B、超声波探伤和X射线探伤C、荧光探伤和着色探伤D、X射线探伤和磁粉探伤51、【单选题】火焰钎焊灰铸铁的特点是( )。（  B  ）A、焊缝高出母材一块B、母材不熔化C、焊缝可得到灰铸铁组织D、半熔化区易产生白口铸铁组织52、【单选题】灰铸铁气焊时，应采用的火焰是( )。（  D  ）A、碳化焰或弱氧化焰B、强碳化焰或氧化焰C、强氧化焰或碳化焰D、中性焰或弱碳化焰53、【单选题】焊接场地应保持必要的通道，人行通道宽度不小于( )。（  D  ）A、4.5mB、3.5mC、2.5mD、1.5m54、【单选题】焊接弧光的红外线辐射有可能引起( )。（  D  ）A、高度畏光B、电光性眼炎C、流泪D、白内障55、【单选题】焊接接头冲击试样，最新解 析 ，的数量，按( )所在位置各自不少于3个。（  D  ）A、焊缝B、熔合线C、热影响区D、缺口56、【单选题】焊接接头的弯曲试样按( )与焊缝的相对位置可分为横向弯曲试样和纵向弯曲试样。（  D  ）A、试样的高度B、试样的宽度C、试样的厚度D、试样的长度57、【单选题】焊接铜及铜合金时，防止产生热裂纹的措施中没有( )。（  C  ）A、严格控制焊丝中杂质的含量B、气焊时加入溶剂C、采用较大的线能量D、焊前预热58、【单选题】焊补灰铸铁时，由于灰铸铁本身( )，所以焊接接头容易产生裂纹。（  C  ）A、含合金元素高B、含氢高C、塑性极差D、强度太高59、【单选题】焊补铸铁时，采用加热减应区法的目的是为了( )。（  A  ）A、减小焊接应力，防止产生裂纹B、防止产生白口铸铁组织C、得到高强度的焊缝D、得到高塑性的焊缝60、【单选题】珠光体钢和奥氏体不锈钢厚板对接焊时，可先在( )焊接材料，采用多层多道焊的方法，堆焊过渡层。（  A  ）A、珠光体钢的坡口上用25-13型B、珠光体钢的坡口上用18-12型C、奥氏体不锈钢的坡口上用25-13型D、奥氏体不锈钢的坡口上用25-20型61、【单选题】生产中广泛采用E309-16和E309-15焊条，焊接珠光体钢和奥氏体不锈钢，目的是为了得到( )的奥氏体+铁素体的焊缝组织。（  B  ）A、强度高B、抗裂性能好C、冲击韧性高D、耐腐蚀性好62、【单选题】用于焊接压力容器主要受压元件的( )，其碳的质量分数不应大于0.25%。（  D  ）A、铝及铝合金B、奥氏体不锈钢C、铜及铜合金D、碳素钢和低合金钢63、【单选题】由于球化剂具、安全 生产模拟考 试一点通 、有( )作用，因此球墨铸铁产生白口铸铁组织的倾向比灰铸铁大。（  C  ）A、使石墨呈球状B、提高力学性能C、阻碍石墨化D、减小焊接应力64、【单选题】由于铝的( )，使铝及铝合金焊接时产生较大的焊接应力，引起热裂纹。（  C  ）A、热膨胀系数大，凝固收缩率小B、热膨胀系数小，凝固收缩率大65、【单选题】由于铝的热膨胀系数大，凝固收缩率大，因此焊接时( )，容易产生热裂纹。（  D  ）A、熔池含氢量高B、熔化时没有显著的颜色变化C、高温强度低D、产生较大的焊接应力66、【单选题】电弧冷焊灰铸铁时，一般得到( )。（  C  ）A、灰铸铁焊缝B、球墨铸铁焊缝C、非铸铁焊缝D、可锻铸铁焊缝67、【单选题】电流频率不同，电击对人体的伤害程度也不同，如频率在1000Hz以上，伤害程度( )。（  C  ）A、明显增加B、明显大大增加C、明显减轻D、明显为零68、【单选题】碳的质量分数等于( )的钢是中碳钢。（  C  ）A、0.08％～0.45％B、0.25％～0.45％C、0.25％～0.60％D、0.45％～0.80％69、【单选题】细丝CO2气体保护焊焊补灰铸铁时不应该采用( )的焊接工艺。（  B  ）A、小电流B、高电压C、焊后锤击D、断续焊70、【单选题】职业道德的意义很深远，但不包括( )。（  C  ）A、有利于推动社会主义精神文明建设B、有利于行业建设和发展C、有利于社会体制改革D、有利于个人的提高和发展71、【单选题】荧光探伤是用来发现各种焊接接头的( )缺陷。（  A  ）A、表面B、内部C、深层D、根部72、【单选题】荧光探伤是用来发现各种焊接接头的( )，常作为非磁性材料工件的检“安 全生产模拟考试 一点通“查。（  C  ）A、组织缺陷B、微小缺陷C、表面缺陷D、层状撕裂73、【单选题】选用25-13型焊接材料，进行珠光体钢和奥氏体不锈钢厚板对接焊时，可先在( )的方法，堆焊过渡层。（  D  ）A、奥氏体不锈钢的坡口上，采用单道焊B、奥氏体不锈钢的坡口上，采用多层多道焊C、珠光体钢的坡口上，采用单道焊D、珠光体钢的坡口上，采用多层多道焊74、【单选题】金属材料在外力作用下产生塑性变形的能力称为( )。（  B  ）A、抗拉强度B、塑性C、冲击韧度D、屈服点75、【单选题】钛及钛合金焊接时，焊缝和热影响区呈( )，表示保护效果最不好。（  B  ）A、银白色B、深蓝色C、淡黄色D、深黄色76、【单选题】钨极氩弧焊机的调试包括( )。（  B  ）A、钨极的成分B、阴极雾化作用C、焊机的弧长自动调节效果D、焊剂的铺撒和回收77、【单选题】铝及铝合金( )时一律采用直流反接。（  C  ）A、手工钨极氩弧焊B、自动钨极氩弧焊C、熔化极氩弧焊D、钨极脉冲氩弧焊78、【单选题】铝合金焊接时防止气孔的主要措施中没有( )。（  D  ）A、预热降低冷却速度B、严格清理焊丝表面C、熔化极氩弧焊用直流反接D、焊件背面加垫板79、【单选题】铸铁的分类中不包括( )（  C  ）A、白口铸铁B、灰铸铁C、可浇铸铁D、球墨铸铁80、【单选题】锅炉压力容器是生产和生活中广泛使用的( )。（  B  ）A、受力非常复杂的容器B、有爆炸危险的承压设备C、要求耐腐蚀性非常高的设备D、有断裂危险的受拉容器81、【单选题】马氏体是碳在α－铁中的过饱和固溶体，其性能特点是( )。（  D  ）A、韧性很高B、塑性很好C、无磁性D、硬度很高82、【单选题】黄铜H62中的数字“62”表示( )。（  C  ）A、锌的含量62%B、抗拉强度为62MPaC、铜的含量62%D、伸长率为62%83、【单选题】黄铜气焊时，使用弱氧化焰，以使焊缝表面生成一层( )薄膜，阻挡锌的蒸发。（  A  ）A、氧化硅B、氧化锌C、氧化铜D、氧化铝84、【判断题】E308L-16是铸铁焊条。（  ×  ）85、【判断题】HT100中，“HT”为灰铸铁的代号。（  √  ）86、【判断题】使用了低合金结构钢，不仅大大地节约了钢材，提高了硬度及耐磨性，同时也大大提高了产品质量和使用寿”安全生产模拟考试一 点通”命。（  ×  ）87、【判断题】变压器是利用电磁感应原理工作，无论是升压或降压，变压器只能改变电压，而不能改变电流的频率。（  √  ）88、【判断题】引弧性能是钨极氩弧焊枪的试验内容。（  ×  ）89、【判断题】船舶使用的特种设备的安全监察不适用《特种设备安全监察条例》。（）（  √  ）90、【判断题】数控气割机是按照给定的程序自动进行切割的。（  √  ）91、【判断题】水压试验时，当压力达到试验压力后，要恒压一定时间，根据不同技术要求，一般为30～60分钟，观察是否有落压现象。（  ×  ）92、【判断题】焊接场地应保持必要的通道，车辆通道宽度不小于3m。（  √  ）93、【判断题】焊接过程中有很多污染环境的有害因素，其中属于化学有害因素的是焊接弧光、高频电磁场、焊接烟尘及有害气体等。（  ×  ）94、【判断题】电源参数的测试是埋弧焊机控制系统的调试内容。（  ×  ）95、【判断题】钢淬火的目的是为了细化晶粒，提高钢的综合力学性能。（  ×  ）96、【判断题】钨极氩弧焊枪的使用试验包括焊枪有无漏气、漏水现象；在额定电流和额定负载持续率情况下使用时，焊枪发热情况。（  √  ）97、【判断题】铜及铜合金工件易于采用全位置焊接。（  ×  ）98、【判断题】铝及铝合金气焊用熔剂是CJ201。（  ×  ）99、【判断题】铸铁开深坡口焊补时，常采用栽螺钉法的目的是为了防止熔融金属外流。（  ×  ）100、【判断题】锅炉压力容器是生产和生活中广泛使用的有断裂危险的受拉容器。（  ×  ）支持全国各地区精准焊工（高级）考试试题，支持安全资格证，特种作业操作证，职业技能鉴定等工种题库练习。http://www.ppmy.cn/news/1541468.html相关文章MySQLDBA修炼之道-开发篇（一）三、开发基础 
1. 数据模型 
1.1 关系数据模型介绍 
关于NULL 
如果某个字段的值是未知的或未定义的&amp;#xff0c;数据库会提供一个特殊的值NULL来表示。NULL值很特殊&amp;#xff0c;在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;85 or&gt;绩…阅读更多...挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:49 +0000</pubDate>
    </item>
    <item>
      <title>MySQLDBA修炼之道-开发篇（一）</title>
      <link>https://www.ppmy.cn/news/1541467.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQLDBA修炼之道-开发篇（一）news/2025/11/4 0:21:48/三、开发基础1. 数据模型1.1 关系数据模型介绍关于NULL如果某个字段的值是未知的或未定义的，数据库会提供一个特殊的值NULL来表示。NULL值很特殊，在关系数据库中应该小心处理。例如查询语句“select*from employee where 绩效得分&lt;=85 or&gt;绩效得分&gt;85；” 就不能查询出绩效得分是未知的（NULL）的数据。关于key和索引key常指表中能唯一标识一笔记录的字段（属性）或多个字段的组合。现实中，key和索引可以简单地看作同义词，key不一定唯一标识。数据库管理系统为了高效地检索记录，往往会创建各种索引结构加速检索记录，或者按照索引/key的顺序存储记录，所以基于记录的索引/key会很容易查找到记录。实体–关系建模ER建模ER建模是一种自上而下的数据库设计方法。我们通过标识模型中必须要表示的重要数据（称为实体）及数据之间的关系开始ER建模，然后增加细节信息，如实体和关系所要具有的信息（称为属性）。该方法的输出是实体类型、关系类型和约束条件的清单。UMLUML是一种分析人员和开发人员广泛使用的标准建模语言，它可以以图形化的方式表示实体、关系。实体实体代表现实世界的一组对象集合，可以粗略地认为它是名词，如学生、雇员、订单、演员、电影。实体一般用矩形来表示。关系关系指特定实体之间的关系。可以粗略地认为是动词，如公司拥有员工、演员演电影。关系用线来表示。一般为二元关系。二元关系的基数就是我们所说的一对一、一对多、多对多。在数据库设计中，需要选择合适的基数表示法，如IDEF1X表示法、关系表示法或Crow’s foot表示法。对于Crow’s foot表示法，实体表示为矩形框，关系表示为矩形框之间的线，线两端的形状表示关系的基数。空心圆表示零或多，单阴影线标记表示一或多，单阴影线标记和空心圆表示零或一，双阴影线标记表示恰好为一。2. SQL基础2.1 变量MySQL里的变量可分为用户变量和系统变量。用户变量用户变量与连接有关。也就是说，一个客户端定义的变量不能被其他客户端看到或使用。当客户端退出时，该客户端连接的所有变量将自动释放。这点不同于在函数或存储过程中通过DECLARE语句声明的局部变量，局部变量的生存周期在它被声明的“BEGIN…END”块内。对于用户变量的值，可以先保存在用户变量中，然后以后再引用它；这样就可以将值从一个语句传递到另外一个语句。设置用户变量执行SET语句SET@var_name=expr[,@var_name=expr]...系统变量MySQL服务器维护着两种系统变量：全局变量影响MySQL服务的整体运行方式；所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中对指定的选项进行更改。服务器启动后，通过连接服务器并执行SETGLOBAL var_name语句，可以动态更改这些全局变量。要想更改全局变，必须具有SUPER权限。修改了全局变量，只影响更改后连接的客户的相应会话变量。会话变量影响具体客户端连接的操作。服务器还为每个连接的客户端维护一系列的会话变量。在连接时使用相应全局变量的当前值对客户端的会话变量进行初始化。对于动态会话变量，客户端可以通过SET SESSION var_name语句更改它们。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量，而不能更改其他客户端的会话变量。2.2 保留字‌A‌：ALL, ALTER, AND, ANY, ARRAY, AS, ASC‌B‌：BEGIN, BETWEEN, BIGINT, BINARY, BLOB, BOOLEAN, BY, BYTES‌C‌：CASE, CAST, CHAR, CHECK, COLUMN, COMPUTE, CONDITION, CONSTRAINT, CONTINUE, CREATE‌D‌：DATABASE, DATE, DATETIME, DECIMAL, DECLARE, DEFAULT, DELETE, DESC, DESCRIBE, DISTINCT, DIV, DOUBLE‌E‌：ELSE, ESCAPE, EXCEPT, EXISTS, EXPLAIN, EXTRACT‌F‌：FALSE, FETCH, FLOAT‌G‌：GEO2D, GRANT, GROUP, GROUPING, GROUP_CONCAT‌H‌：HAVING‌I‌：IDENTIFIED, IF, IGNORE, IN, INDEX, INNER, INSERT, INT‌J‌：JOIN‌K‌：KEY‌L‌：LEAVE, LEFT, LIKE, LIMIT, LOCK‌M‌：MATCH, MEDIUMINT, MERGE, MINUS‌N‌：NATURAL‌O‌：ON, OPEN, OR‌P‌：PRIMARY‌R‌：RELEASE2.3 数据类型MySQL支持常用的数据类型：数值类型、日期/时间类型和字符串（字符）类型。数值类型数值类型可分为两类：整型和实数。对于实数，MySQL支持确切精度的值（定点数）和近似精度的值（浮点数）。确切精度的数值类型有DECIMAL类型，近似精度的数值类型有单精度（FLOAT）或双精度（DOUBLE）两种类型。整型整型包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，下面是各种整型的空间占用及表示的数值范围。无符号（unsigned）属性可扩展一倍的最大值上限。类型字节最小值最大值TINYINT1-1280127255SMALLINT2-3276803276765535MEDIUMINT3-83886080838860716777215INT4-2147483648021474836474294967295BIGINT8-92233720368547758080922337203685477580718446744073709551615DECIMAL和NUMERIC类型（定点数）定点数也就是DECIMAL型，指的是数据的小数点的位置是固定不变的。也就是说，小数点后面的位数是固定的。DECIMAL和NUMERIC在MySQL中被视为相同的类型。它们用于保存必须为确切精度的值，例如货币数据。FLOAT和DOUBLE类型（浮点数）单精度值（FLOAT）使用4个字节，双精度值（DOUBLE）使用8个字节。浮点数可以比整型、定点数表示更大的数值范围。为了保证最大可能的可移植性，对于使用近似数值存储的代码，应使用FLOAT或DOUBLE来表示，不规定精度或位数。由于浮点数存在误差问题，如果用到浮点数，要特别注意误差的问题，并尽量避免做浮点数比较。日期/时间类型表示时间值的日期和时间类型有DATETIME、DATE、TIMESTAMP、TIME和YEAR等。每个时间类型都有一个有效值范围，TIMESTAMP类型有其特有的自动更新特性。可以使用ALLOW_INVALID_DATES SQL模式让MySQL接受不合法的日期，例如’1999-11-31’不使用NO_ZERO_DATE SQL模式，MySQL还允许将’0000-00-00’保存为“伪日期”。这在某些情况下比使用NULL值更方便，并且数据和索引占用的空间更小。DATETIME、DATE和TIMESTAMP类型当需要同时包含日期和时间信息的值时，建议使用DATETIME（日期时间组合）类型。支持的范围为’1000-01-0100:00:00’到’9999-12-3123:59:59’。DATETIME类型占8个字节。当只需要日期值而不需要时间部分时，建议使用DATE（日期）类型。支持的范围是’1000-01-01’到’9999-12-31’。DATE类型占3个字节。TIMESTAMP（时间戳）列用于在进行INSERT或UPDATE操作时记录日期和时间。显示宽度固定在19个字符，并且格式为’YYYY-MM-DDHH:MM:SS’。TIMESTAMP的范围是从’1970-01-0100:00:01’UTC到’2038-01-0903:14:07’UTC。TIMESTAMP类型占4个字节。TIME（时间）类型该时间类型的范围是’-838:59:59’到’838:59:59’。TIME类型占3个字节。YEAR（两位或四位格式的年）类型YEAR类型表示两位或四位格式的年。默认是四位格式，在四位格式中，允许的值是1901~2155和0000。在两位格式中，如果是两位字符串，那么范围为’00’~‘99’。‘00’~‘69’和’70’~'99’范围的值被分别转换为2000~2069和1970~1999范围的YEAR值。如果是两位整数，范围为1~99。1~69和70~99范围的值被分别转换为2001~2069和1970~1999范围的YEAR值。YEAR类型占1个字节。字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。CHAR和VARCHAR类型CHAR与VARCHAR类型类似，但它们保存和检索数据的方式不同。在保存VARCHAR的值时，只保存需要的字符数，然后用1~2个字节来存储值的长度，所以如果是很短的值（如仅一个字符），那么耗费的存储空间比CHAR还会多些，所以，如果想存储很短的类型，使用CHAR会更合适。VARCHAR可选的一种场景是最长记录的长度值比平均长度的值大得多。CHAR是固定长度的字符串，它的长度固定为创建表时声明的长度。长度范围为0到255个字符。当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格会被删除掉，这是MySQL服务器级别控制的，和存储引擎无关。CHAR类型适合存储大部分值的长度都差不多的数据，例如MD5值。VARCHAR列中的值为可变长度的字符串。长度可以指定为0到65535之间的值BINARY和VARBINARY类型BINARY和VARBINARY类似于CHAR和VARCHAR，不同的是，它们包含的是二进制字符串而不是非二进制字符串。也就是说，它们包含的是字节字符串而不是字符字符串，它们的长度是字节长度而不是字符长度。这说明它们没有字符集，并且排序和比较也是基于字节的二进制值进行的。相对来说，二进制字符串的比较比字符字符串的比较更为简单有效。BLOB和TEXT类型BLOB是一个二进制大对象，可以容纳可变数量的数据。BLOB类型共有4种：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。BLOB是SMALLBLOB的同义词。TEXT类型也有4种：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。它们分别对应上面的4种BLOB类型，有相同的最大长度和存储需求。TEXT是SMALLTEXT的同义词。BLOB用于存储二进制字符串（字节字符串），而TEXT列则被视为非二进制字符串（字符字符串）的存储方式，它是有字符集和排序规则的。在大多数情况下，可以将BLOB列视为能够存储足够大数据的VARBINARY列。同样，也可以将TEXT列视为VARCHAR列。但是，BLOB和TEXT在以下几个方面不同于VARBINARY和VARCHAR。保存或检索BLOB和TEXT列的值时不用删除尾部的空格。对于BLOB和TEXT列的索引，必须指定索引前缀的长度。BLOB和TEXT列不能有默认值。排序时只使用该列的前max_sort_length个字节。max_sort_length的默认值是1024。BLOB或TEXT对象的最大长度由其类型来确定，但在客户端和服务器之间实际可以传递的最大数据量是由可用内存数量和通信缓存区的大小来确定的。可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端的程序。使用BLOB、TEXT等大字段可能会导致严重的性能问题，比如导致产生磁盘临时表。ENUM类型ENUM（枚举）类型是一个字符串对象，其值通常选自一个允许值列表，该列表是在创建表时被定义的。慎重使用。2.4 选择合适的数据类型MySQL支持许多数据类型，选择合适的数据类型可以获得更好的性能，从而更节省空间。指导原则：各表使用一致的数据类型字段在每个表中都应该使用一样的数据类型、长度，因为以后可能需要进行JOIN（连接）操作，这样做是为了避免无谓的转换或可能出现不期望的结果。我们不仅要考虑数据类型是如何存储的，也要清楚数据类型是如何计算和比较的。小往往更好选择更短的数据类型。更短的类型意味着更少的磁盘空间、更少的内存空间、更少的CPU处理时间。简单类型更好简单的数据类型能够进行更快的处理。尽可能避免NULL值应尽量显式定义“not NULL”，如果查询涉及的是NULL值的字段，MySQL会很难去优化查询。可使用0、空字符串或特殊的值来代替NULL存储。当然，也不要去刻意追求“not NULL”，因为更改NULL字段为“not NULL”，对性能的提升可能没什么太大的作用，让设计更自然、更具可理解性应该更值得看重。2.5 函数数值函数算数操作符可使用常见的算数操作符。例如‘+’、‘-’、‘*’、‘/’、DIV（整除）。数学函数ABS(X)：X的绝对值。CEIL(X)：返回不小于X的最小整数值。FLOOR(X)：返回不大于X的最大整数值。CRC32(X)：计算循环冗余码校验值并返回一个32比特无符号值。RAND()、RAND(N)：返回一个随机浮点值v，范围在0到1之间（即其范围为0≤v≤1.0）。若已指定一个整数参数N，则它被用作种子值，用来产生重复序列。SIGN(X)：返回X的符号。TRUNCATE(X,D)：返回被舍去至小数点后D位的数字X。若D的值为0，则结果不带有小数点或不带有小数部分。ROUND(X)、ROUND(X,D)：返回参数X，其值接近于最近似的整数。在有两个参数的情况下，返回X，其值保留到小数点后D位，而第D位的保留方式为四舍五入。若要保留X值到小数点左边的D位，可将D设为负值，例如，ROUND（123.45，-1）的结果是120，ROUND（167.8，-2）的结果是200。​字符类型处理函数CHAR_LENGTH(str)：返回值为字符串str的长度，长度的单位为字符。一个多字节字符算作一个单字符。对于一个包含5个二字节的字符集，LENGTH()的返回值为10，而CHAR_LENGTH()的返回值为5。LENGTH(str)：返回值为字符串str的长度，单位为字节。CONCAT(str1,str2,…)：返回结果为连接参数产生的字符串。如下查询将拼接’My’、‘S’、'QL’3个字符串。LEFT(str,len)：从字符串str开始，返回最左len个字符。RIGHT(str,len)：从字符串str开始，返回最右len个字符。SUBSTRING(str,pos)、SUBSTRING(str,pos,len)：不带有len参数的格式是从字符串str返回一个子字符串，起始于位置pos。带有len参数的格式是从字符串str返回一个长度同len字符相同的子字符串，起始于位置pos。LOWER(str)：返回字符串str转化为小写字母的字符。UPPER(str)：返回字符串str转化为大写字母的字符。日期和时间函数NOW()：返回当前日期和时间的值，其格式为’YYYY-MM-DDHH:MM:SS’或YYYYMMDDHHMMSS。CURTIME()：将当前时间以’HH:MM:SS’或HHMMSS的格式返回。CURDATE()：将当前日期按照’YYYY-MM-DD’或YYYYMMDD格式的值返回。DATEDIFF(expr1,expr2)：是返回开始日期expr1与结束日期expr2之间相差的天数，计算中只用到这些值的日期部分。返回值为正数或负数。DATE_ADD(date,INTERVAL expr type)、DATE_SUB(date,INTERVAL expr type)：这些函数执行日期运算。date是一个DATETIME或DATE值，用来指定起始时间。expr是一个表达式，用来指定从起始日期添加或减去的时间间隔值。type为关键词，它指示了表达式被解释的方式。type常用的值有SECOND、MINUTE、HOUR、DAY、WEEK、MONTH、YEAR。DATE_FORMAT(date,format)：下面的代码会根据format字符串安排date值的格式。常用的日期格式’YYYY-MM-DDHH:MM:SS’STR_TO_DATE(str,format)：是DATE_FORMAT()函数的倒转。它将获取一个字符串str和一个格式字符串format。若格式字符串包含日期和时间部分，则STR_TO_DATE()返回一个DATETIME值，若该字符串只包含日期部分或只包含时间部分，则返回一个DATE或TIME值。2.6 操作符及优先级以下是按照从低到高的优先级列出的各种运算操作符::=||、OR、XOR&amp;&amp;、ANDNOTBETWEEN、CASE、WHEN、THEN、ELSE=、&lt;=&gt;、&gt;=、&gt;、&lt;=、&lt;、&lt;&gt;、!=、IS、LIKE、REGEXP、IN|&amp;&lt;&lt;、&gt;&gt;-、+*、/（DIV）、%（MOD）^（按位异或）-（负号）、~（按位取反）!2.7 SQL语法1. 数据定义语句（DDL）创建表CREATETABLEemployees_2(emp_noint(11)NOTNULL,birth_datedateNOTNULL,first_namevarchar(14)NOTNULL,last_namevarchar(16)NOTNULL,genderenum('M','F')NOTNULL,hire_datedateNOTNULL,primarykey(emp_no))engine=innodbdefaultcharset=latin1删除表DROPTABLEemployees_2;修改表# 修改表名ALTERTABLEt1RENAMEt2;# 添加列ALTERTABLEt2ADDdTIMESTAMP;# 添加索引ALTERTABLEt2ADDINDEX(d),ADDINDEX(a);# 删除列ALTERTABLEt2DROPCOLUMNc;# 修改列类型ALTERTABLEt2MODIFYaTINYINTNOTNULL;# 修改列名ALTERTABLEt2 CHANGE b cCHAR(20);CHANGE和MODIFY都用于修改表的列属性，但它们之间存在一些差异：重命名列。CHANGE允许修改列名，而MODIFY不支持重命名列。12345678数据类型和约束修改。CHANGE和MODIFY都可以修改列的数据类型，但CHANGE还可以修改列的其他属性，如长度、默认值、是否为空等。使用频率。MODIFY通常用于进行较小的修改，例如修改列的数据类型，而CHANGE用于进行幅度较大的修改，如修改列名。验证表结构DESCemployees_2创建索引# 在表的列id上创建索引。CREATEINDEXid_indexONemployees_2(id);# 在customer表的name列上创建一个索引，索引使用name列的前10个字符。CREATEINDEXpart_of_nameONcustomer(name(10));# 在tbl_name表的a、b、c列上创建一个复合索引CREATEINDEXidx_a_b _cONtbl_name(a,b,c);句删除索引# 删除表tbl_name上的index_name索引时使用如下命令。DROPINDEXindex_nameONtbl_name;修改字符集和排序规则# 更改排序字符集ALTERTABLEtest.tt1 CHANGE v2 v2VARCHAR(10)CHARACTERSETutf8COLLATEutf8_general_ci;# 更改排序规则ALTERTABLEtable_name CHANGE col_a col_aVARCHAR(50)CHARACTERSETlatin1COLLATElatin1_bin2. 数据操作语句（DML）INSERT语句INSERTINTOtable_name(column1,column2....)VALUES(value1,value2...);修改数据（UPDATE）UPDATEtable_nameSETcolumn_name1=value1,column_name2=value2,column_name3=value3...[WHEREconditions];删除（DELETE）DELETEFROMtable_name[WHEREconditions];SELECT语句SELECTcolumn_namesFROMtable_name[WHERE...conditions];SQL模式匹配SQL有两个通配符，“-”匹配任意单个字符，“%”匹配任意多个字符（包括0个字符）。模式匹配默认是区分大小写的，它一般使用LIKE或NOT LIKE这些比较操作符。SELECT*FROMemployeesWHEREfirst_nameLIKE'D%';SELECT*FROMemployeesWHEREfirst_nameLIKE'Ang__'逻辑操作符与或非（AND、OR、NOT）可以用逻辑操作符组合成多个筛选条件范围操作符IN和BETWEENSELECT*FROMemployeesWHEREbirth_dateIN('1964-06-01','1964-06-02','1964-06-04');SELECT*FROMemployeesWHEREbirth_dateBETWEEN'1964-06-01'AND'1964-06-04';限制获取记录数（使用LIMIT子句）SELECT*FROMemployeesLIMIT5;排序（ORDERBY）SELECT*FROMemployeesORDERBYbirth_dateASCLIMIT10;数据计算SELECTemp_no,first_name,last_name,birth_date,curdate(),timestampdiff(year,birth_date,curdate())asageFROMemployeesORDERBYfirst_name,last_nameLIMIT10;使用DISTINCT获取不重复的唯一值SELECTDISTINCTfirst_nameFROMemployees;聚集函数COUNT、MIN、MAX、AVG、SUMSELECTCOUNT(*)FROMemployees;SELECTMIN(emp_no)FROMemployees;SELECTMAX(emp_no)FROMemployees;SELECTAVG(salary)FROMsalariesWHEREto_date='9999-01-01';SELECTSUM(salary)FROMsalariesWHEREto_date='9999-01-01';分组统计GROUP BY子句一般将GROUP BY语句和聚集函数一起使用，从而实现分组统计。SELECTMAX(a),MAX(b),MAX(c)FROMtable_nameWHERE...GROUPBYd;可以在GROUP BY语句后添加HAVING子句，并对聚集结果进行筛选。SELECTfirst_name,COUNT(*)cntFROMemployeesGROUPBYfirst_nameHAVINGcnt&gt;270ORDERBYcntDESC;并集操作（UNION和UNION ALL）UNION和UNION ALL都是将两个结果集合并为一个，但UNION ALL比UNION更快。UNION实际上是UNION DISTINCT，在进行表连接后会筛选掉重复的记录，而UNION ALL则是不管有没有重复记录，都直接返回合并后的记录。SELECT*FROMaUNIONALLSELECT*FROMb;NULL值NULL值的判断一般使用IS NULL或IS NOTNULL3. JOIN（连接）MySQL使用JOIN来连接多个表查询数据，主要使用的JOIN算法只有一种，那就是nested-loop join。nested-loop join算法实现的机制很简单，就是从驱动表中选取数据作为循环基础数据，然后以这些数据作为查询条件到下一个表中进行查询，如此往复。这个实现机制类似于foreach函数的遍历。因此带来的问题就是连接的表越多，函数嵌套的层数就越多，算法复杂度呈指数级增长。JOIN语句的含义是把两张（或者多张）表的属性通过它们的值组合在一起，一般会遇到如下3种连接：等值连接（[INNER]JOIN）左外连接（LEFT JOIN）右外连接（RIGHT JOIN）内连接（INNER JOIN）内连接可以被进一步分为等值连接、自然连接和交叉连接。较常用的是等值连接。外连接（OUT JOIN）外连接可依据连接表保留左表、右表或全部表的行而进一步分为左外连接、右外连接和全外连接。左外连接（LEFT JOIN、LEFT OUTER JOIN）左外连接也简称为左连接（LEFT JOIN），若A和B两表进行左外连接，那么结果表中将包含“左表”（即表A）的所有记录，即使那些记录在“右表”B中没有符合连接条件的匹配。这就意味着即使ON语句在表B中的匹配项是0条，连接操作也还是会返回一条记录，只不过这条记录中的来自于表B的每一列的值都为NULL。右外连接（RIGHT JOIN、RIGHTOUT JOIN）右外连接也简称右连接（RIGHT JOIN），它与左外连接完全类似，只不过是连接表的顺序相反而已。如果A表右连接B表，那么“右表”B中的每一行在连接表中至少会出现一次。如果B表的记录在“左表”A中未找到匹配行，则连接表中来源于A表中的列的值将设为NULL4. 子查询子查询是指查询语句里的SELECT语句。SELECT*FROMt1WHEREcolumn1=(SELECTcolumn1FROMt2);这个子查询是嵌套在外部查询中的，子查询嵌套的层次不宜过多，否则性能可能会很差。MySQL对于子查询的优化不佳，由于子查询一般可以改写成JOIN语句，因此一般建议使用JOIN的方式查询数据。3. 索引数据库索引，是数据库管理系统中一个排序的数据结构，用于协助快速查询、更新数据库表中的数据。目前MySQL主要支持的几种索引有：B树索引（B-tree）、散列索引（hash）、空间索引（R-tree）和全文索引（full-text）。由于索引是在存储引擎层实现的，所以不同的存储引擎的索引实现会有一些差异。逻辑上又可以分为：单列索引、复合索引（多列索引）、唯一（Unique）索引和非唯一（NonUnique）索引。如果索引键值的逻辑顺序与索引所服务的表中相应行的物理顺序相同，那么该索引被称为簇索引（cluster index），也称为聚集索引、聚簇索引，也就是说数据和索引（B+树）在一起，记录被真实地保存在索引的叶子中，簇索引也称为索引组织表，反之为非聚集索引。簇索引的优点如：将相关的的数据保持在一起，叶子节点内可保存相邻近的记录。因为索引和数据存储在一起，所以查找数据通常比非簇索引更快。由于主键是有序的，很显然，对于InnoDB表，最高效的存取方式是按主键存取唯一记录或进行小范围的主键扫描。簇索引的不足：簇索引对I/O密集型的负荷性能提升最佳，但如果数据是在内存中（访问次序不怎么重要），那么簇索引并没有明显益处。插入操作很依赖于插入的顺序，按primary key的顺序插入是最快的。更新簇索引列的成本比较高，因为InnoDB不得不将更新的行移动到新的位置。全表扫描的性能不佳，尤其是数据存储得不那么紧密时，或者因为页分裂（pagesplit）而导致物理存储不连续。二级索引的叶节点中存储了主键索引的值，如果主键采用的是较长的字符，那么索引可能会很大，且通过二级索引查找数据也需要进行两次索引查找。3.1 使用索引的场景及注意事项MySQL目前仅支持前导列筛选记录的条件应能组成复合索引最左边的部分，即按最左前缀的原则进行筛选。# 复合索引idx_a_b_cCREATEINDEXidx_a_b_cONtb1(a,b,c);# 只有使用如下条件才可能应用到这个复合索引WHEREa=?WHEREa=?ANDb=?WHEREa=?ANDb=?ANDc=?WHEREa=?ANDc=?#注意这个查询仅仅利用了MySQL索引的a列信息索引列上的范围查找在对某个条件进行范围查找时，如果这个列上有索引，且使用的是WHERE…BETWEEN…AND…、&gt;、&lt;等范围操作符时，那么可能就会用到索引范围查找。一般应该避免大范围的索引范围查找，如果索引范围查找的成本太高，那么数据库可能会选择全表扫描的方式。IN(…)并不属于范围查找的范畴。JOIN列在联合查询两个表时，比如查询语句为“SELECT a.col1,b.col2 FROMaJOIN b ON a.id=b.id”，其中id为主键，若a表是驱动表，那么数据库可能全表扫描a表，并用a表的每个id去探测b表的索引查找匹配的记录。WHERE子句WHERE子句的条件列是复合索引前面的索引列再加上紧跟的另一个列的范围查找。CREATEINDEXidx_a_b_c_dONtb1(a,b,c,d);# 只有使用如下条件才可能应用到这个复合索引。WHEREa=?ANDb=?ANDc&gt;10000;WHEREa=?ANDb=?ANDc=?ANDd&lt;10000;# 下面d&lt;100000这个筛选操作并不会走索引WHEREa=?ANDb=?ANDc&gt;10000ANDd&lt;100000;MySQL优化器MySQL优化器会做一些特殊优化，比如对于索引查找MAX（索引列），那么可以进行直接定位。​注意事项和建议WHERE条件中的索引列不能是表达式的一部分，MySQL也不支持函数索引。InnoDB的非主键索引存储的不是实际记录的指针，而是主键的值，所以主键最好是整型值，如自增ID，基于主键存取数据是最高效的，使用二级索引存取数据则需要进行两次索引查找。最好是按主键的顺序导入数据，如果导入大量随机id的数据，那么可能需要运行OPTIMIZE TABLE命令来优化表。索引应尽量是高选择性的，而且需要留意“基数（cardinality）”值，基数指的是一个列中不同值的个数，显然，最大基数意味着该列中的每个值都是唯一的，最小基数意味着该列中的所有值都是相同的。索引列的基数相对于表的行数较高时（也就是说重复值更少），索引的工作效果更好。使用更短的索引。可以考虑前缀索引，前缀索引仅索引前面一部分字符（值），但应确保所选择的前缀的长度可以保证大部分值是唯一的。索引太多时可能会浪费空间，且降低修改数据的速度。所以，不要创建过多的索引，也不要创建重复的索引。MySQL允许在同样的列上创建多个索引而不会提示报错，一些其他分支的版本有统计信息可以甄别出没有被使用的索引。而对于官方版本，你可能需要借助工具清理掉过多的重复索引。如果是唯一值的列，创建唯一索引会更佳，也可以确保不会出现重复数据。使用覆盖索引（covering index）也可以大大提高性能。所谓“覆盖索引”是指所有数据都可以从索引中得到，而不需要去读取物理记录。利用索引来排序。MySQL有两种方式可以产生有序的结果。一种是使用文件排序（filesort）来对记录集进行排序，另一种是扫描有序的索引。我们应尽量利用索引来排序。添加冗余索引，需要权衡。如果已有一个索引（columnA），那么一个新的索引（columnA，columnB）就是冗余索引，因为后面的索引包含了前面索引的所有信息。比如原来的索引是创建在一个整型列上的，要是再添加一个很长的字符列，那么索引会变得很大，从而影响性能。这种情况下，可能不得不选择添加新的复合索引，保留原来的索引，这样做的不利之处是增加了索引维护的开销，而且一个新的索引也需要占据内存空间。3.2 索引的错误用法以下是生产环境中常犯的一些错误，而且由于表结构不易调整，因此往往会导致严重的性能影响。创建了太多的索引或无效的索引。比如在WHERE条件的每个列上都建立单独的索引，当单个索引效率不高的时候，MySQL往往就会选择全表扫描，太多的索引可能会导致索引所占用的磁盘空间比实际数据还大得多。对于复合索引，如果不考虑ORDERBY、GROUP BY这样的一些操作，那么把最具选择性的列放在前面是合适的，复合索引主要用于优化WHERE查找。但如果是排序之类的操作，把最具选择性的列放在前面则不一定最有效，因为避免随机I/O和排序可能才是我们更值得考虑的。忽略了值的分布。某些值只有少量记录，查询对这些值的筛选执行就会很快，而某些值即使经过了索引筛选，满足条件的仍然还有大量的记录，这样索引效果就会很差。一般来说，数据表内值的分布应该尽量均匀，由于MySQL的统计信息不完善，数据分布不均匀很可能会产生很差的执行计划，导致严重的性能问题。InnoDB主键过长，导致二级索引过大。主键的选择，一般建议是整型。3.3 如何使用EXPLAIN工具使用EXPLAIN工具可以确认执行计划是否良好，查询是否走了合理的索引。使用EXPLAIN命令查看执行计划EXPLAINSELECT……EXPLAIN命令还有如下两种变体:EXPLAIN EXTENDEDSELECT……以上命令将执行计划“反编译”成SELECT语句，运行SHOW WARNINGS可得到被MySQL优化器优化后的查询语句。EXPLAIN PARTITIONS SELECT……以上命令用于分区表的EXPLAIN命令执行计划包含的信息及解读详细阐述EXPLAIN输出的各项内容：id：id包含一组数字，表示查询中执行SELECT子句或操作表的顺序。如果id相同，则执行顺序由上至下。如果是子查询，id的序号会递增，id值越大则优先级越高，越先被执行。如果id相同，则可以认为它们是一组，从上往下顺序执行。在所有组中，id值越大，优先级就越高，越先执行。select_typeselect_type表示查询中每个SELECT子句的类型（是简单还是复杂）。SIMPLE：查询中不包含子查询或UNION。查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY。在SELECT或WHERE列表中若包含了子查询，则该子查询被标记为SUBQUERY。在FROM列表中包含的子查询将被标记为DERIVED（衍生）。若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，则外层SELECT将被标记为DERIVED。从UNION表中获取结果的SELECT将被标记为UNION RESULT。typetype表示MySQL在表中找到所需行的方式，又称“访问类型”。下面类型，由上至下，由最差到最好。ALL：FullTable Scan，MySQL将遍历全表以找到匹配的行。index：FullIndex Scan，index与ALL区别为index类型只遍历索引树。range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询。ref：非唯一性索引扫描，将返回匹配某个单独值的所有行。常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找。eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。const、system：当MySQL对查询的某部分进行优化，并转换为一个常量时，可使用这些类型进行访问。NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引。possible_keyspossible_keys将指出MySQL能使用哪个索引在表中找到行，查询涉及的字段上若存在索引，则该索引将被列出，但不一定会被查询使用。keykey将显示MySQL在查询中实际使用到的索引，若没有使用索引，则显示为NULL。key_lenkey_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。注意，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得的，而不是通过表内检索得出的。refref表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。rowsrows表示MySQL根据表统计信息及索引选用的情况，估算地找到所需的记录所需要读取的行数。ExtraExtra包含不适合在其他列中显示但十分重要的额外信息。它可能包含如下4种信息。Using index。该值表示相应的SELECT操作中使用了覆盖索引。包含满足查询需要的所有数据的索引称为覆盖索引。Usingwhere。该值表示MySQL服务器在存储引擎收到记录后进行“后过滤”（Post-filter）。Using temporary。该值表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。Using filesort。Using filesort即文件排序。MySQL中将无法利用索引完成的排序操作称为“文件排序”。MySQL执行计划的局限EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。EXPLAIN不考虑各种Cache。EXPLAIN不能显示MySQL在执行查询时所做的优化工作。部分统计信息是估算的，并非精确值。MySQL 5.6之前EXPALIN只能解释SELECT操作，其他操作需要重写为SELECT后才能查看执行计划。如果FROM子句里有子查询，那么MySQL可能会执行这个子查询，如果有昂贵的子查询或使用了临时表的视图，那么EXPLAIN其实会有很大的开销。4. 优化索引的方法学生产环境中数据库出现性能问题，有80%的原因是索引策略导致的，表结构不易变动，而调整索引或SQL往往可以很快就能解决问题。有性能测量在应用程序中记录访问数据库的性能日志，这样就可以对整体的访问吞吐有一个很直观很全面的统计，我们应该优化对数据库操作最频繁、最耗资源的那些SQL，但由于性能统计框架的缺位，大部分中小公司更多地依赖于数据库自身的慢查询日志来定位耗时较长的SQL，由慢查询日志入手也是一个很好的出发点，但可能存在一些滞后，不能及时发现性能问题，MySQL的慢查询日志默认记录查询时间超过1s的查询。查看执行计划找到消耗资源最多的查询请求后，可以使用EXPLAIN工具查看其执行计划，检查是否走的是合适的索引。优化索引我们应该熟悉数据量、数据类型等信息及表之间的关系，按照自己的索引经验，调整或增加索引。测试验证如果是线上生产环境，那么请不要在线上环境进行测试验证，除非是非常紧急的情况。应该选择在开发环境中尽量使用和线上环境一样的数据规模，来进行验证测试。上线当确认优化达到了预期的效果后，就可以安排上线了。有一个错误的观念是定期重建索引，如果需要重建索引，首先要证明，重建索引真的能够大大改善性能，否则建议不要做这种费力又不讨好的事情，数据库索引本来就应该是“不好不坏”的状态，不要期望它始终以一种理想的状态在运行。5. ID主键建议主键是整型。如果表中包含一列能够确保唯一、非空（NOTNULL），以及能够用来定位一条记录的字段，就不要因为传统而觉得一定要加上一个自增ID做主键。主键也遵从索引的一些约定，注意联合主键的字段顺序。为主键选择更有意义的名称，如ID这个名称太过笼统，表达的信息可能不准确。自增ID主键自增列的默认起始值是1，默认可以按步长为1进行递增，自增列的增长将受两个MySQL全局参数的影响。auto_increment_offset：确定AUTO_INCREMENT列值的起点。auto_increment_increment：控制列值增加的间隔，即步长。InnoDB选择主键创建簇索引。如果没有主键，就会选取一个唯一非空的索引来替代；如果仍然找不到合适的列，那么将创建一个隐含的主键来创建簇索引。选取一个唯一非空的索引做主键可能不是我们所期待的，一般的解决办法是删除我们不期望的主键（唯一索引），创建一个非空的自增列，再增加这个唯一索引。自增ID可以插入指定的值自增ID还有一个特性，那就是如果插入0值或NULL值，InnoDB会认为没有设定值，然后帮你自增一个值。6.字符集和国际化支持字符集（character set）是一套符号和编码。校对规则（collation）是在字符集内用于比较字符的一套规则，即字符集的排序规则。对于字符集，MySQL能够做如下这些事情。使用多种字符集来存储字符串。使用多种校对规则来比较字符串。在同一台服务器、同一个数据库甚至在同一个表中，使用不同的字符集或校对规则来混合字符串。允许定义任何级别的字符集和校对规则。6.1 字符集设置字符集设置可以分为两类：一类是创建对象的默认值；字符集和校对规则有4个级别的默认设置：服务器级、数据库级、表级和连接级。更低级别的配置会继承更高级别的配置。另一类是控制server端和client端交互通信的配置。绝大部分MySQL客户端都不具备同时支持多种字符集的能力，每次都只能使用一种字符集。客户和服务器之间的字符集转换工作是由如下几个MySQL系统变量来控制的。character_set_server：MySQL Server默认字符集。character_set_database：数据库默认字符集。character_set_client：MySQL Server假定客户端发送的查询使用的字符集。character_set_connection：MySQL Server接收客户端发布的查询后，将其转换为character_set_connection变量指定的字符集。character_set_result：MySQL Server把结果集和错误信息转换为character_set_result指定的字符集，并发送给客户端。http://www.ppmy.cn/news/1541467.html相关文章挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计挑战性课程《信号处理系统》&amp;#xff08;原信号与系统数字信号处理&amp;#xff09;课程课程设计 
课程设计题目4&amp;#xff1a;图像处理 
课程设计基本要求 
基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能 
实际实现的功能 
基于DCT的图像压缩以及MSE的计算基于奇异值分…阅读更多...Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:48 +0000</pubDate>
    </item>
    <item>
      <title>挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计</title>
      <link>https://www.ppmy.cn/news/1541466.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计news/2025/11/4 0:21:47/挑战性课程《信号处理系统》（原信号与系统+数字信号处理）课程课程设计课程设计题目4：图像处理课程设计基本要求基于DCT的图像压缩另一种图像压缩算法并实现额外的两个功能实际实现的功能基于DCT的图像压缩以及MSE的计算基于奇异值分解的图像压缩以及MSE的计算图像的退化与复原Gaussian模糊及实现运动模糊及实现Gaussian噪声及实现约束最小二乘滤波及实现维纳滤波及实现Lucy-Richardson滤波及实现盲解卷积复原及实现传统图像处理功能图像均衡边缘检测模糊处理尺寸变化亮度变化特定区域操作模式识别方向实时人脸检测图像检索图像小波包变换音频与图像信号的转换GUI界面的设计与实现如需要源码，请私信联系http://www.ppmy.cn/news/1541466.html相关文章Apache StringUtils：专为Java字符串而生的工具类&amp;#xff08;String&amp;#xff09;在我们的日常工作中&amp;#xff0c;用得非常非常非常多。 
在我们的代码中经常需要对字符串判空&amp;#xff0c;截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。 
如果只用 String 类提供的那些方法…阅读更多...养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:47 +0000</pubDate>
    </item>
    <item>
      <title>Apache StringUtils：专为Java字符串而生的工具类</title>
      <link>https://www.ppmy.cn/news/1541465.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Apache StringUtils：专为Java字符串而生的工具类news/2025/11/4 0:21:46/（String）在我们的日常工作中，用得非常非常非常多。在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。如果只用 String 类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。现在有个好消息是：org.apache.commons.lang3包下的StringUtils工具类，给我们提供了非常丰富的选择。Maven 坐标：&lt;dependency&gt;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;version&gt;3.12.0&lt;/version&gt;
&lt;/dependency&gt;StringUtils 提供了非常多实用的方法，大概有下图的四页到五页，我只截了两页，实在是太多了。接下来，我们来拿一些常用的方法举例说明。字符串判空其实空字符串，不只是 null 一种，还有""，" "，"null"等等，多种情况。StringUtils 给我们提供了多个判空的静态方法，例如：String str1 = null;
String str2 = "";
String str3 = " ";
String str4 = "abc";
System.out.println(StringUtils.isEmpty(str1));
System.out.println(StringUtils.isEmpty(str2));
System.out.println(StringUtils.isEmpty(str3));
System.out.println(StringUtils.isEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotEmpty(str1));
System.out.println(StringUtils.isNotEmpty(str2));
System.out.println(StringUtils.isNotEmpty(str3));
System.out.println(StringUtils.isNotEmpty(str4));
System.out.println("=====");
System.out.println(StringUtils.isBlank(str1));
System.out.println(StringUtils.isBlank(str2));
System.out.println(StringUtils.isBlank(str3));
System.out.println(StringUtils.isBlank(str4));
System.out.println("=====");
System.out.println(StringUtils.isNotBlank(str1));
System.out.println(StringUtils.isNotBlank(str2));
System.out.println(StringUtils.isNotBlank(str3));
System.out.println(StringUtils.isNotBlank(str4));执行结果：true
true
false
false
=====
false
false
true
true
=====
true
true
true
false
=====
false
false
false
true示例中的：isEmpty、isNotEmpty、isBlank和isNotBlank，这 4 个判空方法你们可以根据实际情况使用。优先推荐使用isBlank和isNotBlank方法，因为它会把" "也考虑进去。分隔字符串分隔字符串是常见需求，如果直接使用 String 类的 split 方法，就可能会出现空指针异常。String str1 = null;
System.out.println(StringUtils.split(str1,","));
System.out.println(str1.split(","));执行结果：null
Exception in thread "main" java.lang.NullPointerException
\tat com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)使用 StringUtils 的 split 方法会返回 null，而使用 String 的 split 方法会报指针异常。判断是否纯数字给定一个字符串，判断它是否为纯数字，可以使用isNumeric方法。例如：String str1 = "123";
String str2 = "123q";
String str3 = "0.33";
System.out.println(StringUtils.isNumeric(str1));
System.out.println(StringUtils.isNumeric(str2));
System.out.println(StringUtils.isNumeric(str3));执行结果：true
false
false将集合拼接成字符串有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用join方法。例如：List&lt;String&gt; list = Lists.newArrayList("a", "b", "c");
List&lt;Integer&gt; list2 = Lists.newArrayList(1, 2, 3);
System.out.println(StringUtils.join(list, ","));
System.out.println(StringUtils.join(list2, " "));执行结果：a,b,c
1 2 3其他方法这里再列举一些，其他的方法可以自己去研究一下。trim(String str)：去除字符串首尾的空白字符。trimToEmpty(String str)：去除字符串首尾的空白字符，如果字符串为 null，则返回空字符串。trimToNull(String str)：去除字符串首尾的空白字符，如果结果为空字符串，则返回 null。equals(String str1, String str2)：比较两个字符串是否相等。equalsIgnoreCase(String str1, String str2)：比较两个字符串是否相等，忽略大小写。startsWith(String str, String prefix)：检查字符串是否以指定的前缀开头。endsWith(String str, String suffix)：检查字符串是否以指定的后缀结尾。contains(String str, CharSequence seq)：检查字符串是否包含指定的字符序列。indexOf(String str, CharSequence seq)：返回指定字符序列在字符串中首次出现的索引，如果没有找到，则返回 -1。lastIndexOf(String str, CharSequence seq)：返回指定字符序列在字符串中最后一次出现的索引，如果没有找到，则返回 -1。substring(String str, int start, int end)：截取字符串中指定范围的子串。replace(String str, String searchString, String replacement)：替换字符串中所有出现的搜索字符串为指定的替换字符串。replaceAll(String str, String regex, String replacement)：使用正则表达式替换字符串中所有匹配的部分。join(Iterable&lt;?&gt; iterable, String separator)：使用指定的分隔符将可迭代对象中的元素连接为一个字符串。split(String str, String separator)：使用指定的分隔符将字符串分割为一个字符串数组。capitalize(String str)：将字符串的第一个字符转换为大写。uncapitalize(String str)：将字符串的第一个字符转换为小写。http://www.ppmy.cn/news/1541465.html相关文章养老院网站毕设计算机毕业设计基于SpringBootSSM框架目录 
1.概述 
2.设计思路 
2.1 开发背景 
2.2 项目需求 
3. 需求分析 
3.1‌用户需求分析‌ 
3.2‌功能需求‌ 
3.3非功能需求‌ 
4. 数据库设计 1.概述 
本文旨在设计并实现一个功能全面、用户友好的养老院网站&amp;#xff0c;以提供养老院管理、老人信息管理、服务预约与跟踪等…阅读更多...群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:46 +0000</pubDate>
    </item>
    <item>
      <title>养老院网站毕设计算机毕业设计基于SpringBootSSM框架</title>
      <link>https://www.ppmy.cn/news/1541464.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维养老院网站毕设计算机毕业设计基于SpringBootSSM框架news/2025/11/4 0:21:45/目录1.概述2.设计思路2.1 开发背景2.2 项目需求3. 需求分析3.1‌用户需求分析‌3.2‌功能需求‌3.3非功能需求‌4. 数据库设计1.概述本文旨在设计并实现一个功能全面、用户友好的养老院网站，以提供养老院管理、老人信息管理、服务预约与跟踪等全方位服务。借助SpringBoot与SSM（Spring、SpringMVC、MyBatis）框架的先进技术，我们构建了一个高效、可扩展且易于维护的养老院管理平台。在毕业设计过程中，我们深入分析了养老院的实际需求，明确了网站的核心功能模块，包括用户管理、老人信息管理、服务预约管理、员工管理以及数据统计与分析等。通过合理的数据库设计与后端逻辑实现，我们确保了网站数据的安全性与一致性。同时，我们注重用户体验，设计了简洁明了的页面布局与交互方式，使得用户能够轻松上手并享受便捷的服务。前端页面采用了响应式设计，能够适应不同设备的屏幕尺寸与分辨率，提供了良好的跨平台体验。在系统实现方面，我们充分利用了SpringBoot框架的优势，实现了快速的系统开发与部署。SSM框架的引入，进一步提升了系统的性能与稳定性，使得系统能够更好地应对高并发访问与大数据量处理的需求。最后，我们对网站进行了全面的功能测试与性能测试，确保了所有功能的正常运行以及系统在高负载情况下的稳定运行。本文详细阐述了养老院网站的设计思路、实现过程以及测试结果，充分展示了基于SpringBoot与SSM框架的计算机毕业设计的成果与创新点。2.设计思路‌技术选型‌：采用Java作为开发语言，后端框架选用Spring Boot（SSM框架升级版），前端使用Vue+ElementUI，数据库选择MySQL，开发工具为IDEA或Eclipse。‌功能模块设计‌：系统包含管理员、护工、用户三个角色，每个角色拥有不同的权限和功能。管理员可以管理用户信息、护工信息、养老机构信息等；护工可以查看老人健康档案、护理项目等；用户可以查看护工信息、进行护工聘请操作等。‌设计理念‌：以老年人为中心，注重人性化、无障碍化设计，为老年人提供一个安全、舒适、健康的生活环境。同时，系统也注重智能化设计，以提高工作效率和服务质量‌。‌2.1 开发背景‌随着社会老龄化的加剧，养老院作为老年人生活的重要场所，其管理和服务质量日益受到关注。传统的养老院管理方式往往依赖于人工和纸质记录，不仅效率低下，而且容易出现信息不准确、不及时等问题。因此，开发一个功能全面、用户友好的养老院网站，以提升养老院的管理效率和服务质量，显得尤为重要。2.2项目需求‌老龄化社会的需求‌：随着老龄化社会的到来，养老院的数量和规模不断扩大，对高效、便捷的管理方式的需求也日益增长。网站作为一种现代化的信息交流平台，能够为养老院提供全面的管理支持。‌信息化管理的趋势‌：信息化管理已经成为各行各业的发展趋势，养老院也不例外。通过开发养老院网站，可以实现信息的实时更新和共享，提高管理效率，减少人为错误。‌提升服务质量的需求‌：养老院网站不仅可以为管理人员提供便捷的管理工具，还可以为老年人及其家属提供更加便捷、贴心的服务。通过网站，他们可以随时了解养老院的最新动态、老人的生活状况以及健康状况等信息。综上所述，养老院网站的开发是顺应老龄化社会需求、信息化管理趋势以及提升服务质量需求的必然产物。它的出现将为养老院的管理和服务带来全新的变革，为老年人提供更加优质、便捷的生活体验。3. 需求分析‌   随着人口老龄化问题的日益严峻，养老院作为老年人晚年生活的重要场所，其管理和服务质量受到广泛关注。传统的养老院管理方式存在效率低下、信息不透明等问题，难以满足现代养老服务的需求。因此，开发一个功能全面、用户友好的养老院网站，以提升管理效率和服务质量，成为当前的重要任务。3.1‌用户需求分析‌‌1.养老院管理者‌：需要对养老院进行全面监控，包括财务管理、人员管理、设施管理等。需要一个高效的信息管理系统，以便快速准确地获取和处理各类信息。需要实现信息的实时更新和共享，确保各部门之间协同工作。‌2.护理人员‌：需要快速获取老人的健康数据、护理计划和紧急联系信息。需要一个便捷的工作平台，以便记录护理过程和提交工作报告。‌3.老人及其家属‌：需要及时了解老人的日常生活和健康状况。需要一个在线沟通平台，以便与养老院管理人员和护理人员进行交流。需要在线缴纳费用、预约服务等便捷功能。3.2‌功能需求‌基于上述用户需求，养老院网站应具备以下功能：‌1.信息管理模块‌：包括老人信息、员工信息、访客信息等基础数据的录入、查询、修改和删除功能。支持信息的实时更新和共享，确保数据的准确性和时效性。‌2.服务管理模块‌：提供日常服务预约、服务评价等功能，方便老人及其家属在线申请服务并进行反馈。支持护理计划的制定、执行和跟踪，确保老人得到及时、专业的护理服务。‌3.健康管理模块‌：记录老人的健康数据，如体检报告、用药记录等。提供健康监测和用药提醒功能，确保老人的健康状况得到及时关注和处理。‌4.财务管理模块‌：处理养老院的财务收支、账单管理等事务。支持在线缴费功能，方便老人及其家属缴纳相关费用。‌5.互动平台模块‌：设立在线咨询、留言板等功能，方便老年人和家属与院方进行沟通交流。提供活动通知、新闻资讯等功能，增强网站的互动性和吸引力。功能图展示3.3非功能需求‌‌安全性‌：确保网站的数据安全和用户隐私保护，采取数据加密、访问控制等措施。‌易用性‌：界面简洁明了，操作简单易懂，符合老年人的使用习惯。‌可扩展性‌：系统架构灵活，便于后续功能的扩展和升级。‌可维护性‌：代码结构清晰，便于后期的维护和故障排查。通过以上需求分析，可以为养老院网站的开发提供明确的方向和目标，确保系统能够满足实际需求并具备良好的用户体验。4. 数据库设计‌     数据库设计就是用来存放和管理养老院所有相关信息的“大仓库”。这个“仓库”里有很多“房间”，每个“房间”都用来存放不同类型的信息，比如老人的信息、员工的信息、访客的信息，还有服务预约、健康数据、财务收支等等。在数据库里，每种信息都有固定的格式和存放方式，就像每个“房间”都有固定的布局和家具摆放一样。这样，我们就可以很方便地找到、添加、修改或者删除这些信息了。数据库还有一个很重要的作用，就是保证信息的安全和准确。它就像是一个有严格门禁的“仓库”，只有有权限的人才能进去，而且里面的信息都是经过仔细核对和整理的，不会出现错误或者混乱的情况。所以，养老院网站毕业设计的数据库就是这个网站能够正常运行的“基石”，它让网站能够方便地管理各种信息，提供优质的服务，同时也保证了信息的安全和准确。http://www.ppmy.cn/news/1541464.html相关文章群晖通过 Docker 安装 MySQL1. 打开 Docker 应用&amp;#xff0c;并在注册表搜索 MySQL 2. 下载 MySQL 镜像&amp;#xff0c;并选择版本 
3. 在 Docker 文件夹中创建 MySQL&amp;#xff0c;并创建子文件夹 4. 设置权限 5. 选择 MySQL 映像运行&amp;#xff0c;创建容器 6. 配置 MySQL 容器 
6.1 使用高权限执行容器 6.2 启…阅读更多...旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:46 +0000</pubDate>
    </item>
    <item>
      <title>群晖通过 Docker 安装 MySQL</title>
      <link>https://www.ppmy.cn/news/1541463.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维群晖通过 Docker 安装 MySQLnews/2025/11/4 0:21:44/1. 打开 Docker 应用，并在注册表搜索 MySQL2. 下载 MySQL 镜像，并选择版本3. 在 Docker 文件夹中创建 MySQL，并创建子文件夹4. 设置权限5. 选择 MySQL 映像运行，创建容器6. 配置 MySQL 容器6.1 使用高权限执行容器6.2 启用自动重新启动6.3 端口设置6.4 创建容器时挂载数据卷挂载 /var/lib/mysql 到宿主机的文件夹（例如 /docker/mysql/data），用于存储数据库数据6.5 设置环境变量MYSQL_ROOT_PASSWORD：设置 root 用户的密码。MYSQL_DATABASE：可以指定一个初始数据库名称（可选）。MYSQL_USER 和 MYSQL_PASSWORD：创建一个普通用户及其密码（可选）。7. 验证7.1 启用 SSH 功能7.2 通过终端输入命令验证sudo docker exec -it mysql-1 mysql -u root -phttp://www.ppmy.cn/news/1541463.html相关文章旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架目录 
1.摘要 
2 引言 
2.1 开发目标 
2.2 项目内容 
2.3 项目背景与目的 
3. 技术选型 
3.1 JAVA 简介 
3.2 MySQL 介绍 
‌4. 功能描述与创新点 
4.1 功能描述 
‌4.2创新点设计 
4.3 功能图展示 
5. 数据库设计 
6. 项目任务与要求 1.摘要 
本文旨在设计并实现一个功能全面、…阅读更多...学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:44 +0000</pubDate>
    </item>
    <item>
      <title>旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架</title>
      <link>https://www.ppmy.cn/news/1541462.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维旅游攻略网站毕业设计计算机毕设基于SpringBootSSM框架news/2025/11/4 0:21:44/目录1.摘要2 引言2.1 开发目标2.2 项目内容2.3 项目背景与目的3. 技术选型3.1 JAVA 简介3.2 MySQL 介绍‌4. 功能描述与创新点4.1 功能描述‌4.2创新点设计4.3 功能图展示5. 数据库设计6. 项目任务与要求1.摘要本文旨在设计并实现一个功能全面、用户友好的旅游攻略网站，以提供游客详尽、准确的旅游信息服务，并致力于提升游客的旅游体验。通过深入调研现有旅游网站的功能与用户体验，我们明确了游客的需求与痛点，并据此制定了网站的功能需求与设计要求。在毕业设计过程中，我们重点关注了网站的整体架构、页面布局、交互设计以及视觉风格，以确保用户能够轻松使用并享受愉悦的浏览体验。同时，我们实现了用户登录/注册、景点介绍、行程规划、评论与评分以及搜索与筛选等核心功能，以满足游客在旅游过程中的多样化需求。为确保网站数据的安全性与一致性，我们设计了合理的数据库结构，并实现了后端与数据库的交互逻辑。此外，我们还对网站进行了全面的功能测试与性能测试，以确保其在高并发情况下仍能稳定运行。最终，我们成功构建了一个集旅游信息、行程规划、用户互动于一体的旅游攻略网站，为游客提供了便捷、高效的旅游服务。本文详细阐述了网站的设计思路、实现过程以及测试结果，充分展示了毕业设计的成果与创新点2 引言‌      随着旅游业的蓬勃发展，人们对于旅游攻略的需求日益增加。一份好的旅游攻略不仅能帮助游客更好地规划行程，提升旅游体验，还能促进旅游目的地的文化传播和经济发展。因此，本次毕业设计旨在创作一份针对特定旅游目的地或主题的详细攻略，以满足不同游客的需求。2.1 开发目标‌实用性‌：提供全面、准确的旅游信息，包括交通、住宿、餐饮、景点介绍等。‌创新性‌：在攻略中融入新颖的元素，如互动地图、虚拟现实体验、个性化推荐等。‌文化传播‌：介绍旅游目的地的历史、文化、风俗等，促进文化交流。‌用户体验‌：注重攻略的易读性、易用性和美观性，提升用户满意度。‌2.2 项目内容‌目的地选择‌：选择一个具有代表性和吸引力的旅游目的地，如历史文化名城、自然风光区、现代都市等。‌信息收集‌：通过实地考察、网络搜索、访谈当地居民等方式，收集关于目的地的详细旅游信息。2.3项目背景与目的随着互联网的快速发展，旅游业与互联网的融合日益加深，旅游网站成为游客获取旅游信息、规划行程的重要平台。本毕业设计项目旨在设计一个功能完善、用户友好的旅游网站，为游客提供全面、准确的旅游信息服务，提升游客的旅游体验，同时促进旅游目的地的文化传播和经济发展。通过本次毕业设计，不仅能够提升学生在旅游规划、信息整合、设计创新等方面的能力，还能为实际旅游市场提供有价值的旅游攻略产品。同时，这也是一次文化传播的尝试，有助于增进人们对不同地域文化的了解和尊重。3. 技术选型‌前端‌：HTML, CSS, JavaScript, Bootstrap。‌后端‌：Spring Framework, Spring MVC, MyBatis。‌数据库‌：MySQL。‌开发工具‌：IDEA或Eclipse，Maven或Gradle。3.1 JAVA 简介Java是一门面向对象的编程语言，具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点‌。Java最初由Sun Microsystems公司于1990年代初开发，名为Oak，目标应用于家用电器等小型系统，后因市场需求不高而被放弃。随着互联网的发展，Sun公司看到Oak在互联网上的应用前景，于1995年5月以Java的名称正式发布，并提出“Write once, Run anywhere”（一次编译，到处运行）的口号。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等，广泛应用于个人PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网等领域‌。3.2 MySQL 介绍MySQL是一个流行的关系型数据库管理系统，广泛应用于各种网站和应用中‌。‌开发背景‌：MySQL最初由瑞典MySQL AB公司开发，后被Sun公司收购，最终成为Oracle旗下产品。‌   语言与版本‌：MySQL使用SQL语言进行数据库操作，提供了社区版和商业版两种版本选择，满足不同用户需求。‌   特点与优势‌：MySQL具有体积小、速度快、成本低等特点，支持多线程和多种操作系统，为多种编程语言提供API。其优化的SQL查询算法有效提高了查询速度，且开放源代码，自主性强。‌应用场景‌：由于其诸多优势，MySQL成为中小型及大型网站开发的首选数据库。‌4. 功能描述与创新点4.1 功能描述‌行程规划‌：根据不同游客的需求（如时间、预算、兴趣等），设计多条旅游路线。‌景点介绍‌：详细描述每个景点的历史、特色、开放时间、门票价格等。‌交通指南‌：提供到达目的地的交通方式，以及目的地内部的交通网络。‌住宿餐饮‌：推荐不同档次的酒店、民宿，以及当地特色餐饮。‌实用信息‌：包括天气、货币、语言、安全提示等。‌4.2创新点设计‌   互动地图‌：设计一份可交互的地图，游客可以通过点击了解各个地点的详细信息。‌虚拟现实体验‌：利用VR技术，让游客在出发前就能预览目的地的风光。‌个性化推荐‌：根据游客的偏好和历史行为，智能推荐适合的旅游路线和景点。4.3 功能图展示5. 数据库设计‌      根据旅游攻略网站的功能需求，我们可以确定以下主要的数据实体：用户信息：包括用户ID、用户名、密码、邮箱、注册时间等。景点信息：包括景点ID、景点名称、所在城市、景点类型、景点介绍、图片链接等。行程信息：包括行程ID、用户ID、景点ID、行程日期、行程状态等。评论信息：包括评论ID、用户ID、景点ID、评论内容、评论时间、评分等。‌1数据库概念结构设计‌根据需求分析的结果，我们可以设计出数据库的概念结构。这通常使用ER图（实体-关系图）来表示。在ER图中，我们可以定义各个实体及其属性，以及实体之间的关系。例如，用户实体和景点实体之间可以通过行程实体建立联系，表示用户访问了哪些景点。同时，用户实体和景点实体之间还可以通过评论实体建立联系，表示用户对景点的评价和评论。‌2数据库逻辑结构设计‌在概念结构设计的基础上，我们可以进一步进行数据库的逻辑结构设计。这包括定义数据库中的表结构、字段类型、字段长度、索引等。例如，用户表可以定义如下字段：用户ID（主键）、用户名、密码、邮箱、注册时间等。景点表可以定义如下字段：景点ID（主键）、景点名称、所在城市、景点类型、景点介绍、图片链接等。同时，我们还需要考虑表之间的关系，如外键约束等。例如，行程表中的用户ID和景点ID可以作为外键，分别引用用户表和景点表中的主键。‌3数据库物理结构设计‌在逻辑结构设计的基础上，我们可以进行数据库的物理结构设计。这包括选择合适的数据库管理系统（如MySQL、Oracle等）、定义存储过程、触发器、视图等数据库对象。同时，我们还需要考虑数据库的性能优化，如索引的创建、查询语句的优化等。‌4数据库实施与维护‌在数据库设计完成后，我们可以进行数据库的实施工作。这包括创建数据库、表、索引等对象，并导入初始数据。同时，我们还需要制定数据库的维护计划，包括定期备份数据、更新索引、检查数据库性能等。6.项目任务与要求1需求分析‌：调研现有旅游网站的功能与用户体验，分析游客的需求与痛点。确定网站的目标用户群体，如年轻游客、家庭游客、背包客等。制定网站的功能需求与设计要求。‌2网站设计‌：设计网站的整体架构与页面布局，确保用户友好与易用性。制作网站的交互原型，包括首页、景点介绍页、行程规划页、用户登录/注册页等。设计网站的视觉风格，包括色彩搭配、图标设计、图片选择等。‌3功能实现‌：实现用户登录/注册功能，包括用户名、密码验证等。实现景点介绍功能，包括文字描述、图片展示、视频介绍等。实现行程规划功能，允许用户自定义旅游路线，并保存与分享。实现用户评论与评分功能，允许用户对景点进行评论与打分。实现搜索与筛选功能，允许用户根据关键词、地点、时间等条件搜索景点。‌4后端与数据库设计‌：设计网站的后端架构，包括服务器选择、编程语言选择等。设计数据库结构，存储用户信息、景点信息、评论信息等。实现后端与数据库的交互逻辑，确保数据的安全性与一致性。‌5测试与优化‌：对网站进行功能测试，确保所有功能正常运行。对网站进行性能测试，确保在高并发情况下仍能稳定运行。根据用户反馈与测试结果，对网站进行优化与改进。http://www.ppmy.cn/news/1541462.html相关文章学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)四、桥协议数据单元(BPDU) 
1、BPDU基本概念 
桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文&amp;#xff0c;直接封装在二层协议&amp;#xff0c;是传输载体。是STP能够正常工作的根本。 
BPDU主要由 4 部分组成&amp;#xff1a; 
(1)根桥ID  
(2)发送者到根桥的开…阅读更多...【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:44 +0000</pubDate>
    </item>
    <item>
      <title>学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)</title>
      <link>https://www.ppmy.cn/news/1541461.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维学习笔记——交换——STP（生成树）桥协议数据单元(BPDU)news/2025/11/4 0:21:43/四、桥协议数据单元(BPDU)1、BPDU基本概念桥协议数据单元(Bridege Protocol Data Unit,BPDU)BPDU是STP的协议报文，直接封装在二层协议，是传输载体。是STP能够正常工作的根本。BPDU主要由 4 部分组成：(1)根桥ID(2)发送者到根桥的开销RPC (root-path-cost)(3) 发送者桥 ID(4) 发送者桥端口(端口优先级128 + 端口id 如1，2，3)四部分只有根桥id不变，其余3部分会变化，第2部分计算入端口开销，采用累加，BPDU hello报文间隔2秒，最大age时间20秒，即若20秒没有收到根桥发来的BPDU，则认为根桥挂了，将重新进行根桥选举。特点：1)根桥每隔2s发送一次BPDU报文，用于交换机(或网桥)之间，交换网桥ID,根路径成本等最新的拓扑信息。2)BPDU利用了一个STP组播传输方式，组播地址(01-80-c2-00-00-00)作为它的一个目的地址，使之能到达相邻的并处于STP侦听状态的交换机。对于STP而言，最重要的工作就是在交换网络中计算出一个无环拓扑。在拓扑计算的过程中，一个非常重要的内容就是配置BPDU的比较。在配置BPDU中，有四个字段非常关键，它们是“根桥ID”、“根路径开销”、“网桥ID” 、“接口ID”，这四个字段便是交换机进行配置BPDU比较的关键内容。STP按照如下顺序选择最优的配置BPDU：1.最小的根桥ID。  主要用于在网络中选举根桥。2.最小的RPC。     主要用于选举根接口及指定接口。3.最小的网桥ID。  主要用于选举根接口及指定接口。4.最小的接口ID。  主要用于选举根接口及指定接口。2、BPDU报文格式在一个交换网络中，STP能够正常工作的基本前提是BPDU的正常交互。网桥之间通过交互配置BPDU来进行根桥的选举以及端口角色的确定。(配置BPDU的格式如下右图)STP的BPDU有两种类型：1)配置BPDU(Configuration BPDU)BPDU报文格式就是指的配置BPDU。2)TCN BPDU(Topology Change Notification BPDU)。(1) 配置BPDU报文格式字段描述Protocol Identifier(协议ID)生成树协议ID，对STP而言，该字段的值总是为0。Protocol version Identifier(协议版本号,PVID)用于描述当前使用的协议版本号：STP(802.1D)传统生成树,值为0;RSTP(802.1W)快速生成树,值为2；MSTP(802.1S)多生成树,值为3;BPDU Type(BPDU类型)描述当前BPDU消息类型：配置BPDU类型(0x00)，用于建立、维护STP拓扑；TCN BPDU类型(0x80)，传达拓扑变更消息；RSTP/MSTP BPDU类型(0x02)；BPDU Flags(BPDU标记域)由8位组成，只使用最高位(第一个bit)和最低位(最后一个bit)，其余6位保留。最低位=TC(Topology Change，拓扑变化)标志，最高位=TCA(Topology Change Acknowledgement，拓扑变化确认)标志Root Identifier(根桥ID)根网桥的桥ID，由2字节的桥优先级+6字节的MAC地址组成。Root Path Cost(根路径开销)根路径开销，描述发送该BPDU报文的端口累计到根桥的开销。Bridge Identifier指定桥ID，本交换机的BID。描述该BPDU的桥ID，由2字节的桥优先级+6字节的MAC地址组成。Port Identifier指定端口ID，即“发送端口ID”。描述由优先级+端口号组成。Message Age(消息生存时间)该BPDU报文的生存时间。即端口保存BPDU的最长时间，过期后将删除，要在这个时间内转发才有效，如果配置BPDU是直接来自根桥的，则Message Age为0，如果是其他桥转发的，则配置BPDU报文经过一个桥，Message Age增加1。MAX age(最大生存时间)BPDU消息的最大生存时间(即老化时间)。默认20sHello Time(Hello消息定时器)发送两个相邻BPDU的时间间隔。默认2s根桥通过不断发送STP维持自己的地位，Hello time 是发送的间隔时间Forward Delay(转发延时)最大延迟时间，默认15s。(端口状态迁移的延迟时间)端口从listening -&gt; learning 或 learning -&gt; forwarding 的转态需要时间。其中通过根桥ID、路径开销、指定桥ID、指定端口ID、Message Age、Max Age、Hello Time和Forward Delay信息来保证设备完成生成树的计算过程。(2) TCN BPDU报文格式TCN BPDU和配置BPDU在结构上基本相同，也是由源/目的MAC地址、L/T位、逻辑链路头和BPDU数据组成。TCN BPDU的BPDU数据组成非常简单，只包含三部分信息：协议类型：字段和配置BPDU相同协议版本号：字段和配置BPDU相同BPDU类型：字段的值为0x80，表示该BPDU为TCN BPDU。TCN BPDU有两个产生条件：1)网桥上有端口转变为Forwarding状态，且该网桥至少包含一个指定端口。2)网桥上有端口从Forwarding状态或Learning状态转变为Blocking状态。当上述两个条件之一满足时，说明网络拓扑发生了变化，网桥需要使用TCN BPDU通知根桥。根桥可以通过将配置BPDU中对应标志位置位来通知所有网桥网络拓扑发生了变化，需要使用较短的MAC地址老化时间，保证拓扑的快速收敛。(3)BPDU的用途两种BPDU各有各的用途。BPDU载荷被直接封装在以太网数据帧中，数据帧的目的MAC地址是组播MAC地址：0180-C200-0000。1)配置BPDU是根桥发送给各个桥的报文；2)TCN BPDU是当网络拓扑中的桥发现网络拓扑发生变化时，向根桥发送的报文。3、BPDU两种报文类型详情STP的BPDU有两种类型：1)配置BPDU(Configuration BPDU)。用于构建、维护STP树。在STP的初始化过程中，每台交换机都会产生并发送配置 BPDU。在STP树形成后的稳定期，只有根桥才会周期性地发送配置BPDU；相应的，非根桥会从自己的根端口收到配置BPDU,并更新自己的配置BPDU，再从指定端口发送出去。这个过程看起来像根桥发出的配置BPDU逐跳的经过了其它交换机。2)拓扑变化通知BPDU(Topology Change Notification BPDU)。简称TCN BPDU，告知根桥拓扑变化了。是非根桥通过根端口向根桥发送的。当非根桥检测到拓扑变化后，就会生成一个描述拓扑变化的TCN BPDU ，并从自己的根端口发送出去。(1)配置BPDU配置BPDU用于生成树计算,通常由根网桥以周期性间隔发出，包括STP参数，用于进行各种选举。配置BPDU包含了桥ID、路径开销、端口ID、计时器等参数。STP协议通过在交换机之间传递配置BPDU来选举根交换机，以及确定每个交换机端口的角色和状态。在初始化过程中，每个桥都主动发送配置BPDU。在网络拓扑稳定以后，只有根桥主动发送配置BPDU，其他交换机在收到上游传来的配置BPDU后，才会发送自己的配置BPDU。配置BPDU是STP进行拓扑计算的关键。在交换网络的初始化过程中，每台交换机都从自己激活了STP的接口向外发送配置BPDU。当STP收敛完成后，只有根桥才会周期性的发送配置BPDU(缺省时，以2s为周期发送配置BPDU，可以在设备的系统视图下使用stp timer hello命令修改发送周期)，而非根桥则会在自己的根接口上收到上游发送过来的配置BPDU，并立即被触发而产生自己的配置BPDU，然后从自己的指定接口发送出去。这一过程看起来就像是根桥发出的配置BPDU逐跳地“经过”了其他的交换机。(2)拓扑变更通告(TCN BPDU)拓扑变更通告(Topology Change Notification BPDU，TCN BPDU)用于通告网络拓扑的变化,这种BPDU是当交换机检测到拓扑发生变更时所产生TCN BPDU。是指下游交换机感知到拓扑发生变化时向上游发送的拓扑变化通知。TCN BPDU只在网络拓扑发生变更时才会被触发。TCN BPDU的格式非常简单，只有“协议ID”、"协议版本ID"以及"BPDU类型"三个字段，并且“BPDU”字段的值为0x80。TCN BPDU用于在网络拓扑发成变化时向根桥通知变化的发生。对于STP而言，当拓扑发生变更时，远离变更点的交换机无法直接感知到变化的发生，此时它们的MAC地址表项还是老旧的，如果依然通过这些MAC地址表项来指导数据转发，便有可能出现问题。因此STP需要一种机制，用于在网络中发生拓扑变更时促使全网的交换机尽快老化自己的MAC地址表项，以适应新的网络拓扑。当拓扑稳定时，网路中只会出现配置BPDU，而当拓扑发生变更时，STP会使用TCN BPDU，以及两种特殊的配置BPDU。TCN示例：1.当拓扑发生变化时，交换机首先会发送一个TCN BPDU来通告根桥。2.根桥会首先回复一个TCA，表明我已经收到了你发送的TCN通告。3.ROOT根桥向全网泛洪TC=1的配置BPDU，持续35秒(20+15 maxage+forwarddelay)4.交换机在收到TC=1的这35S内,所有的交换机的老化时间保持为15秒,直到收到tc=0的配置BPDU后,重新将mac老化时间修改为300。T点接口发生变更后，下游设备会不间断地向上游设备发送TCN BPDU报文直到根桥设备。上游设备收到下游设备发来的TCN BPDU报文后，只有指定端口处理TCN BPDU报文。其它端口也有可能收到TCN BPDU报文，但不会处理。上游设备会把配置BPDU报文中的Flags的TCA位置1，然后发送给下游设备，告知下游设备停止发送TCN BPDU报文。上游设备复制一份TCN BPDU报文，向根桥方向发送。重复步骤1、2、3、4，直到根桥收到TCN BPDU报文。根桥把配置BPDU报文中Flags的TC位和TCA位同时置1后发送，TC位置1是为了通知下游设备直接删除MAC地址表项，TCA位置1是为了通知下游设备停止发送TCN BPDU报文。说明：TCN BPDU报文主要用来向上游设备乃至根桥通知拓扑变化。置位的TCA标记的配置BPDU报文主要是上游设备用来告知下游设备已经知道拓扑变化，通知下游设备停止发送TCN BPDU报文。置位的TC标记的配置BPDU报文主要是上游设备用来告知下游设备拓扑发生变化，请下游设备直接删除MAC地址表项，从而达到快速收敛的目的。4、STP的时间参数在STP的计算过程中，BPDU的时间有三种：Hello Time、Max Age、Forward Delay。(1)Hello Time( Hello 时间)STP交换机发送配置BPDU的时间间隔，默认是2秒。如果要修改时间参数，那么必须在根桥上修改才有效。用于设备检测链路是否存在故障。Hello时间控制了发送配置BPDU的时间间隔，默认2秒。这是根交换机生成BPDU并向非根交换机发送的间隔。生成树协议每隔Hello Time时间会发送BPDU，以确认链路是否存在故障。如果设备在超时时间(超时时间＝超时时间因子×3×Hello Time)内没有收到BPDU，则会由于消息超时而重新计算生成树。非根交换机接收到根交换机发送来的BPDU，再从除接收端口以外的其他端口转发出去，如果在2-20秒里面由于网络故障没有新的BPDU从根交换机发送过来，非根交换机将停止向外发送从根交换机接收到的BPDU。如果这种情况持续20秒，也就是最大存活期，非根交换机就使原储存的BPDU无效，并开始寻找新的根端口。所谓最大存活期就是非根交换机丢弃BPDU前用来备份储存它的时间。(2)Max Age(最大生存时间)BPDU 的最大生存时间，也称为BPDU的老化时间，Max Age的值由根桥指定，默认值是20秒。如果端口在20秒内收到BPDU，最大生存时间会重新计时；如果端口一直没收到 BPDU ，那么BPDU将会老化，设备会重新在端口上选择最优BPDU，也就是重新进行根接口的选举。用于判断BPDU在设备内的保存时间是否“过时”，设备会将过时的BPDU丢弃。缺省情况下Max Age时间为20秒。在MSTP的CIST上，设备根据Max Age时间来确定端口收到的BPDU是否超时。如果端口收到的BPDU超时，则需要对该MSTI重新计算。Max Age时间对MSTP的MSTI无效。STP每隔一个Hello Time发送一个BPDU，并且引入Keepalive机制。Hello包的发送可以避免最大失效定时器溢出。如果最大失效定时器溢出，通常表明有连接错误发生。此时，STP会进入Listening状态。STP要从连接错误中恢复过来，一般需要50秒的时间。其中BPDU最长的失效时间20秒；Listening状态持续15秒；Learning状态持续15秒。3、转发延时是交换机在侦听状态到学习状态所花的时间，默认是15秒。(3)Forward Delay(转发延迟)接口从侦听状态进入学习状态，或从学习状态进入转发状态的延迟时间，默认值是15秒。避免在STP树的生成过程中可能出现的临时环路，或短暂的数据帧泛洪现象，分别在侦听和学习的端口状态各停留一个转发延迟时间。对于STP而言，一个阻塞端口选举为根接口或指定接口后，进入转发状态至少需要经历30秒的时间。用于确定状态迁移的延迟时间。缺省情况下，Forward Delay时间为15秒。链路故障会引发网络重新进行生成树的计算，生成树的结构将发生相应的变化。不过重新计算得到的新BPDU无法立刻传遍整个网络，如果新选出的根端口和指定端口立刻就开始数据转发的话，可能会造成暂时性的环路。为此，生成树协议在端口由Blocking状态向Forwarding状态迁移的过程中设置了Listening和Learning状态作为过渡(Listening和Learning状态都会持续Forward Delay时间)，并规定状态迁移需要等待Forward Delay时间，以保持与远端的设备状态切换同步。新选出的根端口和指定端口要经过2倍的Forward Delay延时后才能进入转发状态，这个延时保证了新的BPDU已经传遍整个网络。为保证网络拓扑的快速收敛，需要配置合适的时间参数。上述三个时间参数之间应满足以下关系，否则会引起网络的频繁震荡：2×(Forward Delay－1秒)≥Max AgeMax Age≥2×(Hello Time＋1秒)举例交换机A 、B 、C 一起启动，各交换机的每个互联端口立即从禁用状态进入到阻塞状态。在阻塞状态的端口只能接收而不能发送BPDU，所以任何端口都收不到BPDU。在等待Max Age后，每台交换机都会认为自己是根桥，所有端口的角色都成为指定端口，并且端口的状态迁移为侦听状态。交换机的端口进入到侦听状态后，开始发送自己产生的配置BPDU，同时也收到其它交换机发送的配置BPDU。因为各个交换机发送BPDU的时间有一定的随机性，所以有可能交换机B和交换机C先选举根桥为交换机B，再收到交换机A的配置BPDU，最后选举出根桥为交换机A。因此，无论交换机开始的状态如何，也不管中间过程有多大差异，最终的结果总是确定且唯一的：桥ID最小的交换机会成为根桥。端口在侦听状态持续Forward Delay的时间后，开始进入学习状态。由于交换机C的 G0/2 端口已经成为备用端口，所以状态也会变成阻塞状态。各个端口(交换机 C 的 G0/2 端口除外)陆续进入学习状态后，会持续Forward Delay的时间。在这段时间里，交换机开始学习MAC地址和端口的映射关系，同时希望STP树在这个时间内能够完全收敛。之后各个端口(交换机 C 的 G0/2 端口除外)相继进入转发状态，开始进行数据帧的转发。由于时间参数的设计，一个STP接口从阻塞状态进入到转发状态，可能需要30~50秒的时间，这段时间内，网络无法正常使用。整个华为数通学习笔记系列中，本人是以网络视频与网络文章的方式自学的，并按自己理解的方式总结了学习笔记，某些笔记段落中可能有部分文字或图片与网络中有雷同，并非抄袭。完处于学习态度，觉得这段文字更通俗易懂，融入了自己的学习笔记中。如有相关文字涉及到某个人的版权利益，可以直接联系我，我会把相关文字删除。【VX：czlingyun    暗号：CSDN】http://www.ppmy.cn/news/1541461.html相关文章【数组知识的扩展①】&amp;#x1f308;个人主页: Aileen_0v0 &amp;#x1f525;热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法 ​&amp;#x1f4ab;个人格言:“没有罗马,那就自己创造罗马~” 
ArrayList在Java数组中的使用技巧 这篇博客灵感来源于某一天Aileen(&amp;#x1f92b;)遇到了一道数组合并的题&amp;…阅读更多...OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:43 +0000</pubDate>
    </item>
    <item>
      <title>【数组知识的扩展①】</title>
      <link>https://www.ppmy.cn/news/1541460.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【数组知识的扩展①】news/2025/11/4 0:21:42/🌈个人主页: Aileen_0v0🔥热门专栏: 华为鸿蒙系统学习|计算机网络|数据结构与算法​💫个人格言:“没有罗马,那就自己创造罗马~”ArrayList在Java数组中的使用技巧这篇博客灵感来源于某一天Aileen(🤫)遇到了一道数组合并的题，于是她按照自己的思路把这道题的解题过程写了下来，如下图所示:她的想法是想把奇数和偶数分别用两个数组装起来再把它们合并在一个新的数组里面But她尝试通过编写代码实现自己的想法，如下：importjava.util.Arrays;publicclassWork11_1{publicstaticStringreverse(int[]arr){//创建一个空数组装所有元素int[]all=newint[]{};//创建一个空数组装偶数int[]evenarr=newint[]{};//创建一个空数组装奇数int[]oddarr=newint[]{};for(inti=0;i&lt;arr.length;i++){if(arr[i]%2==0){evenarr[i]=arr[i];}else{oddarr[i]=arr[i];}}System.arraycopy(oddarr,0,all,0,oddarr.length);returnArrays.toString(all);}publicstaticvoidmain(String[]args){int[]array=newint[]{1,2,3,4,5,6};System.out.println(reverse(array));}运行结果：通过报错信息我们可以知道，她的代码存在着一些问题：数组在初始化时（即：`all` ,`evenarr`,`oddarr`的创建）未给它们分配大小，导致后面我们其实是无法向这些数组里面添加元素的，中国有句古话“强扭的瓜不甜”，即使我们强制给他们添加新元素，这也是徒劳，最终就会看到控制台那句报错信息写的：数组越界异常~她为了解决这个问题，在Java中找到了一个内置类，即 `ArrayList` , 下面我们将进入ArrayList的学习：ArrayList:这个类是Java内置的一个类它继承了Java中的AbstractList并实现了List接口。他是一个可以动态修改的数组，与普通数组相比，他没有固定大小的限制，我们可以通过它进行添加或删除元素。importjava.util.ArrayList;publicclassArrList{publicstaticvoidmain(String[]args){// 创建一个 mylist 存储字符串ArrayList&lt;String&gt;mylist=newArrayList&lt;&gt;();System.out.println("---添加----------------------------------------------------------------------");// 添加元素mylist.add("Apple");mylist.add("Banana");mylist.add("Cherry");System.out.println(mylist);System.out.println("---访问------------------------------------------------------------------------");//使用 get() 方法访问ArrayList中的元素System.out.println(mylist.get(2));//访问第三个元素System.out.println("---修改------------------------------------------------------------------------");//set() 方法修改ArrayList中的元素mylist.set(0,"youzi");//第一个参数为索引位置，第二个是要修改的值System.out.println(mylist);System.out.println("---删除------------------------------------------------------------------------");//remove() 方法删除ArrayList中的元素mylist.remove(2);//删除第三个元素System.out.println(mylist);System.out.println("---计算大小------------------------------------------------------------------------");System.out.println(mylist.size());System.out.println("---迭代打印数组列表------------------------------------------------------------------------");for(inti=0;i&lt;mylist.size();i++){System.out.println(mylist.get(i));}System.out.println("---使用for-each打印数组列表------------------------------------------------------------------------");for(Stringfruit:mylist){System.out.println(fruit);}}}打印结果：让我们把上面学到的ArrayList类的方法用到我们解决这道题的思路上吧~学以致用使用ArrayList(单线程常用)解决问题importjava.util.ArrayList;importjava.util.Arrays;publicclassWork11_1{publicstaticStringreverse(int[]arr){//创建两个 Integer 类型的 ArrayList 数组用于储存 奇数和偶数 的数组//偶数数组ArrayList&lt;Integer&gt;evenList=newArrayList&lt;&gt;();//奇数数组ArrayList&lt;Integer&gt;oddList=newArrayList&lt;&gt;();//遍历数组，将对应的元素放到对应的数组里面for(inti=0;i&lt;arr.length;i++){if(arr[i]%2==0){evenList.add(arr[i]);//将偶数元素装入其对应数组}else{oddList.add(arr[i]);//将奇数元素装入其对应数组}}//创建合并后的数组int[]all=newint[evenList.size()+oddList.size()];//将奇数数组复制到合并后的数组for(inti=0;i&lt;oddList.size();i++){all[i]=oddList.get(i);}//将偶数数组复制到合并后的数组for(inti=0;i&lt;evenList.size();i++){all[oddList.size()+i]=evenList.get(i);}returnArrays.toString(all);}publicstaticvoidmain(String[]args){int[]array=newint[]{1,2,3,4,5,6};System.out.println(reverse(array));}}我们通过使用ArrayList这个动态数组能够提高读`get()`写`add()`、`set()`操作的高效性，并且其内存开销比较小，因为它不会每次修改创建数组的副本。However`ArrayList`不是线程安全的，在多线程环境中，如果多个线程同时对同一个`ArrayList`修改，可能会导致数据不一致，或者抛出异常，如果想在多线程环境中使用`ArrayList`.需要手动同步，但它会增加代码的复杂性和错误的风险。使用CopyOnWriteArrayList(多线程适用)解决问题importjava.util.Arrays;importjava.util.concurrent.CopyOnWriteArrayList;publicclassWork11_1{publicstaticStringreverse(int[]arr){// 使用 CopyOnWriteArrayList 来存储奇数和偶数CopyOnWriteArrayList&lt;Integer&gt;evenList=newCopyOnWriteArrayList&lt;&gt;();CopyOnWriteArrayList&lt;Integer&gt;oddList=newCopyOnWriteArrayList&lt;&gt;();// 遍历输入数组，将奇数和偶数分别放入不同的列表for(inti=0;i&lt;arr.length;i++){if(arr[i]%2==0){evenList.add(arr[i]);// 偶数}else{oddList.add(arr[i]);// 奇数}}// 创建合并后的数组int[]all=newint[evenList.size()+oddList.size()];// 将奇数列表复制到合并后的数组for(inti=0;i&lt;oddList.size();i++){all[i]=oddList.get(i);}// 将偶数列表复制到合并后的数组for(inti=0;i&lt;evenList.size();i++){all[oddList.size()+i]=evenList.get(i);}// 返回合并后的数组的字符串表示returnArrays.toString(all);}publicstaticvoidmain(String[]args){int[]array=newint[]{1,2,3,4,5,6};System.out.println(reverse(array));}}Java中for-each的使用基本语法for（元素类型 变量名:数组或集合）{//这里编写对变量的操作}具体实例publicclassForEach{publicstaticvoidmain(String[]args){int[]numbers={1,2,3,4,5};//使用for-each循环遍历数组//通过变量num遍历数组numbers里面的每一个元素for(intnum:numbers){System.out.print(num+" ");}}}http://www.ppmy.cn/news/1541460.html相关文章OJ-1017中文分词模拟器示例0 
输入&amp;#xff1a; 
ilovechina i,ilove,lo,love,ch,china,lovechina 
输出&amp;#xff1a; 
ilove,china 
示例1 
输入&amp;#xff1a; 
ilovechina i,love,china,ch,na,ve,lo,this,is,the,word 
输出&amp;#xff1a; 
i,love,china 
说明&amp;#xff1a; 示例2 
输入: 
iat i,love,…阅读更多...深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:42 +0000</pubDate>
    </item>
    <item>
      <title>OJ-1017中文分词模拟器</title>
      <link>https://www.ppmy.cn/news/1541459.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维OJ-1017中文分词模拟器news/2025/11/4 0:21:41/示例0输入：ilovechinai,ilove,lo,love,ch,china,lovechina输出：ilove,china示例1输入：ilovechinai,love,china,ch,na,ve,lo,this,is,the,word输出：i,love,china说明：示例2输入:iati,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful输出：i,a,t说明：单个字母，不在词库中且不成词则直接输出单个字母示例3输入：ilovechina,thewordisbeautifuli,love,china,ch,na,ve,lo,this,is,the,word,beauti,tiful,ful输出：i,love,china,the,word,is,beauti,ful说明：标点符号为英文标点符号import java.util.Arrays;
import java.util.List;
import java.util.Scanner;public class 中文模拟分词器2 {public static void main(String[] args) {Scanner in = new Scanner(System.in);String input = in.nextLine();List&lt;String&gt; dict = Arrays.asList(in.nextLine().split(","));int len = input.length();StringBuilder sb = new StringBuilder();int i = 0;while (i &lt; len) {int j = len;boolean found = false;while (j &gt; i) {String s = input.substring(i, j);if (s.matches("[a-zA-Z]+") &amp;&amp; (dict.contains(s) || s.length() == 1)) {sb.append(s).append(",");found = true;i = j;break;}j--;}if (!found) {i++;}}System.out.println(sb.substring(0, sb.length() - 1));}
}http://www.ppmy.cn/news/1541459.html相关文章深度学习端侧推理框架介绍深度学习端侧推理框架介绍 
动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。 
TensorFlow Lite 介绍&amp;#xff1a;TensorFlow的轻量级版本&amp;#xff0c;专为移动和嵌入式设备优化&amp;#xff0c;支持Android和iOS。官网网址&amp;#xff1a;https://tensor…阅读更多...IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:41 +0000</pubDate>
    </item>
    <item>
      <title>深度学习端侧推理框架介绍</title>
      <link>https://www.ppmy.cn/news/1541458.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深度学习端侧推理框架介绍news/2025/11/4 0:21:40/深度学习端侧推理框架介绍动端深度学习推理框架专为在移动设备和边缘设备上高效运行深度学习模型而设计。TensorFlow Lite介绍：TensorFlow的轻量级版本，专为移动和嵌入式设备优化，支持Android和iOS。官网网址：https://tensorflow.google.cn/lite/tutorials?hl=zh_cnGitHub：https://github.com/tensorflow/tensorflow特点：性能优化：TensorFlow Lite提供了模型转换器，可以将训练好的模型转换成TensorFlow Lite格式，并且支持模型量化来进一步压缩模型大小和提高运行速度。硬件加速：TensorFlow Lite支持Android神经网络API（NNAPI）进行硬件加速，能够在兼容的Android设备上利用硬件加速深度学习模型的推理。跨平台支持：TensorFlow Lite不仅支持Android，还支持iOS设备，具有较好的跨平台特性。社区和文档：作为TensorFlow的一部分，TensorFlow Lite拥有强大的社区支持和丰富的文档资源。PyTorch Mobile介绍：PyTorch Mobile 是由 Facebook 的 PyTorch 团队提供的一套工具，它允许开发者在移动设备上运行 PyTorch 模型。PyTorch Mobile 支持 iOS 和 Android平台，使得在移动设备上部署和运行深度学习模型变得更加容易。官网：https://pytorch.org/mobile/home/GitHub：https://github.com/pytorch/pytorch特点：跨平台支持：支持 iOS 和 Android，使得模型可以在两大主流移动操作系统上运行。与 PyTorch 兼容：与 PyTorch 框架兼容，开发者可以在桌面环境中训练模型，并将其无缝迁移到移动设备上TorchScript 支持：支持将 PyTorch 模型转换为 TorchScript 格式，这是一种跨平台的序列化格式，允许模型在没有 Python 环境的设备上运行。C++ 前端：提供 C++ API，允许在移动应用中直接调用和执行 PyTorch 模型，无需 Python 解释器。动态计算图：支持动态计算图，使得模型可以在运行时动态改变，这对于某些需要动态调整模型结构的应用非常有用。自动微分：支持自动微分，这对于需要在设备上进行训练或优化的应用非常有用。模型优化：支持模型量化和剪枝，以减少模型大小并提高推理速度，适应移动设备的资源限制。预编译的二进制文件：提供预编译的二进制文件，简化了集成过程，无需从头编译。灵活性：允许开发者在移动设备上进行模型推理和微调，甚至可以在设备上进行二次训练。性能优化：针对移动设备进行了优化，包括内核融合、内存管理优化等，以提高模型运行效率。易于集成：提供了详细的文档和示例代码，帮助开发者快速集成 PyTorch Mobile 到他们的移动应用中。社区支持：作为 PyTorch 生态系统的一部分，PyTorch Mobile 拥有活跃的社区支持，包括官方文档、论坛和GitHub仓库。MNN介绍：MNN（Mobile Neural Network）是一个阿里巴巴开发的轻量级的深度神经网络推理引擎，专为移动端优化，同时支持服务器、个人电脑、手机和嵌入式设备。官网：https://www.mnn.zone/m/0.3/GitHub：https://github.com/alibaba/MNN特点：轻量性：MNN的主体功能（模型推理CPU+GPU）无任何依赖，代码精简，方便部署到移动设备和嵌入式设备中。iOS平台上，功能全开的MNN静态库大小约12MB，链接后增加的可执行文件大小约2MB。可裁剪主体功能后静态库大小6.1MB，链接后增加的可执行文件大小约600KB。Android平台上，主体功能动态库大小约800KB左右。通用性：支持Tensorflow、Caffe、ONNX、Torchscripts等主流模型文件格式，支持CNN、RNN、GAN、Transformer等主流网络结构。支持多输入多输出，任意维度的输入输出，动态输入以及带控制流的模型。高性能：对iOS、Android、PC、Server的CPU架构进行了适配，编写SIMD代码或手写汇编以实现核心运算，充分发挥CPU的算力。支持基于Metal、OpenCL、Vulkan、CUDA使用设备上的GPU进行推理。广泛运用了Winograd卷积算法提升卷积性能，并支持低精度计算（int8/fp16/bf16）以提升推理性能。易用性：支持使用MNN的算子进行常用的数值计算，覆盖numpy常用功能。提供MNN CV模块，支持图像仿射变换与归一化等图像处理。支持各平台下的模型训练，尤其是移动端上的模型训练，并支持Python调用。工具：提供了一系列工具，包括MNN-Converter（模型转换工具）、MNN-Compress（模型压缩工具）、MNN-Express（支持带控制流的模型运行）、MNN-CV（图像处理算法库）和MNN-Train（训练模块）。跨平台支持：MNN支持Windows、iOS 8.0+、Android 4.3+、Linux及具有POSIX接口的操作系统，使得开发者可以一次开发，多平台部署。应用场景广泛：MNN已经在阿里巴巴的多个App中使用，覆盖直播、短视频、搜索推荐、商品图像搜索、互动营销、权益发放、安全风控等场景。ncnn介绍：NCNN 是一个为移动和嵌入式设备优化的高性能神经网络前向计算框架，由腾讯的优图实验室（YouTu Lab）开发。NCNN 专注于在资源受限的环境中提供快速的深度学习模型推理能力。GitHub：https://github.com/Tencent/ncnn/特点：轻量级设计：NCNN 专注于模型的前向推理，不包含训练功能，这使得它在资源受限的设备上更加高效。跨平台支持：支持多种操作系统，包括 Android、iOS、Windows、Linux 和 macOS。硬件加速：支持多种硬件加速库，如 ARM Neon、OpenCL、Metal（仅限 iOS）和 Vulkan，以充分利用硬件资源。模型压缩：支持模型的量化和剪枝，减少模型大小，提高运行速度。简化操作：提供了简化的 API，方便开发者快速集成和使用。内存管理：优化了内存管理，减少了内存占用，适合内存受限的设备。灵活的输入输出：允许开发者灵活地处理网络的输入和输出，方便与现有应用集成。支持主流模型格式：支持从 Caffe、TensorFlow、PyTorch 等主流框架转换模型。实时推理：针对实时应用进行了优化，如视频处理和增强现实。易于部署：提供了预编译的二进制文件和详细的文档，简化了部署过程。社区支持：拥有活跃的社区和开源支持，开发者可以在 GitHub 上找到 NCNN 的最新版本和相关讨论。ONNX Runtime Mobile介绍：ONNX Runtime Mobile 是微软开发的一个开源项目。它被设计为一个轻量级的推理库，用于在移动设备（如Android和iOS）上执行ONNX（Open NeuralNetworkExchange）模型。这个项目提供了一个优化的执行环境，使得机器学习模型能够在边缘设备上高效运行，包括个人电脑、智能手机、专用嵌入式设备或物联网设备。ONNXRuntime Mobile 支持与 ONNX Runtime 相同的API，使得应用代码可以管理和执行推理会话。官网：https://onnxruntime.ai/GitHub：https://github.com/microsoft/onnxruntime特点：跨平台支持：ONNX Runtime Mobile 支持在 Android 和 iOS 平台上运行，使得开发者能够将 ONNX 模型部署到移动设备上。性能优化：针对移动设备进行了特别的优化，以减少磁盘占用空间，同时保持高性能的推理能力。减少操作符和类型：为了最小化二进制大小，ONNX Runtime Mobile 支持一组减少的操作符和类型，这些与典型的移动应用需求相一致。模型转换要求：使用 ONNX Runtime Mobile 之前，需要将 ONNX 模型转换为 ORT 格式。NNAPI 和 CoreML 集成：ONNX Runtime Mobile 可以利用 Android 平台上的 NNAPI（神经网络API）和 iOS 平台上的 CoreML 进行硬件加速。图优化：ONNX Runtime 应用了大量的图优化，以提高模型的推理性能。Execution Providers (EP) 框架：通过其可扩展的 Execution Providers 框架与不同的硬件加速库协同工作，以在硬件平台上以最佳方式执行 ONNX 模型。量化支持：ONNX Runtime 支持模型量化，这可以显著减少模型大小，同时提高推理速度。自定义操作和优化：开发者可以自定义操作和优化，以适应特定的应用场景和硬件特性。社区和文档支持：ONNX Runtime 拥有活跃的社区和丰富的文档资源，帮助开发者快速上手和解决问题。ML Kit介绍：ML Kit 是由 Google 提供的一款开源的机器学习 SDK，它包含了一系列预训练模型，可以帮助开发者在 Android 和 iOS 应用中快速添加机器学习功能。官网：https://developers.google.cn/ml-kit?hl=urGitHub：https://github.com/googlesamples/mlkit特点：广泛的功能覆盖：ML Kit 提供了包括图像识别、面部识别、物体检测、姿势估计、语音识别、语言识别、手势识别、行为识别、地理位置识别、翻译、自然语言处理和推荐系统等多种机器学习功能。多平台兼容性：ML Kit 适用于 Android 和 iOS 平台，允许开发者在这两个平台上轻松集成机器学习功能。灵活性选择：ML Kit 允许在边缘设备或云端执行模型推理，提供了灵活的部署选项。实时和批量数据处理能力：ML Kit 能够满足不同场景下对实时性和批量处理的需求。自定义模型支持：ML Kit 支持使用自定义的 TensorFlow Lite 模型，允许开发者根据自己的特定需求训练和部署模型。易于使用的高级别 API：ML Kit 提供了简单易用的 API，使得即使没有机器学习背景的开发者也能快速开发出基于机器学习的应用。Firebase 集成：ML Kit 可以与 Firebase 集成，利用 Firebase 的服务进行模型的托管和更新。开源项目：ML Kit 也是一个开源项目，其代码可以在 GitHub 等平台上找到，允许社区贡献和改进。OpenVINO Toolkit介绍：OpenVINO Toolkit 是由英特尔（Intel）开发的一个开源工具套件，用于优化和部署人工智能（AI）推理。官网：https://docs.openvino.ai/2024/index.htmlGitHub：https://github.com/openvinotoolkit/openvinoPaddle Lite介绍：Paddle Lite 是百度飞桨（PaddlePaddle）深度学习平台下的一个项目，它是一个高性能、轻量级、灵活性强且易于扩展的深度学习推理框架，主要定位于支持包括移动端、嵌入式以及服务器端在内的多硬件平台。官网：https://www.paddlepaddle.org.cn/paddle/paddleliteGitHub：https://github.com/PaddlePaddle/Paddle-Lite特点：多平台支持：Paddle Lite 支持多种平台，包括 Android、iOS、嵌入式 Linux 设备、Windows、macOS 和 Linux 主机。多种语言支持：Paddle Lite 支持多种编程语言，包括 Java、Python、C++。轻量化和高性能：Paddle Lite 针对移动端设备的机器学习进行优化，压缩模型和二进制文件体积，高效推理，降低内存消耗。模型优化：Paddle Lite 提供了模型优化工具，包括量化、子图融合、Kernel优选等优化手段，使得优化后的模型更轻量级，耗费资源更少，执行速度更快。多硬件支持：Paddle Lite 架构已经验证和完整支持多种硬件平台，包括 ARM CPU、Mali GPU、Adreno GPU、华为 NPU，以及 FPGA 等，且正在不断增加更多新硬件支持。架构设计：Paddle Lite 的架构设计着重考虑了对多硬件和平台的支持，并且强化了多个硬件在一个模型中混合执行的能力，多个层面的性能优化处理，以及对端侧应用的轻量化设计。开源项目：Paddle Lite 是一个开源项目，其所有项目代码在 Github 上维护，遵循 Apache License Version 2.0 许可协议。模型量化：Paddle Lite 支持静态离线量化、动态离线量化和量化训练等多种量化方式。调试分析工具：Paddle Lite 提供了调试和性能分析工具，帮助开发者优化模型和提高性能。移动端模型训练：Paddle Lite 支持移动端模型训练，使得模型训练更加灵活和便捷。其他http://www.ppmy.cn/news/1541458.html相关文章IDEA如何查看所有的断点（Breakpoints）并关闭前言 
我们在使用IDEA开发Java应用时&amp;#xff0c;基本上都需要进行打断点的操作&amp;#xff0c;这方便我们排查BUG&amp;#xff0c;也方便我们查看设计的是否正确。 不过有时候&amp;#xff0c;我们不希望进入断点&amp;#xff0c;这时候除了点击断点关闭外&amp;#xff0c;有没有更快速的方便关闭…阅读更多...滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:40 +0000</pubDate>
    </item>
    <item>
      <title>IDEA如何查看所有的断点（Breakpoints）并关闭</title>
      <link>https://www.ppmy.cn/news/1541457.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维IDEA如何查看所有的断点（Breakpoints）并关闭news/2025/11/4 0:21:39/前言我们在使用IDEA开发Java应用时，基本上都需要进行打断点的操作，这方便我们排查BUG，也方便我们查看设计的是否正确。不过有时候，我们不希望进入断点，这时候除了点击断点关闭外，有没有更快速的方便关闭所有的断点呢？如何设置首先，我们在运行debug模式的时候，切换到Debug的窗口，然后我们点击左侧的两个点的按钮。然后，在弹出来的界面上，就可以看到我们目前打的所有断点了，可以很方便的把所有断点都关闭掉。勾选掉之后，点击【done】按钮即可。这样，就可以把所有的断点都关闭了。当然，如果我们不想关闭断点，只是临时关闭所有断点，则可以点击下面的按钮，临时关闭所有断点，当想开启断点时，再点击一次即可。总结以上就是我们在IDEA中快速关闭所有断点的方式。欢迎访问我的个人网站：Java入门分享 - Java是一种思维。1.IDEA中如何查看jar包反编译源代码2.程序员保碗之策3.ugit，腾讯自研国产GIT客户端4.vscode如何更改背景颜色主题，黑色或白色？http://www.ppmy.cn/news/1541457.html相关文章滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践全文目录&amp;#xff1a; 前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查 2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式 小结下期预告 前言 
在上一章【第八章&amp;#xff1a;Redis的扩展与…阅读更多...unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:40 +0000</pubDate>
    </item>
    <item>
      <title>滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践</title>
      <link>https://www.ppmy.cn/news/1541456.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维滚雪球学Redis[9.1讲]：Redis的常见问题与最佳实践news/2025/11/4 0:21:39/全文目录：前言1. Redis的常见问题排查常见错误信息与解决方案性能瓶颈的识别与处理数据一致性问题的排查2. Redis的最佳实践Redis使用中的通用原则典型业务场景中的最佳实践如何避免Redis中的反模式小结下期预告前言在上一章【第八章：Redis的扩展与未来发展】中，我们探讨了Redis的扩展能力及其在未来技术中的应用。我们详细介绍了Redis Modules的使用和开发，Redis在云服务中的应用，Redis 6.x的最新特性，以及Redis在人工智能和物联网等新兴领域的潜力。这些内容展示了Redis在现代技术环境中的强大能力和广泛应用前景。本章将集中于Redis的常见问题与最佳实践，旨在帮助您更高效地使用Redis，解决在实际操作中可能遇到的各种问题。我们将从常见错误的排查、性能瓶颈的处理，到数据一致性问题的解决，逐一分析，并提供一些最佳实践和避免反模式的建议，以确保Redis的高效稳定运行。1. Redis的常见问题排查常见错误信息与解决方案Redis作为一个高性能的内存数据库，虽然在大多数情况下运行稳定，但有时也会遇到一些常见的错误。以下是几种常见的Redis错误信息及其解决方案：OOM command not allowed when used memory &gt; 'maxmemory'：问题：Redis实例的内存使用超过了配置的最大内存限制。解决方案：检查并调整maxmemory配置项，增加Redis实例的内存限制；或者调整maxmemory-policy策略，设置合适的内存淘汰策略。ERR no such key：问题：尝试访问一个不存在的键。解决方案：确保键名正确，并在操作之前检查键是否存在，可以使用EXISTS命令。Could not connect to Redis at &lt;host&gt;:&lt;port&gt;: Connection refused：问题：Redis服务器无法连接，可能是服务器未启动或网络问题。解决方案：检查Redis服务器是否正在运行，确保配置的host和port正确，并检查网络连接是否正常。Cluster state changed：问题：Redis集群状态发生变化，可能是节点故障或重新配置。解决方案：检查Redis集群的状态，确保所有节点正常运行，并通过CLUSTER INFO命令检查集群健康状态。性能瓶颈的识别与处理Redis的高性能依赖于其内存存储和单线程模型，但在某些情况下，可能会遇到性能瓶颈。以下是识别和处理Redis性能瓶颈的一些方法：监控资源使用情况：使用INFO命令查看Redis的内存使用情况、CPU负载和网络I/O情况。监控Redis的慢查询日志，通过SLOWLOG命令找出耗时较长的操作。分析命令执行情况：使用MONITOR命令实时监控Redis的命令执行情况，识别执行时间较长的命令或频繁的操作，分析其对性能的影响。优化数据结构和命令使用：避免在高并发场景中使用不适合的命令或数据结构。根据实际需求优化数据结构，例如使用HSET代替SET存储多个字段的数据。调整Redis配置：调整Redis的配置参数，如maxmemory、timeout、tcp-backlog等，以适应实际负载和网络环境。数据一致性问题的排查在分布式环境中，确保数据的一致性是一个挑战。以下是一些排查和处理数据一致性问题的方法：使用Redis主从复制：确保主从节点的数据同步正常。可以使用INFO replication命令检查主从节点的同步状态，确保从节点没有延迟或故障。处理网络分区：在网络分区或故障情况下，可能导致数据不一致。使用Redis Sentinel或Cluster模式来处理主从节点之间的故障转移和数据同步。检查持久化配置：确保RDB和AOF持久化配置正确，定期备份数据，避免数据丢失和一致性问题。2. Redis的最佳实践Redis使用中的通用原则合理配置内存：根据实际应用需求配置Redis的内存限制，确保Redis实例有足够的内存用于数据存储和处理。选择合适的数据结构：根据具体场景选择合适的Redis数据结构，例如使用Sorted Set进行排名，使用Hash存储多个字段的数据。使用合理的持久化策略：根据业务需求选择RDB、AOF或混合持久化策略。对持久化过程进行优化，减少性能开销。定期监控和维护：定期使用Redis的监控工具，如MONITOR、INFO等，监控Redis的运行状态，及时发现并处理潜在问题。典型业务场景中的最佳实践缓存系统：设置合理的缓存过期时间和淘汰策略，避免缓存雪崩。使用CACHE命令（如SETEX）设置带过期时间的缓存。会话管理：使用SET命令存储会话数据，并设置适当的过期时间以自动清除过期的会话。排行榜系统：使用ZADD命令将数据添加到有序集合中，并通过ZRANGE命令查询排行榜数据。确保合理设置数据的排序和排名规则。分布式锁：使用SET命令与NX选项实现分布式锁，并设置合适的过期时间以避免死锁。如何避免Redis中的反模式避免大键和大值：大键和大值会导致Redis性能下降。使用适当的数据结构和分片策略，避免单个键占用过多内存。避免过多的键值对：在高并发环境中，过多的键值对会增加Redis的负载。根据需求合理设计数据结构，避免无用的键值对。避免不必要的持久化：如果数据可以丢失，避免使用AOF持久化，以减少性能开销。根据业务需求选择合适的持久化策略。避免复杂的事务操作：避免在高并发环境中使用复杂的事务操作。尽量使用简单的命令和数据结构，减少事务冲突和性能瓶颈。小结本章详细介绍了Redis常见问题的排查方法，包括错误信息处理、性能瓶颈识别、数据一致性问题的解决。同时，我们提供了Redis的最佳实践，包括使用中的通用原则、典型业务场景中的最佳实践，以及如何避免反模式。这些内容将帮助您在实际操作中更高效地使用Redis，确保其稳定性和性能。下期预告在下期内容【第十章：Redis的未来发展与扩展】中，我们将继续探讨Redis的未来发展方向和扩展能力，介绍Redis在现代技术环境中的应用趋势和未来展望。敬请期待！http://www.ppmy.cn/news/1541456.html相关文章unity 导入的模型设置详谈文章目录 1.Model 模型1.1 Scene&amp;#xff1a;场景级属性&amp;#xff0c;例如是否导入灯光和照相机&amp;#xff0c;以及使用什么比例因子1.2 Mesh&amp;#xff1a;网格的属性1.3 Generate &amp;#xff1a;与几何相关的属性&amp;#xff0c;用于处理拓扑&amp;#xff0c;UV和法线 2.Rig 骨骼3.Animatio…阅读更多...洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:39 +0000</pubDate>
    </item>
    <item>
      <title>unity 导入的模型设置详谈</title>
      <link>https://www.ppmy.cn/news/1541455.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维unity 导入的模型设置详谈news/2025/11/4 0:21:38/文章目录1.Model 模型1.1 Scene：场景级属性，例如是否导入灯光和照相机，以及使用什么比例因子1.2 Mesh：网格的属性1.3 Generate ：与几何相关的属性，用于处理拓扑，UV和法线2.Rig 骨骼3.Animation 动画4.Materials 材质1.Model 模型1.1 Scene：场景级属性，例如是否导入灯光和照相机，以及使用什么比例因子属性功能Scale Factor缩放因子（也就是模型导入后大小如果小了或者大了在这里直接改是相当于该模型的大小的，而且在scale那栏里不会有缩放数值）Convert Units启用此选项可将模型文件中定义的模型比例转换为 Unity 的比例。Import BlendShapes是否导入BlendShape表情/混合形状。BlendShape表情，主要工作量在美术，美术制作好表情动画之后，导入Unity中按照下面设置播放即可。美术方面：美术额外导出一个FBX，带有蒙皮信息、骨骼动画只保留一个造型、单独面部的动画信息（Morphing），经过测试，只有美术网格、骨骼、蒙皮、Morphing动画一起导出来的Fbx才能保留表情动画信息。导入到Unity中，基础模型要开启Import BlendShape，对应的面部SkinnedMeshRenderer上会多出BlendShape的配置（调整这些值就可以看到表情变化了）。Import Visibility可见性是否导入（在编辑模型导出之前可以隐藏模型，隐藏模型选上他了还是可以导出来，勾选上这个在模型拖入场景时，她会显示为隐藏状态）Import Cameras摄像机是否导入（在3D软件打好摄像机了，摄像机的信息会存在fbx里）Import Lights灯光信息是否导入；（在3D软件打好灯光了，灯光的信息会存在fbx里）Preserve Hierarchy保留层次结构（即使此模型只有一个根，也要始终创建一个明确的预制根。通常，FBX 导入会从模型中剥离所有空的根节点作为优化策略。但是，如果您有多个FBX文件，且它们具有相同层次结构的某些部分，则可以使用此选项保留原始层次结构。例如，file1.fbx包含一个装备，而Mesh和file2.fbx包含相同的装备，但仅包含该装备的动画。如果在未启用此选项的情况下导入file2.fbx，则Unity会剥离根节点，层次结构不匹配，并且动画会中断。）1.2 Mesh：网格的属性属性功能Mesh Compression设置压缩率级别以减小网格的文件大小。通过使用网格边界和每个组件较低的位深度来压缩网格数据，增加压缩率会降低网格的精度。最好将其调高到尽可能高的水平，而网格物体看起来与未压缩版本没有太大不同。这对于优化游戏大小很有用。（off:不使用压缩;Low:使用低压缩率;Medium:使用中等压缩比;High:使用高压缩比。）Read/Write Enabled启用此选项后，Unity会将Mesh数据上传到GPU可寻址的内存，但也将其保留在CPU可寻址的内存中。这意味着Unity可以在运行时访问Mesh数据，并且您可以从脚本中访问它。例如，如果您要按程序生成网格，或者要从网格复制某些数据，则可能要执行此操作。禁用此选项后，Unity会将Mesh数据上传到GPU可寻址的内存，然后将其从CPU可寻址的内存中删除。默认情况下，此选项是禁用的。在大多数情况下，要节省运行时内存使用量，请禁用此选项。Optimize Mesh确定网格中三角形的排列顺序，以提高GPU性能。(Nothing:没有优化；Everything：一切让Unity重排多边形和顶点的顶点和索引。这是默认值。Polygon Order：多边形排序仅对多边形重新排序。Vertex Order：顶点顺序仅对顶点重新排序。)Generate Colliders启用自动生成网格碰撞器（mesh collider）。1.3 Generate ：与几何相关的属性，用于处理拓扑，UV和法线属性功能Keep Quads启用此选项可阻止Unity将具有四个顶点的多边形转换为三角形。例如，如果您正在使用“镶嵌着色器”（Tessellation Shaders），则可能要启用此选项，因为镶嵌四边形可能比镶嵌多边形更有效。Unity可以导入任何类型的多边形（三角形到N-gon）。无论此设置如何，具有四个以上顶点的多边形始终会转换为三角形。但是，如果网格具有四边形和三角形（或将N形转换为三角形），则Unity会创建两个子网格来分隔四边形和三角形。每个子网格仅包含三角形或仅包含四边形。提示：如果要从3ds Max将四边形导入Unity，则必须将其导出为可编辑多边形。Weld Vertices合并在空间上具有相同位置的顶点，但前提是它们在整体上具有相同的属性（包括UV，法线，切线和顶点颜色）。通过减少网格的总数，可以优化网格上的顶点数。默认情况下启用此选项。在某些情况下，导入网格物体时可能需要关闭此优化。例如，如果您故意有重复的顶点在网格中占据相同位置，则您可能更喜欢使用脚本来读取或操纵单个顶点和三角形数据。Index Format定 义网格索引缓冲区的大小。注意：出于带宽和内存存储大小的原因，您通常希望将16位索引保留为默认值，并且在必要时仅使用32位，这是“自动”选项所使用的。（Auto：让Unity根据网格顶点数来决定在导入网格时是使用16位索引还是32位索引。这是在Unity 2017.3及更高版本中添加的资产的默认设置。16bit：导入网格时使用16位索引。如果网格较大，则将其划分为&lt;64k个顶点块。这是Unity 2017.2或更早版本中创建的项目的默认设置。32bit：导入网格时使用32位索引。如果您使用的是基于GPU的渲染流水线（例如，使用计算着色器三角形剔除），使用32位索引可确保所有Mesh都使用相同的索引格式。这减少了着色器复杂性，因为它们只需要处理一种格式。）Legacy Blend Shape Normals计算法线的旧方法（版本2017.1之前）。在某些情况下，与当前实施方式相比，它给出的结果略有不同。这是所有FBX预制件的默认设置在将项目迁移到最新版本的Unity之前导入。Blend Shape Normals（2019版本）定义是否以及如何计算混合形状的法线。使用与“法线”属性相同的值。Normals定义是否以及如何计算法线。这对于优化游戏大小很有用。(Import：从文件导入法线‘’这是默认选项。如果文件不包含法线，则将对其进行计算。Calculate：计算根据法线模式，平滑度源和平滑角（如下）计算法线。None：禁用法线。如果网格既不是法线贴图也不是实时光照的影响，则使用此选项。)Normals Mode定义Unity如何计算法线。仅在将法线设置为计算或导入时可用。（Unweighted Legacy：计算法线的旧方法（版本2017.1之前）。在某些情况下，与当前实施方式相比，它给出的结果略有不同。这是所有FBX预制件的默认设置在将项目迁移到最新版本的Unity之前导入。Unweighted：法线不加权。Area Weighted：法线由面的面积大小加权。Angle Weighted：法线由每个面上的顶角大小加权。Area and Angle Weighted：法线由面的面积和每个面的顶角加权。这是默认选项。）Smoothing Angle控制是否为硬边分割顶点：通常，较高的值会减少顶点。注意：仅在非常光滑的物体或非常高的多边形模型上使用此设置。否则，最好在3D建模软件中手动进行平滑处理，然后将“法线”选项设置为“导入”（如上）进行导入。由于Unity的硬边仅基于一个角度，所以您可能会错误地对模型的某些部分进行平滑处理。仅在将法线设置为计算时可用。Tangents定义应如何导入或计算顶点切线。仅在将法线设置为计算或导入时可用。（Import：如果将法线设置为导入，则从FBX文件导入顶点切线。如果“网格”没有切线，则它不适用于法线贴图着色器。计算切线空间使用MikkTSpace计算切线。Calculate Tangent Space：如果“法线”设置为“计算”，则这是默认选项。Calculate Legacy：使用传统算法计算切线。Calculate Legacy - Split Tangent：使用传统算法计算切线，并在UV图表上进行分割。如果法线贴图使用此网格上的接缝破坏了照明。这通常仅适用于字符。None：不导入顶点切线。网格没有切线，因此不适用于法线贴图着色器。）Swap UVs交换网格中的UV通道。如果漫反射纹理使用光照贴图中的UV，请使用此选项。Unity最多支持八个UV通道，但并非所有3D建模应用程序都导出两个以上的通道。Generate Lightmap UVs为光照贴图创建第二个UV通道。2.Rig 骨骼None：没有骨骼（静态物件就选这个）Legacy：使用旧版动画系统。与Unity 3.x及更早版本一样，导入和使用动画。属性功能Generation选择动画导入方法Don’t Import不导入动画Store in OriginalRoots (Deprecated) 以原始根存储（已弃用）Store in Nodes (Deprecated)存储在节点中（已弃用）Store in Root (Deprecated)根存储（已弃用）Store in Root (New)根存储（新）属性功能Skin Weights设置可以影响单个顶点的最大骨骼数量。Generic：如果您的装备不是类人动物（四足动物或要进行动画处理的任何实体），请使用通用动画系统。Unity选择一个根节点，但是您可以标识另一个骨骼作为“根”节点代替。（用自己的骨骼系统分类）Humanoid：如果您的装备是类人动物（它有两条腿，两条手臂和一个头），请使用类人动物动画系统。Unity通常会检测骨架并将其正确映射到头像。在某些情况下，您可能需要更改“头像定义”并手动配置映射。（用unity通用的四足动物骨骼分类，可以动画通用。）3.Animation 动画https://blog.csdn.net/zhenghongzhi6/article/details/106316124如果Rig页签中的Animation Type选择了None，则无法设置Animation相关的属性。Import Constraints：是否导入Constraints(约束)。美术同学可能知道在3D建模软件中有Constraints设置，用来添加一些约束。Unity支持5种约束的导入。目前用到的较少。Import Animation：是否导入动画，如果不勾选代表不导入动画，下面的选项也会隐藏。Bake Animations：该选项只对Maya、3dsMax 、Cinema4D文件可用，对fbx文件不可用。选中时，Unity在导入模型时会将IK或模拟动画转为正向动力学动画。Anim. Compression：动画压缩Off：禁用压缩。Unity不会减少关键帧，这个选项能提高动画的精度，但是会降低运行时性能，存储空间和运行时内存占用都会变大。一般不建议禁用压缩，但如果你需要非常精准的动画，禁用后可以得到原始动画，不会有压缩精度误差。Keyframe Reduction：根据设置的误差值移除关键帧。Optimal：Unity自动决定如何压缩。根据设置的误差值移除关键帧并且压缩关键帧。这只会减小动画存储空间占用，运行时内存占用和 Keyframe Reduction 相同。Anim. Compression 不选择Off时，会显示下面三个选项：Rotation Error：旋转变化小于这个误差的关键帧会被删除。值越小动画越精确。Position Error：位置变化小于这个误差的关键帧会被删除。值越小动画越精确。Scale Error：缩放变化小于这个误差的关键帧会被删除。值越小动画越精确。Animated Custom Properties：是否导入自定义属性。在3D建模软件中可以设置一些自定义属性，这个选项可以将这些自定义属性导入进来。Clips：动画片段，Start和End分别代表了该段动画在整段动画中的起始帧和结束帧。下面详细学习。4.Materials 材质Material Creation Mode：里面选项有None、Standard、Import via MaterialDescription （Experimental）None：不导入材质Standard：导入材质用标准材质球，也就是StandardImport via MaterialDescription （Experimental）：根据Fbx里面的材质信息分析用的什么材质，比如 Autodesk InteractiveLocation:Use External Materials （Legacy）:使用外部材质，也就是她会直接导出材质到当前materials文件夹Use Embedded Materials：嵌入材料，就和prefab似的，可以手动赋予。（默认选项。）Extract Textures：导出贴图Extract Materials：导出材质导出贴图就是在导出FBX时候勾选了 Embed Media 的时候会显示，直接从FBX里导出里面的贴图Naming： 定义材质的命名策略属性功能By Base Texture Name使用主贴图命名From Model’s Material使用原本的材质球命名Model Name + Model’s Material使用模型命名+材质命名Search：Search and Remap按钮查找以有材质自动挂到材质上的索引规则属性功能Local Materials Folder在本地 Materials 子文件夹（即模型文件所在的同一文件夹）中查找现有材质。Recursive-Up在所有父文件夹（一直向上追溯到 Assets 文件夹）中的所有 Materials 子文件夹中查找现有材质。Project-Wide在所有 Unity 项目文件夹中查找现有材质。http://www.ppmy.cn/news/1541455.html相关文章洛谷 [语言月赛 202410] 题解(C++)本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录 
题一: 
题目大意和解答思路: 
代码(C): 
题二: 
题目大意和解答思路: 
代码(C): 
题三: 
题目大意和解答思路: 
代码(C): 
题四: 
题目大意和解答思路: 
代码(C): 
题五: 
题目大意和解答思路…阅读更多...《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:38 +0000</pubDate>
    </item>
    <item>
      <title>洛谷 [语言月赛 202410] 题解(C++)</title>
      <link>https://www.ppmy.cn/news/1541454.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维洛谷 [语言月赛 202410] 题解(C++)news/2025/11/4 0:21:37/本文为洛谷 [语言月赛 202410] 的全部题解(最后一题太麻烦暂时给不出完整代码)目录题一:题目大意和解答思路:代码(C++):题二:题目大意和解答思路:代码(C++):题三:题目大意和解答思路:代码(C++):题四:题目大意和解答思路:代码(C++):题五:题目大意和解答思路:代码(C++):题六:题目大意和解答思路:代码(C++):题七:题目大意和解答思路:代码(C++):题八:题目大意和解答思路:题一:B4042 [语言月赛 202410] 顺序结构 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:根据题目对输入进来的变量a进行操作即可代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int a;std::cin &gt;&gt; a;std::cout &lt;&lt; (a + 5) * 3 &lt;&lt; " " &lt;&lt; a * 3 + 5 &lt;&lt; "\n";
}题二:题目大意和解答思路:题目关键:她想知道有哪些刻度和 a 厘米刻度的距离恰好是 b比较a - b &gt;= 0， 比较  a + b &lt;= n满足前者，就输出a - b满足后者，就输出a + b都不满足就输出No solution注意b = 0 的时候，输出a根据上面思路即可很快完成代码我这里使用一个vector简化代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int n, a, b;std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;if (b == 0) {std::cout &lt;&lt; a &lt;&lt; "\n";return 0;}std::vector&lt;int&gt; res;if (a - b &gt;= 0) res.push_back(a - b);if (a + b &lt;= n) res.push_back(a + b);if (res.empty()) {std::cout &lt;&lt; "No solution\n";} else {for (int x : res) {std::cout &lt;&lt; x &lt;&lt; " ";}std::cout &lt;&lt; "\n";}
}题三:B4045 [语言月赛 202410] 同桌 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:就是说，现在是第一周的周六然后每个课程都会在第一次课都会在第一周开始，w为星期几开始，d为隔几周开一次课求下一次最近上课的需要隔多少天都是周一到周五，所以没有其他的条件直接算出每个课程下次上课的间隔，然后求出最小值即可代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int n;std::cin &gt;&gt; n;int res = 14 * 7; //d 最大为14,所以可以初始化14 * 7for (int i = 0; i &lt; n; i++) {int w, d;std::cin &gt;&gt; w &gt;&gt; d;int next = (w - 6) + d * 7;res = std::min(res, next);}std::cout &lt;&lt; res &lt;&lt; "\n";
}题四:B4045 [语言月赛 202410] 同桌 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:就是说，一共有n 个桌子，2 * n个人，然后每两个人坐一个桌子，这两个人是同桌然后输入每个人希望的同桌，判断最后是否能满足每个人的希望，注意自己不能跟自己为同桌很常规的模拟首先用一个大小为2*n + 1的数组A来存数据(下标从1开始)，然后呢首先自己不能跟自己做同桌，那么A[i] != i这个条件必须满足然后判断希望的同桌， 编号A[i] 是编号 第 i 位同学希望的同桌， 那么编号A[i] 希望的同桌呢？很明显是A[A[i]], 那么此时只用判断A[A[i]] == i 这个条件即可代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int n;std::cin &gt;&gt; n;std::vector&lt;int&gt; A(n * 2 + 1);for (int i = 1; i &lt;= 2 * n; i++) {std::cin &gt;&gt; A[i];}for (int i = 1; i &lt;= 2 * n; i++) {bool f = (A[i] != i &amp;&amp; A[A[i]] == i);if (!f) {std::cout &lt;&lt; "No\n";return 0;}}std::cout &lt;&lt; "Yes\n";
}题五:B4046 [语言月赛 202410] 寻找质数 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:题目意思就是，从1 ~ n这n个数字中，满足“孤独数”性质的数字，第k大的是多少可以这么模拟，先定义一个变量cnt, 从n 开始循环遍历到 1，碰到一个满足条件的“孤独数”就把cnt++,当cnt == k的时候，表示找到了第k大的数字，输出然后return 0 即可遍历完还没找到的话，输出-1即可代码(C++):bool is_prime(int n) {if (n &lt;= 1) return false;if (n &lt;= 3) return true;if (n % 2 == 0 || n % 3 == 0) return false;for (int i = 5; i * i &lt;= n; i += 6) {if (n % i == 0 || n % (i + 2) == 0) return false;}return true;
}
bool is_lone(int n, int m, int r) {return is_prime(n) &amp;&amp; n % m == r;
}
int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int n, m, r, k;std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; k;int cnt = 0;for (int i = n; i &gt;= 1; i--) {if (is_lone(i, m, r)) {cnt++;}if (cnt == k) {std::cout &lt;&lt; i &lt;&lt; "\n";return 0;}}std::cout &lt;&lt; "-1\n";
}题六:B4047 [语言月赛 202410] 校门外的施工 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:这题主要是要读清楚题目的意思，一共有m棵树，每个树之间有一片绿化带然后进行了n次施工，施工类型为两种，然后题目是求施工后还剩下多少棵树这题就是源于题目的改编：P1047 [NOIP2005 普及组] 校门外的树 - 洛谷 | 计算机科学教育新生态加了一个绿化带然后和施工方案数据量不大，重复遍历即可首先根据题目条件就是一个长度为2 * m的全部元素初始化为1数组（下标从1开始），然后每一棵树的位置x变成了x * 2 - 1然后每次施工，根据条件，把这一区间都变成0，最后数出树的个数和绿化带个数即可当然还有效率更高的方法，可以参考我的文章，区间合并：算法题练习小技巧之区间合并--套路详细讲解带例题和源码(Python,C++)_区间合并c++-CSDN博客代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int m, n;std::cin &gt;&gt; m &gt;&gt; n;std::vector&lt;int&gt; A(2 * m, 1);while (n--) {int op, l, r;std::cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;if (op == 1) {for (int i = 2 * l; i &lt; r * 2 - 1; i++) {A[i] = 0;}} else {for (int i = 2 * l - 1; i &lt;= r * 2 - 1; i++) {A[i] = 0;}}}int cnt1 = 0, cnt2 = 0;for (int i = 1; i &lt; 2 * m; i++) {if (A[i]) {if (i % 2 == 0) {cnt2++;} else {cnt1++;}}}std::cout &lt;&lt; cnt1 &lt;&lt; " " &lt;&lt; cnt2 &lt;&lt; "\n";
}题七:B4048 [语言月赛 202410] 断章取义 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:有点看不懂这个题目的T是啥意思题目的意思就是说，给一个字符串，让你每一轮删除里面所有的"not"让你输出最后的字符串和删除轮数库函数秒了，先用一个while 1循环，然后 .find("not"),找出第一个not的位置,如果没找到就退出大循环，如果找到了，就从这个位置开始反复找和删，然后cnt++即可代码(C++):int main() {std::ios::sync_with_stdio(0);std::cin.tie(0);int t;std::cin &gt;&gt; t;std::string s;std::cin &gt;&gt; s;int cnt = 0;while (true) {int idx = s.find("not");if (idx == std::string::npos) {break;}while (idx != std::string::npos) {s.erase(idx, 3);idx = s.find("not", idx);}cnt++;}std::cout &lt;&lt; s &lt;&lt; "\n" &lt;&lt; cnt &lt;&lt; "\n";
}题八:B4049 [语言月赛 202410] 平均分计算 - 洛谷 | 计算机科学教育新生态题目大意和解答思路:感觉好麻烦， 而且学号还放在最后一位了，真恶心不过可以用结构体进行模拟吧struct Course {int people;std::vector&lt;int&gt; id;std::vector&lt;int&gt; part;std::vector&lt;int&gt; score;Course(int p) : people(p), id(p), part(p), score(p) {}
};然后最后记得用gcd方法来格式化答案http://www.ppmy.cn/news/1541454.html相关文章《整洁代码最佳实践》阅读心得《整洁代码最佳实践》心得 
阅读《整洁代码最佳实践》这篇文章后&amp;#xff0c;我深感共鸣。作者通过自身经历分享了许多宝贵的观点&amp;#xff0c;不仅强调了整洁代码的重要性&amp;#xff0c;而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会&amp;#xff1a; 
1. 命名的重要性…阅读更多...插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:37 +0000</pubDate>
    </item>
    <item>
      <title>《整洁代码最佳实践》阅读心得</title>
      <link>https://www.ppmy.cn/news/1541453.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维《整洁代码最佳实践》阅读心得news/2025/11/4 0:21:36/《整洁代码最佳实践》心得阅读《整洁代码最佳实践》这篇文章后，我深感共鸣。作者通过自身经历分享了许多宝贵的观点，不仅强调了整洁代码的重要性，而且还提供了一些具体的实践建议。以下是我在阅读后的几点体会：1. 命名的重要性最基础也是最核心的一点就是给变量和函数起有意义的名字。一个好的名字应该能够让读者立刻明白其用途，而不是让人去猜测其作用。例如，将processData1这样的名字改为更具描述性的combineLists，可以让代码更加易读。这种做法不仅提高了代码的可读性，也为后续的维护带来了便利。2. 代码的一致性无论是 Python 的 PEP 8 指南还是 TypeScript 的类型声明，都是为了确保代码风格的一致性。在团队协作中，一致性可以帮助消除由于个人习惯差异所带来的困扰，使得代码更加统一和谐。遵守编码规范不仅是为了美观，更是为了让代码更加易读、易维护。当我们遵循这些规则时，不仅能够提高代码的质量，还能增强团队成员间的相互理解。3. 小函数的力量将一个庞大的函数拆分成多个小函数，每个小函数专注完成一件具体的事情，这样不仅有助于理解，还能简化测试工作。当函数足够小时，它的内部逻辑通常也会更加简单明了，这有助于减少错误的发生。此外，小函数的设计也便于进行单元测试，从而提高代码的整体质量。4. 避免“魔法数字”在代码中使用具有明确意义的常量来代替未加解释的数字，可以让代码的意义更加明确。例如，将0.07更改为SALES_TAX，这样的做法不仅提升了代码的可读性，也让后续的修改变得更加容易。通过这种方式，我们可以在代码中留下清晰的痕迹，方便未来的自己或其他开发者理解。5. 遵循 DRY 原则DRY（Don’t Repeat Yourself）原则鼓励我们避免重复的代码逻辑。通过抽象和重用代码，而不是简单地复制粘贴，可以使得代码更加模块化和灵活。遵循 DRY 原则，不仅可以使代码结构更加清晰，还能降低错误率，提高开发效率。小结整洁的代码不仅让程序运行得更好，更是一种对自己和未来维护者负责的态度。整洁的代码就像是给未来的一份礼物，它减少了后续的维护成本，并体现了编写者的专业素养。作为开发者，我们应该不断学习和实践这些原则，努力写出既高效又美观的代码。在日常工作中，我们要时刻提醒自己编写易于理解、易于修改和易于扩展的代码，让每一行代码都能够清晰地传达其意图。通过这样的方式，我们不仅能够提升个人技能，还能为团队创造更大的价值。代码不仅是写给机器执行的指令，更是写给人类阅读的作品。因此，追求整洁的代码，不仅是技术层面的要求，更是一种职业态度的体现。推荐大家都能阅读《阿里巴巴开发指南》并遵循其中的开发规范，会让我们阅读理解彼此代码时更加高效。http://www.ppmy.cn/news/1541453.html相关文章插入排序（Python）插入排序是一种简单直观的排序算法&amp;#xff0c;其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分&amp;#xff0c;每次从未排序部分取出一个元素&amp;#xff0c;将其插入到已排序部分的适当位置&amp;#xff0c;从而保持已排序部分的有序性…阅读更多...MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:37 +0000</pubDate>
    </item>
    <item>
      <title>插入排序（Python）</title>
      <link>https://www.ppmy.cn/news/1541452.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维插入排序（Python）news/2025/11/4 0:21:36/插入排序是一种简单直观的排序算法，其工作原理类似于我们平时整理扑克牌或书籍的方式。它的核心思想是将数组分为已排序和未排序两部分，每次从未排序部分取出一个元素，将其插入到已排序部分的适当位置，从而保持已排序部分的有序性。插入排序的原理1）初始状态：假设数组的第一个元素是已排序的，其余元素是未排序的。2）遍历：从数组的第二个元素开始，依次取出每一个元素。3）插入：对于每一个取出的元素，将其与已排序部分的元素进行比较，找到其应该插入的位置，并将其插入。4）重复：重复上述步骤，直到所有元素都被插入到已排序部分，此时整个数组即为有序。Python代码实现def insertion_sort(arr):  # 遍历从第二个元素到最后一个元素  for i in range(1, len(arr)):  key = arr[i]  # 当前需要插入的元素  j = i - 1  # 将key插入到已排序部分的适当位置  while j &gt;= 0 and key &lt; arr[j]:  arr[j + 1] = arr[j]  # 将arr[j]向右移动一位  j -= 1  arr[j + 1] = key  # 插入key  return arr  # 测试代码  
if __name__ == "__main__":  arr = [12, 11, 13, 5, 6]  print("排序前的数组:", arr)  sorted_arr = insertion_sort(arr)  print("排序后的数组:", sorted_arr)http://www.ppmy.cn/news/1541452.html相关文章MySQL的并行复制原理1. 并行复制的概念 
并行复制&amp;#xff08;Parallel Replication&amp;#xff09;是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于&amp;#xff0c;并行复制更多关注的是数据块或事务之间的并行执行&amp;#xff0c;而不是单纯的任务并发。在数据库主从复制中&amp;…阅读更多...Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:36 +0000</pubDate>
    </item>
    <item>
      <title>MySQL的并行复制原理</title>
      <link>https://www.ppmy.cn/news/1541451.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQL的并行复制原理news/2025/11/4 0:21:35/1.并行复制的概念并行复制（Parallel Replication）是一种通过同时处理多个复制任务来加速数据复制的技术。它与并发复制的区别在于，并行复制更多关注的是数据块或事务之间的并行执行，而不是单纯的任务并发。在数据库主从复制中，并行复制允许多个事务在从库上同时执行，这样可以充分利用多核CPU的能力，大大提升复制效率。2.并行复制解决的问题并行复制主要解决的问题是：复制延迟：传统的主从复制采用串行方式进行事务复制，当主库有大量并发事务时，从库难以跟上主库的步伐，造成复制延迟。而并行复制能够同时复制多个事务，大幅降低复制延迟。性能瓶颈：在分布式系统中，单线程复制在高并发场景下会成为性能瓶颈，而通过并行执行多个复制任务，可以有效缓解这一瓶颈。3.并行复制的使用场景数据库的主从复制：MySQL、PostgreSQL等数据库都支持并行复制，在高并发场景下能够提高从库的同步速度，降低主从延迟。分布式存储系统：如HDFS、Cassandra等分布式存储系统，数据节点之间的数据复制可以通过并行复制来加速。日志处理：在大规模日志处理系统中，并行复制可以加速日志的备份与同步。4.底层原理设计并行复制的核心原理是在数据同步时，按照事务的独立性或数据块的分片来将复制任务分配到不同的线程进行并行处理，确保多个复制操作可以同时执行。底层设计的关键点：事务分解：将可以并行执行的事务或者数据分片。多线程执行：为每个独立的事务或分片分配一个线程，保证它们能够并行执行。事务依赖管理：如果某些事务之间有依赖关系，需要确保它们的执行顺序。合并结果：等待所有并行任务执行完成，最终将结果合并。5.Java 并行复制模拟代码下面是一个简化的Java代码，模拟并行复制的过程。我们通过使用ExecutorService来管理多个线程并行处理多个数据块。importjava.util.concurrent.*;importjava.util.*;publicclassParallelReplication{// 模拟数据分片privatestaticList&lt;String&gt;dataChunks=newArrayList&lt;&gt;();// 初始化数据static{for(inti=1;i&lt;=10;i++){dataChunks.add("Chunk-"+i);}}// 模拟复制任务类，实现Callable接口staticclassReplicationTaskimplementsCallable&lt;String&gt;{privateStringdataChunk;publicReplicationTask(StringdataChunk){this.dataChunk=dataChunk;}@OverridepublicStringcall()throwsException{// 模拟复制操作System.out.println(Thread.currentThread().getName()+" is replicating: "+dataChunk);Thread.sleep(200);// 模拟复制时间returndataChunk+" replicated successfully.";}}publicstaticvoidmain(String[]args)throwsInterruptedException,ExecutionException{intparallelism=4;// 并行度，表示同时复制的任务数量ExecutorServiceexecutor=Executors.newFixedThreadPool(parallelism);List&lt;Future&lt;String&gt;&gt;results=newArrayList&lt;&gt;();// 提交复制任务到线程池，进行并行处理for(Stringchunk:dataChunks){ReplicationTasktask=newReplicationTask(chunk);Future&lt;String&gt;result=executor.submit(task);results.add(result);}// 等待所有任务完成，并输出结果for(Future&lt;String&gt;result:results){System.out.println(result.get());// 输出每个任务的结果}// 关闭线程池executor.shutdown();}}6.代码解释数据初始化：dataChunks列表中包含10个数据块，表示需要复制的数据，每个块被标记为Chunk-1到Chunk-10。ReplicationTask：这是实现了Callable接口的类，模拟了一个数据块的复制过程。每个任务在执行时会打印当前线程的名称以及正在复制的数据块，并模拟复制需要的时间（200毫秒）。ExecutorService：使用Executors.newFixedThreadPool(parallelism)创建一个固定大小的线程池。在这个例子中，线程池的大小为4，也就是说系统最多可以同时并行执行4个复制任务。Future：每个复制任务的结果由Future对象来表示，主线程通过future.get()方法来获取任务执行的结果。线程池关闭：最后调用executor.shutdown()方法来关闭线程池，确保所有线程执行完毕。7.运行结果程序运行时，将会看到以下输出（部分）：pool-1-thread-1 is replicating: Chunk-1
pool-1-thread-2 is replicating: Chunk-2
pool-1-thread-3 is replicating: Chunk-3
pool-1-thread-4 is replicating: Chunk-4
Chunk-1 replicated successfully.
Chunk-2 replicated successfully.
Chunk-3 replicated successfully.
Chunk-4 replicated successfully.
...输出解析：各个线程同时执行不同的数据块复制任务，展示了并行执行的能力。每个线程会输出它正在处理的数据块，并在复制完成时输出“replicated successfully”表示任务完成。8.并行复制的底层原理事务或数据块分片：并行复制的第一个步骤是将大事务拆分为多个可以独立执行的小事务（例如数据库事务），或者将数据拆分为多个块（例如分布式文件系统中的数据块）。并行执行：多个线程同时执行不同的数据块的复制任务，充分利用系统的多核CPU资源。依赖管理：在某些情况下，如果不同的任务之间存在依赖关系（如某些事务需要按顺序执行），需要引入事务调度或依赖管理机制，确保任务按照依赖关系执行。故障处理：如果并行复制中的某个任务失败，系统需要有重试机制或者回滚机制，确保数据一致性。9.并行复制的应用场景高性能数据库主从复制：在高并发数据库系统中，并行复制可以显著降低主从库之间的延迟，确保从库的数据与主库一致。分布式文件系统：如HDFS或Ceph中的数据块复制，通过并行复制可以加速数据节点之间的同步。大规模日志处理：日志系统中的并行复制可以加速日志的备份与同步过程，提高系统的容错能力。10.借鉴并行复制的思想来实现业务场景你可以借鉴并行复制的思想，用于设计以下业务场景：并行文件上传：将大文件分成多个部分，通过并行上传的方式加速整个上传过程，类似于分片上传的实现。数据批量处理：对于需要处理大量数据的场景，可以将数据分成多个部分，使用多线程并行处理每个部分，提升处理速度。大规模任务调度：在后台任务调度系统中，可以采用并行复制的思想，同时调度多个独立的任务，提高任务处理的吞吐量。在MySQL的发展历程中，每个版本都引入了新的功能来提升复制性能和一致性，尤其是在并行复制领域。以下是各版本中关键复制相关特性的简要说明：11.MySQL不同版本1.MySQL 5.6：库级别并行复制特点：MySQL 5.6引入了库级别的并行复制（schema-based parallel replication），这意味着在主库上同时修改不同数据库的事务可以在从库上并行应用。实现原理：在主库上，所有涉及不同库的事务可以并行执行。在从库上，这些事务会被分配到不同的线程执行，从而提高复制的并发度，减少主从库之间的延迟。局限：只能并行执行不同数据库的事务，如果多个事务作用于同一个库，它们仍然是串行执行。2.MySQL 5.7：组提交（Group Commit）特点：MySQL 5.7增强了并行复制，增加了组提交（group commit）功能。事务在主库提交时，如果有多个事务同时准备提交，它们会被作为一个组提交。实现原理：组提交的主要目的是通过批量提交来减少IO操作次数，进而提升性能。在从库上，这些事务组也可以并行应用，提升复制性能。优势：不仅减少了单个事务的提交等待时间，也允许多个事务在从库上并行应用，进一步提高了从库同步的效率。3.MySQL 8.0：WRITESET 并行复制特点：MySQL 8.0引入了更加先进的WRITESET并行复制，允许事务在表级别甚至行级别并行复制，极大提升了复制的并发能力。实现原理：WRITESET会追踪每个事务写入的行（或行的主键），从而判断事务是否冲突。只要多个事务之间没有修改同一行数据，它们就可以并行应用到从库上。优势：相比库级和表级的并行复制，WRITESET能够更精细地控制并行度，减少冲突，进一步提升复制性能，特别是在高并发写入的场景下。12.总结并行复制通过多线程或多进程同时执行多个复制任务，大幅提高了复制效率，适用于数据库主从复制、分布式存储、日志同步等多个高并发场景。通过Java中的ExecutorService和Callable，可以实现并行复制的功能，有效提升系统的性能和数据同步速度。MySQL 5.6：通过库级别并行复制提升多库场景下的复制效率。MySQL 5.7：通过组提交和批量复制，进一步降低提交的IO开销，增强了并行能力。MySQL 8.0：通过WRITESET实现了更加精细的行级并行复制，使得复制的并发度大大提高，在高并发写入的场景下表现尤为出色。http://www.ppmy.cn/news/1541451.html相关文章Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选实现代码 
&lt;template&gt;&lt;el-tree-v2:data"treeData":props"defaultProps"node-key"id"ref"treeRef"show-checkbox:check-strictly"true":expand-on-click-node"false"node-click"handleNodeClick&amp;quo…阅读更多...Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:35 +0000</pubDate>
    </item>
    <item>
      <title>Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选</title>
      <link>https://www.ppmy.cn/news/1541450.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Element Plus的el-tree-v2 组件实现仅叶子节点显示勾选框，并且只能单选news/2025/11/4 0:21:34/实现代码&lt;template&gt;&lt;el-tree-v2:data="treeData":props="defaultProps"node-key="id"ref="treeRef"show-checkbox:check-strictly="true":expand-on-click-node="false"@node-click="handleNodeClick"@check="handleCheck"/&gt;&lt;/template&gt;&lt;scriptsetup&gt;import{ref}from'vue';consttreeData=ref([// ...树形数据]);constdefaultProps={children:'children',label:'label',};consttreeRef=ref(null);consthandleNodeClick=(nodeData,node)=&gt;{// 如果是叶子节点，则选中它if(node.isLeaf){treeRef.value.setChecked(nodeData,true,true);}};consthandleCheck=(data,{checked})=&gt;{// 处理单选逻辑if(checked){// 清除其他选中的节点constcheckedKeys=treeRef.value.getCheckedKeys();if(checkedKeys.length&gt;1){treeRef.value.setCheckedKeys([data.id]);}}};&lt;/script&gt;&lt;stylescoped&gt;/* 样式穿透，隐藏非叶子节点的复选框 */:deep(.el-tree-node) &gt; .el-tree-node__content .el-checkbox .el-checkbox__inner{display:none;}:deep(.el-tree-node.is-leaf) &gt; .el-tree-node__content .el-checkbox .el-checkbox__inner{display:inline-block;}&lt;/style&gt;实现思路handleNodeClick方法用于处理节点点击事件，如果点击的是叶子节点，则将其选中。handleCheck 方法用于处理复选框的选中事件，确保只有一个叶子节点被选中。使用:check-strictly="true"确保复选框的选择不会影响父子节点。使用:expand-on-click-node="false"确保点击节点不会展开或折叠，这样点击叶子节点时不会触发展开操作。http://www.ppmy.cn/news/1541450.html相关文章Docker容器间链路管理Docker容器是一个轻量级的、可移植的软件打包技术&amp;#xff0c;它允许开发者将应用程序及其依赖项打包到一个独立的容器中&amp;#xff0c;然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制&amp;#xff0c;相互之间不会有任何接口&amp;#xff0c;容器性能开销极低。 
可以将…阅读更多...赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:34 +0000</pubDate>
    </item>
    <item>
      <title>Docker容器间链路管理</title>
      <link>https://www.ppmy.cn/news/1541449.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Docker容器间链路管理news/2025/11/4 0:21:33/Docker容器是一个轻量级的、可移植的软件打包技术，它允许开发者将应用程序及其依赖项打包到一个独立的容器中，然后发布到任何支持Docker的环境中运行。容器是完全使用沙箱机制，相互之间不会有任何接口，容器性能开销极低。可以将docker中的每个容器当成是一个房间里的隔断，如果有两套不同的应用需要部署，你可以选择开设两台虚拟机来运行他们，但是成本太高，服务要求过高。而docker的出现则可以有效的解决这一系列问题，通过轻量的部署来完成多套环境的部署。其网络关系，容器间链路连接则是容器间通信的重要问题。Docker的四种网络模式：1.bridge –network bridge 为每一个容器分配、设置 ip ，并将容器连接到 docker0 虚拟网桥上，这也是默认网络模式，容器之间可以通过IP或者容器名称互相通信，但默认情况下与宿主机网络隔离。2.host –network host 容器不会创建自己的网卡，配置 ip 等，而是使用宿主机的 ip 和端口。这种模式下容器的网络性能较好，但安全性较低，因为容器可以直接访问宿主机的网络资源。3.container –network 容器名称或id 新创建的容器不会创建自己的网卡和配置自己的ip，而是和一个指定的容器共享ip、端口范围。这意味着两个容器将有相同的网络配置，包括IP地址和端口范围。通常用于需要紧密网络交互的场景，如分布式系统中的多个服务实例。4.none –network none 容器有独立的Network namespace，但并没有对其进行任何网络设置。在None模式下，Docker不会为容器配置任何网络设备，容器仅有一个回环接口（lo）。自定义网络Docker允许用户创建自定义的网络，以满足特定的网络拓扑和隔离需求。可以通过docker network create命令创建网络，并指定网络类型（如bridge）、子网、网关等参数。docker network create自定义网络可以实现容器间的服务发现，通过容器名称自动解析IP地址。端口映射使用-p标志可以在容器和宿主机之间映射端口。格式为-p 宿主机端口:容器端口，这使得外部可以通过宿主机的端口访问容器内的服务。-P（大写P）标志会随机映射所有公开的容器端口到宿主机的一个高阶端口上。网络配置文件Docker守护进程的网络配置存储在/etc/docker/daemon.json文件中。修改此文件后，可能需要使用systemctl daemon-reload命令刷新systemd配置，并重启Docker服务以应用新配置。systemctl daemon-reload常用命令查看网络docker network ls创建网络#基础用法网络名称docker network create#创建网络时是可以添加一系列参数的：–driver：驱动程序类型–gateway：主子网的IPV4和IPV6的网关–subnet：代表网段的CIDR格式的子网mynet：自定义网络名称docker network create --driver=bridge --gateway=192.168.137.1 --subnet=192.168.137.0/16 mynet不指定任何选项的时候默认的–driver(网络模式)也是bridge(桥接)但是gateway和subnet会自动生成查看网络数据源docker network inspect 网络名称将容器连接到指定网络docker network connect 网络名称 容器名称断开容器的网络docker network disconnect 网络名称 容器名称删除所有不在使用的网络docker network prune删除一个或多个网络docker network rm 网络名称使用示例创建容器时挂载网络创建一个桥接类型的网络docker network create --driver=bridge --gateway=192.168.137.1 --subnet=192.168.137.0/16 myNet1创建并运行容器时指定网络docker run --name containerName -p 80:80 -d --network myNet1 myNginx不想用时可以断开网络docker network disconnect myNet1 myNginx容器已存在时连接到新网络创建一个桥接类型的网络docker network create --driver=bridge --gateway=192.168.137.1 --subnet=192.168.137.0/16 myNet2为容器连接新的网络执行后myNginx容器的网络就变成了myNet2docker network connect myNet2 myNginx不想用时可以断开网络docker network disconnect myNet2 myNginx容器与容器间访问网络容器之间可以通过以下几种方式互相访问：1、默认桥接网络（docker0）：Docker默认为每个容器分配一个IP，并将它们连接到一个名为docker0的虚拟网桥上。容器之间可以通过这些IP地址直接通信，也可以使用容器名作为主机名进行DNS解析。如果要限制容器间的访问，可以创建自定义网络并控制网络的访问权限。2、自定义网络：使用docker network create命令创建自定义网络，可以选择桥接、overlay等多种网络类型。可以为网络指定子网、网关等，并通过--opt添加额外的网络配置选项。将容器连接到同一自定义网络的容器之间可以透明地通信，不受默认网络的限制。3、端口映射：虽然通常用于容器与宿主机之间的通信，但理论上可以通过宿主机作为中介，实现容器间通信。即使不在同一网络的容器，也可以通过映射到宿主机的端口来间接访问其他容器的服务。http://www.ppmy.cn/news/1541449.html相关文章赋值 浅拷贝 深拷贝赋值操作 
赋值操作&amp;#xff08;如 b  a&amp;#xff09;只是将变量 b 指向变量 a 当前指向的对象。这意味着 b 和 a 引用同一个对象。如果对象是可变的&amp;#xff08;如列表、字典&amp;#xff09;&amp;#xff0c;对对象的修改会反映在所有引用该对象的变量上。 
a  [1, 2, 3]
b  a
a[0]  9…阅读更多...计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:34 +0000</pubDate>
    </item>
    <item>
      <title>赋值 浅拷贝 深拷贝</title>
      <link>https://www.ppmy.cn/news/1541448.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维赋值 浅拷贝 深拷贝news/2025/11/4 0:21:33/赋值操作赋值操作（如b = a）只是将变量b指向变量a当前指向的对象。这意味着b和a引用同一个对象。如果对象是可变的（如列表、字典），对对象的修改会反映在所有引用该对象的变量上。a = [1, 2, 3]
b = a
a[0] = 99
print(a)  # 输出: [99, 2, 3]
print(b)  # 输出: [99, 2, 3]在这个例子中，a和b引用同一个列表对象。修改a的元素会同时影响b。拷贝操作拷贝操作会创建一个新的对象，新对象的内容与原对象相同，但它们是不同的对象。Python 提供了多种拷贝方式，包括浅拷贝和深拷贝。浅拷贝浅拷贝会创建一个新的对象，但新对象中的子对象仍然是原对象中子对象的引用。import copya = [1, [2, 3], 4]
b = copy.copy(a)
a[0] = 99
a[1][0] = 88
print(a)  # 输出: [99, [88, 3], 4]
print(b)  # 输出: [1, [88, 3], 4]在这个例子中，a和b是不同的列表对象，但它们包含的子列表是同一个对象。因此，修改子列表会影响a和b。深拷贝深拷贝会创建一个新的对象，并且递归地拷贝原对象中的所有子对象。新对象和原对象是完全独立的。import copya = [1, [2, 3], 4]
b = copy.deepcopy(a)
a[0] = 99
a[1][0] = 88
print(a)  # 输出: [99, [88, 3], 4]
print(b)  # 输出: [1, [2, 3], 4]在这个例子中，a和b是完全独立的列表对象，修改a不会影响b。总结赋值操作：只是将变量指向同一个对象，对对象的修改会影响所有引用该对象的变量。浅拷贝：创建一个新的对象，但子对象仍然是原对象中子对象的引用。深拷贝：创建一个新的对象，并且递归地拷贝所有子对象，新对象和原对象是完全独立的。可变对象（Mutable Objects）可变对象是指在创建后可以修改其内容的对象。常见的可变对象包括：列表（List）：可以通过索引和切片修改元素。字典（Dictionary）：可以通过键修改值。集合（Set）：可以添加和删除元素。不可变对象（Immutable Objects）不可变对象是指在创建后不能修改其内容的对象。常见的不可变对象包括：整数（int）浮点数（float）字符串（str）元组（tuple）布尔值（boolhttp://www.ppmy.cn/news/1541448.html相关文章计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)1&amp;#xff0c;绪论 
1.1 项目背景 
随着社会发展&amp;#xff0c;网上购物已经成为我们日常生活的一部分。但是&amp;#xff0c;至今为止大部分电商平台都是从人们日常生活出发&amp;#xff0c;出售都是一些日常用品比如&amp;#xff1a;食物、服装等等&amp;#xff0c;并未发现一个专注于鲜花的电商…阅读更多...Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:33 +0000</pubDate>
    </item>
    <item>
      <title>计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)</title>
      <link>https://www.ppmy.cn/news/1541447.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维计算机毕业设计 | vue+springboot 在线花店后台管理系统(附源码)news/2025/11/4 0:21:32/1，绪论1.1 项目背景随着社会发展，网上购物已经成为我们日常生活的一部分。但是，至今为止大部分电商平台都是从人们日常生活出发，出售都是一些日常用品比如：食物、服装等等，并未发现一个专注于鲜花的电商平台。我国地府辽阔，人数众多，现阶段需要鲜花的人们不在少数，而大多时候，人们需要买鲜花的时候都需要去特定的商店购买，并且如果路途遥远还需要耗费较长时间。所以开发一个专注于买鲜花的电商系统来解决人们线下购买商品问题，使鲜花也能通过网上购物的方式购买。1.2 项目意义通过前期调研、需求分析、数据库设计。系统的设计与实现和测试来构建一个Web端鲜花购物的网站，其目的是构建一个在线花店后台管理系统，让用户可以在网上进行购物、商家也可以在网上进行菜品商品的发布，让更多的用户购买自己的菜品。并在存在系统管理员对用户、商品等信息进行统一的管理，维护好在线花店后台管理系统的秩序。2，系统设计功能权限图3，需求分析在线花店后台管理系统内含角色权限管理和菜单权限管理，用户可自定义系统角色用户登录：不同用户登录后进入对应身份的后台管理界面（本系统用户为管理员、采购员、销售员）。用户管理：用户是系统操作者，该功能主要完成系统用户配置。角色管理：管理员为角色分配菜单权限。菜单管理：对菜单信息进行新增、修改及删除。供应商管管理：对供应商信息进行新增、修改及删除。客户管理：对客户信息进行新增、修改及删除。采购入库管理：采购员录入采购申请单，并由管理员审核，审核通过后由采购员进行入库操作。入库统计：入库信息统计。销售出库管理：销售员录入出库通知单，并由管理员审核，审核通过后由销售员进行出库操作。出库统计：出库信息统计。寄养服务管理：录入寄养信息，价格结算。花材管理：对花材信息进行新增、修改及删除。花材类别管理：对花材类别信息进行新增、修改及删除。单位管理:对单位信息进行新增、修改及删除。库存盘点:盘点所有花材的库存，提醒采购员及时采购。登录日志：记录所有用户登录时间及用户名。数据分析：统计所有经营数据，包括各季度客户数量统计及热销花卉排行等。4，技术分析后端技术技术说明官网SpringBootWeb应用开发框架https://spring.io/projects/spring-bootSpringSecurity认证和授权框架https://spring.io/projects/spring-securityMyBatisORM框架http://www.mybatis.org/mybatis-3/zh/index.htmlMyBatisGenerator数据层代码生成器http://www.mybatis.org/generator/index.htmlDruid数据库连接池https://github.com/alibaba/druidJWTJWT登录支持https://github.com/jwtk/jjwtLombokJava语言增强库https://github.com/rzwitserloot/lombokPageHelperMyBatis物理分页插件http://git.oschina.net/free/Mybatis_PageHelperSwagger-UIAPI文档生成工具https://github.com/swagger-api/swagger-ui前端技术技术说明官网Vue前端框架https://vuejs.org/Vue-router路由框架https://router.vuejs.org/Vuex全局状态管理框架https://vuex.vuejs.org/Element前端UI框架https://element.eleme.ioAxios前端HTTP框架https://github.com/axios/axiosv-charts基于Echarts的图表框架📣 有源码 获取源码5，页面展示5.1 登录5.2 系统首页5.3 系统管理用户管理角色管理菜单管理5.4 业务管理客户管理供应商管理采购管理查看采购单添加采购单销售管理查看采购申请单新增采购单入库管理新增入库单入库统计出库管理新增出库单出库统计寄养服务管理5.5 商品管理花材管理花材类别管理单位管理库存盘点5.6 个人中心修改密码个人信息http://www.ppmy.cn/news/1541447.html相关文章Python GUI 编程：tkinter 初学者入门指南——复选框在本文中&amp;#xff0c;将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。 
复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值&amp;#xff0c;通常&amp;#xff0c;当希望让用户在两个值之间进行选择时&amp;#xff0c;可以使用复选框。 
要创建复选框&amp;#xff0c;…阅读更多...RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:32 +0000</pubDate>
    </item>
    <item>
      <title>Python GUI 编程：tkinter 初学者入门指南——复选框</title>
      <link>https://www.ppmy.cn/news/1541446.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python GUI 编程：tkinter 初学者入门指南——复选框news/2025/11/4 0:21:31/在本文中，将介绍 tkinter Checkbox 复选框小部件以及如何有效地使用它。复选框是一个允许选中和取消选中的小部件。复选框可以保存一个值，通常，当希望让用户在两个值之间进行选择时，可以使用复选框。要创建复选框，请使用如下构造函数。checkbox = tk.Checkbutton(master,text='&lt;checkbox label&gt;',command=check_changed,variable=checkbox_var,onvalue='&lt;value_when_checked&gt;',offvalue='&lt;value_when_unchecked&gt;')text 参数：指定复选框的显示标签。command 参数：选中或取消选中复选框时调用的命令。variable 参数：保存复选框当前值的变量。选中复选框，则变量的值为 1。否则为 0。onvalue、offvalue 参数：指定 variable 变量 0 和 1 以外的其他值。import tkinter as tk
from tkinter.messagebox import showinfo
root = tk.Tk()
root.geometry('600x400+200+200')
root.title('Checkbutton 复选框演示')# 创建变量，保存复选框的值
agr = tk.StringVar()# 定义函数，复选框状态发生变化就调用该函数
def agr_changed():tk.messagebox.showinfo(title='是否同意', message=agr.get())# 创建复选框
checkbox = tk.Checkbutton(root,text='是否同意',command=agr_changed,variable=agr,onvalue='同意',offvalue='不同意')
checkbox.pack()
root.mainloop()以下示例使用 indicatoron=0 选项取消复选框前面的小方块，取消复选框的 Text 并显示图像。import tkinter as tk
from tkinter.messagebox import showinfo
root = tk.Tk()
root.geometry('600x400+200+200')
root.title('Checkbutton 复选框演示')
frame = tk.LabelFrame(root, text='请选择', padx=30, pady=10)
frame.pack(padx=100, pady=100)
checked_image = tk.PhotoImage(file="logo.png")
unchecked_image = tk.PhotoImage(file="logo2.png")
checkbutton_1 = tk.Checkbutton(frame, indicatoron=0, overrelief="sunken", image=unchecked_image, selectimage=checked_image)
checkbutton_1.pack(side=tk.LEFT)
checkbutton_2 = tk.Checkbutton(frame, indicatoron=0, overrelief="sunken", image=unchecked_image, selectimage=checked_image)
checkbutton_2.pack(side=tk.LEFT)
checkbutton_3 = tk.Checkbutton(frame, indicatoron=0, overrelief="sunken", image=unchecked_image, selectimage=checked_image)
checkbutton_3.pack(side=tk.LEFT)
checkbutton_4 = tk.Checkbutton(frame, indicatoron=0, overrelief="sunken", image=unchecked_image, selectimage=checked_image)
checkbutton_4.pack(side=tk.LEFT)
root.mainloop()Checkbox 复选框选项方法说明deselect()取消复选框选择。select()选择复选框。toggle()选择和取消选择之间切换。以下示例设置两个按钮，利用 deselect() 和 select() 方法，全选和取消全选所有复选框。import tkinter as tk
root = tk.Tk()
root.geometry('600x400+200+200')
root.title('Checkbutton 复选框演示')def clear_selection():cb1.deselect()cb2.deselect()cb3.deselect()cb4.deselect()cb5.deselect()cb6.deselect()def selection():cb1.select()cb2.select()cb3.select()cb4.select()cb5.select()cb6.select()var1 = tk.BooleanVar()
var2 = tk.BooleanVar()
var3 = tk.BooleanVar()
var4 = tk.BooleanVar()
var5 = tk.BooleanVar()
var6 = tk.BooleanVar()frame1 = tk.LabelFrame(root, text='Group 1', padx=30, pady=10)
frame1.pack(side=tk.LEFT, padx=50)
frame2 = tk.LabelFrame(root, text='Group 2', padx=30, pady=10)
frame2.pack(side=tk.RIGHT, padx=50)
cb1 = tk.Checkbutton(frame1, text='Number 1', variable=var1)
cb1.pack()
cb2 = tk.Checkbutton(frame1, text='Number 2', variable=var2)
cb2.pack()
cb3 = tk.Checkbutton(frame1, text='Number 3', variable=var3)
cb3.pack()
cb4 = tk.Checkbutton(frame2, text='Number 4', variable=var4)
cb4.pack()
cb5 = tk.Checkbutton(frame2, text='Number 5', variable=var5)
cb5.pack()
cb6 = tk.Checkbutton(frame2, text='Number 6', variable=var6)
cb6.pack()button1 = tk.Button(root, text='Unselect all', command=clear_selection)
button1.pack()
button2 = tk.Button(root, text='Select All', command=selection)
button2.pack()
root.mainloop()Checkbox 复选框选项选项说明master指定复选框的父级窗口或框架。variable保存复选框当前值的变量，用于存储复选框的选中状态。onvalue指定当复选框被选中时，variable变量的值。offvalue指定当复选框未被选中时，variable变量的值。command指定一个函数，当复选框的状态改变时，该函数将被调用。text指定复选框旁边显示的文本。image指定一个图像对象，显示在复选框旁边。compound指定图像和文本的对齐方式，如TOP, BOTTOM, LEFT, RIGHT。invcmd指定一个函数，当复选框的状态改变时，如果command指定的函数返回False，则调用此函数。selectcolor指定复选框被选中时的背景颜色。height指定复选框的高度（通常用于显示图像）。width指定复选框的宽度（通常用于显示文本）。anchor指定文本的对齐方式，如W（西）, E（东）, N（北）, S（南）, CENTER。justify指定文本的对齐方式，如LEFT, RIGHT, CENTER。padx指定复选框与其文本之间的水平填充。pady指定复选框与其文本之间的垂直填充。indicatoron是否绘制前边作为选择的小方块，设置为0,可以将整个小部件变成复选框。http://www.ppmy.cn/news/1541446.html相关文章RISC-V笔记——显式同步1. 前言 
RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。 2. 显示同步 
显示同步指的是&amp;#xff1a…阅读更多...基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:31 +0000</pubDate>
    </item>
    <item>
      <title>RISC-V笔记——显式同步</title>
      <link>https://www.ppmy.cn/news/1541445.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维RISC-V笔记——显式同步news/2025/11/4 0:21:30/1. 前言RISC-V的RVWMO模型主要包含了preserved program order、load value axiom、atomicity axiom、progress axiom和I/O Ordering。今天主要记录下preserved program order(保留程序顺序)中的Explicit Synchronization(显示同步)。2. 显示同步显示同步指的是：a操作在程序顺序中先于b操作，a和b都访问常规主存，不是I/O区域，如果存在以下任何一个条件，那么a操作和b操作在全局内存顺序中的顺序也不会变。a和b之间有FENCE指令。a拥有acquire语义。b拥有release语义。a和b都有RCsc语义。a和b是配对的。关于第一点，默认情况下，FENCE指令确保所有在程序顺序中位于FENCE之前的指令的内存访问（“前导集”）在全局内存顺序中比在程序顺序中位于FENCE之后的指令的内存访问（“后续集”）出现得更早。不过，为了性能上的考量，FENCE可以选择性进一步地限制前导集和后续集为较小的内存访问集。具体来说，FENCE有PR、PW、SR和SW bits，它们限制了前导集和后续集所包含的指令类型。如果PR为1，那么前导集包括load；如果PW为1，那么前导集包含store；如果SR为1，那么后续集包括load；如果SW为1，那么后续集包括store。FENCE中PR、PW、SR和SW这4bit可以组成16种FENCE语义，但不是每一种组合都有用的。其中有7中组合具有空的前导集或后续集，因此是无操作的。另外FENCE还有一个额外的编码为FENCE.TSO，提供它主要是方便映射到“acquire+release”或RVTSO语义上。不过在这10(16-7+1)个选项中，只有下面6个在实践中常用：FENCE RW,RWFENCE.TSOFENCE RW,WENCE R,RWFENCE R,RFENCE W,WRISC-V手册建议程序员只使用这6种FENCE指令，其他组合的FENCE指令可能不生效，而且会造成意外的结果。关于第二点，通常在关键代码的临界区开始时使用acquire操作，要求在程序顺序在acquire之后的load和store操作也要在全局内存顺序上在acquire之后。这样可以确保关键代码临界区内位于acquire操作之后的所有load和store可以获取最新的数据。Acquire操作排序可以通过两种方式来实现。使用acquire语义的指令：它只针对同步变量本身强制排序使用FENCE R,RW：它针对之前的所有load强制排序如下代码1使用第一种方案，因为amoswap使用了aq，所以临界区的load和store保证出现于获取锁的amoswwap之后的全局内存顺序中。然而a1和a2指向不同的内存位置，临界区的load和store可能与它们乱序，也就是在全局内存顺序中，它们之间的顺序不是固定的。如下代码2使用第二种方案，在这种情况下，尽管amoswap不强制使用aq进行排序，但FENCE仍然强制amoswap在全局内存顺序中出现的时间比临界区中的所有load和store都要早。但使用FENCE的一个副作用就是，FENCE还强制执行了额外的排序，它还要求程序开始时的a2不相关的load指令出现的时间要早于临界区的load和store。因此，FENCE命令比aq命令在排序上更强硬些，当然也更粗糙些。关于第三点，Release排序和acquire排序的工作原理类似，只是排序的方向相反。Release语义要求在release操作程序顺序之前的所有load和store也要在全局内存顺序上先于release操作。这样可以确保在全局内存顺序中，临界区的内存访问出现在release释放锁的store之前。就像acquire语义一样，release语义可以通过两种方式来实现：使用带release的指令使用FENCE RW,W指令例子就如同第二点中代码1和代码2。代码1在关键代码片段的末尾使用rl来确保顺序，其中a3和a4与rl之间没有固定关系，在全局内存顺序上没有固定顺序。代码2在关键片段的末尾使用FENCE RW,W来确保顺序。关于第四点，如果单独使用RCpc语义，就不会强制store release到load acquire的顺序，这有助于移植在TSO或RCpc内存模型下编写的代码。为了确保store release到load acquire的顺序，代码必须使用RCsc的语义。关于第五点，在全局内存顺序中，SC必须出现在与其配对的LR之后。由于固有的语法数据依赖，通常使用LR/SC来执行原子读-修改-写操作。但其实即使store的值在语法上不依赖于成对LR返回的值，这一点也适用。http://www.ppmy.cn/news/1541445.html相关文章基于微信小程序的智能社区服务管理系统作者&amp;#xff1a;计算机学姐 开发技术&amp;#xff1a;SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等&amp;#xff0c;“文末源码”。 专栏推荐&amp;#xff1a;前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码 精品专栏&amp;#xff1a;…阅读更多...Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:31 +0000</pubDate>
    </item>
    <item>
      <title>基于微信小程序的智能社区服务管理系统</title>
      <link>https://www.ppmy.cn/news/1541444.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维基于微信小程序的智能社区服务管理系统news/2025/11/4 0:21:29/作者：计算机学姐开发技术：SpringBoot、SSM、Vue、MySQL、JSP、ElementUI、Python、小程序等，“文末源码”。专栏推荐：前后端分离项目源码、SpringBoot项目源码、Vue项目源码、SSM项目源码、微信小程序源码精品专栏：Java精选实战项目源码、Python精选实战项目源码、大数据精选实战项目源码系统展示基于微信小程序+Java+SpringBoot+Vue+MySQL的智能社区服务管理系统开发语言：Java数据库：MySQL技术：SSM、Vue、微信小程序工具：IDEA/Ecilpse、Navicat、Maven小程序界面首页房屋家政个人中心后台界面摘要基于微信小程序的智能社区服务管理系统，通过整合小程序的技术优势，实现了智能化、精细化的社区管理。该系统涵盖了用户注册登录、服务类型分类、活动信息发布、活动报名处理、活动相册展示等功能，极大地提升了物业服务的效率和质量。同时，系统还具备智能门禁、监控等安全措施，加强了社区的安全防范。此外，通过线上社交平台，居民可以分享生活、组织活动，促进了邻里间的沟通和互动。整体而言，该系统为现代社区管理带来了全新的解决方案，提升了居民的居住体验。研究意义研究基于微信小程序的智能社区服务管理系统，对于推动社区管理的智能化、精细化具有深远意义。该系统不仅提升了物业服务的响应速度和效率，还通过智能化安全措施增强了社区的安全性。同时，线上社交平台的建设促进了邻里间的互动和沟通，增强了社区的凝聚力和归属感。该系统为现代社区管理提供了新的思路和方法，对于构建更加和谐、智能的社区环境具有重要意义。研究目的本研究旨在设计并实现一个基于微信小程序的智能社区服务管理系统，以提升社区管理的智能化和精细化水平。通过该系统，实现志愿者和服务活动的有效匹配，优化活动安排，提升志愿服务效率。同时，为社区管理者和居民提供一个交互式的平台，方便信息交流和资源共享。此外，该系统还致力于提升居民对社区服务的满意度和获得感，促进社区的和谐发展。文档目录1.绪论1.1 研究背景1.2 研究意义1.3 研究现状1.4 研究内容2.相关技术2.1 Java语言2.2 B/S架构2.3 MySQL数据库2.4 SSM框架2.5 小程序框架3.系统分析3.1 系统可行性分析3.1.1 技术可行性分析3.1.2 经济可行性分析3.1.3 操作可行性分析3.2 系统性能分析3.2.1 易用性指标3.2.2 可扩展性指标3.2.3 健壮性指标3.2.4 安全性指标3.3 系统流程分析3.3.1 操作流程分析3.3.2 登录流程分析3.3.3 信息添加流程分析3.3.4 信息删除流程分析3.4 系统功能分析4.系统设计4.1 系统概要设计4.2 系统功能结构设计4.3 数据库设计4.3.1 数据库E-R图设计4.3.2 数据库表结构设计5.系统实现5.1 小程序功能实现5.2 后台功能实现6.系统测试6.1 测试目的及方法6.2 系统功能测试6.2.1 登录功能测试6.2.2 添加功能测试6.2.3 删除功能测试6.3 测试结果分析代码{"pages":["pages/index/index", // 首页"pages/login/login", // 登录页"pages/community/community"// 社区页，示例中未详细展开],"window":{"navigationBarTitleText":"智能社区服务","navigationBarBackgroundColor":"#ffffff","navigationBarTextStyle":"black"},"tabBar":{"list":[{"pagePath":"pages/index/index","text":"首页","iconPath":"images/home.png","selectedIconPath":"images/home-active.png"},{"pagePath":"pages/community/community","text":"社区","iconPath":"images/community.png","selectedIconPath":"images/community-active.png"},{"pagePath":"pages/login/login","text":"我的","iconPath":"images/user.png","selectedIconPath":"images/user-active.png"}]}}总结基于微信小程序的智能社区服务管理系统，通过智能化、精细化的管理手段，极大地提升了社区管理的效率和质量。该系统不仅解决了传统社区管理中的诸多痛点问题，还适应了现代城市生活的需求变化。未来，随着技术的不断进步和应用的不断深化，该系统将在社区管理中发挥越来越重要的作用，为居民提供更加便捷、智能的社区服务。获取源码一键三连噢~http://www.ppmy.cn/news/1541444.html相关文章Docker 安装Postgres和PostGIS，并制作镜像1. 查找postgres和postgis现有的镜像和版本号 
镜像搜索网站&amp;#xff1a;https://docker.aityp.com/  测试使用的是postgres:15.4 和 postgis:15-3.4 
2、镜像拉取 
docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成&amp;#xff0c;docker images 查看如…阅读更多...CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:30 +0000</pubDate>
    </item>
    <item>
      <title>Docker 安装Postgres和PostGIS，并制作镜像</title>
      <link>https://www.ppmy.cn/news/1541443.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Docker 安装Postgres和PostGIS，并制作镜像news/2025/11/4 0:21:29/1. 查找postgres和postgis现有的镜像和版本号镜像搜索网站：https://docker.aityp.com/测试使用的是postgres:15.4 和 postgis:15-3.42、镜像拉取docker pull postgres:15.4docker pull postgis/postgis:15-3.4镜像下载完成，docker images 查看如下3、启动容器# 创建postgres文件夹mkdir/home/postgres注意：--privileged=true参数一定要加上，否则会报无权限错误。# 启动普通postgres的镜像docker run -it --name postgres\# 创建容器名称--restart=always\# 自动启动--privileged=true\# 赋予容器几乎与主机相同的权限ALLOW_IP_RANGE=0.0.0.0/0\# 允许所有ip访问,不加非本机ip访问不了-ePOSTGRES_USER=postgres\# postgresql 用户名-ePOSTGRES_PASSWORD=P@ssw0rd123456 -e\# postgresql 密码-v /home/postgres/postgresql :/var/lib/postgresql\# postgresql数据卷映射到本地环境-p54321:5432# 占用服务器端口:docker内部虚拟端口-d postgres:15.4# 使用的镜像名称:版本# 启动带postgis的镜像docker run --name postgis_postgres\# 创建容器名称--restart=always\# 自动启动--privileged=true\# 赋予容器几乎与主机相同的权限ALLOW_IP_RANGE=0.0.0.0/0\# 允许所有ip访问,不加非本机ip访问不了-ePOSTGRES_USER=postgres\# postgresql 用户名-ePOSTGRES_PASSWORD=P@ssw0rd123456\# postgresql 密码-p54321:5432   /# 占用服务器端口:docker内部虚拟端口-v /host/postgres/postgis:/var/lib/postgis\# postgis数据卷映射到本地环境-v /host/postgres/postgresql:/var/lib/postgresql\# postgresql数据卷映射到本地环境-d postgis/postgis:15-3.4# 使用的镜像名称:版本http://www.ppmy.cn/news/1541443.html相关文章CIM+全场景应用，铸就智慧城市发展新篇在数字化浪潮的推动下&amp;#xff0c;智慧城市建设正成为全球城市发展的新趋势。而CIM&amp;#xff08;城市信息模型&amp;#xff09;作为智慧城市建设的核心&amp;#xff0c;正以其强大的数据集成和分析能力&amp;#xff0c;引领着城市发展的新篇章。今天&amp;#xff0c;让我们一起探讨CIM全场景应用…阅读更多...C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:29 +0000</pubDate>
    </item>
    <item>
      <title>CIM+全场景应用，铸就智慧城市发展新篇</title>
      <link>https://www.ppmy.cn/news/1541442.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维CIM+全场景应用，铸就智慧城市发展新篇news/2025/11/4 0:21:28/在数字化浪潮的推动下，智慧城市建设正成为全球城市发展的新趋势。而CIM（城市信息模型）作为智慧城市建设的核心，正以其强大的数据集成和分析能力，引领着城市发展的新篇章。今天，让我们一起探讨CIM+全场景应用如何助力智慧城市的建设。1. CIM的定义与重要性CIM是一种集成了城市物理空间、社会经济活动、环境资源等多源信息的三维模型。它不仅包括了建筑物、道路、桥梁等基础设施的三维数据，还涵盖了人口、交通、经济等动态信息。CIM的核心价值在于其能够为城市管理者提供全面、实时、准确的城市信息，从而支持更高效的决策制定。2. CIM+全场景应用的内涵CIM+全场景应用，意味着将CIM技术与物联网、大数据、人工智能等现代信息技术深度融合，实现城市管理的全面智能化。这包括但不限于以下几个方面：智能交通系统：通过CIM集成交通流量数据，实现交通信号的智能调控，优化交通流。智慧能源管理：利用CIM分析能源消耗模式，优化能源分配，提高能源利用效率。环境监测与保护：通过CIM监控城市环境质量，及时预警污染事件，保护城市生态。公共安全监控：集成CIM与视频监控系统，提高公共安全事件的响应速度和处理效率。地图数据的下载、转换、浏览、编辑（基于 AutoCAD），可使用GeoSaaS的相关工具GIS数据转换器(测绘数据转换软件)——支持DWG(AutoCAD)、DXF、SHP、MDB(ArcGIS)、Kml(google)、Kmz、Gpx、GeoJson、Excel、CSV、TXT、SQL Server、MySQL、PostgreSQL、PDF、JPG、GeoTiff、Image(img)、Bitmap(bmp)、Png等格式批量转换，支持西安80坐标、2000国家大地坐标、北京54坐标、WGS-84坐标、百度坐标、火星坐标(谷歌、高德、腾讯)、墨卡托坐标系的任意转换,支持批量转换和图层合并,支持地图数据的下载、浏览和编辑3. CIM+全场景应用的实践案例在全球范围内，许多城市已经开始探索CIM+全场景应用的实践。例如：新加坡：通过CIM集成了城市交通、能源、环境等多个领域的数据，实现了城市管理的智能化。上海：利用CIM技术，实现了城市交通的实时监控和智能调度，有效缓解了交通拥堵问题。4. 面临的挑战与展望尽管CIM+全场景应用前景广阔，但在实践中也面临着数据安全、隐私保护、技术整合等挑战。未来，我们需要：加强数据安全与隐私保护：建立健全的数据安全管理体系，保护个人和企业数据不被滥用。推动技术整合与创新：鼓励跨领域的技术合作，推动CIM技术的持续创新。培养专业人才：加强相关领域的教育和培训，培养更多CIM技术的专业人才。结语CIM+全场景应用是智慧城市建设的重要方向，它将为我们的城市带来更高效、更智能、更绿色的管理方式。让我们携手共进，共同开启智慧城市发展的新篇章。http://www.ppmy.cn/news/1541442.html相关文章C#中的LINQ之美：优雅的数据查询与操作LINQ&amp;#xff08;Language Integrated Query&amp;#xff0c;语言集成查询&amp;#xff09;是C#中一个强大的工具&amp;#xff0c;它将查询功能直接融入到语言中&amp;#xff0c;使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率&amp;#xff0c;而且让代码…阅读更多...PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:28 +0000</pubDate>
    </item>
    <item>
      <title>C#中的LINQ之美：优雅的数据查询与操作</title>
      <link>https://www.ppmy.cn/news/1541441.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C#中的LINQ之美：优雅的数据查询与操作news/2025/11/4 0:21:27/LINQ（Language Integrated Query，语言集成查询）是C#中一个强大的工具，它将查询功能直接融入到语言中，使开发者能够以一种更直观、更接近自然语言的方式来操作数据。LINQ不仅能极大地提高开发效率，而且让代码变得更加简洁易读。LINQ的语法LINQ的语法主要分为两种：查询语法：这种语法更接近SQL，具有很强的可读性。方法语法：这种语法使用一系列扩展方法来实现查询，更加灵活。查询语法示例：varquery=frompersoninpeoplewhereperson.Age&gt;30selectperson.Name;方法语法示例：varquery=people.Where(person=&gt;person.Age&gt;30).Select(person=&gt;person.Name);LINQ的工作原理LINQ的底层实现是基于迭代器模式的。当我们执行一个LINQ查询时，它并不会立即执行，而是创建了一个表示查询的表达式树。只有当我们对查询结果进行遍历时，表达式树才会被执行，并且结果会被延迟加载。LINQ的应用场景及示例1.筛选数据int[]numbers={5,4,1,3,9,8,6,7,2,0};varevenNumbers=numbers.Where(n=&gt;n%2==0);2.投影数据List&lt;Person&gt;people=newList&lt;Person&gt;{/* ... */};varnames=people.Select(p=&gt;p.Name);3.排序数据varsortedPeople=people.OrderBy(p=&gt;p.Age);4.分组数据vargroupedByAge=people.GroupBy(p=&gt;p.Age);5.聚合操作int[]numbers={5,4,1,3,9,8,6,7,2,0};intsum=numbers.Sum();doubleaverage=numbers.Average();6.连接数据varorders=newList&lt;Order&gt;{/* ... */};varcustomers=newList&lt;Customer&gt;{/* ... */};varcustomerOrders=orders.Join(customers,o=&gt;o.CustomerId,c=&gt;c.Id,(o,c)=&gt;new{CustomerName=c.Name,OrderTotal=o.Total});7.集合操作vardistinctNumbers=numbers.Distinct();varunion=numbers.Union(new[]{10,11,12});8.条件判断boolhasAnyEvenNumber=numbers.Any(n=&gt;n%2==0);9.数量统计intcount=people.Count(p=&gt;p.Age&gt;30);10.自定义扩展方法publicstaticIEnumerable&lt;T&gt;MyCustomFilter&lt;T&gt;(thisIEnumerable&lt;T&gt;source,Func&lt;T,bool&gt;predicate){foreach(Telementinsource){if(predicate(element))yieldreturnelement;}}LINQ的优势统一的数据访问：LINQ提供了一个统一的接口来访问各种数据源，使得开发者可以专注于业务逻辑。提高代码可读性：LINQ的语法简洁明了，更容易理解。延迟执行：延迟执行可以提高性能，避免不必要的计算。丰富的操作符：LINQ提供了一系列丰富的操作符，可以实现各种各样的数据查询和操作。集成到IDE：Visual Studio对LINQ提供了很好的支持，包括智能感知、代码提示等。LINQ作为C#语言的一大亮点，为开发者提供了一种优雅、高效的方式来操作数据。通过学习和掌握LINQ，我们可以写出更加简洁、可读性更高的代码，提高开发效率。http://www.ppmy.cn/news/1541441.html相关文章PHP如何实现页面跳转在PHP中&amp;#xff0c;实现页面跳转有多种方法&amp;#xff0c;这些方法包括使用HTTP头信息、JavaScript以及Meta标签。 
方法一&amp;#xff1a;使用HTTP头信息 
PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式&amp;#xff0c;因为它不需要依赖客户端的Java…阅读更多...等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:27 +0000</pubDate>
    </item>
    <item>
      <title>PHP如何实现页面跳转</title>
      <link>https://www.ppmy.cn/news/1541440.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维PHP如何实现页面跳转news/2025/11/4 0:21:26/在PHP中，实现页面跳转有多种方法，这些方法包括使用HTTP头信息、JavaScript以及Meta标签。方法一：使用HTTP头信息PHP可以使用header()函数发送HTTP头信息来实现页面跳转。这是最常用和推荐的方式，因为它不需要依赖客户端的JavaScript。示例代码：&lt;?php  
// 跳转到指定的URL  
header("Location: http://www.example.com/");  
exit; // 确保脚本停止执行  
?&gt;注意事项：必须在任何HTML输出之前调用：header()函数必须在任何实际输出（如HTML标记、空格或echo语句）之前调用，否则会引发错误。使用exit或die：在调用header()之后，使用exit或die函数来确保脚本停止执行，避免后续代码被执行。状态码：除了基本的跳转，你还可以指定HTTP状态码。例如，使用301表示永久重定向，302表示临时重定向。&lt;?php  
// 永久重定向  
header("Location: http://www.example.com/", true, 301);  
exit;  // 临时重定向  
header("Location: http://www.example.com/", true, 302);  
exit;  
?&gt;方法二：使用JavaScript在某些情况下，你可能希望在客户端使用JavaScript进行页面跳转。这通常用于需要在跳转之前进行一些客户端验证或处理的情况。示例代码：&lt;?php  
echo '&lt;script type="text/javascript"&gt;';  
echo 'window.location.href="http://www.example.com/";';  
echo '&lt;/script&gt;';  
?&gt;注意事项：依赖JavaScript：这种方式依赖于客户端的JavaScript支持，如果用户的浏览器禁用了JavaScript，跳转将不会执行。页面内容：由于这种方式是在HTML中嵌入JavaScript，所以你可以在跳转之前显示一些内容或进行其他操作。方法三：使用Meta标签你也可以在HTML中使用Meta标签来实现页面跳转，但这种方式不如前两种常用。示例代码：&lt;?php  
echo '&lt;!DOCTYPE html&gt;';  
echo '&lt;html&gt;';  
echo '&lt;head&gt;';  
echo '&lt;meta http-equiv="refresh" content="0;url=http://www.example.com/"&gt;';  
echo '&lt;/head&gt;';  
echo '&lt;body&gt;';  
echo '&lt;/body&gt;';  
echo '&lt;/html&gt;';  
?&gt;注意事项：延迟跳转：content属性中的第一个值表示延迟时间（以秒为单位），0表示立即跳转。不推荐：这种方法不推荐用于实际的PHP应用中，因为它依赖于HTML解析和客户端的JavaScript支持（尽管Meta标签本身不依赖JavaScript执行）。方法四：结合条件判断在实际应用中，页面跳转往往需要根据某些条件来判断。例如，用户登录成功后跳转到主页，登录失败则跳转到登录页面。示例代码：&lt;?php  
session_start();  // 假设有一个登录验证函数  
$isLoggedIn = login_check();  if ($isLoggedIn) {  header("Location: http://www.example.com/home.php");  exit;  
} else {  header("Location: http://www.example.com/login.php?error=1");  exit;  
}  function login_check() {  // 这里是登录验证逻辑，返回true表示登录成功，false表示登录失败  // 示例：  return isset($_SESSION['user_id']);  
}  
?&gt;注意事项：条件判断：根据业务逻辑进行条件判断，决定跳转到哪个页面。安全性：确保登录验证逻辑的安全性，避免潜在的安全漏洞。方法五：使用框架的跳转功能如果你使用的是PHP框架（如Laravel、Symfony、CodeIgniter等），这些框架通常提供了自己的页面跳转方法。Laravel示例：&lt;?php  
// 在控制器中  
return redirect('http://www.example.com/');  // 命名路由  
return redirect()-&gt;route('home');  // 带参数的跳转  
return redirect()-&gt;with('status', 'Login successful')-&gt;to('/home');  
?&gt;Symfony示例：&lt;?php  
// 在控制器中  
return $this-&gt;redirectToRoute('home');  // 带参数的跳转  
return $this-&gt;redirectToRoute('show_item', ['id' =&gt; $itemId])-&gt;with('success', 'Item updated successfully');  
?&gt;注意事项：框架文档：查阅你所使用的框架的官方文档，了解如何使用框架提供的跳转功能。一致性：使用框架提供的跳转方法可以保持代码的一致性和可维护性。总结PHP实现页面跳转有多种方法，包括使用HTTP头信息、JavaScript和Meta标签。其中，使用HTTP头信息是最常用和推荐的方式，因为它不需要依赖客户端的JavaScript，并且可以在服务器端直接控制跳转逻辑。在实际应用中，你需要根据具体需求和业务逻辑来选择最适合的跳转方法。同时，如果你使用的是PHP框架，建议利用框架提供的跳转功能来保持代码的一致性和可维护性。http://www.ppmy.cn/news/1541440.html相关文章等价文件名绕过1.绕过黑名单绕过&amp;#xff08;等价扩展名-pass-03&amp;#xff09; 
fuzz字典&amp;#xff1a;https://github.com/evi1hack/Fuzz_dic/tree/master 下载后就是所有php文件参数的后缀 2.这里用upload-labs&amp;#xff08;less-3&amp;#xff09;进行示例&amp;#xff0c;将抓包中的php后缀修改成tes…阅读更多...【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:26 +0000</pubDate>
    </item>
    <item>
      <title>等价文件名绕过</title>
      <link>https://www.ppmy.cn/news/1541439.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维等价文件名绕过news/2025/11/4 0:21:25/1.绕过黑名单绕过（等价扩展名-pass-03）fuzz字典：https://github.com/evi1hack/Fuzz_dic/tree/master下载后就是所有php文件参数的后缀2.这里用upload-labs（less-3）进行示例，将抓包中的php后缀修改成test.phP2/然后放过3.这里发现文件成功上传4.这里再用bp对后缀进行批量爆破一下5.发现都能上传成功，接下来就按之前说的直接利用蚁剑连接即可http://www.ppmy.cn/news/1541439.html相关文章【python + Redis】hash值查增删文章目录 前置步骤一、查二、增三、删 前置步骤 
pip install redis# -*- coding: utf-8 -*-
import redis
#这个redis不能用&amp;#xff0c;请根据自己的需要修改
r redis.Redis(host"127.0.0.1",port6379,password"123456", db0)Redis库数据 
keyvalue1{“i…阅读更多...Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:25 +0000</pubDate>
    </item>
    <item>
      <title>【python + Redis】hash值查增删</title>
      <link>https://www.ppmy.cn/news/1541438.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【python + Redis】hash值查增删news/2025/11/4 0:21:24/文章目录前置步骤一、查二、增三、删前置步骤pipinstallredis# -*- coding: utf-8 -*-importredis#这个redis不能用，请根据自己的需要修改r=redis.Redis(host="127.0.0.1",port=6379,password="123456",db=0)Redis库数据keyvalue1{“id”: 1, “name”: “xxx”, “age”: “18”, “sex”: “\u7537”}2{“id”: 2, “name”: “xxx”, “age”: “15”, “sex”: “\u5973”}3{“id”: 3, “name”: “xxx”, “age”: “18”, “sex”: “\u7537”}一、查1.定义列表list_r1,存储查询到的数据2.定义data，用r.hgetall方法获取哈希表的所有字段和值,3.循环遍历出行数据,转成字典类型4.最后用if all方法将库中字段与之相匹配的数据查出，添入list_r1# hash查def get_hv(redis_name,params):list_r1=[]data=r.hgetall(redis_name)fork,vindata.items():row_data=json.loads(v.decode('utf-8'))ifall(row_data.get(key,False)==valforkey,valinparams.items()):list_r1.append(row_data)print("list_r1:",list_r1)returnlist_r1二、增1.params[“id”]要与Mysql数据库中的自增id相同2.这里用到了r.hset方法,格式为: r.hset(表名,key,value)3.注意value不能使用字典类型，我们需要用json.dumps转字符串# hash增def set_hv(hash,params):ifparams.get("id",False):r.hset(hash,params["id"],json.dumps(params))returnTrue三、删# hash删def del_hv(hash,params):ifparams.get("id",False):r.hdel(hash,params["id"],json.dumps(params))returnTrueelse:returnFalsehttp://www.ppmy.cn/news/1541438.html相关文章Zookeeper面试整理-Zookeeper的核心功能Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能： 1. 配置管理（Configuration Management） Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可…阅读更多...代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:24 +0000</pubDate>
    </item>
    <item>
      <title>Zookeeper面试整理-Zookeeper的核心功能</title>
      <link>https://www.ppmy.cn/news/1541437.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Zookeeper面试整理-Zookeeper的核心功能news/2025/11/4 0:21:23/Zookeeper 作为一个分布式协调服务，提供了许多关键的功能，这些功能帮助开发人员解决分布式系统中的一致性、协调和同步问题。以下是 Zookeeper 的核心功能：1. 配置管理（Configuration Management）Zookeeper 提供了一个分布式应用程序的集中配置存储。通过 Zookeeper，可以将配置信息存储在 ZNode 中，客户端通过读取 ZNode 获取最新的配置信息。这种集中式的配置管理可以保证在分布式环境下，所有节点使用相同的配置。http://www.ppmy.cn/news/1541437.html相关文章代码工艺：写代码的好习惯1. 充分校验入参 
有一句话叫 “All input is evil”&amp;#xff0c;即一切的输入都可能是恶意的。 因此&amp;#xff0c;经验丰富的工程师会对接口的入参进行严格的校验&amp;#xff0c;从最基础的非空、长度校验&amp;#xff0c;到复杂的业务逻辑校验都不应忽略。例如&amp;#xff0c;在典型的电…阅读更多...数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...C++中的vector使用与实现一、vector的使用 
1.1 vector的定义 
是一种类模板 
template &lt; class T, class Alloc  allocator&lt;T&gt; &gt; 
class vector; 
其中的模板参数Alloc是在使用空间配置器&amp;#xff08;内存池&amp;#xff09;&amp;#xff0c;并给了缺省值&amp;#xff0c;暂时不深究 
1.2遍历方式 
1.…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:23 +0000</pubDate>
    </item>
    <item>
      <title>代码工艺：写代码的好习惯</title>
      <link>https://www.ppmy.cn/news/1541436.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维代码工艺：写代码的好习惯news/2025/11/4 0:21:22/1. 充分校验入参有一句话叫 “All input is evil”，即一切的输入都可能是恶意的。 因此，经验丰富的工程师会对接口的入参进行严格的校验，从最基础的非空、长度校验，到复杂的业务逻辑校验都不应忽略。例如，在典型的电商下单场景中，我们需要校验用户状态是否正常、商品是否上架、库存是否充足、优惠券是否可用等。请记住，入参校验是防止低级错误的第一道防线，养成这个习惯至关重要。2. 完整记录日志我们总希望自己写的代码在本地、测试、甚至生产环境下都能完美执行。但现实中，业务异常情况常常发生，即使我们拥有像ELK、Skywalking这样的日志收集和链路追踪工具，日志记录的全面性和合理性仍直接影响我们排查问题的效率。日志的覆盖面应该包括关键路径、异常处理等。你今天省下的日志记录时间，将来很可能会在排查问题时花费更多。3. RPC 调用需考虑网络问题RPC 调用不同于本地调用，因为网络不稳定性带来了许多不确定因素。你需要思考以下问题：请求未能到达服务提供者怎么办？请求到达但未返回结果时如何处理？超时和重试策略如何设置？根据不同业务场景（如读请求、写请求，高并发与非高并发），处理策略应该有所不同，不能一概而论。4. 批量处理替代单次处理在需要多次执行 RPC 或数据库操作时，如果每次都在循环中调用单次接口，而不采用批量处理，将大大降低性能，尤其是在大量数据场景下。 此外，在循环体中添加日志记录时也要注意，避免生成大量日志，消耗磁盘资源。5. 复杂 SQL 需先执行计划那种海量数据下多表关联查询的SQL语句，一次执行把整个数据库搞挂并不是完全的小概率事件。因此，如果你写完一个这样的SQL语句，一定要记得怀有敬畏之心地先执行一下，看看效果。记住，不要在测试环境的数据库中执行，因为有的公司的测试库和生产库的数据量是天差地别，数据分布形态也不一样，执行结果可能没有参考性。记得要去生产库的从库去执行，因为主库一旦出现问题，影响范围太大。从库也不要直接去执行，执行之前还是要explain一下，看看执行计划的。如果执行计划中出现了大表的type=all，那也就别再执行SQL了，把从库打挂了影响也不小，先想办法优化吧。6. 扩展或新增，不直接修改维护中台服务时，如果对业务全貌还不熟悉，不要轻易修改业务主流程，特别是在多个业务线共用同一服务的情况下。采用扩展或新增的方式，可以减少对已有功能的影响，避免牵一发而动全身的风险。7. 重构而非重写重构的目标是优化现有代码的结构，而非推翻重写。相比于重新编写整个系统，合理的重构可以提升代码的可维护性，避免造成大规模的业务中断。牢记：重构是为了提高代码质量，而非推倒重来。8. 非必要，不引入在满足业务需求的前提下，技术方案越简单越好。例如：如果 MySQL 足以承受业务请求压力，就不需要引入 Redis 或 ES。如果同步调用能够满足业务需求，就不要盲目使用异步 MQ。如果简单coding即可高效迭代的需求，那就绝对不引入设计模式；过度引入新技术不仅增加了系统复杂性，也提高了维护成本。一个出色的工程师，他的特质是喜欢迎接挑战，但一个营收惊人的关键系统，对它最好的方式是杜绝挑战。9. 保证数据一致性当业务系统采用多数据源时（如 MySQL 主从模式或 MySQL + Redis 组合），需明确哪个是主数据源，发生数据不一致时以主数据源为准。此外，需设计策略确保多数据源最终一致性，以免系统埋下隐患。10. 避免过度前瞻性设计有些工程师在项目初期就着眼于未来的高并发或大规模扩展，过早地拆分微服务、进行数据库分库分表。这种过度设计会增加开发和调试难度，尤其是在业务前景不明朗的情况下，可能导致资源浪费。 我们要根据实际业务情况设计系统，保持简单而实用，避免不必要的复杂性。http://www.ppmy.cn/news/1541436.html相关文章数智合同 | 业财一体与履约联动的数字化转型随着信息化技术的发展&amp;#xff0c;合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用&amp;#xff0c;以提高合同管理水平&amp;#xff0c;应对新形势下的市场竞争挑战与合规要求&amp;#xff0c;实现企业的高质量发展。 2024年5月&amp;#xff0c;…阅读更多...esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...C++中的vector使用与实现一、vector的使用 
1.1 vector的定义 
是一种类模板 
template &lt; class T, class Alloc  allocator&lt;T&gt; &gt; 
class vector; 
其中的模板参数Alloc是在使用空间配置器&amp;#xff08;内存池&amp;#xff09;&amp;#xff0c;并给了缺省值&amp;#xff0c;暂时不深究 
1.2遍历方式 
1.…阅读更多...万户ezEIP企业管理系统 productlist.aspx SQL注入漏洞复现0x01 产品简介 
万户ezEIP是一种企业资源规划软件，旨在帮助企业管理其各个方面的业务流程。它提供了一套集成的解决方案，涵盖了财务、供应链管理、销售和市场营销、人力资源等各个领域。 
0x02 漏洞概述 
万户ezEIP企业管理系统 productlist.aspx 接口存在SQL注入漏洞，未经身…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:22 +0000</pubDate>
    </item>
    <item>
      <title>数智合同 | 业财一体与履约联动的数字化转型</title>
      <link>https://www.ppmy.cn/news/1541435.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维数智合同 | 业财一体与履约联动的数字化转型news/2025/11/4 0:21:21/随着信息化技术的发展，合同数智化管理为应对合同管理挑战提供了新机遇。企业需要深入思考数智化手段在合同管理中的应用，以提高合同管理水平，应对新形势下的市场竞争挑战与合规要求，实现企业的高质量发展。2024年5月，用友网络与厦门国家会计学院联合发布《大型企业合同数智化白皮书》，旨在助力广大企业用户深入洞察合同管理在企业运营中的现状与问题，系统剖析企业合同数智化管理的框架、标准与重点，学习知名企业集团实施合同数智化管理的成功案例，助力广大用户成就数智企业！本期将为大家分享第8期 ：《业财一体与履约联动的数字化转型》的精彩内容。期待能为合同管理者提供更丰富的工具和资源，以应对不断变化的商业挑战。第8章业财一体与履约联动的数字化转型8.1 构建业财一体化基石在“合同全生命周期运营”管理中，企业需要制定合同管理标准化的建设目标。在企业围绕合同标准化的建设过程中，应当围绕“制度规范”、“流程标准”、“系统落实”、“业务执行”四个角度来完善方案、制度、信息系统的详细设计。通过配套的制度、标准的流程及系统相应的管控，方可达到企业合同标准化管理的目标。图8.1-1 规范化有效落实建设的必要因素合同的标准化至少要考虑以下“八项标准”。通过定义 “制度、分类、编码、模板、条款、审核、签章、档案”标准，使企业通过建设一整套规范管理的线上化合同管理体系，实现合同管理的规范化、数字化。图8.1-2 合同全生命周期运营解决方案常见的八项合同标准8.2  业财一体：重塑企业运营新模式在公司经营过程中，合同是业务、财务执行的准绳。几乎所有的业务活动都与合同紧密相关，因为合同不仅是业务运营的基础，也是财务执行的关键依据。因此，公司和数字化解决方案提供商需要深入研究合同在企业主要业务流程中的作用，并详细梳理业务、财务整合管理的需求和挑战。以合同为基础，构建集成解决方案，帮助公司更高效地管理业务和财务，实现规范化和协同化管理目标，同时将经营风险降到最低。图8.2-1 端到端业务流程下合同业财管控诉求“合同全生命周期运营”解决方案围绕“业务追溯”、“业务履行“、”财务履行”、“财务管控“这四项核心业财融合项，梳理合同视角下业财一体化的关注要点，并提出相应的管理规划和系统规划。图8.2-2 梳理业务到财务流程中的详细的管理要素示例8.3  强化合同执行与监控在“合同全生命周期运营”解决方案中，企业和数字化解决方案厂商需要围绕合同签约“事前”关联财务预算、匹配业务，“事中”达成业财管控，“事后”追溯活动发生的设计思路，形成业财一体化的蓝图设计。图8.3-1 合同全生命周期运营围绕事前、事中、事后的业财一体化蓝图设计以常见的企业采销活动为例，通过合同穿透项目进度、供应链订单、收付款进度等，实现合同履约管控的 为了实现合同智能化，需要重点关注以下几个方面的工作：全面覆盖、合同执行链条的全程追溯、合同相关数据的完整呈现。图8.3-2 以采销为代表的合同业财一体化解决方案示例《大型企业合同数智化白皮书》目录详情下期预告《第9期 | 智驭风险，数启洞察：构建高效风控新生态》http://www.ppmy.cn/news/1541435.html相关文章esxi配置磁盘直通虚拟机基于VMware Exsi环境&amp;#xff0c;考虑到特殊业务需求&amp;#xff0c;需要直接将磁盘数据提供给虚拟机使用。 
打开SSH服务 
登录VMware vSphere Web Client控制台&amp;#xff0c;主机-服务中启用安全Shell(SSH)&amp;#xff0c;通过SSH登录esxi服务器 
配置磁盘直通 
# 通过VMware vSpher…阅读更多...vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...C++中的vector使用与实现一、vector的使用 
1.1 vector的定义 
是一种类模板 
template &lt; class T, class Alloc  allocator&lt;T&gt; &gt; 
class vector; 
其中的模板参数Alloc是在使用空间配置器&amp;#xff08;内存池&amp;#xff09;&amp;#xff0c;并给了缺省值&amp;#xff0c;暂时不深究 
1.2遍历方式 
1.…阅读更多...万户ezEIP企业管理系统 productlist.aspx SQL注入漏洞复现0x01 产品简介 
万户ezEIP是一种企业资源规划软件，旨在帮助企业管理其各个方面的业务流程。它提供了一套集成的解决方案，涵盖了财务、供应链管理、销售和市场营销、人力资源等各个领域。 
0x02 漏洞概述 
万户ezEIP企业管理系统 productlist.aspx 接口存在SQL注入漏洞，未经身…阅读更多...超简洁的B端系统，还是看国外的设计.国外的一些 B 端系统设计往往注重简洁性和实用性的完美结合。 
从界面布局来看&amp;#xff0c;它们通常采用简洁明快的线条和清晰的模块划分&amp;#xff0c;避免了过多的装饰和繁杂的元素&amp;#xff0c;使得用户能够快速聚焦于核心功能。 
色彩方面&amp;#xff0c;多选用中性色调或淡雅的色…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:21 +0000</pubDate>
    </item>
    <item>
      <title>esxi配置磁盘直通虚拟机</title>
      <link>https://www.ppmy.cn/news/1541434.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维esxi配置磁盘直通虚拟机news/2025/11/4 0:21:20/基于VMware Exsi环境，考虑到特殊业务需求，需要直接将磁盘数据提供给虚拟机使用。打开SSH服务登录VMware vSphere Web Client控制台，主机-服务中启用安全Shell(SSH)，通过SSH登录esxi服务器配置磁盘直通# 通过VMware vSphere Web Client查看新增磁盘ID，对比Exsi后台/vmfs/devices/disks/确定新增磁盘对应IDls/vmfs/devices/disks/# 通过vmkfstools -z将新增磁盘映射到数据存储指定虚拟磁盘文件中vmkfstools -z /vmfs/devices/disks/naa.61866da0692804002855fa603ff25fd9 /vmfs/volumes/datastore/naa.61866da0692804002855fa603ff25fd9.vmdk添加硬盘WEB控制台编辑虚拟机设置-&gt;添加硬盘-&gt;新裸磁盘使用直通硬盘控制台重启虚拟机登入虚拟机分区格式化挂载使用直通的硬盘http://www.ppmy.cn/news/1541434.html相关文章vue3中可组合函数的应用场景可组合函数&amp;#xff08;Composables&amp;#xff09;是 Vue 3 的组合式 API 中的一种设计模式&amp;#xff0c;用于将可复用的逻辑封装成独立的函数&amp;#xff0c;从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元&amp;#xff0c;然后在不同的组件…阅读更多...Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...C++中的vector使用与实现一、vector的使用 
1.1 vector的定义 
是一种类模板 
template &lt; class T, class Alloc  allocator&lt;T&gt; &gt; 
class vector; 
其中的模板参数Alloc是在使用空间配置器&amp;#xff08;内存池&amp;#xff09;&amp;#xff0c;并给了缺省值&amp;#xff0c;暂时不深究 
1.2遍历方式 
1.…阅读更多...万户ezEIP企业管理系统 productlist.aspx SQL注入漏洞复现0x01 产品简介 
万户ezEIP是一种企业资源规划软件，旨在帮助企业管理其各个方面的业务流程。它提供了一套集成的解决方案，涵盖了财务、供应链管理、销售和市场营销、人力资源等各个领域。 
0x02 漏洞概述 
万户ezEIP企业管理系统 productlist.aspx 接口存在SQL注入漏洞，未经身…阅读更多...超简洁的B端系统，还是看国外的设计.国外的一些 B 端系统设计往往注重简洁性和实用性的完美结合。 
从界面布局来看&amp;#xff0c;它们通常采用简洁明快的线条和清晰的模块划分&amp;#xff0c;避免了过多的装饰和繁杂的元素&amp;#xff0c;使得用户能够快速聚焦于核心功能。 
色彩方面&amp;#xff0c;多选用中性色调或淡雅的色…阅读更多...React 基础阶段学习计划React 基础阶段学习计划 
目标 
能够创建和使用React组件。理解并使用State和Props。掌握事件处理和表单处理。 
学习内容 
环境搭建 
安装Node.js和npm 
访问 Node.js官网 下载并安装最新版本的Node.js。打开终端或命令行工具&amp;#xff0c;输入 node -v 和 npm -v 检查是否安装…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:20 +0000</pubDate>
    </item>
    <item>
      <title>vue3中可组合函数的应用场景</title>
      <link>https://www.ppmy.cn/news/1541433.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维vue3中可组合函数的应用场景news/2025/11/4 0:21:19/可组合函数（Composables）是 Vue 3 的组合式 API 中的一种设计模式，用于将可复用的逻辑封装成独立的函数，从而提高代码的模块化和复用性。可组合函数的核心目标是将复杂的逻辑拆分为小的、可管理的单元，然后在不同的组件中共享这些逻辑。以下是可组合函数的典型应用场景和用法示例：1.状态管理在一个应用中，不同的组件可能需要共享相同的状态（如用户登录信息、购物车状态等）。可组合函数可以用于集中管理这些状态，类似于轻量级的状态管理解决方案。**应用场景：**登录状态的管理// useAuth.js
import { ref } from 'vue';export function useAuth() {const isAuthenticated = ref(false);function login() {isAuthenticated.value = true;}function logout() {isAuthenticated.value = false;}return { isAuthenticated, login, logout };
}// 在组件中使用
import { useAuth } from './useAuth';export default {setup() {const { isAuthenticated, login, logout } = useAuth();return { isAuthenticated, login, logout };}
}2.表单处理表单处理是前端开发中常见的需求，包括表单数据的双向绑定、验证和提交。通过可组合函数，表单处理逻辑可以被复用并适应不同的表单结构。**应用场景：**表单数据和验证// useForm.js
import { ref } from 'vue';export function useForm() {const formData = ref({name: '',email: ''});const validate = () =&gt; {return formData.value.name !== '' &amp;&amp; formData.value.email.includes('@');};return { formData, validate };
}// 在组件中使用
import { useForm } from './useForm';export default {setup() {const { formData, validate } = useForm();const submit = () =&gt; {if (validate()) {// 提交表单逻辑console.log('Form is valid');}};return { formData, submit };}
}3.异步数据获取在大型应用中，不同的组件可能需要获取相同的远程数据（如用户信息、列表数据等）。通过可组合函数，数据获取逻辑可以被封装并复用。**应用场景：**数据获取和错误处理// useFetchData.js
import { ref } from 'vue';export function useFetchData(url) {const data = ref(null);const error = ref(null);const loading = ref(true);const fetchData = async () =&gt; {try {const response = await fetch(url);data.value = await response.json();} catch (err) {error.value = err;} finally {loading.value = false;}};fetchData(); // 自动触发数据获取return { data, error, loading };
}// 在组件中使用
import { useFetchData } from './useFetchData';export default {setup() {const { data, error, loading } = useFetchData('https://api.example.com/items');return { data, error, loading };}
}4.事件处理和订阅可组合函数可以用于封装事件处理逻辑，尤其是跨组件间共享的事件处理器。比如，处理窗口大小变化、滚动事件等。**应用场景：**监听窗口大小变化// useWindowSize.js
import { ref, onMounted, onUnmounted } from 'vue';export function useWindowSize() {const width = ref(window.innerWidth);const height = ref(window.innerHeight);const updateSize = () =&gt; {width.value = window.innerWidth;height.value = window.innerHeight;};onMounted(() =&gt; window.addEventListener('resize', updateSize));onUnmounted(() =&gt; window.removeEventListener('resize', updateSize));return { width, height };
}// 在组件中使用
import { useWindowSize } from './useWindowSize';export default {setup() {const { width, height } = useWindowSize();return { width, height };}
}5.处理业务逻辑和复杂交互对于复杂的业务逻辑和交互处理，如处理权限验证、导航守卫等，可组合函数可以帮助将这些复杂的逻辑封装起来，增强代码的可复用性和可读性。**应用场景：**权限验证逻辑封装// usePermissions.js
import { ref } from 'vue';export function usePermissions() {const hasPermission = ref(false);const checkPermission = (user, action) =&gt; {// 假设我们有一个权限列表来验证用户的权限hasPermission.value = user.permissions.includes(action);};return { hasPermission, checkPermission };
}// 在组件中使用
import { usePermissions } from './usePermissions';export default {setup() {const { hasPermission, checkPermission } = usePermissions();const user = { permissions: ['view', 'edit'] };checkPermission(user, 'view'); // 检查用户权限return { hasPermission };}
}6.动画与样式处理可组合函数也可以用于封装动画和样式处理逻辑，比如页面的淡入淡出效果、拖拽效果、滚动等。**应用场景：**页面滚动监听// useScroll.js
import { ref, onMounted, onUnmounted } from 'vue';export function useScroll() {const scrollY = ref(0);const handleScroll = () =&gt; {scrollY.value = window.scrollY;};onMounted(() =&gt; window.addEventListener('scroll', handleScroll));onUnmounted(() =&gt; window.removeEventListener('scroll', handleScroll));return { scrollY };
}// 在组件中使用
import { useScroll } from './useScroll';export default {setup() {const { scrollY } = useScroll();return { scrollY };}
}7.与外部库的结合可组合函数不仅限于应用内部的逻辑封装，它们也可以与外部库结合使用。例如，封装第三方 UI 库或数据处理库的调用。**应用场景：**与第三方地图库结合// useGoogleMap.js
import { onMounted, ref } from 'vue';export function useGoogleMap(apiKey) {const map = ref(null);onMounted(() =&gt; {// 初始化 Google 地图map.value = new google.maps.Map(document.getElementById('map'), {center: { lat: -34.397, lng: 150.644 },zoom: 8});});return { map };
}// 在组件中使用
import { useGoogleMap } from './useGoogleMap';export default {setup() {const { map } = useGoogleMap('your-google-maps-api-key');return { map };}
}总结可组合函数的应用场景非常广泛，几乎可以适用于 Vue 组件中任何需要逻辑复用、状态管理、异步操作和事件处理的场景。它们特别适合以下几类需求：逻辑复用：将某些功能模块化，使得多个组件可以共享相同的逻辑。分离复杂逻辑：将复杂的业务逻辑拆解成小而易管理的部分，增强代码的可维护性和可读性。代码组织优化：使代码组织更加灵活和模块化，减少组件中的重复代码。这种模式不仅提升了代码的复用性，还提高了应用的维护性和扩展性。http://www.ppmy.cn/news/1541433.html相关文章Unity3D功耗和发热分析与优化详解Unity3D作为广泛使用的游戏开发引擎&amp;#xff0c;在游戏开发过程中&amp;#xff0c;功耗和发热问题一直是开发者需要重点关注的问题。功耗和发热不仅影响用户体验&amp;#xff0c;还可能对设备的硬件寿命造成一定影响。本文将从技术角度详细分析Unity3D游戏在移动设备上的功耗和发热问题…阅读更多...第13篇：无线与移动网络安全目录 
引言 
13.1 无线网络的安全威胁 
13.2 无线局域网的安全协议 
13.3 移动通信中的安全机制 
13.4 蓝牙和其他无线技术的安全问题 
13.5 无线网络安全的最佳实践 
13.6 总结 第13篇&amp;#xff1a;无线与移动网络安全 
引言 
无线和移动网络的发展为我们的生活带来了极大的便利…阅读更多...如何从模块内部运行 Pytest在 Python 中&amp;#xff0c;pytest 是一个强大的测试框架&amp;#xff0c;用于编写和运行测试用例。通常我们会在命令行中运行 pytest&amp;#xff0c;但是有时你可能希望从模块或脚本的内部运行 pytest&amp;#xff0c;比如为了自动化测试或集成到某个工作流程中。 
1、问题背景 
当你从模块…阅读更多...C++中的vector使用与实现一、vector的使用 
1.1 vector的定义 
是一种类模板 
template &lt; class T, class Alloc  allocator&lt;T&gt; &gt; 
class vector; 
其中的模板参数Alloc是在使用空间配置器&amp;#xff08;内存池&amp;#xff09;&amp;#xff0c;并给了缺省值&amp;#xff0c;暂时不深究 
1.2遍历方式 
1.…阅读更多...万户ezEIP企业管理系统 productlist.aspx SQL注入漏洞复现0x01 产品简介 
万户ezEIP是一种企业资源规划软件，旨在帮助企业管理其各个方面的业务流程。它提供了一套集成的解决方案，涵盖了财务、供应链管理、销售和市场营销、人力资源等各个领域。 
0x02 漏洞概述 
万户ezEIP企业管理系统 productlist.aspx 接口存在SQL注入漏洞，未经身…阅读更多...超简洁的B端系统，还是看国外的设计.国外的一些 B 端系统设计往往注重简洁性和实用性的完美结合。 
从界面布局来看&amp;#xff0c;它们通常采用简洁明快的线条和清晰的模块划分&amp;#xff0c;避免了过多的装饰和繁杂的元素&amp;#xff0c;使得用户能够快速聚焦于核心功能。 
色彩方面&amp;#xff0c;多选用中性色调或淡雅的色…阅读更多...React 基础阶段学习计划React 基础阶段学习计划 
目标 
能够创建和使用React组件。理解并使用State和Props。掌握事件处理和表单处理。 
学习内容 
环境搭建 
安装Node.js和npm 
访问 Node.js官网 下载并安装最新版本的Node.js。打开终端或命令行工具&amp;#xff0c;输入 node -v 和 npm -v 检查是否安装…阅读更多...基于SpringBoot+Vue+uniapp微信小程序的社区门诊管理系统的详细设计和实现(源码+lw+部署文档+讲解等)项目运行截图 技术框架 
后端采用SpringBoot框架 
Spring Boot 是一个用于快速开发基于 Spring 框架的应用程序的开源框架。它采用约定大于配置的理念&amp;#xff0c;提供了一套默认的配置&amp;#xff0c;让开发者可以更专注于业务逻辑而不是配置文件。Spring Boot 通过自动化配置和约…阅读更多...最新文章学习日报11.2langgraph-reflectionCSP2025-S 游记补发周五日报10.31软件技术基础的第二次作业CSP-S  2023 游记openssl 3和qt5好像打架哎[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]接口实现C#泛型四则运算接口实现C#泛型四则运算[Flink/Hologres/汽车] 骋在数据洪流上：Flink+Hologres驱动零跑科技实时计算的应用与实践 [转]openssl 3和qt5好像打架哎给一个百分制成绩，要求输出成绩等级‘A,B,C,D,E大模型应用开发技术路线（上）：从概念到RAG实战，这套方法论让我从0到1落地企业级AI应用20251103 之所思 - 人生如梦Copyright @ 2022~2023</description>
      <pubDate>Mon, 03 Nov 2025 16:21:19 +0000</pubDate>
    </item>
  </channel>
</rss>
