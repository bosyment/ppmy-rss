<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>PPMY RSS</title>
    <link>https://www.ppmy.cn/news</link>
    <description>PPMY 网站文章 RSS</description>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 31 Oct 2025 16:22:56 +0000</lastBuildDate>
    <item>
      <title>101 - Lecture 11</title>
      <link>https://www.ppmy.cn/news/1541032.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维101 - Lecture 11news/2025/11/1 0:24:57/课程概述•	汇编语言中的输出（Output in inline assembly）
•	汇编语言中的输入（Input in inline assembly）
•	printf 函数的更多细节
•	scanf 函数的更多细节
•	程序流程控制（Controlling program flow）
•	跳转指令（Jumps）
•	无条件跳转（Unconditional jumps）
•	有条件跳转（Conditional jumps）1. 汇编语言中的输出Output in inline assembly• 在C语言中声明变量后，汇编语言可以通过以下方式调用printf输出：声明字符串： char format[] = "Hello World\n";，用于存储需要输出的字符串。lea eax,format// 将字符串 'format' 的**地址**加载(load)到 eax 中push eax// 将字符串地址压入栈中(address of string, stack parameter)call printf// 调用 printf 库函数(use library code subroutine)add esp,4// 清理栈上4字节的参数(clean 4 byte parameter off stack)等效的C代码为：printf(“Hello World\n”);输出数字的示例：•	通过汇编调用printf输出整数：声明格式字符串：声明格式化字符串 char format[] = “%d\n”;，用于指定printf以十进制的形式输出整数。声明整数变量：声明一个整数变量 int myint = 157;，用于存储要输出的值。push myint// 将**变量的值**压入栈中lea eax,format// 将格式字符串的地址加载到 eax 中(address of the format string is saved in max)push eax// 将**格式字符串地址**压入栈中call printf// 调用 printf 函数(it will take two parameters from the stack)add esp,8// 清理栈上两个参数的位置(clean up top two position in the stack)在C语言中的等效代码为：printf(“%d”, myint);Qualifier（限定词/修饰符） “%d” means the content of ‘myint’ will be printed as a decimal integer（十进制整数）• scanf的作用是接收用户输入并存储在指定的变量中。因此，scanf不仅需要知道你希望存储数据的位置，还需要有权限去修改该变量的值。为了实现这一点，scanf需要获取变量的地址，从而能够直接修改变量的内容。如果我们仅仅将变量的值压入栈中，scanf就无法知道应当在哪里存储输入的数据。因此，我们需要将变量的地址（而不是变量的值）压入栈中，以便scanf能够根据地址找到相应的内存位置来存储用户输入的值。汇编语言中调用 printf 输出整数时的步骤。压入第二个参数：Push the second parameter(integer variable to the stack)• 首先，将第二个参数（即要输出的整数值）压入栈中。因为 printf 需要先接收到数据才能进行输出，所以整数值作为输出的参数需要首先压入栈中。压入第一个参数：push the first parameter(actually, address of the string)to the stack• 接着，将第一个参数压入栈中。在这里，第一个参数实际上是格式化字符串（如"%d"），它告诉 printf 应该如何处理输出的值。因此，压入的并不是格式字符串的内容，而是格式字符串的地址。调用 printf 函数：call printf routine• 之后，调用 printf 函数。此时 printf 函数从栈中获取刚刚压入的两个参数：第一个是格式化字符串，第二个是要输出的整数。清理栈：clean up top two positions in the stack• 最后，清理栈顶的两个位置。由于刚刚压入了两个参数，在调用 printf 之后，这两个参数仍然在栈中，所以需要将这两个参数从栈中移除，以确保栈处于干净状态，防止内存泄漏或混乱。2. 汇编语言中的输入Input in inline assemblycall to the standard C library routine:scanf(“%d”,&amp;input);• &amp;input presents the address of the variable ‘input’•使用scanf读取用户输入并存储到变量中：charformat[]="%d";//声明格式化字符串，用于指定 scanf 以十进制整数的格式读取用户输入。intinput;//声明一个整数变量 input，用于存储用户输入的数据。lea eax,input// 将变量 input 的地址加载到 eax 中push eax// 将变量地址压入栈中lea eax,format// 将格式字符串的地址加载到 eax 中(adress of the format string is saved in eax)push eax// 将格式字符串地址压入栈中call scanf// 调用 scanf 函数add esp,8// 清理栈上两个参数的位置(clean top two position in the stack)_asm 是 inline assembly（内联汇编）的缩写，用于在 C 语言代码中插入汇编语言指令。这里，input是用于存储用户输入的整数变量，format表示格式化字符串"%d"，用于读取整数。3. More about printf和scanf•printf的类型修饰符(qualifiers)：• %c：输出字符(character)• %d或%i：输出有符号的十进制整数(a signed decimal number)• %s：输出字符串(a string of characters)•scanf的类型修饰符(qualifiers)：• %c：读取一个字符(a single character)• %d：读取一个有符号的十进制整数• %s：读取一个字符串，直到遇到空格、换行或终止符(a string of characters until a white space or terminator(blank, new line, tab)is found)4. 程序流程控制Controlling program flowvery few programs execute all instructions sequentially,from the first till the last one.Usually,one needs to control the flow of the program.• 很少有程序从头到尾按顺序执行所有指令，通常需要跳转或循环：• 根据条件从一个位置跳转到另一个位置。• 当某个条件(condition)满足或直到某个条件达到时重复操作(repeat some action)。• 通过调用和返回控制程序流程。(Passing control to and from procedures)Jumps跳转指令分类：“跳转”是改变程序控制流(program control)从一个位置到另一个位置的最直接(straightforward)的方法无条件跳转：(Unconditional)• JMP指令无条件地将控制转移到另一条指令。• 语法：JMP &lt;目标指令的地址&gt;Syntax:JMP&lt;address of the target instruction&gt;•目标指令的位置可以通过它的标签（label）来指定标签通常是一个符号名称，用来标识代码中的一个位置，使得在程序的其他地方可以通过引用这个标签来跳转到这个位置执行代码有条件跳转：(Conditional)• 先测试条件，再根据条件决定跳转与否。• 常见指令包括JCXZ和JECXZ，它们测试寄存器CX或ECX是否为零，其他跳转指令测试状态标志(status flags)。5. 条件跳转指令Jumping based on status flags• 条件跳转指令根据状态标志的设置跳转(Jumping based on status flags)，包括：• JC / JB：如果进位标志设置（=1），则跳转。carry flag is set• JNC / JNB：如果进位标志未设置（=0），则跳转。carry flag is clear• JE / JZ：如果零标志设置（=1），则跳转。zero flag is set• JNE / JNZ：如果零标志未设置（=0），则跳转。zero flag is clear• JS：如果符号标志设置（=1），则跳转。sign flag is set• JNS：如果符号标志未设置（=0），则跳转。sign flag is clear• JO: Overflow flag is set (=1)• JNO: Overflow flag is clear (=0)Jumps Based on Comparison of Two Values基于比较的跳转：•	CMP指令最常用来测试条件跳转。它比较两个值并根据比较结果修改状态标志，而不改变比较的值。
•	常见条件跳转：
•	JE：第一个操作数等于第二个操作数时跳转。
•	JNE：第一个操作数不等于第二个操作数时跳转。
•	JG：第一个操作数大于第二个操作数时跳转。
•	JL：第一个操作数小于第二个操作数时跳转。当执行 cmp eax, ebx 时，CPU 会将 eax 和 ebx 中的值进行减法操作（不改变这两个寄存器的值，只是隐式地进行减法），并根据减法结果设置状态标志。• 如果 eax 和 ebx 的值相等：• 零标志（Z） 将被设置为1（Z = 1），表示比较结果为零。• 如果 eax 和 ebx 的值不相等：• 零标志（Z）将被清除（Z = 0），表示比较结果不为零。Example:cmp ax,bx;比较 AX 和 BX 的值
jg  label1;如果 AX&gt;BX，跳转到 label1
jl  label2;如果 AX&lt;BX，跳转到 label2add ax,input;将 input 的值加到 AX
cmp ax,0;比较 AX 和0jge label1;如果 AX&gt;=0，跳转到 label1
jl  label2;如果 AX&lt;0，跳转到 label2示例问题解答• Q1: 在汇编代码中给printf传递两个参数时，第一个参数应该先压入栈中。（True or False）• 解答：False。调用printf时，应该先压入第二个参数，然后是第一个参数。• Q2: 在汇编中调用printf时，传递给它的参数将被printf从栈中弹出。（True or False）• 解答：True。printf会从栈中弹出传递给它的参数。• Q3: 在汇编中调用scanf时，需要将接收输入的变量地址压入栈中。（True or False）• 解答：True。scanf需要接收变量的地址才能将输入数据存储在该变量中。• Q4: 在printf中打印字符串时，使用的转换说明符是什么？• 解答：%s。• Q5: 如果在调用scanf时有三个整数参数被压入栈中，返回时如何调整寄存器esp的值？• 解答：需要将esp增加12，因为每个整数占4字节，三个整数总共12字节。• Q6: 执行cmp eax, ebx时会检查零标志的设置。（True or False）• 解答：True。cmp指令会根据比较结果设置零标志，如果eax和ebx相等，则设置零标志为1。http://www.ppmy.cn/news/1541032.html相关文章数据库作业2作业&amp;#xff1a; 建立数据库&amp;#xff1a; 建表&amp;#xff1a; 插入数据&amp;#xff1a; 查询&amp;#xff1a; 
&amp;#xff08;1&amp;#xff09;&amp;#xff1a; &amp;#xff08;2&amp;#xff09;&amp;#xff1a; &amp;#xff08;3&amp;#xff09;&amp;#xff1a; &amp;#xff08;4&amp;#xff09;&amp;#xff1a; &amp;#xf…阅读更多...训练自己的语音并生成音频fish.audioFish Speech 是一个致力于提供高质量、易用且功能强大的语音合成解决方案的开源项目。它融合了多项先进的语音合成技术&amp;#xff0c;为研究者、开发者和普通用户提供了一个功能丰富的语音合成平台。 fish.audio开发团队是我们是公认的开源SVC / TTS 项目的开创者在GitHub上拥有超…阅读更多...通过 Twitter Token 实现授权与操作通过 Twitter Token 实现授权与操作 
一、Twitter API 概览 
1.1 Twitter API 简介 
Twitter API 是 Twitter 公司提供的一种编程接口，它允许开发者访问 Twitter 的海量数据，包括用户信息、推文内容、关系网络等。通过这些接口，开发者可以创建应用程序，实现自动化的社交媒体…阅读更多...PyCharm借助MobaXterm跳板机连接服务器服务器信息&amp;#xff1a; Step 1 
MovaXterm→Session→SSH输入服务器信息 Step 2 
MovaXterm→Session→SSH→Network setting→SSG gateway(jump host) 输入跳板机信息 键入密码即可 
Step 3 
MovaXterm→Tunneling→New SSH tunnel 依次输入&amp;#xff1a;A本机端口&amp;#xff0c…阅读更多...离散制造和流程制造分别是什么？它们有什么区别？为何有的企业生产过程看似一气呵成&amp;#xff0c;而有的则是由多个环节组合而成&amp;#xff1f;其实这就涉及到了制造业的两种常见生产模式。 
流程制造离散制造 
那么&amp;#xff0c;在生产管理方面&amp;#xff0c;离散制造和流程制造分别有什么特点、区别呢&amp;#xff1f; 
今天&amp;#xff0…阅读更多...Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:57 +0000</pubDate>
    </item>
    <item>
      <title>数据库作业2</title>
      <link>https://www.ppmy.cn/news/1541031.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维数据库作业2news/2025/11/1 0:24:56/作业：建立数据库：建表：插入数据：查询：（1）：（2）：（3）：（4）：（5）：（6）：（7）：（8）：（9）；（10）：（11）：（12）：（13）：（14）：（15）；http://www.ppmy.cn/news/1541031.html相关文章训练自己的语音并生成音频fish.audioFish Speech 是一个致力于提供高质量、易用且功能强大的语音合成解决方案的开源项目。它融合了多项先进的语音合成技术&amp;#xff0c;为研究者、开发者和普通用户提供了一个功能丰富的语音合成平台。 fish.audio开发团队是我们是公认的开源SVC / TTS 项目的开创者在GitHub上拥有超…阅读更多...通过 Twitter Token 实现授权与操作通过 Twitter Token 实现授权与操作 
一、Twitter API 概览 
1.1 Twitter API 简介 
Twitter API 是 Twitter 公司提供的一种编程接口，它允许开发者访问 Twitter 的海量数据，包括用户信息、推文内容、关系网络等。通过这些接口，开发者可以创建应用程序，实现自动化的社交媒体…阅读更多...PyCharm借助MobaXterm跳板机连接服务器服务器信息&amp;#xff1a; Step 1 
MovaXterm→Session→SSH输入服务器信息 Step 2 
MovaXterm→Session→SSH→Network setting→SSG gateway(jump host) 输入跳板机信息 键入密码即可 
Step 3 
MovaXterm→Tunneling→New SSH tunnel 依次输入&amp;#xff1a;A本机端口&amp;#xff0c…阅读更多...离散制造和流程制造分别是什么？它们有什么区别？为何有的企业生产过程看似一气呵成&amp;#xff0c;而有的则是由多个环节组合而成&amp;#xff1f;其实这就涉及到了制造业的两种常见生产模式。 
流程制造离散制造 
那么&amp;#xff0c;在生产管理方面&amp;#xff0c;离散制造和流程制造分别有什么特点、区别呢&amp;#xff1f; 
今天&amp;#xff0…阅读更多...Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:56 +0000</pubDate>
    </item>
    <item>
      <title>训练自己的语音并生成音频fish.audio</title>
      <link>https://www.ppmy.cn/news/1541030.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维训练自己的语音并生成音频fish.audionews/2025/11/1 0:24:55/Fish Speech 是一个致力于提供高质量、易用且功能强大的语音合成解决方案的开源项目。它融合了多项先进的语音合成技术，为研究者、开发者和普通用户提供了一个功能丰富的语音合成平台。fish.audio开发团队是我们是公认的开源SVC / TTS 项目的开创者在GitHub上拥有超过70,000 星标。 Previous slide. rcell. So-VITS-SVC 创始人. GPT-SoVITS 创始人. Bert-VITS2 创始人我们用雷总的声音生成了一段音频，然后用他的音频驱动一段视频，得到这个效果。考虑到版权的问题，就不上传视频了。https://fish.audio/zh-CN/train/new-model/还能训练自己的专属声音只要上传一段音频，通过训练完成之后就可以使用啦，目前还是免费的哦！训练自己的语音并生成音频fish.audiohttps://www.jinshuangshi.com/forum.php?mod=viewthread&amp;tid=319(出处: 金双石科技)http://www.ppmy.cn/news/1541030.html相关文章通过 Twitter Token 实现授权与操作通过 Twitter Token 实现授权与操作 
一、Twitter API 概览 
1.1 Twitter API 简介 
Twitter API 是 Twitter 公司提供的一种编程接口，它允许开发者访问 Twitter 的海量数据，包括用户信息、推文内容、关系网络等。通过这些接口，开发者可以创建应用程序，实现自动化的社交媒体…阅读更多...PyCharm借助MobaXterm跳板机连接服务器服务器信息&amp;#xff1a; Step 1 
MovaXterm→Session→SSH输入服务器信息 Step 2 
MovaXterm→Session→SSH→Network setting→SSG gateway(jump host) 输入跳板机信息 键入密码即可 
Step 3 
MovaXterm→Tunneling→New SSH tunnel 依次输入&amp;#xff1a;A本机端口&amp;#xff0c…阅读更多...离散制造和流程制造分别是什么？它们有什么区别？为何有的企业生产过程看似一气呵成&amp;#xff0c;而有的则是由多个环节组合而成&amp;#xff1f;其实这就涉及到了制造业的两种常见生产模式。 
流程制造离散制造 
那么&amp;#xff0c;在生产管理方面&amp;#xff0c;离散制造和流程制造分别有什么特点、区别呢&amp;#xff1f; 
今天&amp;#xff0…阅读更多...Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:55 +0000</pubDate>
    </item>
    <item>
      <title>通过 Twitter Token 实现授权与操作</title>
      <link>https://www.ppmy.cn/news/1541029.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维通过 Twitter Token 实现授权与操作news/2025/11/1 0:24:53/通过 Twitter Token 实现授权与操作一、Twitter API 概览1.1 Twitter API 简介Twitter API 是 Twitter 公司提供的一种编程接口，它允许开发者访问 Twitter 的海量数据，包括用户信息、推文内容、关系网络等。通过这些接口，开发者可以创建应用程序，实现自动化的社交媒体管理和分析。Twitter API 的强大功能使其成为社交媒体分析、品牌监控、客户服务和市场营销等领域的重要工具。1.2 授权机制Twitter API 的使用受到严格的授权机制控制，以确保用户数据的安全和隐私。Twitter 实现了 OAuth 1.0a 和 OAuth 2.0 两种授权协议，这些协议允许用户授权第三方应用程序访问其 Twitter 数据，而无需共享用户名和密码。这种授权方式不仅提高了安全性，也为用户提供了更多的控制权。二、Twitter Token 详解2.1 Token 的作用Token 在 Twitter API 的授权机制中扮演着核心角色。它是一个临时的、安全的凭证，用于验证应用程序的身份，并控制应用程序对用户数据的访问权限。Token 的使用确保了只有经过用户授权的应用程序才能访问其数据，从而保护了用户的隐私和数据安全。2.2 Token 的类型Twitter API 使用了多种类型的 Token，每种类型都有其特定的用途和生命周期：http://www.ppmy.cn/news/1541029.html相关文章PyCharm借助MobaXterm跳板机连接服务器服务器信息&amp;#xff1a; Step 1 
MovaXterm→Session→SSH输入服务器信息 Step 2 
MovaXterm→Session→SSH→Network setting→SSG gateway(jump host) 输入跳板机信息 键入密码即可 
Step 3 
MovaXterm→Tunneling→New SSH tunnel 依次输入&amp;#xff1a;A本机端口&amp;#xff0c…阅读更多...离散制造和流程制造分别是什么？它们有什么区别？为何有的企业生产过程看似一气呵成&amp;#xff0c;而有的则是由多个环节组合而成&amp;#xff1f;其实这就涉及到了制造业的两种常见生产模式。 
流程制造离散制造 
那么&amp;#xff0c;在生产管理方面&amp;#xff0c;离散制造和流程制造分别有什么特点、区别呢&amp;#xff1f; 
今天&amp;#xff0…阅读更多...Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:54 +0000</pubDate>
    </item>
    <item>
      <title>PyCharm借助MobaXterm跳板机连接服务器</title>
      <link>https://www.ppmy.cn/news/1541028.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维PyCharm借助MobaXterm跳板机连接服务器news/2025/11/1 0:24:53/服务器信息：Step 1MovaXterm→Session→SSH输入服务器信息Step 2MovaXterm→Session→SSH→Network setting→SSG gateway(jump host)输入跳板机信息键入密码即可Step 3MovaXterm→Tunneling→New SSH tunnel依次输入：A本机端口，B 跳板机信息，C 服务器信息点击runStep 4Pycharm 连接到 p6661 127.0.0.1 即可http://www.ppmy.cn/news/1541028.html相关文章离散制造和流程制造分别是什么？它们有什么区别？为何有的企业生产过程看似一气呵成&amp;#xff0c;而有的则是由多个环节组合而成&amp;#xff1f;其实这就涉及到了制造业的两种常见生产模式。 
流程制造离散制造 
那么&amp;#xff0c;在生产管理方面&amp;#xff0c;离散制造和流程制造分别有什么特点、区别呢&amp;#xff1f; 
今天&amp;#xff0…阅读更多...Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:53 +0000</pubDate>
    </item>
    <item>
      <title>离散制造和流程制造分别是什么？它们有什么区别？</title>
      <link>https://www.ppmy.cn/news/1541027.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维离散制造和流程制造分别是什么？它们有什么区别？news/2025/11/1 0:24:51/为何有的企业生产过程看似一气呵成，而有的则是由多个环节组合而成？其实这就涉及到了制造业的两种常见生产模式。流程制造离散制造那么，在生产管理方面，离散制造和流程制造分别有什么特点、区别呢？今天，我就用一文讲清流程制造与离散制造的概念、特点、对应企业如何进行生产管理以及它们在生产业务流、生产管理方面的区别与联系，文末，我还会给出三个与流程型、离散型生产管理有关的常见问题并进行解答。一、什么是离散制造与流程制造？在开始介绍之前，先给大家展示一下离散制造和流程制造的生产管理模板，帮助大家更直观的了解两种生产方式。离散型重在装配管理，也就是最终要把分散在各地的零件集中在一起进行组装，生产管理模板如下：https://s.fanruan.com/9cbav流程型重在工序管理，也就是每个环节之间都要安排的井井有条，在工序上万万不可出差错：https://s.fanruan.com/rxg761.离散制造“多个环节组合”进行生产的企业采用了离散制造，采用这种生产模式的产品对零部件的生产没有特定顺序要求，可以在不同地方的流水线对原材料进行加工后形成零部件，最后再把来自不同地的零件组装起来，形成产品。离散制造具体是指产品的生产过程由多个独立的零部件经过一系列不连续的工序加工、组装而成的制造方式。在离散制造中，每个零部件的生产通常可以在不同的时间和地点进行，生产过程具有明显的阶段性和可分割性。例如汽车制造、电子产品制造等行业，都是典型的离散制造。离散制造的特点主要包括以下几个方面：产品多样性：可以生产出多种不同规格、型号和性能的产品，以满足不同客户的需求。例如，汽车制造商可以生产出不同款式、配置的汽车。生产过程复杂：涉及多个零部件的加工和组装，生产流程相对较长且复杂。每个零部件可能需要经过多道工序，如切削、冲压、焊接等，然后再进行组装。生产设备通用性与专用性结合：离散制造企业通常会使用通用设备和专用设备的组合。通用设备可以用于生产多种不同的产品，而专用设备则针对特定的零部件或工艺进行设计，提高生产效率和质量。生产计划与控制难度大：由于产品的多样性和生产过程的复杂性，离散制造的生产计划需要考虑多个因素，如零部件的库存、生产进度、设备可用性等。同时，生产过程中的不确定性因素较多，需要进行灵活的调整和控制。2.流程制造企业生产“一气呵成”的采用的是流程制造，顾名思义，也就是按照特定的流程顺序对原材料进行一系列加工直到形成工业品，通常是单一的流水线流程制造具体是指原材料经过一系列连续的物理或化学变化，转化为最终产品的制造方式。在流程制造中，生产过程通常是连续的，一旦开始就难以中断，需要持续进行直到产品产出。例如石油化工、食品饮料、制药等行业，都属于流程制造。流程制造的特点主要包括以下几个方面：产品相对单一：通常生产标准化的产品，产品的性质和质量在生产过程中相对稳定，变化较小。例如，炼油厂生产的汽油、柴油等产品，其规格和质量标准相对固定。生产过程连续：原材料按照一定的工艺流程连续地进行加工和转化，各个生产环节紧密相连。生产设备通常是大型的专用设备，一旦安装完成，难以用于其他产品的生产。工艺过程复杂，生产设备专用性强：涉及多个物理或化学变化过程，对工艺参数的控制要求严格。例如，在石油化工行业，温度、压力、流量等工艺参数的微小变化都可能对产品质量产生重大影响。通常使用大型的专用设备，设备的专业性强，投资大，一旦安装完成，难以用于其他产品的生产。例如炼油厂的蒸馏塔、反应釜等设备，只能用于特定的工艺流程。生产计划相对稳定：由于生产过程连续且难以中断，流程制造的生产计划通常是基于长期的市场需求预测和设备产能制定的，相对稳定。同时，需要保证原材料的稳定供应和设备的正常运行，以确保生产的连续性。二、离散制造和流程制造的区别离散制造和流程制造在实际应用中的区别到底是什么呢？下面就用我刚才展示的那两个系统给大家详细的讲解。离散制造的业务流程离散制造的产品通常是由多个零部件经过一系列不连续的工序组装而成。其生产业务流一般包括以下步骤：订单接收：企业接收客户订单，明确产品的规格、型号、数量等要求。设计规划：根据订单要求，进行产品设计和规划，确定所需的零部件清单。零部件采购：采购部门根据零部件清单，从供应商处采购所需的零部件。生产排程：根据订单交付时间和零部件到货情况，制定生产排程计划，安排各个零部件的生产顺序和时间。零部件生产：各个生产车间按照生产排程计划，分别生产零部件。组装调试：将生产好的零部件运输到组装车间，进行组装和调试，形成最终产品。质量检验：对组装好的产品进行质量检验，确保产品符合质量标准。包装入库：对合格产品进行包装，然后入库存储，等待发货。离散制造的生产管理产品管理：注重零部件的规格、型号、质量等信息的管理，确保零部件的准确性和兼容性，以满足产品的定制化需求。计划管理：生产计划相对复杂，需要考虑多个因素，如零部件的供应、生产进度、客户订单的优先级等。需通过精确的生产排程，协调各个零部件的生产和组装进度，以满足客户的交货期要求。委外管理：由于零部件众多，可能会将部分零部件的生产委托给外部供应商，对委外供应商进行选择、评估和监控，确保委外零部件的质量、交货期和成本符合要求。​​​​​​​库存管理：离散型制造需要管理大量的零部件库存，以满足生产的需要，但同时也面临库存积压的风险。需要优化库存水平，减少库存成本，同时确保零部件的及时供应。​​​​​​​装配管理（离散制造专属）：对生产计划-装配执行环节进行实时跟踪，统计装配用料、入库情况。​​​​​​​流程制造的业务流程流程制造的生产过程是连续的，原材料经过一系列的物理或化学变化，形成最终产品。其生产业务流一般包括以下步骤：原材料采购：企业采购所需的原材料，如原油、矿石、粮食等。生产准备：对原材料进行预处理，如清洗、粉碎、混合等，为生产过程做好准备。连续生产：原材料进入生产设备，经过一系列连续的物理或化学变化，转化为产品。过程控制：在生产过程中，对温度、压力、流量等工艺参数进行实时监测和控制，确保生产过程的稳定性和产品质量。质量检验：对生产出的产品进行质量检验，确保产品符合质量标准。包装储存：对合格产品进行包装，然后储存到仓库中，等待销售。流程制造的生产管理产品/技术管理：关注产品的质量稳定性和一致性，对原材料的质量和配方的控制较为严格。​​​​​​​计划管理：生产计划相对稳定，主要基于长期的市场需求预测和设备产能制定，要保证生产过程的连续性，避免因计划调整导致生产中断。​​​​​​​委外管理：流程管理制造的委外情况相对较少，因为生产过程连续且对设备专业性要求高，管理重点主要集中在原材料的采购管理上，确保原材料的稳定供应。库存管理：流程制造的库存主要包括原材料和成品，库存管理重点在于确保原材料的充足供应和成品的及时发货，要对库存的周转率和存储成本进行控制，避免库存积压。生产工序管理（流程制造专属）：在产品信息环节设定产品对应的工艺路线及工序，确保产品工序井然有序。下面，就给大家对比分析一下离散制造与流程制造的区别与联系。三、离散制造与流程制造有什么异同？相同点都是制造业的重要组成部分，离散制造和流程制造共同构成了现代制造业的主体。无论是汽车、电子产品等离散制造产品，还是石油、化工、食品等流程制造产品，都是人们生活和社会经济发展不可或缺的。相互依存，离散制造产品的生产往往需要流程制造提供原材料和零部件。例如汽车制造需要钢铁、橡胶、塑料等原材料，这些原材料大多是通过流程制造生产出来的。同时，流程制造也需要离散制造提供设备和技术支持。技术融合随着科技的发展，离散制造和流程制造在技术上逐渐融合。例如自动化技术、信息技术在两种生产模式中的广泛应用，提高了生产效率和质量控制水平。同时，智能制造的发展也为两种生产模式的融合提供了新的机遇。都需要进行生产计划管理：无论是离散制造还是流程制造，都需要根据市场需求和企业资源制定合理的生产计划，以确保生产的高效进行。都注重质量控制：产品质量是企业生存和发展的关键，两种生产模式都需要建立严格的质量控制体系，确保产品符合标准和客户需求。都需要进行成本管理：降低生产成本是企业提高竞争力的重要手段，两种生产模式都需要通过优化生产流程、降低原材料消耗、提高设备利用率等方式来降低成本。不同点生产计划的重点不同：离散制造的生产计划重点在于零部件的生产和组装进度的协调，以满足客户的定制化需求。而流程制造的生产计划重点在于保证生产的连续性和稳定性，以确保产品的质量和产量。质量控制的方法不同：离散制造通常采用抽样检验的方法进行质量控制，对生产过程中的关键环节进行检验，以确保产品的质量。而流程制造由于生产过程连续，通常采用在线检测的方法进行质量控制，实时监测生产过程中的参数变化，以确保产品的质量稳定。设备管理的要求不同：离散制造的设备通用性较强，设备管理重点在于设备的维护和保养，以确保设备的正常运行。而流程制造的设备专业性强，设备管理重点在于设备的可靠性和稳定性，以确保生产的连续性。最后给大家整理了几个私信常会被问到的问题及解答四、常见问题及解答问题一：离散制造和流程制造在生产管理上的主要难点分别是什么？离散制造的生产管理难点主要在于零部件众多，生产计划复杂，需要协调各个零部件的生产进度和组装进度，同时还要应对客户的定制化需求。流程制造的生产管理难点在于生产过程连续，一旦出现问题可能影响整个生产线，对设备的可靠性和稳定性要求高，同时需要严格控制工艺参数以确保产品质量稳定。问题二：如何提高离散制造企业的生产效率？可以通过优化生产排程、提高设备利用率、加强供应链管理等方式提高离散制造企业的生产效率。例如，采用先进的生产排程软件，合理安排各个零部件的生产顺序和时间；定期对设备进行维护和保养，提高设备的可靠性和稳定性；与供应商建立紧密的合作关系，确保原材料的及时供应。问题三：流程制造企业如何确保产品质量？流程制造企业可以通过严格控制工艺参数、加强在线检测、建立完善的质量管理体系等方式确保产品质量。例如，对生产过程中的温度、压力、流量等工艺参数进行实时监测和控制，确保生产过程的稳定性；采用在线检测设备，实时监测产品质量，及时发现问题并进行调整；建立完善的质量管理体系，对原材料、生产过程、成品进行全面的质量控制。http://www.ppmy.cn/news/1541027.html相关文章Electron-（三）网页报错处理与请求监听在前端开发中&amp;#xff0c;Electron 是一个强大的框架&amp;#xff0c;它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中&amp;#xff0c;及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监…阅读更多...Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:52 +0000</pubDate>
    </item>
    <item>
      <title>Electron-（三）网页报错处理与请求监听</title>
      <link>https://www.ppmy.cn/news/1541026.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Electron-（三）网页报错处理与请求监听news/2025/11/1 0:24:50/在前端开发中，Electron 是一个强大的框架，它允许我们使用 Web 技术构建跨平台的桌面应用程序。在开发过程中，及时处理网页报错和监听请求是非常重要的环节。本文将详细介绍 Electron 中网页报错的日志记录、webContents 的监听事件以及如何监听全部请求并记录。一、Electron 中网页报错的日志记录在 Electron 中，我们可以通过监听BrowserWindow的错误事件来记录网页加载失败、临时加载失败、带响应的加载失败、网页崩溃以及渲染进程消失等情况的日志。例如，以下代码展示了如何监听BrowserWindow的错误事件并记录日志：importlogfrom"./log.js";importconfigfrom"./config.js";import{BrowserWindow}from"electron";functionstartSurveil(win){// 监听网页加载失败事件win.webContents.on("did-fail-load",(_event,errorCode,errorDescription,_validatedURL)=&gt;{log.error(`网页加载失败：错误码${errorCode}，错误描述${errorDescription}`);});// 监听临时加载失败事件win.webContents.on("did-fail-provisional-load",(_event,errorCode,errorDescription,_validatedURL)=&gt;{log.error(`临时加载失败：错误码${errorCode}，错误描述${errorDescription}`);});// 监听带响应的加载失败事件win.webContents.on("did-fail-load-with-response",(_event,errorCode,errorDescription,_validatedURL,response)=&gt;{log.error(`带响应的加载失败：错误码${errorCode}，错误描述${errorDescription}，响应${response}`);});// 监听网页崩溃事件win.webContents.on("crashed",()=&gt;{log.error("网页崩溃");});// 监听渲染进程消失事件win.webContents.on("renderer-process-gone",(_event,details)=&gt;{log.error(`渲染进程消失：原因${details.reason}`);});}通过以上代码，我们可以在应用程序中及时发现网页报错情况，并记录详细的错误信息，以便后续的排查和修复。二、Electron 中 webContents 的监听事件webContents是 Electron 中BrowserWindow的一个重要属性，它代表了窗口的渲染进程内容。我们可以通过监听webContents的各种事件来实现对网页的监控和交互。在上述代码中，我们使用了以下几个webContents的监听事件：did-fail-load：当网页加载失败时触发。did-fail-provisional-load：当临时加载失败时触发。did-fail-load-with-response：当带响应的加载失败时触发。crashed：当网页崩溃时触发。renderer-process-gone：当渲染进程消失时触发。这些事件可以帮助我们及时发现网页的各种问题，并采取相应的措施进行处理。三、Electron 监听全部请求并记录除了监听网页报错事件，我们还可以监听 Electron 应用程序中的全部请求并记录相关信息。在上述代码中，我们使用了webContents.session.webRequest.onCompleted方法来监听请求完成事件。以下是具体的代码实现：constses=win.webContents.session;ses.webRequest.onCompleted({types:[],urls:[config.domain+"/*"],},(details)=&gt;{if(config.statusCodesForRecord.indexOf(details.statusCode)&gt;-1){log.warn("&gt; Request error: ",details.url);log.warn("  &gt; error: ",details.error);log.warn("  &gt; method: ",details.method);log.warn("  &gt; statusLine: ",details.statusLine);log.warn("  &gt; resourceType: ",details.resourceType);}});在这个方法中，我们通过指定types和urls参数来过滤需要监听的请求。在回调函数中，我们可以根据请求的状态码来判断是否需要记录请求错误信息。如果请求的状态码在config.statusCodesForRecord数组中，我们就记录请求的 URL、错误信息、请求方法、状态行和资源类型等信息。四、总结通过以上的介绍，我们了解了在 Electron 中如何记录网页报错的日志、监听webContents的事件以及监听全部请求并记录。这些功能对于开发稳定、可靠的 Electron 应用程序非常重要。在实际开发中，我们可以根据具体的需求对这些功能进行扩展和优化。例如，我们可以将错误日志发送到远程服务器进行集中管理，或者对特定的请求进行更详细的分析和处理。总之，Electron 提供了丰富的 API 来处理网页报错和监听请求，我们可以充分利用这些功能来提高应用程序的质量和稳定性。http://www.ppmy.cn/news/1541026.html相关文章Web3的核心概念：去中心化如何改变互联网Web3&amp;#xff0c;作为互联网的下一代技术架构&amp;#xff0c;正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比&amp;#xff0c;Web3的核心在于去中心化的理念&amp;#xff0c;旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。 
1. 数据的掌控与隐私保护 
在W…阅读更多...持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:50 +0000</pubDate>
    </item>
    <item>
      <title>Web3的核心概念：去中心化如何改变互联网</title>
      <link>https://www.ppmy.cn/news/1541025.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Web3的核心概念：去中心化如何改变互联网news/2025/11/1 0:24:49/Web3，作为互联网的下一代技术架构，正在重新定义用户与数据、平台之间的关系。与以往的Web2.0时代相比，Web3的核心在于去中心化的理念，旨在通过区块链等技术实现更高的透明度、安全性和用户控制权。1. 数据的掌控与隐私保护在Web2.0时代，用户的数据被中心化平台（如社交媒体和搜索引擎）收集和控制，这些公司能够对数据进行商业化利用，导致用户隐私面临重大风险。Web3通过去中心化的技术架构，使用户能够掌控自己的数据。区块链技术允许用户以加密的形式存储和管理自己的数据，只有用户自己能够决定谁可以访问这些信息。这种转变将极大地增强用户的隐私保护意识，推动互联网朝着更加安全的方向发展。2. 用户身份与数字身份管理Web3中的去中心化身份（DID）概念，允许用户在不同的平台之间无缝切换，而无需每次都注册新账户。用户可以利用区块链创建和管理自己的数字身份，确保身份信息的安全性和可验证性。这种新形式的身份管理不仅提高了安全性，还简化了用户体验，避免了在不同平台间重复身份验证的麻烦。用户能够自由选择分享哪些信息，从而增强对自己数字身份的控制。3. 去中心化应用（DApps）的崛起Web3时代的去中心化应用（DApps）是基于区块链技术构建的应用程序，用户可以直接在没有中介的情况下进行交互。这意味着用户可以在应用内自由交换价值、信息和资产，而无需依赖于传统的中心化平台。DApps的兴起为开发者提供了新的商业模式，降低了进入门槛，并为创新提供了广阔的空间。4. 社区驱动的治理在Web3的生态系统中，去中心化治理成为重要特征。传统平台的决策往往由少数公司或团队掌握，而Web3鼓励用户共同参与治理。许多项目采用去中心化自治组织（DAO）的形式，让社区成员通过投票直接参与重要决策。这种治理结构不仅增强了透明度和参与感，也能更好地反映用户的需求和意见，使得产品和服务不断优化。5. 价值的重新定义去中心化还促使了价值观的重新定义。在Web3中，用户不仅是内容的消费者，更是创造者和价值的生产者。用户可以通过参与社区活动、贡献内容、提供服务等方式获得回报，这一过程打破了传统平台的价值链。用户的参与和贡献在去中心化网络中得到了更好的认可和奖励，促进了生态系统的可持续发展。DApps通过区块链技术实现了无信任的交互，用户可以在没有中介的情况下进行交易和互动。这不仅减少了对第三方机构的依赖，还降低了数据被滥用的风险。ClonBrowser通过其账户管理功能，用户可以在不同的DApps上保持匿名，从而进一步保护自己的隐私。http://www.ppmy.cn/news/1541025.html相关文章持续科技创新 高德亮相2024中国测绘地理信息科技年会图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。 
10月15日&amp;#xff0c;2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商&amp;#xff0c;高德地图凭借高精度高动态导航地图技术应用受邀参会。 
本…阅读更多...vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:49 +0000</pubDate>
    </item>
    <item>
      <title>持续科技创新 高德亮相2024中国测绘地理信息科技年会</title>
      <link>https://www.ppmy.cn/news/1541024.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维持续科技创新 高德亮相2024中国测绘地理信息科技年会news/2025/11/1 0:24:48/图为博览会期间, 自然资源部党组成员、副部长刘国洪前往高德企业展台参观。10月15日，2024中国测绘地理信息科学技术年会暨中国测绘地理信息技术装备博览会在郑州召开。作为国内领先的地图厂商，高德地图凭借高精度高动态导航地图技术应用受邀参会。本届年会由中国测绘学会主办，以“拥抱新质生产力、促进测绘地理信息高质量发展”为主题。会议期间，自然资源部、中国测绘学会等多个部门领导、包括多位两院院士在内的众多学术界泰斗和优秀企事业单位代表参加，围绕测绘地理信息领域的前沿技术、最新科研成果以及创新应用进行深入交流和探讨，共同推动行业进步与发展。在会上，高德地图董事长刘振飞做了“践行使命担当、持续科技创新、用心做好一张活地图”的主题分享。他强调，作为当代地图人，高德将紧跟国家战略、科技前沿、用户需求，致力于成为国家需要的地图、符合时代发展的地图、老百姓需要的地图，让出行与生活更美好。打造大数据时代地图生产的新质生产力近年来，我国测绘地理信息科技水平跻身世界先进行列，测绘地理信息生产力水平实现了质的飞跃。高德地图从最初拥有甲级测绘资质的领先地图厂商，到如今构建的出门好生活开放服务平台，始终围绕连接真实世界，做好一张活地图的使命不变。在智慧出行方面，业界亟需“高精度高动态的导航地图”。要能覆盖全域、能大规模动态更新，这是一道国际性的技术难题。高德地图通过自主创新，研发了大规模复杂城市场景下视觉众源实时感知、多模态定位、知识与数据协同的自动化制图技术，构建了面向亿级用户的高精度高动态导航地图生产与服务平台，满足了广大用户对高精度高动态导航地图的迫切需求。同时，高德地图还通过数实融合以科技创新助力交通强国建设。作为参与交通强国试点的民营科技企业，高德聚焦一体化出行服务战略，通过整合多种运输方式、提供系统性出行解决方案，构筑一站式出行入口和一体化出行生态，满足人民群众多层次、多样化、个性化的出行需求，以聚合模式构建一体化出行服务体系。高德秉承“新技术”加“老师傅”的建设模式，在交通出行领域创新引入聚合模式，通过与专业交通运输企业合作，建设一体化出行服务平台，为用户提供了一站式出行入口。如融入公交地铁、出租车、骑步行等城市出行服务；火车、客运、飞机等城际出行服务；以及酒店、门票、加油、充电等配套服务。都是通过把传统“位移服务”变为现代“出行服务”，构建融合产业链的一体化出行服务体系。图为高德地图董事长刘振飞在本次年会上做主题分享。“为了更好打造高德一体化出行服务平台，我们坚持聚合这一生态模式，通过聚合全域企业，聚合全栈服务，将高德平台打造成为服务360行的产业基础底座，为千行百业赋能，最终实现生态共进，产业共赢。从而带动生态共赢。“刘振飞如是说。除此之外，高德地图还奋力构筑北斗系统全面主导的产品服务矩阵。作为一家专注于地图导航的科技企业，高德有幸见证了北斗从起步到世界一流的发展历程。2022年，高德地图全面应用北斗系统，推出北斗卫星定位查询功能，同年11月高德地图北斗调用率已超越GPS等系统。目前，高德地图调用北斗卫星日定位量已超3000亿次，峰值超4500亿次。刘振飞提到，2023年，高德地图发起“北斗民用出行创新计划”，进一步探索拓展北斗系统在民用领域的产业化，助力国家自主高精尖科技在交通出行场景的落地。做一张既有科技感又有人情味的活地图随着移动互联网的发展，高德地图不断进行技术升级，以应对用户不断变化的需求。而地图和AI的结合，不仅是技术的叠加，更是需求与功能的完美契合。公开资料显示，高德地图最新发布的V15版本，升级推出了车道级领航、北斗卫星无网导航、卫星求救、3D立体地图、AI领航员等功能，通过引入AI等前沿技术，提升用户体验。刘振飞介绍，高德地图在数字化转型的创新与实践过程中，基于时空AI新技术，发布了业内首个基于时空信息打造的产业融合大模型。通过构建统一时空要素平台，以此为基础自主研发了面向数据洞察和决策支持类场场景的时空大模型引擎“云睿”和面向政府和企业资产数字化管理场景，还原真实世界的时空孪生地图“云境”。其中，基于“云睿”的高德地图交通行业大模型应用后，实现了“毫秒级”表征Link级交通特征要素构建、“秒级”多场景解决方案自动生成、“分钟级”实时交通流全量预测和“天级”超大规模城市交通评诊治系统弹性上线。“云境”时空孪生地图具备高效、易用、低成本和多精度的特征，更是为实景三维中国的建设提供了有效的助力。据了解，目前云境时空孪生地图已经广泛的应用于智慧路口、低空经济、城市应急、重大活动及消防管理等诸多城市治理的需求场景。刘振飞表示，除了科技，高德还要做有人情味的活地图，紧跟特殊人群、特殊场景需求，做老百姓需要的地图。目前，高德针对老年人群体启动“助老暖心出行计划”，推出一键叫车功能，服务老年人累计已超6000万次；针对腿脚不方便的人群上线无障碍轮椅导航服务，已覆盖全国50个主要城市，提供超9500万次无障碍路线规划；针对视障人士上线视障导航，解决盲人出行提示音嘈杂、难分方向、避开障碍、盲道占用等痛点问题；针对听障人士高德新增手语无障碍公共服务点位信息指引，已经在杭州、上海、长沙和哈尔滨4个城市上线了120个点位；秉承“让生命享有更高的通行优先权”，上线“一路护航”功能，提供让行播报、绿灯保障、线路定制等服务，为救护车开辟绿色通道，目前每天让行播报发布约6000次……此外，高德还推出了长辈版地图、色盲地图、厕所地图、扶贫地图、公益地图等服务。“促科技创新，与生态共进，连接真实世界，做好一张活地图，让出行与生活更美好！”刘振飞说，高德地图将致力于各种前沿技术转化为民用交通服务，不断深化细分场景，提供有温度、有体感的出行服务。http://www.ppmy.cn/news/1541024.html相关文章vector和listvector 
1.vector的介绍 
https://legacy.cplusplus.com/reference/vector/vector/?kwvector 
点击上面链接&amp;#xff0c;进去搜索vector&amp;#xff0c;就会有相应的文档介绍了。 
使用STL的三个境界&amp;#xff1a;能用&amp;#xff0c;明理&amp;#xff0c;能扩展&amp;#xff0c;那么学习vect…阅读更多...AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:48 +0000</pubDate>
    </item>
    <item>
      <title>vector和list</title>
      <link>https://www.ppmy.cn/news/1541023.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维vector和listnews/2025/11/1 0:24:47/vector1.vector的介绍https://legacy.cplusplus.com/reference/vector/vector/?kw=vector点击上面链接，进去搜索vector，就会有相应的文档介绍了。使用STL的三个境界：能用，明理，能扩展，那么学习vector，也是按照这个方法进行的。我们在学习CPP的时候，一定要学会看文档。其实vector就是我们再C语言学习的顺序表，只不过，我们再C学习的时候，每次都需要手撕代码。而到了C++就不用了，STL已经帮我们写好了，我们只需要去学习，并熟悉它的使用方法就行了。2.构造和析构下面，我们需要来熟悉一下，vector的构造，析构和赋值。构造和赋值，都比较简单，而析构的话，编译器会自动析构，不用我们显式的调用析构。还有就是vector也可以存储vector。int main()
{//相当于二维数组vector&lt;vector&lt;int&gt;&gt; vv;//顺序表里面存的是string对象vector&lt;string&gt; tmp;return 0;
}当然，不仅限于这些内置类型，容器这些。我们的自定义类型也可以存储。比如我们前面写的日期类，也可以进行使用vector存储。3.迭代器操作其实，我们前面讲的string类，其实底层也和顺序表类似的，说一说不仅仅是迭代器操作，还是其他的操作，接口都是类似的。我们这里就不一一演示了。4.capacity1.max_size这里需要解释一下，max_size这个接口，它表示的是返回vector能够储存的最大容量大小。但是这也和内存有关系，也和栈上面的空间有联系的，它不一定能够到达最大容量。2.shrink_to_fit这个接口的意思是，让容器的容量缩小到适应其的长度。但这个适应的长度也和编译器有相关，也可能刚好和size一样大，也可能比size要大。然后其他的接口相对来说比较简单，我们再string也讲过，就不说了。5.成员接口由于vector底层其实就是数组，所以可以使用下标访问，前面我们说了at其实和[ ]访问差不多，但是我们应该都习惯使用 下标加[ ]。然后，front我们应该也用的比较少，我们可以直接访问[ 0]就行了，这样反而更麻烦。back相对来说可能用得多一点 ， 但是 我们也可以使用[ size()]来访问。 相对来说back 和 front 在 list 里使用更加方便。6. 修改（modify）1.assign（分配）这个接口，就是给vector分配多少个空间，并进行初始化。像这样，就为vector 分配了100个空间，并用4来初始化了。2.emplaceemplace的使用就是和insert 差不多的，我们平常使用的insert 较多一点，使用insert 也是可以的。vector的使用我们就先说到这里，下面来看一看list。list1.list 的介绍list 就是链表，但是链表又分为 单向带头和不带头链表，双向带头和不带头链表。我们这里学习的STL中的list是双向带头链表。list相较于vector的使用就会复杂一点。下面我们来了解一下。list的使用：list中的接口比较多，只需要掌握如何正确的使用，然后再去深入了解底层是怎样实现的，已经可以达到扩展的能力。2.构造析构赋值析构一般也不需要我们显式调用，编译器会自动调用。3.迭代器迭代器的使用也和前面的容器差不多的。我们后面主要讲迭代器的底层实现。4.capacity5.成员接口对于list来说，无法做到随机访问，只能访问front 和 back，如果要找某一个成员的话，就只能遍历链表了。6.modifymodify的接口也没有什么特别的，特别的是加入了 swap 和clear。swap 其实就是交换两个链表的值，也没有什么好说的。clear 这个接口就是清除所有的节点，只留哨兵位，但是它的空间长度不会改变，智慧改变size（）的大小。7.其它操作函数1.reversereverse 就是将链表反转，我们只需要调用它即可。 然后，再标准库中还有一个reverse函数，那一个迭代器就需要我们传入迭代器区间进行反转。2.merge 和 sort这两个操作是排序，merge就是归并排序，sort 底层使用的快速排序。3.uniqueunique 这个函数是删除链表中的重复的元素，如果有多个，就只留下第一个，删除后面相同的元素。4.splicesplice 是拼接的意思，我们可以把另一个链表，拼接到第一个链表的任何位置。总结说到最后，我们来说一说list 和 vector的优缺点。List优点：动态大小：list可以根据需要动态增加或减少大小，不需要预先定义大小。插入和删除操作高效：在中间位置插入或删除元素的时间复杂度为 O(1)，不需要移动其他元素。内存使用灵活：可以不连续地存储节点，特别是在大数据量需要频繁插入和删除时更具优势。缺点：访问速度慢：与vector相比，随机访问（如根据索引访问元素）的时间复杂度为 O(n)，因为需要从头遍历到指定位置。内存开销大：每个节点需要额外的内存存储前驱或后继指针，相比之下，vector的内存开销较小。Cache(高速缓存） 效率低：由于节点的内存位置不连续，可能导致缓存命中率降低，影响性能。Vector优点：随机访问速度快：支持 O(1) 的随机访问，可以直接通过索引访问元素。内存开销小：元素存储在连续的内存块中，开销相对较小，适合存储大量数据。Cache（高速缓存） 效率高：由于内存连续，可以更好地利用 CPU 缓存，提高性能。缺点：插入和删除操作效率低：在中间位置插入或删除元素的时间复杂度为 O(n)，需要移动大量元素。容量限制：尽管vector支持动态扩展，但当达到容量时，可能需要重新分配更大的内存，涉及到元素的拷贝，性能消耗较大。不支持高效的链式数据结构特性：例如，无法在中间部分高效地插入或删除节点。总结选择list：当需要频繁在集合中间插入或删除元素时，或者不在乎访问速度时。选择vector：当需要高效的随机访问和更小的内存开销，且插入和删除操作相对较少时。根据具体的使用场景和需求来决定应该使用哪种数据结构是很重要的。http://www.ppmy.cn/news/1541023.html相关文章AI编译器与TVM由于AI芯片的特殊性和高度定制化&amp;#xff0c;为了兼容硬件的多样性&amp;#xff0c;AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入&amp;#xff0c;将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产…阅读更多...大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:47 +0000</pubDate>
    </item>
    <item>
      <title>AI编译器与TVM</title>
      <link>https://www.ppmy.cn/news/1541022.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维AI编译器与TVMnews/2025/11/1 0:24:46/由于AI芯片的特殊性和高度定制化，为了兼容硬件的多样性，AI模型必须能被高效地映射到各种AI芯片上。AI编译器将深度学习框架描述的AI模型作为输入，将为各种AI芯片生成的优化代码作为输出。AI编译器的目标是通过编译优化的方法将深度学习框架产生的AI模型转化为与特定架构的AI芯片适配的可执行机器码。主流的AI硬件厂商都提供了高度优化的算子库或者推理引擎来实现高效计算，但是依赖算子库的缺点是算子库覆盖的硬件范围有限，而且库函数的更新落后于模型的发展速度，无法充分发挥AI芯片算力。算子与硬件算子库高度耦合会导致算子不可分解，从而影响算子进一步优化，使其难以在硬件平台上高效执行。为了解决这些缺点，业界设计了AI编译器。AI编译器可以在代码生成期间生成对库函数的调用，这样工作量就可以从编译器转移到算子开发上了。相反，如果编译器有强大的代码生成能力，则对内核函数的优化的依赖也会减小。AI编译器结构常规的编译器包含三个部分：前端、优化器和后端。前端主要负责将输入的源代码解析为抽象语法树，做语法分析、语义分析等；优化器在前端的基础上进行优化；后端会尽可能利用目标机器上的特殊指令优化中间代码，并将其转化为指定硬件平台的机器码。该三部分的数据传输是通过IR(Intermediate Representation)传输的，IR可以保证编译器的跨平台。AI编译器一般采用分层的设计，通过多级IR设计，实现针对AI模型的特定优化设计。高阶IR服务于前端，执行硬件无关的优化，低阶IR服务于后端，执行硬件相关的编译、优化和代码生成操作。高阶IR也叫图IR，旨在抽象计算和控制流，其目的是建立控制流及算子与数据之间的依赖关系，并为图优化提供接口。高阶IR还需要对数据张量和算子进行支持。低阶IR主要设计用于各种硬件相关的优化和代码生成。低阶IR会更加细粒度的反应硬件特性。低阶IR还需要兼容第三方工具链，利用已有编译工具完成通用优化和代码生成。AI编译器的输入是深度学习框架的模型，然后AI编译器将输入转化为高阶IR。AI编译器前端会结合通用编译器优化和AI特定的图优化方法对计算图优化生成优化后的计算图，该部分的优化是硬件平台无关的优化。AI编译器的后端优化是在高阶IR转化为低阶IR后，利用硬件的先验信息，通过定制化优化pass将优化后的代码实现映射为AI芯片的执行指令。TVM架构TVM是一个端到端的全栈编译器，提供端到端的编译优化。TVM以AI模型作为输入，首先将其转化为计算图，然后执行高级数据流重写，为计算图生成优化图。算子级优化模块为优化图中每个融合算子生成高效代码，并以声明式张量表达式指定算子。TVM会给指定硬件目标算子建立可能的优化集合，然后使用基于机器学习的代价模型搜索优化算子。最后将生成的代码打包到可部署模块中。代码生成是将TIR表示编译成目标硬件平台的机器码。TVM支持多种后端，包括但不限于：LLVM：可以针对任意微处理器架构生成代码，包括标准x86和ARM处理器，AMDGPU和NVPTX代码生成，以及LLVM支持的任何其他平台；专门的编译器，如NVCC（NVIDIA的编译器）；嵌入式和专用目标，通过TVM的Bring Your Own Codegen（BYOC）框架实现。因此，最终的输出是针对特定硬件平台优化的机器码，它可以是一个可执行文件、动态链接库（DLL）、静态链接库（LIB）或其他硬件平台支持的格式。这种格式的代码可以直接在目标硬件上运行，以实现高效的模型推理。TVM图级优化TVM可以对计算图做各种图优化，按照优化范围可以分为局部优化和全局优化。局部优化包括算子融合、代数简化、常量折叠，是图级优化的重点。全局优化是在整个计算图中搜索特定特征，并对这些特征执行优化操作，例如死代码消除、公共子表达式消除。高阶图优化的最好结果只能达到与算子库优化相同的性能。随着引入的算子越来越多，可融合的内核数量急剧膨胀，并且随着硬件后端种类不断增加，开发者将无法依赖算子库提供融合能力。考虑到每种硬件后端上算子手工实现优化内核会因工作量太大而不切实际。因此，TVM提供了代码生成方法为指定的AI模型算子生成可能的实现。在代码生成期间生成对库函数的调用，这样工作量就可以从编译器转移到算子开发上了。计算与调度TVM提供了张量表达式语言，为自动代码生成提供支持。张量表达式语言的每个计算操作分为两个部分：第一个部分指定输出张量形状，第二部分描述张量中每个元素的计算规则。张量表达式并没有指定执行细节，这为不同硬件中的优化实现提供可能性，开发者可以通过lambda表达式快速定义计算，而无需实现新函数。不同实现方法性能存在巨大差异，因此，TVM要求开发者指定如何执行计算，如访问数据的顺序、多线程并行的方式。TVM中将这种计算的实现称为调度(严格意义上来说是执行计算的实现的规划)，由tvm.te.schedule.Schedule对象表示，其中包含若干阶段，每个阶段对应一个描述调度方式的操作。TVM将计算和调度分离，同一种计算可以通过不同的调度实现。计算只定义了结果的计算方式，计算结果与运行平台无关。计算的实现由调度决定，调度取决于硬件，但不可影响结果的正确性。调度可以表示（为）张量表达式到底层代码的特定映射。TVM提供了许多调度原语为各种后端实现高性能代码。自动调优框架开发者需要对调度进行优化才能更好发挥硬件性能。这种优化可以是基于经验的手动优化，但是需要为每种硬件提供调度优化策略和调度相关参数，这样就会形成一个巨大的算子实现搜索空间。TVM提供了自动调度优化框架，可以为算子提供高性能底层代码实现。自动调优过程分两步：第一步定义搜索空间，第二部运行搜索算法。定义搜索空间可以看作是对调度的参数化，可将固定的调度改为定义调度策略的可调调度模板，通过该可调调度模板，从候选参数中选择在不同目标硬件上最优的参数组合。TVM提供了四种调优器在搜索空间中找到最优调度，RandomTuner：随机顺序遍历配置空间；GridSearchTuner：以网络搜索顺序遍历配置空间；GATuner：用遗传算法搜索配置空间，该方法无代价模型，只能在真实机器上测试；XGBTuner：该优化器的代价模型基于模拟退火算法，使用XGBoost算法训练模型，然后在配置空间中测试最优配置。在TVM中，搜索的主要是以下几个方面：调度参数：这些参数定义了如何在目标硬件上执行计算。它们包括循环的重排、并行化、向量化、展开、融合等循环变换。内存访问模式：不同的内存访问模式对性能有显著影响。搜索空间可能包括不同的内存访问模式，例如全局内存访问、共享内存访问、寄存器访问等。算子实现：对于某些操作，可能有多种实现方式。搜索空间可能包含不同的算子实现，以找到最适合特定硬件的版本。资源分配：这涉及到如何在硬件上分配计算资源，例如线程数、块数等。精度配置：在某些情况下，可以通过降低操作的数值精度来提高性能，搜索空间可能包括不同的精度配置。混合精度：在搜索空间中，还可以探索使用不同精度（如FP32和FP16）的组合来平衡性能和精度。自动调度算法：TVM提供了AutoTVM和AutoScheduler两种自动调优模块。AutoTVM是基于模板的调优模块，而AutoScheduler（Ansor）是无模板的调优模块，它们都通过搜索算法来探索搜索空间。TVM两级IRTVM有两级IR：Relay IR和张量级IR。Relay IR作为一种高阶图级IR，旨在最大限度利用函数式编程语言、类型系统和编译器技术的研究成果，改善模型部署开销。Relay IR的表达同时采用基于DAG的IR和基于let-binding的IR。DAG即有向无环图，可以明确表示算子之间的依赖关系，但是缺乏计算范围的定义，可能会出现二义性问题。let-binding通过在有限范围内为某些函数提供let表达式来消除语义二义性。高级IR有助于执行通用优化如内存重用、布局转化、自动分区等。高阶IR实现包括数据表示和算子实现。TVM的数据表示包括张量数据表示、形状表示、数据布局和边界推断等。TVM中数据通常以张量形式组织，通过占位符表示，持有明确的形状信息。通过占位符，开发者可以在不考虑具体元素的情况下操作计算图，实现了计算的定义与执行的分离。数据布局是作为算子的参数写入的，以便算子的实现和减少编译开销。数据布局包括维度顺序、分片、填充和跨距等。不同的硬件最优数据不同，执行性能也不同。Relay算子受数据布局影响程度各不相同，布局转换本身会消耗资源引入开销，TVM将Relay算子分为对布局无感、对布局轻度敏感和对布局重度敏感三类。TVM提供了ConvertLayout Pass，希望能以最少的数据布局转化次数改变整个图的数据布局。在高阶IR的算子实现中，开发者需要描述计算和调度，声明输入输出的形状。TVM添加新算子各层IR都需要改动，图级IR需要为新算子设置计算规则，张量级IR需要为每个硬件平台实现对应内核。低阶IR以更细粒度的表示形式描述计算，通过提供计算调优和内存访问接口实现目标相关的优化。经过Relay优化和降级之后，优化的算子通过TIR降级为C++/CUDA，或者降级为LLVM IR，然后通过NVCC或者LLVM等后端优化器和代码生成器产生机器码。运行时定制TVM运行时是部署和执行已编译模块的主要方式，其目标是提供可与前端语言交互的API集合。TVM运行时有两个基础模块：PackedFunc和ModuleNode。TVM代码生成将已编译对象封装为Module对象，并以PackedFunc对象形式返回其中的已编译函数。自定义硬件平台后端应派生ModuleNode子类实现各自的运行时模块，并在其中添加目标相关的运行时API调用。使用TVM运行时：编译后的模型可以生成为一个可执行文件或者库文件，然后通过TVM运行时来加载和执行。TVM运行时是一个轻量级的模块，提供了C API以及Python和Rust等语言的绑定，用于动态加载和执行编译后的模型。集成到应用程序：编译后的模型可以被集成到应用程序中，例如集成到移动应用或嵌入式设备中。这种方式下，应用程序可以直接调用编译后的模型执行推理。使用Graph Executor：TVM提供了Graph Executor，它是一个执行引擎，用于执行编译后的模型。Graph Executor可以加载编译后的模型，并执行推理过程。使用RPC服务：TVM支持远程过程调用（RPC）服务，允许模型在一台服务器上编译，然后通过网络在另一台设备上执行。这种方式适用于模型部署在不同的硬件平台或分布式系统中。使用WebAssembly：TVM还支持将模型编译为WebAssembly格式，使得模型可以在Web浏览器中运行，无需后端服务器。使用TVM微控制器运行时：对于微控制器和嵌入式系统，TVM提供了专门的运行时系统，用于在资源受限的设备上执行编译后的模型。使用TensorRT：对于NVIDIA GPU，TVM可以与TensorRT集成，利用TensorRT的高性能推理优化来执行编译后的模型。使用OpenCL：在支持OpenCL的设备上，TVM可以编译模型并利用OpenCL运行时来执行模型。使用Metal：对于苹果设备，TVM可以编译模型并使用Metal API来执行模型。TVM前后端优化计算图到目标代码的过程中可以分解若干个独立的步骤，这些步骤成为pass。RelayIR和TIR都包含一系列pass，为了使这些pass正确顺序执行，需要一个管理器安排pass执行顺序，在TVM中称作TVM pass基础架构。通过pass基础架构可以管理不同层次IR的优化pass。前端优化前端优化时通过遍历Relay IR，并从中捕获特定计算特征，以此指导图重写和图转换。前端优化与硬件无关只适用于计算图。优化pass可以分两种：函数级优化和模块级优化。函数级优化实现Relay或TIR模块中各函数内部优化，没有全局信息，不能添加或删除函数。如常量折叠、死代码消除。模块级优化用于实现过程间优化和分析，作用于IRModule对象上，可以对任何函数体做修改。如移除无用函数。后端优化TVM后端优化不仅针对低阶IR做优化，更针对不同硬件目标，结合硬件特性和后端优化技术，实现高效代码生成。后端优化可通过不同方式实现。一种是针对自定义加速器硬件，利用AI模型特性设计定制化的后端优化方法。第二种是将低阶IR转化为LLVM IR，利用LLVM基础结构生成优化的硬件可执行机器码。第三种是将低阶IR转化为内核源代码如CUDA，在利用已有的编译器如NVCC生成可执行代码。AI推理引擎与AI编译器的区别简单来讲，推理引擎就是对前端模型进行解释执行，一般是JIT的编译方式，提供了优化的kernel实现和设计的IR，并且IR一般是一种。AI编译器同样完成了对前端模型的执行操作但是一般包含多级IR，每级IR有不同的优化称作Pass，可以前端模型转化为C代码或者其他可执行代码，也可以转化为某种IR然后交由Runtime来解释执行。http://www.ppmy.cn/news/1541022.html相关文章大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试点一下关注吧&amp;#xff01;&amp;#xff01;&amp;#xff01;非常感谢&amp;#xff01;&amp;#xff01;持续更新&amp;#xff01;&amp;#xff01;&amp;#xff01; 
目前已经更新到了&amp;#xff1a; 
Hadoop&amp;#xff08;已更完&amp;#xff09;HDFS&amp;#xff08;已更完&amp;#xff09;MapReduce&amp;#xff08;已更完&amp;am…阅读更多...Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:46 +0000</pubDate>
    </item>
    <item>
      <title>大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试</title>
      <link>https://www.ppmy.cn/news/1541021.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大数据-171 Elasticsearch ES-Head 与 Kibana 配置 使用 测试news/2025/11/1 0:24:45/点一下关注吧！！！非常感谢！！持续更新！！！目前已经更新到了：Hadoop（已更完）HDFS（已更完）MapReduce（已更完）Hive（已更完）Flume（已更完）Sqoop（已更完）Zookeeper（已更完）HBase（已更完）Redis （已更完）Kafka（已更完）Spark（已更完）Flink（已更完）ClickHouse（已更完）Kudu（已更完）Druid（已更完）Kylin（已更完）Elasticsearch（正在更新…）章节内容上节我们完成了如下的内容：Elasticsearch 集群模式集群模式配置 启动 测试ES-Head插件为了我们测试和学习的方便，我们要安装一个叫：Elasticsearch Head插件。它是一个界面化的集群操作和管理工具，可以对集群进行傻瓜式操作，你可以通过把插件把它集成到ES。ES-Head主要是三个方面的操作：显示集群的拓扑，能够快速访问并显示集群的状态，并且能够执行索引和节点级别的操作。搜索接口能够查询集群中原始JSON或表格格式的检索数据有一个输入窗口，允许任意调用RESTAPIES-Head 是一个用于 Elasticsearch 集群管理的开源可视化插件，帮助用户监控和管理集群状态、索引及数据分布。ES-Head 是轻量级的，界面简洁直观，适合开发者和运维人员实时观察集群运行状况。官方地址这是一个开源的插件：https://github.com/mobz/elasticsearch-head功能特点集群健康监控显示集群的健康状态（green、yellow、red）。显示所有节点信息，包括主节点、副本节点状态。索引管理支持索引的查看、创建、删除、关闭和打开操作。查看每个索引的元信息（例如文档数量、段数量、占用存储等）。可以直接从界面更新索引的mapping和settings。数据节点监控显示每个节点的状态，包括已分配分片和未分配分片。展示节点的硬件资源信息，如存储空间使用情况。分片管理可视化显示分片的分配情况。支持查看未分配分片的原因，并手动重新分配分片。RESTful 查询执行提供查询编辑器，可以在插件中直接发送 RESTful 请求到集群。支持 GET、POST、PUT、DELETE 等请求方法，帮助调试和验证 API。索引分布可视化提供分片在集群中的分布图，便于检查数据分布和副本均衡情况。多集群支持可以在一个界面管理多个集群，支持跨集群查看索引状态。安装步骤Elasticsearch-head是一个基于Node.js的前端工程，官方有可以运行的Elasticsearch-Head的方式，但是这里我们为了方便，就不从部署的方式去做了，直接用Chrome插件的方式：https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm/安装之后，可以看到一个这样的插件：测试连接我们填写地址之后，访问（里边本来空的，后来为了测试，启动了Kibana之后，测试的这个）：使用场景开发和调试：开发者可以在插件界面直接发送 REST 请求，查看索引结构和数据。实时监控集群健康：管理员可以通过插件快速发现集群中的问题（如未分配的分片、节点挂掉等）。资源均衡优化：可视化查看分片分布，帮助进行负载均衡。注意事项由于 ES-Head 插件不需要登录认证，一旦对外开放接口，可能会存在安全风险。在生产环境中使用时，应通过 VPN 或防火墙限制访问权限。在大规模集群中，数据过多可能会导致界面响应缓慢。Kibana官方地址https://www.elastic.co/cn/support/matrix#matrix_osKibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图标，如柱形图、线状图、饼图等。而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。核心功能仪表盘（Dashboard）将多个可视化图表集成到一个页面，形成实时动态的仪表盘。支持图表拖拽、缩放和联动更新，方便数据展示。数据探索（Discover）提供灵活的搜索查询界面，可以按时间、字段和过滤条件进行数据检索。支持使用 KQL（Kibana Query Language） 和 Lucene 语法 查询数据。可视化（Visualizations）支持创建多种类型的可视化图表，如柱状图、折线图、饼图、地图、热力图等。可以将查询结果以图形方式展示，帮助更好地理解数据。日志分析（Logs）针对日志数据优化，支持快速查询和实时日志流分析。适合用于系统运维、错误排查和日志监控。监控（Monitoring）可监控 Elasticsearch 集群和 Kibana 自身的运行状态，如集群健康状况、节点性能等。可以帮助发现 Elasticsearch 集群中的瓶颈和问题。安全性（Security）支持用户认证和授权控制，与 Elasticsearch 的 X-Pack 安全插件集成。可以基于角色和用户设置访问权限，确保数据安全。告警（Alerting）支持创建告警规则，基于查询结果触发事件（如错误日志或异常情况）。可以将告警发送到电子邮件、Slack 或 Webhook。机器学习（Machine Learning）通过内置的机器学习功能，可以自动检测数据中的异常模式和趋势。应用于日志分析、指标监控和预测分析。Canvas用于创建自定义的交互式报告和演示。可以自定义图表样式和背景，适合数据驱动的商业演示。Geo 可视化（Maps）提供基于地理信息的可视化展示，支持 GeoJSON 数据。用于展示与地理位置相关的数据，如用户分布、销售区域等。安装步骤（注意：我们要在ROOT用户下进行操作！）我们现在项目并且上传（直接在服务器上下载也可以），上传到 h121 服务器上。对应的截图内容如下：解压配置cd/opt/softwarelstar-zxvf kibana-7.3.0-linux-x86_64.tar.gzmvkibana-7.3.0-linux-x86_64../servers对应的截图如下图所示：改变Kibana目录拥有者账号：chown-R es_server /opt/servers/kibana-7.3.0-linux-x86_64此外，还需要设置访问权限：chmod-R777/opt/servers/kibana-7.3.0-linux-x86_64配置文件修改配置文件：vim/opt/servers/kibana-7.3.0-linux-x86_64/config/kibana.yml在当中修改端口号等信息：server.port:5601elasticsearch.hosts:["http://h121.wzk.icu:9200"]server.host:"0.0.0.0"server.publicBaseUrl:"http://h122.wzk.icu:5601"修改内容部分如下图所示：启动服务配置完成之后，我们切换用户进行启动：sues_servercd/opt/servers/kibana-7.3.0-linux-x86_64
bin/kibana对应的截图如下：访问服务http://h122.wzk.icu:5601/网页的页面如下：(不一定有账号密码，高版本有要求，低版本直接进入就好)账号密码是 elastic 和 elastic的密码（之前postman测试的那个）我们点击右侧的：DevTool按钮，就可以进入 Kibana 提供的可视化工具了：可以测试一下这些命令，发现是没问题的，以后的命令可以在这里测了：使用场景日志与系统监控通过 Logstash 将日志文件发送到 Elasticsearch，使用 Kibana 实时监控系统日志和应用程序日志。业务数据分析在业务系统中，通过 Kibana 监控销售数据、客户数据等，支持企业决策。异常检测与告警使用 Kibana 监控系统性能或业务关键指标，当检测到异常时触发告警。用户行为分析监控网站或应用的用户行为，分析用户访问路径和流失率。http://www.ppmy.cn/news/1541021.html相关文章Docker 用例：15 种最常见的 Docker 使用方法容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念&amp;#xff0c;使容器管理流行起来。Docker 处于这一转变的核心&amp;#xff0c;帮助组织无缝地采用容器化技术。最近&amp;#xff0c;Docker 用例遍布所有行业&amp;#xff0c;无论规模大小和性质如何。 
什么是Docker&amp;…阅读更多...【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:45 +0000</pubDate>
    </item>
    <item>
      <title>Docker 用例：15 种最常见的 Docker 使用方法</title>
      <link>https://www.ppmy.cn/news/1541020.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Docker 用例：15 种最常见的 Docker 使用方法news/2025/11/1 0:24:43/容器化应用程序而不是将它们托管在虚拟机上是过去几年一直流行的概念，使容器管理流行起来。Docker 处于这一转变的核心，帮助组织无缝地采用容器化技术。最近，Docker 用例遍布所有行业，无论规模大小和性质如何。什么是Docker？Docker 是一种容器化技术，它使开发人员能够将服务及其依赖项、库和操作系统打包到容器中。通过将应用程序与基础架构分离，Docker 允许您在各种环境中无缝部署和移动应用程序。Docker 使用以下步骤可以非常简单地创建和管理容器：创建一个 Docker 文件并添加代码基于 Dockerfile 构建 Docker 镜像从 Docker 镜像创建一个正在运行的实例按需扩展容器什么是微服务？传统上，软件是使用单体架构开发的，其中整个软件是使用瀑布开发方法作为单个实体开发的。这些单体架构带来了规模、复杂性和可扩展性方面的挑战。微服务或微服务架构允许开发人员将应用程序分解为更小的独立单元，这些单元使用 REST API 相互通信，从而解决了这些挑战。通常，每个功能都可以开发为独立的服务，这意味着每个服务都可以独立运行而不影响任何其他服务。因此，组织可以加快发布周期、按需扩展操作并无缝更改代码，而无需应用程序停机。从单体架构迁移到微服务是一个流行的 Docker 用例。什么是容器？容器是微服务架构的一个显着用例。容器是一个标准的软件单元，它通过将应用程序与所有依赖项和所需资源打包在一起，将应用程序与其底层基础设施隔离开来。与虚拟化硬件层的虚拟机不同，容器仅虚拟化操作系统级别之上的软件层。我们将讨论更多关于容器管理的内容。Docker 的业务优势Docker 因其可移植性和生态系统而成为容器化的代名词。AWS、GCP 和 Azure 等主要云提供商都将 Docker 纳入系统并提供支持。因此，您可以在任何环境（包括 VirtualBox、Rackspace 和 OpenStack）上无缝运行 Docker 容器。可扩展性是 Docker 的最大优势之一。通过在单个主机上部署多个容器，组织可以显着降低运营成本。此外，Docker 允许您在商品硬件上部署服务，从而消除购买昂贵服务器的成本。​​​​​​​Docker 的基本格言包括更少的资源和更小的工程团队。因此，组织可以使用更少的资源执行操作，从而需要更少的人员来监视和管理此类操作。这意味着成本节约和更高的投资回报率。Docker 允许您轻松地即时创建和管理容器，从而促进更快的部署。使用简单的 YAML 配置文件部署和扩展基础设施的能力使其易于使用，同时提供更快的上市时间。每个隔离容器都优先考虑安全性。您将在下面找到最常见的 Docker 用例。Docker 用例 1：从单体架构到微服务架构仅使用整体方法（瀑布模型）开发软件的日子已经一去不复返了，在这种情况下，整个软件是作为一个实体开发的。尽管整体架构有助于软件的构建、测试、部署和水平扩展，但随着应用程序变得越来越大，管理可能会成为一个挑战。任何功能中的任何错误都会影响整个应用程序。此外，进行简单的更改需要重写、测试和部署整个应用程序。因此，采用新技术并不灵活。另一方面，微服务将应用程序分解为多个独立的模块化服务，每个服务都拥有自己的数据库模式，并通过 API 相互通信。微服务架构适合支持 DevOps 的基础架构，因为它有助于持续交付。通过利用 Docker，组织可以轻松地将 DevOps 最佳实践整合到基础架构中，从而在竞争中保持领先地位。此外，Docker 允许开发人员轻松地与运营团队共享软件及其依赖项，并确保它在两端以相同的方式运行。例如，管理员可以使用开发人员使用 Dockerfile 创建的 Docker 镜像来暂存和更新生产环境。像这样，降低了构建和配置 CI/CD 管道的复杂性，从而可以更高级别地控制对基础设施所做的所有更改。负载均衡配置也变得更容易。Docker 用例 2：提高生产力在传统的开发环境中，复杂性通常在于使用手动工作定义、构建和配置开发环境，而不会延迟发布周期。缺乏可移植性会导致应用程序出现不一致的行为。Docker 允许您使用 Docker 映像构建容器化开发环境，并轻松设置和使用开发环境，同时在其整个生命周期内提供一致的性能。此外，它还为开发环境中使用的所有工具、框架和技术提供无缝支持。其次，Docker 环境促进了自动化构建、自动化测试和 Webhooks。这意味着您可以轻松地将 Bitbucket 或 GitHub 存储库与开发环境集成，并从源代码创建自动构建并将它们移至 Docker 存储库。开发人员和 CI/CD 工具之间的连接工作流也意味着更快的发布。Docker 带有一个云管理的容器注册表，无需管理您自己的注册表，当您扩展底层基础设施时，这可能会变得昂贵。此外，配置的复杂性已成为过去。实施基于角色的访问允许不同团队的人员安全地访问 Docker 镜像。此外，Slack 集成允许团队在整个产品生命周期中无缝协作和协调。毫无疑问，Docker 提供加速开发、自动化工作流程和无缝协作，可以提高生产力。Docker 用例 3：基础架构即代码微服务架构使您能够将软件分解为多个服务模块，从而使您能够单独处理每个功能。虽然这带来了可扩展性和自动化，但也有一个问题：它让您有数百个服务需要监控和管理。这就是基础架构即代码(IaC) 为您提供帮助的地方，它使您能够使用代码管理基础架构。基本上，它允许您使用配置文件为基础设施定义资源配置，并将基础设施转换为软件，从而利用 CI/CD 流程、自动化、可重用性和版本控制等软件最佳实践。Docker 将 IaC 带入 CI/CD 管道的开发阶段，因为开发人员可以使用 Docker-compose 构建使用多个服务的复合应用程序，并确保它在整个管道中一致地工作。IaC 是 Docker 用例的典型示例。Docker用例4：多环境标准化Docker 为管道中的所有成员提供了一个生产对等环境。考虑一个软件开发团队正在发展的例子。当一个新成员加入团队时，每个成员都必须安装/更新操作系统、数据库、节点、纱线等。光是准备好机器就需要 1-2 天的时间。此外，确保每个人都获得相同的操作系统、程序版本、数据库版本、节点版本、代码编辑器扩展和配置也是一项挑战。例如，如果您为两个不同的程序使用两个不同版本的库，则需要安装两个版本。此外，应在执行这些程序之前指定自定义环境变量。现在，如果您在开发阶段对依赖项进行了某些最后一刻的更改而忘记在生产阶段进行这些更改怎么办？Docker将所有需要的资源打包到一个容器中，并保证依赖之间没有冲突。此外，您可以监控破坏环境的未跟踪元素。Docker 标准化了环境，确保容器在整个 CI/CD 管道中以相似的方式工作。Docker 用例 5：松耦合架构传统瀑布软件开发模型的时代已经一去不复返了。如今，在云和微服务架构的支持下，开发人员正在将应用程序分解成更小的单元，并轻松地将它们构建为松散耦合的服务，这些服务通过 REST API 相互通信。Docker 帮助开发人员将每项服务连同所需的资源打包到一个容器中，从而使其易于部署、移动和更新。电信行业正在利用 5G 技术和 Docker 对软件定义网络技术的支持来构建松耦合架构秒。新的5G技术支持网络功能虚拟化，使电信能够虚拟化网络设备硬件。因此，他们可以将每个网络功能划分并开发为服务，并将其封装到容器中。这些容器可以安装在商用硬件上，使电信公司无需昂贵的硬件基础设施，从而显着降低成本。公有云提供商最近进入电信市场已经缩减了电信运营商和 ISV 的利润。他们现在可以使用 Docker 通过现有基础设施构建具有成本效益的公共云，从而将 Docker 用例转化为新的收入流。Docker 用例 6：用于多租户多租户是一种云部署模型，其中单个安装的应用程序为多个客户提供服务，每个客户的数据完全隔离。软件即服务 (SaaS) 应用程序大多使用多租户方法。多租户模型有 4 种常见方法：共享数据库——独立模式：所有租户的数据都存储在一个数据库中，每个租户都有一个单独的模式。隔离度中等。共享数据库 - 共享模式：所有租户的数据都存储在一个数据库中，其中每个租户的数据都由“外键”标识。隔离级别低。隔离数据库——共享应用服务器：与每个租户相关的数据存储在单独的数据库中。隔离级别高。基于 Docker 的独立租户：一个单独的数据库存储每个租户的数据，每个租户由一组新的容器标识。虽然租户数据是分开的，但所有这些方法都为所有租户使用相同的应用程序服务器。也就是说，Docker 允许完全隔离，其中每个租户应用程序代码都在每个租户自己的容器内运行。为此，组织只需将应用程序代码转换为 Docker 镜像即可运行容器，并使用 docker-compose.yaml 定义多容器和多租户应用程序的配置，从而使他们能够为每个租户运行容器。一个单独的 Postgres 数据库和一个单独的应用程序服务器将用于容器内运行的每个租户。每个租户将需要 2 个数据库服务器和 2 个应用程序服务器。您可以通过添加 NGINX 服务器容器将您的请求路由到正确的租户容器。Docker 用例 7：加速 CI/CD 管道部署与需要几分钟才能启动的整体应用程序不同，容器在几秒钟内启动，因为它们是轻量级的。因此，您可以使用CI/CD管道中的容器以闪电般的速度快速部署代码或快速更改代码库和库。但是，请务必注意，较长的构建时间会减慢 CI/CD 部署的速度。发生这种情况是因为 CI/CD 管道每次都必须从头开始，这意味着每次都必须拉取依赖项。幸运的是，Docker 带有一个缓存层，可以轻松解决构建问题。也就是说，它仅适用于本地机器，因此不适用于远程运行器机器。为了解决这个问题，使用“--from-cache”命令指示Docker build从本地机器镜像中获取缓存。如果您没有本地现有的 docker 镜像，您可以简单地创建一个镜像并在执行“Docker build”命令之前拉取它。需要注意的是，此方法仅使用最新的 docker 镜像库。因此，为了获得更早的图像缓存，您应该根据每个阶段推送和拉取每个 docker 图像。Docker 用例 8：独立的应用基础设施Docker 的主要优势之一是其独立的应用程序基础架构。每个容器都打包了所有依赖，因此您无需担心依赖冲突。无论应用程序的操作系统、平台和版本如何，您都可以轻松地在一台或多台计算机上轻松部署和运行多个应用程序。考虑一个实例，其中两个服务器使用同一应用程序的不同版本。通过在独立容器中运行这些服务器，您可以消除依赖性问题。Docker 还提供了一个 SSH 服务器，用于每个独立容器的自动化和调试。由于每个服务/守护进程都是隔离的，因此很容易监视在隔离容器内运行的应用程序和资源并快速识别错误。这使您可以运行不可变的基础架构，从而最大限度地减少因基础架构更改而导致的停机时间。Docker 用例 9：可移植性——将任何应用程序运送到任何地方可移植性是前五个 Docker 用例之一。可移植性是软件应用程序在任何环境中运行的能力，无论主机操作系统、插件或平台如何。容器提供了可移植性，因为它们打包了运行应用程序所需的所有资源，例如代码、系统库、运行时、库和配置设置。可移植性还通过应用程序移动到另一个主机环境所需的调整量来衡量。例如，Linux 容器可以在所有 Linux 发行版上运行，但有时无法在 Windows 环境中运行。Docker 提供了完整的可移植性，允许您在各种环境之间移动应用程序，而无需对其配置进行任何重大更改。Docker 为容器化创建了一个标准，因此，它的容器高度便携也就不足为奇了。此外，Docker 容器使用主机操作系统内核，无需添加操作系统。这使它们重量轻且易于在不同环境之间移动。当开发人员想要在各种操作系统中测试应用程序并分析结果时，上述内容特别有用。代码中的任何差异只会影响单个容器，因此不会导致整个操作系统崩溃。Docker 用例 10：混合云和多云支持根据​Channel Insider​的说法，组织中采用 Docker 的三大驱动因素是混合云、VMware 成本和来自测试团队的压力。尽管混合云非常灵活并且允许您运行定制的解决方案，但在多个环境中分配负载可能是一个挑战。为了促进云之间的无缝移动，云提供商通常需要在成本或功能集上做出妥协。Docker 消除了这些互操作性问题，因为它的容器在内部部署和云部署中以相同的方式运行。您可以在测试和生产环境或使用多个云供应商产品构建的内部云之间无缝移动它们。此外，部署过程的复杂性也降低了。多亏了 Docker，组织可以构建混合和多云环境，其中包含来自不同供应商的两个或多个公共/私有云。从 AWS 迁移到 Azure 云很容易。此外，您可以选择服务并根据安全协议和服务级别协议将它们分布在不同的云中。Docker 用例 11：降低 IT/基础设施成本对于虚拟机，您需要复制整个来宾操作系统。值得庆幸的是，Docker 并非如此。Docker 允许您预置更少的资源，使您能够运行更多的应用程序并促进资源的有效优化。例如，开发团队可以将资源整合到一台服务器上，从而降低存储成本。此外，Docker 具有高可扩展性，允许您在精确的时刻配置所需的资源，并按需自动扩展基础设施。您只需为实际使用的资源付费。此外，在 Docker 中运行的应用程序在整个 CI/CD 管道中提供相同级别的性能，从开发到测试、暂存和生产。因此，错误和错误被最小化。这种环境对等使组织能够以最少的人员和技术资源管理基础架构，从而大大节省维护成本。基本上，Docker 提高了生产力，这意味着您不需要像在传统软件开发环境中那样雇用那么多的开发人员。Docker 还具有最高级别的安全性，最重要的是，它是开源和免费的。Docker 用例 12：安全实践Docker 容器默认是安全的。当你使用 Docker 创建容器时，它会自动创建一组命名空间并将容器隔离。因此，容器无法访问或影响在另一个容器内运行的进程。同样，每个容器都有自己的网络堆栈，这意味着除非授予某些权限，否则它无法获得对其他容器的网络端口、套接字和接口的特权访问。除了资源核算和限制之外，控制组还处理内存、计算和磁盘 I/O 资源的配置。因此，由于资源耗尽的容器不会使系统崩溃，因此成功缓解了分布式拒绝服务 (DDoS) 攻击。当容器启动时，Docker 守护进程会激活一组限制功能，通过细粒度的访问控制来增强二进制根目录。这提供了更高的安全性，因为许多以 root 身份运行的进程不需要真正的 root 权限。因此，他们可以以较小的权限进行操作。另一个重要功能是使用 dockerd 配置文件中定义的 Docker 内容信任签名验证功能运行签名图像。如果你想添加额外的安全层并强化 Docker 容器，SELinux、Apparmor 和 GRSEC 是可以帮助你这样做的著名工具。Docker 用例 13：灾难恢复虽然混合云和多云环境为组织带来了惊人的好处，但它们也带来了某些挑战。保持弹性是一个值得注意的问题。为了确保业务连续性，您的应用程序必须能够承受错误和故障而不会丢失数据。当组件出现故障时，您无法承受停机时间，尤其是对于关键应用程序。因此，我们建议您使用冗余组件弹性和访问路径来消除单点故障以实现高可用性。应用程序还应该具有自我修复能力。容器可以在这方面为您提供帮助。然而，对于出现意外故障的情况，您需要一个灾难恢复计划来减少人为或自然故障期间的业务影响。Docker 容器可以轻松即时地创建或销毁。当一个容器出现故障时，它会自动被另一个容器替换，因为容器是使用 Docker 镜像构建的，并且基于 dockerfile 配置。在将图像移动到另一个环境之前，您可以将数据提交到现有平台。您还可以在发生灾难时恢复数据。综上所述，重要的是要了解底层主机可能连接到其他组件。因此，您的灾难恢复计划还应该包括启动替换主机。此外，您还应该考虑有状态服务器、网络和 VPN 配置等问题。Docker 用例 14：简单的基础设施扩展Docker 增强了微服务架构，其中应用程序被分解为独立的服务并打包到容器中。组织正在利用微服务和云架构并构建分布式应用程序。Docker 使您能够立即为应用程序启动相同的容器并水平扩展基础设施。随着容器数量的增加，您将需要使用​容器编排工具​例如 Kubernetes 或 Docker Swarm。这些工具具有智能扩展能力，允许它们按需自动扩展基础设施。它们还可以帮助您优化成本，因为它们消除了运行不必要容器的需要。为了使编排更容易，细化组件很重要。此外，无状态和一次性组件将使您能够轻松监控和管理容器的生命周期。Docker 用例 15：依赖管理依赖隔离是容器最强大的特性。考虑一个实例，您有两个应用程序使用不同的第三方库。如果应用程序依赖于同一库的不同版本，那么在整个产品生命周期中密切关注版本差异可能是一项挑战。您可能需要允许容器相互通信。例如，一个应用程序需要与另一个应用程序关联的数据库对话。当您将应用程序移动到新机器时，您必须记住所有依赖项。此外，版本和包冲突可能会很痛苦。尝试重现环境时，应注意操作系统、语言和包依赖性。如果您使用 Python 语言，则需要依赖项管理工具，例如 virtualenv、venv 和 pyenv。如果新环境没有像 git 这样的工具，你需要创建一个脚本来安装 git CLI。该脚本会针对不同的操作系统和操作系统版本不断变化，因此每个团队成员都应该了解这些工具，这并不总是那么容易。无论是操作系统、语言还是 CLI 工具依赖，Docker 都是依赖管理的最佳工具。通过简单地在 dockerfile 中定义配置及其依赖项，您可以将应用程序无缝地移动到另一台机器或环境，而无需记住依赖项、担心包冲突或跟踪用户首选项和本地机器配置。由 Docker 提供支持的公司Docker 用例不受地区或行业限制。PayPal是一家领先的美国金融科技公司，在全球范围内提供在线支付服务。该公司在三个不同的系统中每秒处理大约 200 笔付款；贝宝、Venmo 和布伦特里。因此，在不同的云和架构之间移动服务常常会延迟部署和维护任务。因此，PayPal 实施了 Docker 并在整个基础设施中标准化了其应用程序和操作。时至今日，该公司已将 700 个应用程序迁移到 Docker，并与 4000 名软件员工合作，每年管理 200,000 个容器和 8+0 亿次交易，同时实现生产力提高 50%。Adobe还使用 Docker 进行容器化任务。例如，ColdFusion 是一种 Adobe 网络编程语言和应用程序服务器，可促进网络应用程序与后端系统之间的通信。Adobe 使用 Docker 来容器化和部署 ColdFusion 服务。它使用 Docker Hub 和 Amazon Elastic Container Registry 来托管 Docker 镜像。因此，用户可以将这些图像拉到本地机器并运行 Docker 命令。GE是为数不多的几家在技术萌芽阶段就大胆采用该技术的公司之一，多年来已成为领导者。因此，该公司运行多个遗留应用程序，从而延迟了部署周期。GE 转而使用 Docker，并成功地大大减少了开发到部署的时间。此外，它现在能够实现比 VM 更高的应用程序密度，从而降低运营成本。Docker 之后的下一步是什么？一旦您了解了 Docker 如何影响不同的业务方面，接下来您要掌握的是如何充分利用 Docker 技术。随着组织运营的发展，对数以千计的容器的需求出现了。值得庆幸的是，Docker 具有高度可扩展性，您可以轻松地向上和向下扩展服务，同时定义使用规模所需的副本数量。$ docker 服务规模前端=50您还可以使用 docker service scale 命令一次扩展多个服务。集装箱管理系统随着业务的发展，组织需要按需扩展运营。此外，随着容器集群的增加，编排它们变得具有挑战性。容器管理系统可帮助您管理容器任务，从创建和部署一直到扩展和销毁，让您可以在适用的地方使用自动化。基本上，它们简化了容器管理。除了创建和删除容器之外，这些系统还管理其他与容器相关的任务，例如编排、安全、调度、监控、存储、日志管理、负载平衡和网络管理。根据Datadog的说法，使用容器管理系统的组织平均每台主机托管 11.5 个容器，而在非编排环境管理时每台主机托管 6.5 个容器。流行的容器管理工具以下是您的企业中一些最受欢迎的容器管理器。Kubernetes：Kubernetes 是谷歌开发的最受欢迎的容器编排工具。不久之后，Kubernetes 就成为了容器管理和编排的事实标准。谷歌将该工具移交给了云原生计算基金会（CNCF），这意味着该工具现在得到了 IBM、微软、谷歌和 RedHat 等行业巨头的支持。它使您能够轻松地快速打包、测试、部署和管理大型容器集群。它还是开源的、具有成本效益的并且与云无关。Amazon EKS：随着 Kubernetes 成为容器管理的标准，云提供商开始将其整合到他们的平台产品中。Amazon Elastic Kubernetes Service (EKS) 是一种托管 Kubernetes 服务，用于在 AWS 上管理 Kubernetes。使用 EKS，组织不需要安装和配置 Kubernetes 工作节点或平面，因为它会为您处理这些事情。简而言之，EKS 充当容器服务并为您管理容器编排。但是，EKS 仅适用于 AWS 云。Amazon ECS：Amazon Elastic Container Service (ECS) 是一种适用于 AWS 环境的完全托管的容器编排工具，可帮助组织轻松管理微服务和批处理作业。ECS 看起来与 EKS 相似，但在管理容器集群方面有所不同，与仅执行 Kubernetes 任务的 EKS 不同。ECS 是免费的，而 EKS 每小时收费 0.1 美元。也就是说，由于它是开源的，EKS 为您提供了来自社区的更多支持。另一方面，ECS 更像是一种专有工具。ECS 最适合那些没有广泛的 DevOps 资源或发现 Kubernetes 很复杂的人。Amazon Fargate：Amazon Fargate 是另一种容器管理，作为一种无服务器容器服务，使组织能够运行虚拟机而无需管理服务器或容器集群。它实际上是 ECS 的一部分，但它也适用于 EKS。虽然 ECS 可以更好地控制基础架构，但它具有一些管理复杂性。如果您想运行特定任务而不用担心基础设施管理，我们推荐 Fargate。Azure Kubernetes 服务：Azure Kubernetes 服务 (AKS) 是一种容器管理工具，是 Microsoft 为 Azure 环境提供的完全托管的 Kubernetes 服务。它是开源的，而且大部分是免费的，因为您只需为相关资源付费。AKS 与 Azure Active Directory (AD) 集成，并通过基于角色的访问控制提供更高的安全级别。它与 Microsoft 解决方案无缝集成，并且易于使用 Azure CLI 或 Azure 门户进行管理。Google Kubernetes Service：Google Kubernetes Engine (GKE) 是 Google 于 2015 年开发的 Kubernetes 托管服务，用于管理运行 Kubernetes 的 Google 计算引擎实例。GKE 是有史以来第一个 Kubernetes 托管的服务，其次是 AKS 和 EKS。GKE 提供比其竞争对手更多的功能和自动化。Google 对每个集群每小时收费 0.15 美元。结论在当今复杂的软件开发环境中，包括多种操作系统、编程语言、插件、框架、容器管理和架构，Docker 为每个成员在整个产品生命周期中创建了一个标准化的工作流环境。更重要的是，Docker 是开源的，并得到强大而充满活力的社区的支持，可以帮助您解决任何问题。未能成功利用 Docker 用例肯定会使您落后于竞争对手。http://www.ppmy.cn/news/1541020.html相关文章【Flutter】基础入门：Widgets在 Flutter 中&amp;#xff0c;Widget 是应用程序构建块的基础。几乎所有的对象都是一个 Widget&amp;#xff0c;不论是显示在屏幕上的 UI 元素&amp;#xff0c;还是一些功能性组件&amp;#xff08;例如用于手势检测的 GestureDetector&amp;#xff0c;或用于传递应用主题数据的 Theme&amp;#xff09;&amp;…阅读更多...AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:44 +0000</pubDate>
    </item>
    <item>
      <title>【Flutter】基础入门：Widgets</title>
      <link>https://www.ppmy.cn/news/1541019.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Flutter】基础入门：Widgetsnews/2025/11/1 0:24:42/在 Flutter 中，Widget是应用程序构建块的基础。几乎所有的对象都是一个 Widget，不论是显示在屏幕上的 UI 元素，还是一些功能性组件（例如用于手势检测的GestureDetector，或用于传递应用主题数据的Theme），它们都是 Widget。与原生开发中“控件”仅指 UI 元素不同，Flutter 的 Widget 概念更加广泛，它涵盖了界面显示、布局、手势检测、状态管理等多个层面。本文将深入讲解 Flutter 中的 Widget，帮助你从概念到实践掌握它们。什么是 WidgetWidget 是 Flutter 应用的核心概念。万物皆 Widget，这是开发 Flutter 时需要牢记的一点。无论是屏幕上展示的文字、图片、按钮，还是布局的容器、手势检测器，甚至主题和动画控制，它们都以 Widget 的形式存在。你可以将 Widget 理解为 UI 元素的描述或一个函数，在输入某些参数时返回一个特定的用户界面。Flutter 中的 Widget 分类Flutter 中的 Widget 大体上可以分为两类：有状态的 Widget (StatefulWidget)无状态的 Widget (StatelessWidget)无状态的 Widget (StatelessWidget)StatelessWidget是静态的，它们在生命周期中不发生变化。简单的文本、图标和图片等不需要交互的组件通常是无状态的。示例：import'package:flutter/material.dart';voidmain()=&gt;runApp(MyApp());classMyAppextendsStatelessWidget{@overrideWidgetbuild(BuildContext context){returnMaterialApp(home:Scaffold(appBar:AppBar(title:Text('StatelessWidget Example')),body:Center(child:Text('Hello, Flutter!')),),);}}在上面的代码中，MyApp是一个StatelessWidget，它只需要简单地显示一行文字。有状态的 Widget (StatefulWidget)StatefulWidget可以管理和更新状态。它们能够根据用户的交互或内部事件（如计时器或动画）来动态更新界面。每个StatefulWidget都有一个对应的State对象，负责管理 Widget 的状态。示例：import'package:flutter/material.dart';voidmain()=&gt;runApp(MyApp());classMyAppextendsStatefulWidget{@override_MyAppStatecreateState()=&gt;_MyAppState();}class_MyAppStateextendsState&lt;MyApp&gt;{int _counter=0;void_incrementCounter(){setState((){_counter++;});}@overrideWidgetbuild(BuildContext context){returnMaterialApp(home:Scaffold(appBar:AppBar(title:Text('StatefulWidget Example')),body:Center(child:Column(mainAxisAlignment:MainAxisAlignment.center,children:&lt;Widget&gt;[Text('You have pressed the button this many times:'),Text('$_counter',style:Theme.of(context).textTheme.headline4),],),),floatingActionButton:FloatingActionButton(onPressed:_incrementCounter,tooltip:'Increment',child:Icon(Icons.add),),),);}}在这个例子中，点击按钮会触发_incrementCounter函数，更新State中的计数器值，随后通过setState()通知 Flutter 重新构建 UI 以反映最新的状态。常见的基础 Widget文本 Widget (Text)Text是用于显示简单文本的 Widget。它可以通过style属性自定义文字的字体、颜色和大小。示例：Text('Hello, Flutter!',style:TextStyle(fontSize:24,color:Colors.blue),)图片 Widget (Image)Image用于加载和显示图片。它支持多种方式加载图片，如网络图片、文件图片、资源图片等。示例：Image.network('https://example.com/sample-image.jpg')图标 Widget (Icon)Icon是用于显示图标的 Widget，Flutter 提供了丰富的内置图标库，如 Material Icons。示例：Icon(Icons.favorite,color:Colors.red,size:40)容器 Widget (Container)Container是最常用的布局 Widget，它可以包含子组件，并支持设置大小、边距、填充、对齐方式等。示例：Container(padding:EdgeInsets.all(10),margin:EdgeInsets.all(20),color:Colors.blue,child:Text('Container example'),)列 Widget (Column) 与 行 Widget (Row)Column和Row是用于垂直和水平排列子组件的 Widget。它们常用于构建基本的布局。示例：Column(children:&lt;Widget&gt;[Text('Item 1'),Text('Item 2'),Text('Item 3'),],)按钮 Widget (ElevatedButton)按钮是常见的交互元素，Flutter 提供了多种按钮组件，如ElevatedButton、TextButton和IconButton。示例：ElevatedButton(onPressed:(){},child:Text('Click Me'),)布局 WidgetsFlutter 提供了丰富的布局 Widgets，帮助开发者构建灵活且强大的 UI 布局。PaddingPadding用于给组件增加内边距。示例：Padding(padding:EdgeInsets.all(16.0),child:Text('Padded Text'),)CenterCenter将子 Widget 居中显示。示例：Center(child:Text('Centered Text'),)StackStack是一个叠加布局 Widget，允许将多个 Widget 叠加显示。常用于实现浮动按钮或重叠布局。示例：Stack(children:&lt;Widget&gt;[Container(color:Colors.blue,width:200,height:200),Positioned(left:50,top:50,child:Text('Stacked Text'),),],)ExpandedExpanded用于在Row或Column中扩展子组件，分配剩余的空间。示例：Row(children:&lt;Widget&gt;[Expanded(child:Container(color:Colors.red)),Expanded(child:Container(color:Colors.green)),],)Widget 的生命周期在StatefulWidget中，Widget 的生命周期主要有以下几个阶段：createState()：创建状态对象，这个对象会保持 Widget 的状态。initState()：初始化状态，只调用一次。build()：构建 Widget 的 UI，每次状态改变时都会调用。setState()：当需要更新 UI 时调用此方法。dispose()：当 Widget 被销毁时调用，用于清理资源。总结在 Flutter 中，Widget 是应用程序构建的核心，涵盖了所有的 UI 组件、布局和功能模块。无论是无状态还是有状态的 Widget，都通过嵌套和组合的方式来构建复杂的用户界面。掌握基础的 Widget，如Text、Image、Icon，以及常用的布局 Widget，如Column、Row、Padding、Expanded，是学习 Flutter 的基础。通过理解 Widget 的使用方式和它们的生命周期，开发者能够灵活构建高效、可维护的应用。http://www.ppmy.cn/news/1541019.html相关文章AWS 实现CI/CD1 任务定义  
containerDefinitions 定义部署信息指定每个子项的资源 最外层定义这个task需要的资源 这时候就可以使用低配置的EC2启动 创建service 增加负载均衡选择Application Load Balancer 创建新的监听器&amp;#xff0c;监听端口是负载均衡入口的端口 查看负载均衡流量正常 …阅读更多...Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:42 +0000</pubDate>
    </item>
    <item>
      <title>AWS 实现CI/CD</title>
      <link>https://www.ppmy.cn/news/1541018.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维AWS 实现CI/CDnews/2025/11/1 0:24:41/1任务定义containerDefinitions 定义部署信息指定每个子项的资源最外层定义这个task需要的资源这时候就可以使用低配置的EC2启动创建service增加负载均衡选择Application Load Balancer创建新的监听器，监听端口是负载均衡入口的端口查看负载均衡流量正常粘贴DNS 名称在页面可以看到负载均衡部署从code pipline进入第一页上只填名称配置source为 codeCommit添加codebuild信息配置部署阶段代码中添加一个json文件，[{"name": "springboot-frontend","imageUri": "043942809940.dkr.ecr.ap-south-1.amazonaws.com/springboot/frontend:latest"}
]name对应的ECS task里的name，imageUri 填写ECR上的镜像地址把这个文件名填写到部署的空里本地提交代码，自动触发构建检查负载均衡页面代码已经更新了http://www.ppmy.cn/news/1541018.html相关文章Oracle权限安全管理实验内容 
本次实验先使用system用户连接 温馨提示&amp;#xff1a;题目要求切换账户登录的时候自己记得切换&amp;#xff0c;本文章只提供相应的SQL语句 在表空间BOOKTBS1&amp;#xff08;实验4第1题已创建&amp;#xff09;创建一张表BOOKS,其字段如下&amp;#xff1a;&amp;#xff1a; SQL&gt; create…阅读更多...24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:41 +0000</pubDate>
    </item>
    <item>
      <title>Oracle权限安全管理</title>
      <link>https://www.ppmy.cn/news/1541017.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Oracle权限安全管理news/2025/11/1 0:24:40/实验内容本次实验先使用system用户连接温馨提示：题目要求切换账户登录的时候自己记得切换，本文章只提供相应的SQL语句在表空间BOOKTBS1（实验4第1题已创建）创建一张表BOOKS,其字段如下：：SQL&gt; create table BOOKS2  (ISBN varchar(50) primary key,3  title varchar(50),4  author varchar(50),5  cost number(12)) tablespace BOOKTBS1;表已创建。在其中插入一条数据('20240101','Oracle数据库管理与开发','李真',48)。SQL&gt; insert into BOOKS(ISBN,title,author, cost)2  values ('20240101','Oracle数据库管理与开发','李真',48);已创建 1 行。创建一张表CUSTOMERS，其字段如下：SQL&gt; CREATE TABLE CUSTOMERS (2    customer_id NUMBER(4) PRIMARY KEY,3    name VARCHAR2(20) NOT NULL,4    phone VARCHAR2(50) NOT NULL5  ) TABLESPACE BOOKTBS1;表已创建。1、用户创建与修改（1）以自己名字首字母创建一个用户（后文称为本人用户），采用口令认证方式，口令自己定义，默认表空间为 USERS表空间，临时表空间为 TEMP，在 USERS 表空间上配额为 10M，在 BOOKTBS1 表空间上的配额为 50M。（下划线填自己名字首字母，下文也是）SQL&gt; create user _____2  identified by 0000003  default tablespace USERS4  temporary tablespace TEMP5  quota 10M on USERS6  quota 50M on BOOKTBS1;用户已创建。（2）创建一个名为Tom的用户，采用口令认证方式，口令为Tom，默认表空间为BOOKTBS1表空间，默认临时表空间为TEMP，在USERS表空间上配额为10MB，在BOOKTBS1表空间上的配额为20MB。该用户的初始状态为锁定状态。SQL&gt; create user Tom2  identified by Tom3  default tablespace BOOKTBS14  temporary tablespace TEMP5  account lock6  quota 10M on USERS7  quota 20M on BOOKTBS1;用户已创建。（3）为方便数据库中用户的登录，为 ORCL 数据库中所有用户授予 CREATE SESSION系统权限。SQL&gt; grant create session to public;授权成功。（4）分别使用 本人用户和 Tom 用户登录 ORCL 数据库，测试是否成功。使用 SQLPlus 链接数据库，以本人用户和 Tom 用户的身份登录 ORCL 数据库，测试是否成功。（5）为 Tom 用户帐户解锁，并重新进行登录。SQL&gt; alter user Tom account UNLOCK;2、授权与回收操作（6）切回SYSTEM用户，为本人用户授予 CREATE TABLE、 CREATE VIEW 系统权限，并可以进行权限传递转授；授予books表和customer表上的所有对象权限给本人用户。SQL&gt; grant create table,create view to ____ with admin option;授权成功。SQL&gt; grant all privileges on BOOKS to ____with grant option;授权成功。SQL&gt; grant all privileges on CUSTOMERS to ____ with grant option;授权成功。（7）切换到本人用户，将 books、customer 表的查询、插入权限以及CREATE VIEW、 CREATE TABLE 的系统权限授予 Tom 用户。SQL&gt; grant select,insert on system.BOOKS to Tom;授权成功。SQL&gt; grant create table,create view to Tom;授权成功。（8）使用 Tom 用户连接数据库， 查询 books表中的数据，新增一条书籍数据（自拟）。SQL&gt; insert into system.books2  (ISBN,TITLE,AUTHOR,COST)3  values (20240202,'javac程序设计','张三',52);已创建 1 行。（9）使用本人用户回收其授予 Tom 用户的 CREATE VIEW 的系统权限，以及其授予 Tom 用户的在 books 表上的 INSERT 权限。SQL&gt; revoke create view from Tom;撤销成功。SQL&gt; revoke insert on system.BOOKS from Tom;撤销成功。（10）使用 system用户登录数据库， 回收本人用户所有具有的 CREATE TABLE系统权限以及在 books 表上 SELECT 权限，思考这时Tom用户的这两项权限是否受影响。此时，Tom用户的CREATE VIEW权限和在books表上的INSERT权限应该受到影响。SQL&gt; revoke create table from ____;撤销成功。SQL&gt; revoke select on system.BOOKS from ____;撤销成功。（11）分别查询 本人用户、Tom 用户所具有的对象权限和系统权限详细信息。SQL&gt; select * from dba_tab_privs where grantee='____';SQL&gt; select * from dba_sys_privs where grantee='____';SQL&gt; select * from dba_tab_privs where grantee='TOM';SQL&gt; select * from dba_sys_privs where grantee='TOM';3、角色的创建与授予（12）使用system用户登录，创建一个角色 seller，不使用口令验证，将 books 表的所有对象权限以及对customers 表的 SELECT 权限授予该角色。SQL&gt; create role seller;角色已创建。SQL&gt; grant all privileges on system.BOOKS to seller;授权成功。SQL&gt; grant select on system.CUSTOMERS to seller;授权成功。（13）将seller角色授予 Tom 用户，在dba_role_privs中查看当前Tom被授予的角色，在dba_tab_privs中查看seller角色所具有的对象属性。思考此时Tom拥有哪些权限。此时，Tom拥有的权限将包括：对books表的所有权限（SELECT, INSERT, UPDATE, DELETE等）；对customers表的SELECT权限。SQL&gt; grant seller to Tom;授权成功。SQL&gt; select * from dba_role_privs where grantee='TOM';（14）使用Tom用户，通过SET ROLE 角色名语句启用seller角色，并查询books表中的数据。SQL&gt; set role seller;角色集SQL&gt; select * from system.BOOKS;4、概要文件使用（15） 创建一个 bs_profile1 的概要文件， 限定用户的最长会话时间为 30 分钟， 如果连续10 分钟空闲，则结束会话。同时， 限定其口令有效期为 20 天， 连续登录 2 次失败后将锁定账户，10 天后自动解锁。SQL&gt; create profile bs_profile1 limit2  CONNECT_TIME 303  IDLE_TIME 104  PASSWORD_LIFE_TIME 205  FAILED_LOGIN_ATTEMPTS 26  PASSWORD_LOCK_TIME 10;配置文件已创建（16） 将概要文件bs_profile1指定给Tom用户。SQL&gt; alter user Tom profile bs_profile1;用户已更改。（17）利用Tom用户登录ORCL数据库，连续两次输入错误口令，查看执行结果，并使用system查看Tom用户的锁定状态。SQL&gt; select username,account_status from dba_users where username = 'TOM';http://www.ppmy.cn/news/1541017.html相关文章24.10.20（换根哈希）星期一&amp;#xff1a; 
阴间场 cf渡劫成功&amp;#xff0c;拿下三题&amp;#xff0c;终于上蓝&amp;#x1f973;&amp;#x1f973;&amp;#x1f973; 贴 cf round978 div2 C                                    cf传送门 答案取到n1但初始化没到n1&amp;#xff0c;wa了一发&amp;#xff0c;很烦&amp;#x1f63f;…阅读更多...Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:40 +0000</pubDate>
    </item>
    <item>
      <title>24.10.20（换根哈希）</title>
      <link>https://www.ppmy.cn/news/1541016.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维24.10.20（换根哈希）news/2025/11/1 0:24:39/星期一：阴间场 cf渡劫成功，拿下三题，终于上蓝🥳🥳🥳贴 cf round978 div2 C                                    cf传送门答案取到n+1但初始化没到n+1，wa了一发，很烦😿思路：dp【i】【1/2/3】表示第一行的第 i列对应第二行的 i-1/ i /i+1列，且左边全部分配完毕的最多得分，答案即为 dp【n+1】【2】这题的分配区域感觉就像填俄罗斯方块，有可变换方向的三角形和长条形观察一下可发现上下两行的分配进度一直都会很接近，如第一行第一个空在 i列，那么如果第二行的第一空在 i-1列之前，其实第二行也只能补长条到 i-1/ i /i+1列，故设定状态不是每个状态都是有效的，先把dp数组初始化为-1（注意这里要初始化到n+1，否则多组样例会出错），设dp【1】【2】为 0。遍历所有状态，若状态合法，则考虑可以怎么填方块转移到下一个状态，讨论一下即可，这题适合用向后推的转移写法。代码如下：const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=1e9+7;
ll n;
int a[3][N];
int dp[N][4];
void solve(){cin &gt;&gt; n;for(int i=1;i&lt;=n+1;i++)    //初始化到n+1,否则多组样例会出错！！！for(int j=1;j&lt;=3;j++)dp[i][j]=-1;for(int i=1;i&lt;=2;i++){for(int j=1;j&lt;=n;j++){
//			cin &gt;&gt; a[i][j];char ch; cin &gt;&gt; ch;if(ch=='A') a[i][j]=1;else a[i][j]=-1;}}dp[1][2]=0;for(int i=1;i&lt;=n;i++){for(int j=1;j&lt;=3;j++){if(dp[i][j]!=-1){if(j==2){int sum1=a[1][i]+a[1][i+1]+a[1][i+2];int sum2=a[2][i]+a[2][i+1]+a[2][i+2];dp[i+3][2]=max(dp[i][j]+(sum1&gt;0)+(sum2&gt;0),dp[i+3][2]);int sum3=a[1][i]+a[2][i];dp[i+1][3]=max(dp[i][j]+(sum3+a[2][i+1]&gt;0),dp[i+1][3]);dp[i+2][1]=max(dp[i][j]+(sum3+a[1][i+1]&gt;0),dp[i+2][1]);}else if(j==1){int sum1=a[1][i]+a[1][i+1]+a[1][i+2];int sum2=a[2][i-1]+a[2][i]+a[2][i+1];dp[i+3][1]=max(dp[i][j]+(sum1&gt;0)+(sum2&gt;0),dp[i+3][1]);int sum3=a[1][i]+a[2][i-1]+a[2][i];dp[i+1][2]=max(dp[i][j]+(sum3&gt;0),dp[i+1][2]);}else if(j==3){int sum1=a[1][i]+a[1][i+1]+a[1][i+2];int sum2=a[2][i+1]+a[2][i+2]+a[2][i+3];dp[i+3][3]=max(dp[i][j]+(sum1&gt;0)+(sum2&gt;0),dp[i+3][3]);int sum3=a[1][i]+a[1][i+1]+a[2][i+1];dp[i+2][2]=max(dp[i][j]+(sum3&gt;0),dp[i+2][2]);}}}}cout &lt;&lt; dp[n+1][2] &lt;&lt; "\n";
}补 cf round978 div2 D                                    cf传送门昨天只看到是个交互就去睡了，其实思路也比较简单，不过剩半小时应该是调不出来思路：可发现，先忽略冒牌的情况，i-j若是1，即表明 i与 j为同一阵营，否则相反阵营。顺着问n-1次，可以把所有人分为两集合，随手写个样例就能发现，阵营从冒牌开始会反着放，即冒牌之后的人都会被放到相反阵营，那么即可二分去找冒牌这个点注意处理下边界情况代码如下：const int N=2e6+10,M=210;
const int INF=0x3f3f3f3f;
const int mod=1e9+7;
ll n;
int a[N];
void solve(){cin &gt;&gt; n;for(int i=1;i&lt;n;i++){cout &lt;&lt; "? " &lt;&lt; i &lt;&lt; " " &lt;&lt; i+1 &lt;&lt; endl;bool ifs=0; cin &gt;&gt; ifs;if(ifs) a[i+1]=a[i];else a[i+1]=a[i]^1;}int l=1,r=n-1,res=0;    //r&lt;n,避免自己问自己的情况while(l&lt;=r){int mid=l+r&gt;&gt;1;cout &lt;&lt; "? " &lt;&lt; n &lt;&lt; " " &lt;&lt; mid &lt;&lt; endl;bool ifs; cin &gt;&gt; ifs;if(ifs==(a[mid]==a[n])) r=mid-1;else res=mid,l=mid+1;}if(!res) res=n;if(res==n-1){cout &lt;&lt; "? " &lt;&lt; n-2 &lt;&lt; " " &lt;&lt; n-1 &lt;&lt; endl;bool ifs1; cin &gt;&gt; ifs1;cout &lt;&lt; "? " &lt;&lt; n-1 &lt;&lt; " " &lt;&lt; n-2 &lt;&lt; endl;bool ifs2; cin &gt;&gt; ifs2;if(ifs1==ifs2) res++;}cout &lt;&lt; "! " &lt;&lt; res &lt;&lt; endl;
}补 cf round856 E 换根哈希                            cf传送门思路：先按集合数为n考虑，显然当以 rt为根的深度集合等于给出集合时，rt即好点，可用dfs实现但肯定不能对每个点都dfs一遍，所以可以很自然地想到换根dp那么如何快速地对给出集合和深度集合进行比较呢，直接比较是O(n)，可以处理出哈希值O(1)比较hsh【i】=C0+C1*ba+C2*ba^2+C3*ba^3......+Cn-1*ba^n-1，Cj表示深度为j的点的个数，注意因为n&lt;=2e5，所以Cj的值最多也可达到2e5级别，底数需选取一个&gt;2e5的质数第一遍dfs处理出hsh【i】表示以 i为根的子树的哈希值，第二遍dfs即可进行换根转移，可发现其实哈希值很好转移，hsh【v】+=（hsh【u】- hsh【v】*base）*base从 u到 v，hsh【v】原本的值保留，hsh【v】子树外的深度集合哈希值即 hsh【u】-hsh【v】*ba 这是对于 u的哈希值，对于 v而言所有深度需要+1，所以再乘个base最后一个数任意选取，这个值可以是0到n-1，对应的哈希值即1-ba^n-1，即ba的整数次幂，可用map实现代码如下：const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
vector&lt;int&gt;ve[N];
ll cnt[N],hsh[N],has;
const ll base=2e5+3,MOD=(1ll&lt;&lt;61)-1;  //大于n的质数base
ull add(ull a,ull b){a+=b; if(a&gt;=MOD) a-=MOD;return a;
}
ull mul(ull a,ull b){__int128 c=(__int128)a*b;return add(c&gt;&gt;61,c&amp;MOD);
}
void dfs(int x,int f){hsh[x]=1;for(int v:ve[x]) if(v!=f){dfs(v,x);hsh[x]=add(hsh[x],mul(hsh[v],base));}
}
void dfs2(int x,int f){for(int v:ve[x]) if(v!=f){hsh[v]=add(hsh[v],mul(add(hsh[x],add(-mul(hsh[v],base),MOD)),base));dfs2(v,x);}
}
void solve(){cin &gt;&gt; n;for(int i=1;i&lt;n;i++){int a; cin &gt;&gt; a;cnt[a]++;}ll tb=1;map&lt;ll,bool&gt;mp;for(int i=n-1;~i;i--){has=add(mul(has,base),cnt[i]);mp[tb]=1;tb=mul(tb,base);}for(int i=1;i&lt;n;i++){int u,v; cin &gt;&gt; u &gt;&gt; v;ve[u].push_back(v);ve[v].push_back(u);}dfs(1,0);dfs2(1,0);vector&lt;int&gt;ans;for(int i=1;i&lt;=n;i++) if(mp.count(hsh[i]-has) || mp.count(hsh[i]+MOD-has)) ans.push_back(i);cout &lt;&lt; ans.size() &lt;&lt; "\n";for(int i:ans) cout &lt;&lt; i &lt;&lt; " ";cout &lt;&lt; "\n";
}星期二：重写 cf edu round170 C 双指针                        cf传送门思路：其实思路比较明显，一个简简单单双指针就能拿下，但可惜线段树入脑的我选择了硬凹线段树。。开始写的动态开点，写完了发现无法处理查询，因为动态开点在区间查询的merge上很不方便（现在想想应该也不是不能写），就改成了离散化，反正是浪费了挺多时间。代码如下：const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
ll a[N];
void solve(){int k; cin &gt;&gt; n &gt;&gt; k;for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i];sort(a+1,a+n+1);int ans=0;for(int i=1,j=1;i&lt;=n;i++){j=max(i,j);           //双指针别忘了这句while(j&lt;n &amp;&amp; a[j+1]&lt;=a[j]+1 &amp;&amp; a[j+1]-a[i]&lt;k) j++;ans=max(j-i+1,ans);}cout &lt;&lt; ans &lt;&lt; "\n";
}补 D                                                                cf传送门赛时想到大概得是m^2的复杂度,但转移不出来思路：总点数为tot，dp【i】表示 i点智力 tot-i点武力通过的测试数用f【i】记录测试，若输入 r&gt;0，则对于所有 i&gt;=r，f【i】++，r&lt;0，对于i∈[0,tot+r]，f【i】++，可以使用差分处理，当r==0时再求前缀和还原，还原后即可把f【j】加到dp【j】上然后tot点数需要加一，注意tot加一后dp【i】的含义也会随之改变，例如tot为6时，dp3表示3智3武，tot加到7后，dp3表示的即3智4武了，3智4武当然可由3智3武转化而来，但同样也可从2智4武变来即dp2，即得dp【i】= max（dp【i-1】，dp【i】），然后这里应该倒着遍历代码如下:const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
int f[5050],dp[5050];
void solve(){ll m; cin &gt;&gt; n &gt;&gt; m;ll tot=0;for(int i=1;i&lt;=n;i++){int r; cin &gt;&gt; r;if(r&gt;0){if(r&lt;=tot) f[r]++;}else if(r&lt;0){r=-r;r=tot-r;if(r&gt;=0) f[0]++,f[r+1]--;}else{for(int j=1;j&lt;=tot;j++) f[j]+=f[j-1];for(int j=0;j&lt;=tot;j++) dp[j]+=f[j];tot++;for(int j=tot;j;j--) dp[j]=max(dp[j-1],dp[j]);for(int j=0;j&lt;=tot;j++) f[j]=0;}}for(int j=1;j&lt;=tot;j++) f[j]+=f[j-1];for(int j=0;j&lt;=tot;j++) dp[j]+=f[j];cout &lt;&lt; *max_element(dp,dp+tot+1) &lt;&lt; "\n";
}星期三：看了一天林克砍树没看明白，决定还是11月23日后再学星期四：补 cf round977 C2                                            cf传送门思路：这里为了方便，给a中的排列按1到n赋值易想到维护每个数的第一次出现下标，记 fi【i】，满足条件即 fi 1 &lt; fi 2 &lt; fi 3...&lt; fi n，如何维护q次修改呢，其实完全用不着什么数据结构，只需要一个变量 c维护有多少 fi i &lt; fi i+1，因为一次修改只会影响 bs和 t的下标为了方便讨论给0和n+1的值也发个下标代码如下：const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
ll a[N],b[N],to[N];
set&lt;int&gt;st[N];
bool if1[N];
void solve(){int m,q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;for(int i=0;i&lt;=n+1;i++) st[i].clear();for(int i=1;i&lt;=n;i++){cin &gt;&gt; a[i];to[a[i]]=i;st[i].insert(m+1);}for(int i=1;i&lt;=m;i++){cin &gt;&gt; b[i];st[to[b[i]]].insert(i);}int c=0;st[0].insert(0);st[n+1].insert(m+1);for(int i=0;i&lt;=n;i++) c+=if1[i]=(*st[i].begin()&lt;=*st[i+1].begin());if(c==n+1) cout &lt;&lt; "YA\n";else cout &lt;&lt; "TIDAK\n";while(q--){int s,t; cin &gt;&gt; s &gt;&gt; t;int x=to[b[s]],x2=to[t];st[x].erase(st[x].find(s));st[x2].insert(s);b[s]=t;if(!if1[x-1] &amp;&amp; *st[x-1].begin()&lt;=*st[x].begin()) c++,if1[x-1]=1;else if(if1[x-1] &amp;&amp; *st[x-1].begin()&gt;*st[x].begin()) c--,if1[x-1]=0;if(!if1[x] &amp;&amp; *st[x].begin()&lt;=*st[x+1].begin()) c++,if1[x]=1;else if(if1[x] &amp;&amp; *st[x].begin()&gt;*st[x+1].begin()) c--,if1[x]=0;if(x!=x2){if(!if1[x2-1] &amp;&amp; *st[x2-1].begin()&lt;=*st[x2].begin()) c++,if1[x2-1]=1;else if(if1[x2-1] &amp;&amp; *st[x2-1].begin()&gt;*st[x2].begin()) c--,if1[x2-1]=0;if(!if1[x2] &amp;&amp; *st[x2].begin()&lt;=*st[x2+1].begin()) c++,if1[x2]=1;else if(if1[x2] &amp;&amp; *st[x2].begin()&gt;*st[x2+1].begin()) c--,if1[x2]=0;}if(c==n+1) cout &lt;&lt; "YA\n";else cout &lt;&lt; "TIDAK\n";}
}补24 牛客多校10 F                                       牛客传送门思路：赛时以为暴力是O(n^5)，就直接run了，实在不应该其实想下能放最多点的放法也就能放 2n个点，复杂度算满是O(n^3)，实际上是远没到这么多，实测300ms跑完代码如下:const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
vector&lt;PII&gt;ve;
bool vi[1010][1010];
void solve(){cin &gt;&gt; n;int x,y; cin &gt;&gt; x &gt;&gt; y;ve.push_back({x,y}); cout &lt;&lt; 1;for(int i=1;i&lt;n*n;i++){int x,y; cin &gt;&gt; x &gt;&gt; y;if(vi[x][y]){cout &lt;&lt; 0; continue;}for(auto [vx,vy]:ve){if(vx==x){for(int i=1;i&lt;=n;i++) vi[x][i]=1;continue;}else if(vy==y){for(int i=1;i&lt;=n;i++) vi[i][y]=1;continue;}int dx=abs(vx-x),dy=abs(vy-y);int gc=__gcd(dx,dy);dx/=gc,dy/=gc;if(x&lt;vx){if(y&lt;vy){for(int xx=x,yy=y;xx&gt;0 &amp;&amp; yy&gt;0;xx-=dx,yy-=dy) vi[xx][yy]=1;for(int xx=x,yy=y;xx&lt;=n &amp;&amp; yy&lt;=n;xx+=dx,yy+=dy) vi[xx][yy]=1;//}else{for(int xx=vx,yy=vy;xx&lt;=n &amp;&amp; yy&gt;0;xx+=dx,yy-=dy) vi[xx][yy]=1;for(int xx=vx,yy=vy;xx&gt;0 &amp;&amp; yy&lt;=n;xx-=dx,yy+=dy) vi[xx][yy]=1;//}}else{if(y&lt;vy){for(int xx=x,yy=y;xx&lt;=n &amp;&amp; yy&gt;0;xx+=dx,yy-=dy) vi[xx][yy]=1;for(int xx=x,yy=y;xx&gt;0 &amp;&amp; yy&lt;=n;xx-=dx,yy+=dy) vi[xx][yy]=1;//}else{for(int xx=vx,yy=vy;xx&gt;0 &amp;&amp; yy&gt;0;xx-=dx,yy-=dy) vi[xx][yy]=1;for(int xx=vx,yy=vy;xx&lt;=n &amp;&amp; yy&lt;=n;xx+=dx,yy+=dy) vi[xx][yy]=1;}}}ve.push_back({x,y}); cout &lt;&lt; 1;}
}星期五：重做24百度之星国赛 小度爬丸山                      mtj传送门抛开树上差分板子不谈，赛时能出这题我很满意思路：先想到既然左边是单调递增，右边单调递减，那么能不能将左右分开维护，答案是可以易想到dp【i】【j】【0/1】表示到第 i个数，第 j个数作为峰值的左/右子序列个数，但数组肯定开不了那么大，那么考虑第一维能不能舍弃，答案是可以在这里将数组分为两个，分别维护左右，写俩样例就能发现 ai为峰值的丸山子序列即tl【i】*tr【i】接下来考虑如何维护子序列数量，设ai值为 num，那么转移即这是一个比较典的转移，任何小于num的值为结尾的子序列，后面都可以再加个num，仍单调，且num一个数字本身也是单调子序列。用树状数组维护即可还要注意重复计算答案的问题，计算答案时可以算小于num的所有序列数+1，可避免算重代码如下：const int N=3e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
int a[N];
ll tl[N],tr[N];
#define lowbit(x) x&amp;-x
inline void add(int x,ll v,bool ifl){if(ifl) for(int i=x;i&lt;=n;i+=lowbit(i)) (tl[i]+=v+mod)%=mod;else for(int i=x;i&lt;=n;i+=lowbit(i)) (tr[i]+=v+mod)%=mod;
}
inline ll ask(int x,bool ifl){ll res=0;if(ifl) for(int i=x;i;i-=lowbit(i)) (res+=tl[i])%=mod;else for(int i=x;i;i-=lowbit(i)) (res+=tr[i])%=mod;return res;
}
void solve(){cin &gt;&gt; n;map&lt;int,int&gt;to; int cnt=0;for(int i=1;i&lt;=n;i++){cin &gt;&gt; a[i];to[a[i]]=1;}for(auto &amp;[x,y]:to) y=++cnt;for(int i=n;i;i--){int num=to[a[i]];add(num,ask(num-1,0)+1,0);}ll ans=0;for(int i=1;i&lt;=n;i++){int num=to[a[i]];add(num,ask(num-1,1)+1,1);
//		(ans+=(ask(num,1)-ask(num-1,1)+mod)%mod*((ask(num,0)-ask(num-1,0)+mod)%mod)%mod)%=mod;//会算重(ans+=(ask(num-1,0)+1)*(ask(num-1,1)+1)%mod)%=mod;add(num,-ask(num-1,0)-1,0);}cout &lt;&lt; ans;
}补24牛客多校7 K                                           牛客传送门思路：首先可以找出S的最短前缀满足存在子序列为T，和最短后缀满足存在子序列为rT，设这俩位置为p1和p2，若p1&lt;p2，那么先把前后缀的子序列选上，中间无论是什么都满足题意，所以可以直接对中间一坨求个 不同子序列数，这是个很经典的线性dp上述求的是前后缀不相交的情况，还需补上前后缀相交的情况。若存在相交，则显然相交部分一定是回文串，可以先用字符串哈希预处理T和rT，再遍历一遍相交部分的长度len，需同时满足其回文且pl【m-len】&lt;= pr【m】（前缀匹配第m-len个字符的位置，和后缀匹配最后一个字符的位置，即可ans++代码如下：const int N=2e6+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=1e9+7;
ll n;
const ull MOD=(1ll&lt;&lt;61)-1,ba=131;
inline ull add(ull a,ull b){a+=b; if(a&gt;=MOD) a-=MOD;return a;
}
inline ull mul(ull a,ull b){__int128 c=(__int128)a*b;return add(c&gt;&gt;61,c&amp;MOD);
}
ull hsh[N],rhsh[N],qb[N];
int pl[N],pr[N];
ll dp[N];
void solve(){ll m; cin &gt;&gt; n &gt;&gt; m;string s,t; cin &gt;&gt; s &gt;&gt; t;s=" "+s,t=" "+t;for(int i=1,j=1;i&lt;=n;i++)if(j&lt;=m &amp;&amp; s[i]==t[j]) pl[j++]=i;for(int i=n,j=1;i;i--)if(j&lt;=m &amp;&amp; s[i]==t[j]) pr[j++]=i;if(!pl[m] || !pr[m]){cout &lt;&lt; 0; return ;}string rt=t; reverse(rt.begin(),rt.end());rt=" "+rt,rt.pop_back();qb[0]=1;for(int i=1;i&lt;=m;i++){qb[i]=mul(qb[i-1],ba);
//		hsh[i]=hsh[i-1]*ba+t[i];hsh[i]=add(mul(hsh[i-1],ba),t[i]);rhsh[i]=add(mul(rhsh[i-1],ba),rt[i]);}ll ans=0;if(pl[m]&lt;pr[m]){int pos[33]={0};
//		cout &lt;&lt; pl[m] &lt;&lt; " " &lt;&lt; pr[m] &lt;&lt; endl;for(int i=pl[m]+1;i&lt;pr[m];i++){int num=s[i]-'a'+1;if(!pos[num]) dp[i]=(dp[i-1]*2+1)%mod,pos[num]=i;else dp[i]=(dp[i-1]*2%mod-dp[pos[num]-1]+mod)%mod,pos[num]=i;}(ans+=dp[pr[m]-1]+1)%=mod;
//		cout &lt;&lt; ans &lt;&lt; "\n";}for(int i=1;i&lt;=m &amp;&amp; pl[i]&lt;=pr[m];i++){ull h1=add(hsh[m],add(-mul(hsh[i-1],qb[m-i+1]),MOD)),h2=rhsh[m-i+1];
//		cout &lt;&lt; h1 &lt;&lt; " " &lt;&lt; h2 &lt;&lt; "\n";if(h1==h2) (ans+=1)%=mod;}cout &lt;&lt; ans &lt;&lt; "\n";
//	for(int i=1;i&lt;=m;i++) cout &lt;&lt; hsh[i] &lt;&lt; " " &lt;&lt; rhsh[i] &lt;&lt; "\n";
}星期六：下午vp了场ccpc好像是，差点被签到模拟腐乳，读题和代码细节真的一言难尽。。补24 牛客多校6 A                                          牛客传送门思路：先考虑二阶段Bob会怎么分，不难想到选取0占比最大的一段前缀长为len，把蛋糕均分len份然后就是一阶段的dfs博弈，暑假写过一丢类似的，需要根据回合来讨论，不过这题比较不同的一点是无论谁的回合都要考虑二阶段Bob的分法dp【u】表示走到 u点Alice的比例，Alice回合取子节点中最大，否则取最小，dfs结束后，考虑二阶段时，若子节点1的占比大于当前 u，那么Bob将不会给子节点切蛋糕，所以dpu还要和 cp取min代码如下：const int N=2e5+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=1e9+7;
ll n;
vector&lt;PII&gt;ve[N];
double dp[N];
void dfs(int u,int f,bool ifg,int c0,int c1){
//	cout &lt;&lt;  u &lt;&lt; " " &lt;&lt; c0 &lt;&lt; " " &lt;&lt; c1 &lt;&lt; "\n";dp[u]=1.0*c1/(c0+c1);if(ve[u].size()==1) return ;   //叶子节点直接return,无需后续操作double cp=1-ifg;for(auto [k,v]:ve[u]) if(v!=f){dfs(v,u,!ifg,c0+!k,c1+k);ifg?cp=max(dp[v],cp):cp=min(dp[v],cp);  //一阶段}dp[u]=min(cp,dp[u]); //二阶段
}
void solve(){cin &gt;&gt; n;for(int i=1;i&lt;=n;i++) ve[i].clear();for(int i=1;i&lt;n;i++){int u,v,k; cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;ve[u].push_back({k,v});ve[v].push_back({k,u});}double ans=0;for(auto [k,v]:ve[1]) if(k){  //Alice第一次只能走1边dfs(v,1,0,0,1);ans=max(dp[v],ans);}cout &lt;&lt; fixed &lt;&lt; setprecision(11) &lt;&lt; ans &lt;&lt; "\n";
}周日：补集美11届校赛 F 字符串哈希                         牛客传送门被莫名其妙的RE搞了一晚上，心态有点小炸🤕刚开始还想建个字典树啥的，但完全建不起来思路：先将字符串粘贴一次，此时需要比较的字符串即s1至sn开头的长度为n字符串先提出一个问题，已知俩字符串的哈希值，如何快速比较其字典序，方法是二分找到第一个哈希值不同的点，再进行直接比较，复杂度为O(logn)那么可以把s的哈希数组处理出来，然后将1到n的值排个序，复杂度为O(n*log^2n)，即得字典序第k小的字符串起始下标代码如下：const int N=2e6+10,M=1e4+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
ll n;
const ull MOD=(1ll&lt;&lt;61)-1,ba=131;
ull hsh[N],qp[N];
inline ull add(ull a,ull b){a+=b; if(a&gt;=MOD) a-=MOD;return a;
}
inline ull mul(ull a,ull b){__int128 c=(__int128)a*b;return add(c&gt;&gt;61,c&amp;MOD);
}
inline ull geth(int l,int r){return add(hsh[r],add(-mul(hsh[l-1],qp[r-l+1]),MOD));
}
int a[N];
void solve(){ll k; cin &gt;&gt; n &gt;&gt; k;string s; cin &gt;&gt; s;s.append(s),s=" "+s;qp[0]=1;for(int i=1;i&lt;=n*2;i++){qp[i]=mul(qp[i-1],ba);hsh[i]=add(mul(hsh[i-1],ba),s[i]);a[i]=i;}sort(a+1,a+n+1,[&amp;](int idx,int bdx){int l=1,r=n,res=n;while(l&lt;=r){int mid=l+r&gt;&gt;1;if(geth(idx,idx+mid-1)!=geth(bdx,bdx+mid-1)) res=mid,r=mid-1;else l=mid+1;}if(res==n) return idx&lt;bdx;        //不加会RE,感觉没道理return s[idx+res-1]&lt;=s[bdx+res-1];});cout &lt;&lt; s.substr(a[k],n) &lt;&lt; "\n";
}http://www.ppmy.cn/news/1541016.html相关文章Docker 安装sql server 登陆失败错误&amp;#xff1a; Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish co…阅读更多...网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:39 +0000</pubDate>
    </item>
    <item>
      <title>Docker 安装sql server 登陆失败</title>
      <link>https://www.ppmy.cn/news/1541015.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Docker 安装sql server 登陆失败news/2025/11/1 0:24:38/错误：Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : SSL Provider: [error:0A000086:SSL routines::certificate verify failed:self-signed certificate]. Sqlcmd: Error: Microsoft ODBC Driver 18 for SQL Server : Client unable to establish connection. For solutions related to encryption errors, see https://go.microsoft.com/fwlink/?linkid=2226722遇到这个错误通常是因为 SQL Server 客户端尝试与 SQL Server 建立安全连接时，无法验证服务器提供的证书。SQL Server 容器默认会生成一个自签名证书，而这个证书可能不会被客户端信任，导致连接失败。以下是几种解决方法：方法 1: 禁用证书验证对于开发或测试环境，你可以通过禁用证书验证来绕过这个问题。请注意，这种方法在生产环境中不推荐使用，因为它会降低安全性。使用sqlcmd连接时禁用证书验证sqlcmd -S localhost -U sa -P 'YourStrong!Passw0rd' -C这里的-C参数告诉sqlcmd忽略证书验证错误。方法 2: 使用自定义证书为了提高安全性，你可以为 SQL Server 配置一个由受信任的 CA（证书颁发机构）签发的证书。生成或获取证书：你可以从一个受信任的 CA 获取证书，或者使用 OpenSSL 生成一个自签名证书。将证书文件复制到 SQL Server 容器中：使用docker cp命令将证书文件复制到容器中。配置 SQL Server 使用该证书：进入容器内部，使用 SQL Server 配置管理器或其他工具配置 SQL Server 使用新的证书。方法 3: 信任自签名证书如果你使用的是自签名证书，可以将其添加到客户端的信任证书列表中。导出自签名证书：从 SQL Server 容器中导出自签名证书。你可以进入容器并使用openssl工具导出证书。将证书导入客户端的信任存储：在 Windows 上，你可以使用certmgr.msc导入证书。在 Linux 上，你可以将证书添加到/etc/ssl/certs目录，并更新证书索引。方法 4: 使用mssql-conf配置 SQL Server如果你有权限访问 SQL Server 容器，可以使用mssql-conf工具来配置 SQL Server 的网络设置，包括证书。进入容器：docker exec -it sqlserver1 /bin/bash运行mssql-conf/opt/mssql/bin/mssql-conf set network.ssl 0方法 5: 使用环境变量配置 SQL Server你也可以在启动容器时通过环境变量来配置 SQL Server 使用特定的证书。docker run -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=YourStrong!Passw0rd' \-e 'MSSQL_TLS_CERTIFICATE=/path/to/your/certificate.pem' \-e 'MSSQL_TLS_KEY=/path/to/your/privatekey.pem' \-p 1433:1433 --name sqlserver1 -d mcr.microsoft.com/mssql/server:2019-latest这里的MSSQL_TLS_CERTIFICATE和MSSQL_TLS_KEY环境变量指定了证书和私钥的路径。http://www.ppmy.cn/news/1541015.html相关文章网络相关(HTTP/TCP/UDP/IP)网络相关 
常见的状态码 100 临时响应 100 继续，请求者应当继续提出请求101 切换协议200 成功响应 200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来…阅读更多...2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:38 +0000</pubDate>
    </item>
    <item>
      <title>网络相关(HTTP/TCP/UDP/IP)</title>
      <link>https://www.ppmy.cn/news/1541014.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维网络相关(HTTP/TCP/UDP/IP)news/2025/11/1 0:24:37/网络相关常见的状态码100 临时响应100 继续，请求者应当继续提出请求101 切换协议200 成功响应200: 服务器成功处理请求201 以创建，请求成功并且服务器创建了新的资源202 已接受：服务器已接受请求，但尚未处理203 非授权信息：服务器已成功处理请求，但返回的信息可能来自另一来源204 无内容：服务器成功处理了请求，但没有返回任何内容205 重置内容： 服务器成功处理请求，没有返回任何内容，此响应要求请求者重置文档视图（例如: 清除表单内容以输入新内容）206 部分内容 服务器已成功处理部分GET请求300 重定向300 多种选择： 针对请求，服务器可执行多种操作，服务器可根据请求者选择一项操作，提供操作列表共请求者选择301 永久移动： 请求页面永久移动刀新的位置302 临时移动： 服务器目前从不通位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求303 查看其他位置： 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码304 为修改：自上次请求后，页面未修改。不返回网页内容305 使用代理：请求者只能使用代理访问请求的网页307 临时重定向 服务器目前从不同位置的网页相应请求，请求者应继续使用原有位置来响应以后的请求。400 请求错误400 请求错误： 服务器不理解请求的语法401 未授权：要求身份验证403 禁止访问： 服务器拒绝请求404 未找到： 服务器找不到请求的页面405 方法禁止： 禁用请求中指定的方法406 不接受： 无法使用请求的内容特性响应请求网页407 需要代理授权408 请求超时409 冲突410 已删除： 请求资源永久删除411 需要有效长度412 为满足提前条件413 请求实体过大414 请求URI过长415 不支持的媒体类型416 请求范围不符合要求417 维曼姿期望值： 服务器为满足“期望”请求表头字段的请求500 服务器内部错误500 服务器内部错误，无法完成请求501 尚未实施 服务器不具备办成请求的功能502 错误网关：服务器作为网关或代理，从上游服务器收到无效响应503 服务不可用： 服务器目前无法使用（由于超早或者停机维护），通常只是暂时状态504 网关超时： 服务器作为网关或者代理，但是没后及时从上游服务器收到请求505 HTTP版本不受支持： 服务器不支持请求中所用的HTTP协议版本http 与 https答http://www.ppmy.cn/news/1541014.html相关文章2024.10月18日- Vue2组件开发（3）Vue组件开发 
一、 ref属性 
如果在vue里&amp;#xff0c;想要获取DOM对象&amp;#xff0c;并且不想使用JS的原生语法&amp;#xff0c;那么就可以使用ref属性。ref属性的用法&amp;#xff1a; 
1&amp;#xff09;在HTML元素的开始标记中&amp;#xff0c;或者在Vue子组件中的开始标记中定义&amp;#xff0c;相…阅读更多...大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:37 +0000</pubDate>
    </item>
    <item>
      <title>2024.10月18日- Vue2组件开发（3）</title>
      <link>https://www.ppmy.cn/news/1541013.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维2024.10月18日- Vue2组件开发（3）news/2025/11/1 0:24:36/Vue组件开发一、 ref属性如果在vue里，想要获取DOM对象，并且不想使用JS的原生语法，那么就可以使用ref属性。ref属性的用法：1）在HTML元素的开始标记中，或者在Vue子组件中的开始标记中定义，相当于id的替代者html元素上： &lt;h1 ref="xxx"&gt;&lt;/h1&gt; 
Vue组件上：  &lt;School ref="xxx"&gt;&lt;/School&gt;2）获取方式： 在html标签上获取的是真实DOM元素，应用在组件标签上获取的是组件实例对象（vc）this.$refs.xxxsrc/components/School.vue&lt;template&gt;&lt;div class="hello"&gt;&lt;h1&gt;{{ schoolName }}&lt;/h1&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {name: 'School',data(){return {schoolName: "水利电力学院"}}
}
&lt;/script&gt;
​App.vue&lt;template&gt;&lt;div id="app"&gt;&lt;h1 v-text="msg" id="title"  ref="title1"&gt;&lt;/h1&gt;&lt;button ref="btn" @click="showInfo"&gt;点我显示信息&lt;/button&gt;&lt;School ref="sch" id="sch1"/&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
import School from './components/School.vue'
export default {name: 'App',components: {School},data(){return {msg:"哈哈哈"}},methods:{showInfo(){//console.log(document.getElementById("title"))console.log(this.$refs.title1)  //真实DOM元素console.log(this.$refs.btn)  //真实DOM元素console.log(this.$refs.sch)  //School组件的实例对象(vc)console.log(document.getElementById("sch1"))}}
}
&lt;/script&gt;二、 scoped 样式2.1 简介所有组件的style，都会被汇总到一起，如果style中设置的样式名有重复的，那么可能就会后引入的组件的样式会覆盖掉先引入组件的样式。此时，我们可以在组件的style开始标记里，使用scoped属性，来设置style样式只针对当前组件生效，即局部生效。注意：App.vue不适合使用scoped属性。2.2 案例演示School.vue&lt;template&gt;&lt;div class="demo"&gt;&lt;h1&gt;学校信息&lt;/h1&gt;&lt;h3&gt;学校名称: {{ name }}&lt;/h3&gt;&lt;h3&gt;学校地址：{{ address }}&lt;/h3&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;export default {name:"School",data(){return {name:"水利电力",address:"长春净月"}}}
&lt;/script&gt;
&lt;!-- scoped  是组件中的样式属性，设置后，只针对于当前组件的样式生效 --&gt;
&lt;style scoped&gt;.demo{background-color:rgb(0, 174, 255);}
&lt;/style&gt;Student.vue&lt;template&gt;&lt;div class="demo"&gt;&lt;h1&gt;学生信息&lt;/h1&gt;&lt;h3&gt;学生名称: {{ name }}&lt;/h3&gt;&lt;h3&gt;学生年龄：{{ age }}&lt;/h3&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;export default {name:"Student",data(){return {name:"张三",age:18}}}
&lt;/script&gt;
​
&lt;style scoped&gt;.demo{background-color: rgb(38, 136, 123);}
&lt;/style&gt;App.vue&lt;template&gt;&lt;div class="demo"&gt;&lt;h1&gt;正在学习Vue&lt;/h1&gt;&lt;School&gt;&lt;/School&gt;&lt;hr&gt;&lt;Student&gt;&lt;/Student&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;import Student from "./components/Student.vue"import School from "./components/School.vue"export default{name:"App",components:{School,Student},}
&lt;/script&gt;
​
&lt;!-- App.vue中写样式，目的是为了其所包含的内容都是该样式，因此不适合使用scoped --&gt;
&lt;style&gt;h1{color:red}
&lt;/style&gt;三、 组件通信属性3.1 什么是组件通信组件的数据是独立的，无法直接访问其他组件的数据；想使用其他组件的数据，就需要组件通信。组件通信，就是指组件与组件之间的数据传递。3.2 通信解决方案3.3 父子通信流程父组件通过props将数据传递给子组件子组件利用$emit通知父组件修改更新3.4 父&gt;子通信代码演示父向子传值步骤第一步：在父组件中，编写子组件标签时，添加属性和属性值，也就是键值对的形式设置属性和具体值。(发起通信)&lt;Student  name="李四" gender="女" :age="18"/&gt;         :是v-bind的简写，表示18是表达式第二步：子组件内部通过props配置项，来接收。(收到通信)三种配置方式:
-1).简单声明接受信息:  props: ['name','gender','age']
-2).接受的同时限定类型:props:{name:String,gender:String,age:Number}
-3). 限定类型，必要性，默认值等props:{name:{type:String, //约束类型required:true //约束必要性},gender:{type:String,default:"女"  //约束默认值},age:{type:Number,default:100}}第三步：子组件模板中可以直接使用props接收的值案例演示：父组件App.vue&lt;template&gt;&lt;div id="app"&gt;&lt;Student  name="李四" gender="女" :age="18" x="1"/&gt;&lt;hr&gt;&lt;Student  name="王五"/&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
import Student from './components/Student.vue'
​
export default {name: 'App',components: {Student},data(){return {msg:"哈哈哈"}},
}
&lt;/script&gt;子组件Student.vue&lt;template&gt;&lt;div&gt;&lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;h2&gt;学生姓名:{{ name }}&lt;/h2&gt;&lt;h2&gt;学生性别:{{ gender }}&lt;/h2&gt;&lt;!-- &lt;h2&gt;学生年龄:{{ age+1 }}&lt;/h2&gt; --&gt;&lt;h2&gt;学生年龄:{{ myAge+1 }}&lt;/h2&gt;&lt;button @click="add"&gt;点我年龄+1&lt;/button&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {name: 'Student',data(){console.log(this)return {msg:"水利电力学院的学生",// age:18,      props优先级myAge:this.age}},methods:{add(){this.myAge++}},// 简单声明接受// props:["name","gender","age"]// 接收的同时对数据进行类型限制/* props:{name:String,gender:String,age:Number} */
​props:{name:{type:String, //约束类型required:true //约束必要性},gender:{type:String,default:"女"  //约束默认值},age:{type:Number,default:100}}
​
}
&lt;/script&gt;注意：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据1.default和required一般不同时写（因为当时必填项时，肯定是有值的）2.default后面如果是简单类型的值，可以直接写默认。如果是复杂类型的值，则需要以函数的形式return一个默认值3.5 练习：将父组件中的各种类型数据，传递给子组件。 只需要使用指令语法书写表达式即可。这种方式就可以自动推断数据类型了。3.6 子&gt;父通信方式1第一种方式： 通过父组件给子组件传递函数类型的props实现子给父传递数据。App.vue&lt;template&gt;&lt;div id="demo"&gt;&lt;h1&gt; 老师名字：{{teacherName}}&lt;/h1&gt;&lt;h1&gt; 学生名字：{{studentName}}&lt;/h1&gt;&lt;!-- 编写子组件标签时，定义属性，传入函数名 --&gt;&lt;Teacher :getTeacherData="getTeacherName"&gt;&lt;/Teacher&gt;&lt;Student :getStudentData="getStudentName"/&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
import Teacher from './components/Teacher.vue'
import Student from './components/Student.vue'
​
export default {name: 'App',components: {Teacher,Student},data:function(){return {teacherName:'',studentName:''}},methods:{// 定义函数getTeacherName:function(value){console.log("收到了Teacher组件传过来的名字:"+value);this.teacherName = value;},getStudentName(value){console.log("收到了Student组件传过来的名字:"+value);this.studentName = value;}
​}
}
&lt;/script&gt;
&lt;style scoped&gt;#demo{background-color:blueviolet;border: 1px solid blueviolet;}
&lt;/style&gt;Teacher.vue&lt;template&gt;&lt;div&gt;序号:&lt;input type="text" :value="id"&gt; &lt;br&gt;姓名:&lt;input type="text" v-model="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;性别:&lt;input type="text" :value="gender"&gt; &lt;br&gt;&lt;!-- 绑定点击事件，设置回调函数为传过来的函数 --&gt;&lt;button @click="sendTeacherName"&gt;点我给父组件传值&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name:"Teacher",data(){return {id:1,name:"王老师",age:21,gender:'男'}},// 使用props来接受传入的属性--&gt;函数props:['getTeacherData'],methods:{sendTeacherName(){//调用传过来的函数，将名字作为参数传入this.getTeacherData(this.name);}}}&lt;/script&gt;&lt;style scoped&gt;div{background-color: pink;margin: 20px;}&lt;/style&gt;Student.vue&lt;template&gt;
&lt;div&gt;序号:&lt;input type="text" :value="id"&gt; &lt;br&gt;姓名:&lt;input type="text" :value="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;性别:&lt;input type="text" :value="gender"&gt; &lt;br&gt;&lt;button @click="sendStudentName"&gt;点我给父组件传值&lt;/button&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;export default {name:"Student",data(){return {id:1001,name:"韩梅梅",age:21,gender:'女'}},props:['getStudentData'],methods:{sendStudentName(){//调用传过来的函数，将名字作为参数传入this.getStudentData(this.name);}}}
&lt;/script&gt;
​
&lt;style scoped&gt;div{background-color: skyblue;margin:20px;}
&lt;/style&gt;四、 自定义事件4.1 简介除了js中的内置事件，Vue还允许开发者自定义事件。在Vue实例上有以下四个方法，来完成自定义事件的各种操作：vm.$on: 自定义事件监听的核心方法。它允许开发者在Vue实例上注册监听器，以响应特定的事件。-1).监听器注册：通过vm.$on(eventName, callback)的形式，将callback函数注册为eventName事件的监听器。当事件被触发时，callback将被调用。
​
-2).执行顺序：事件触发时，所有注册的回调函数将按照它们注册的顺序依次执行。vm.$emit： 自定义事件派发的核心方法。它允许开发者触发自定义事件，从而实现组件之间的通信。-1). 事件触发：通过vm.$emit(eventName)的形式，可以触发一个名为eventName的事件。
-2). 参数传递：使用vm.$emit(eventName, arg1, arg2, ...)触发事件时，可以传递多个参数。这些参数将按顺序传递给监听器的回调函数。==vm.$emit在Vue组件系统中扮演着至关重要的角色，尤其是在子&gt;父组件的通信中==-1).子组件触发：子组件通过调用vm.$emit来触发一个事件，该事件可以被父组件监听。
-2).父组件监听：父组件通过在子组件的引用上使用v-on指令来监听子组件触发的事件。vm.$off：移除自定义事件监听器的方法，它提供了一种机制来清理不再需要的事件监听，从而避免潜在的内存泄漏问题。-1) 移除机制：vm.$off([event, callback]),如果提供了事件名称和回调函数，则只移除特定的监听器；
-2).如果没有提供参数，则移除所有事件的所有监听器。:   vm.$off()
-3).灵活性：vm.$off的灵活性体现在可以根据实际情况选择移除单个监听器或全部监听器，以满足不同的开发需求。应用场景：-1).组件销毁：在Vue组件被销毁前，使用vm.$off移除所有注册的事件监听器，确保组件不会在销毁后继续触发事件，导致不可预期的行为。
-2).条件性监听：在某些情况下，事件监听可能只在特定条件下需要，一旦条件不再满足，就应该使用vm.$off移除监听器，以避免不必要的资源占用。vm.$once:提供了一种机制，允许事件只被监听一次，在事件触发后自动移除监听器。-1).场景应用：适用于那些只需要执行一次的事件处理，例如初始化操作或一次性资源的加载。
-2).资源管理：通过确保监听器只触发一次，vm.$once有助于避免不必要的资源消耗和潜在的内存泄漏。4.2 子&gt;父通信方法2：v-on绑定自定义事件绑定原理：在编写的子组件标签上使用v-on或者@绑定自定义事件，实际上是将事件绑定到子组件实例对象的VueComponent上。当有人触发了子组件上的这个事件，就会回调绑定到该事件上的函数。App.vue&lt;template&gt;&lt;div id="demo"&gt;&lt;h1&gt; 老师名字：{{teacherName}}&lt;/h1&gt;&lt;h1&gt; 学生名字：{{studentName}}&lt;/h1&gt;&lt;!-- 第二种方式：使用v-on|@方式自定义事件。 --&gt;&lt;Teacher @getTeacherData="getTeacherName"/&gt;&lt;Student @getStudentData="getStudentName"/&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
import Teacher from './components/Teacher.vue'
import Student from './components/Student.vue'
​
export default {name: 'App',components: {Teacher,Student},data:function(){return {teacherName:'',studentName:''}},methods:{// 定义函数getTeacherName:function(value){console.log("收到了Teacher组件传过来的名字:"+value);this.teacherName = value;console.log(this);},getStudentName(value){console.log("收到了Student组件传过来的名字:"+value);this.studentName = value;}
​}
}
&lt;/script&gt;
&lt;style scoped&gt;#demo{background: linear-gradient(to bottom right ,#2980b9,#ffffff);border: 1px solid #cefff1;}
&lt;/style&gt;Teacher.vue&lt;template&gt;&lt;div&gt;姓名:&lt;input type="text" v-model="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;&lt;button @click="sendTeacherName"&gt;点我给父组件传值&lt;/button&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {name:"Teacher",data(){return {name:"王老师",age:21,}},methods:{sendTeacherName(){//当有人点击了子组件上的按钮时，会执行sendTeacherName函数，我们在这个函数的逻辑体中，//使用$emit方法来触发该组件实例对象VueComponent上绑定的事件，并且可以传入其他参数//将参数传入回调函数中。this.$emit('getTeacherData',this.name)}}
}
&lt;/script&gt;
​
&lt;style scoped&gt;div{background-color: #a6acec;margin: 20px;}
&lt;/style&gt;Student.vue&lt;template&gt;&lt;div&gt;姓名:&lt;input type="text" :value="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;&lt;button @click="sendStudentName"&gt;点我给父组件传值&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name:"Student",data(){return {name:"韩梅梅",age:21,}},methods:{sendStudentName(){//当有人点击了子组件上的按钮时，会执行sendTeacherName函数，我们在这个函数的逻辑体中，//使用$emit方法来触发该组件实例对象VueComponent上绑定的事件，并且可以传入其他参数//将参数传入回调函数中。this.$emit('getStudentData',this.name)}}}&lt;/script&gt;&lt;style scoped&gt;div{background-color:#ace7ef;margin:20px;}&lt;/style&gt;4.3 子&gt;父通信方法3：$on绑定自定义事件App.vue&lt;template&gt;&lt;div id="demo"&gt;&lt;h1&gt; 老师名字：{{teacherName}}&lt;/h1&gt;&lt;h1&gt; 学生名字：{{studentName}}&lt;/h1&gt;&lt;!-- 第三种方式：使用ref和$on方式来自定义事件，更加灵活。 --&gt;&lt;Teacher ref="teacher"/&gt;&lt;Student ref="student"/&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
import Teacher from './components/Teacher.vue'
import Student from './components/Student.vue'
​
export default {name: 'App',components: {Teacher,Student},data:function(){return {teacherName:'',studentName:''}},methods:{// 定义函数getTeacherName:function(value){console.log("收到了Teacher组件传过来的名字:"+value);this.teacherName = value;console.log(this);},getStudentName(value){console.log("收到了Student组件传过来的名字:"+value);this.studentName = value;}},mounted(){// 通过$refs属性获取组件实例对象，然后使用$on来绑定事件，这样的方式更加灵活this.$refs.teacher.$on('getTeacherData',this.getTeacherName)this.$refs.student.$on('getStudentData',this.getStudentName)}
}
&lt;/script&gt;
&lt;style scoped&gt;#demo{background: linear-gradient(to bottom right ,#2980b9,#ffffff);border: 1px solid #cefff1;}
&lt;/style&gt;4.4 总结：组件的自定义事件1）一种组件间通信的方式，适用于：子组件 ====&gt; 父组件通信2）使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调函数在A中）3）绑定自定义事件：第一种方式，在父组件中：&lt;Demo @pClick="test"/&gt;或&lt;Demo v-on:pClick="test"/&gt;第二种方式，在父组件中： 使用ref和$on&lt;Demo ref="demo"/&gt;mounted(){this.$refs.demo.$on('pClick',data)}4）若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法5）触发自定义事件：this.$emit('pClick',数据)6）解绑自定义事件：this.$off('pClick')7）组件上也可以绑定原生DOM事件，需要使用native修饰符&lt;Demo @click.native=“f1()”&gt;注意：通过this.$refs.xxx.$on('pClick',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！4.5 全局事件总线：任意组件之间通信全局事件总线（GlobalEventBus）是一种可以在任意组件间通信的方式，本质上就是一个对象。它必须满足以下条件：1. 所有的组件对象都必须能看见他  
2. 这个对象必须能够使用$on、$emit和$off方法去绑定、触发和解绑事件步骤1）安装全局事件总线：new Vue({...beforeCreate() {Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm},...
})步骤2）使用事件总线：接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身export default {methods(){demo(data){...}}...mounted() {this.$bus.$on('xxx',this.demo)}
}提供数据：B组件想要提供数据，则在B组件中触发$bus身上的自定义事件this.$bus.$emit('xxx',data)建议：最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件main.jsimport Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue({render: h =&gt; h(App),beforeCreate() {//定义一个全局总线，也就是所有组件都可以访问到的对象Vue.prototype.$bus = this},}).$mount('#app')Student.vue&lt;template&gt;&lt;div&gt;姓名:&lt;input type="text" v-model="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;&lt;button @click="sendToTeacher" &gt;点我给Teacher组件传值&lt;/button&gt;&lt;/div&gt;
&lt;/template&gt;
​
&lt;script&gt;
export default {name:"Teacher",data(){return {name:"韩梅梅",age:21,}},methods:{sendToTeacher(){console.log("给teacher组件发送信息")this.$bus.$emit('getStudentSendData',this.name);},getTeacherSendData(value){console.log("获取Teacher发送过来的信息");this.name = value;}},mounted() {this.$bus.$on('getTeacherSendData',this.getTeacherSendData)},beforeDestroy(){this.$bus.$off('getTeacherSendData')}
}
&lt;/script&gt;
​
&lt;style scoped&gt;div{background-color: pink;margin: 20px;}
&lt;/style&gt;Teacher.vue&lt;template&gt;&lt;div&gt;姓名:&lt;input type="text" v-model="name"&gt; &lt;br&gt;年龄:&lt;input type="text" :value="age"&gt; &lt;br&gt;&lt;button @click="sendToStudent" &gt;点我给Student组件传值&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {name:"Teacher",data(){return {name:"王老师",age:21}},methods:{sendToStudent(){console.log("给Student发送信息");this.$bus.$emit('getTeacherSendData',this.name)},getStudentSendData(value){console.log("获取Student发送过来的信息");this.name = value;}},mounted() {this.$bus.$on('getStudentSendData',this.getStudentSendData)},beforeDestroy(){this.$bus.$off('getStudentSendData')}}&lt;/script&gt;&lt;style scoped&gt;div{background-color: skyblue;margin: 20px;}&lt;/style&gt;http://www.ppmy.cn/news/1541013.html相关文章大数据面试题整理——Yarn系列文章目录 
第一章 HDFS面试题 第二章 MapReduce面试题 文章目录 系列文章目录什么是 Yarn&amp;#xff1f;一、Yarn 的主要组件及其功能是什么&amp;#xff1f;二、Yarn 中的容器&amp;#xff08;Container&amp;#xff09;是什么&amp;#xff1f;三、简述 Yarn 的工作流程。四、Yarn 如何进行资…阅读更多...Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:36 +0000</pubDate>
    </item>
    <item>
      <title>大数据面试题整理——Yarn</title>
      <link>https://www.ppmy.cn/news/1541012.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大数据面试题整理——Yarnnews/2025/11/1 0:24:34/系列文章目录第一章 HDFS面试题第二章 MapReduce面试题文章目录系列文章目录什么是 Yarn？一、Yarn 的主要组件及其功能是什么？二、Yarn 中的容器（Container）是什么？三、简述 Yarn 的工作流程。四、Yarn 如何进行资源分配？五、Yarn 与 MapReduce 的关系。六、Yarn 与 Hive 的关系。七、Yarn 常见的配置参数有哪些？八、如何优化 Yarn 性能？九、Yarn 有哪些容错机制？十、Yarn 如何处理节点故障？什么是 Yarn？Yarn是 Hadoop 生态系统中的资源管理和任务调度框架。责管理调度资源。一、Yarn 的主要组件及其功能是什么？ResourceManager（RM）：它是集群资源分配和管理中心，负责处理客户端请求、启动应用程序，监控 NodeManager 资源使用情况并为应用程序的 ApplicationMaster 分配资源。NodeManager（NM）：管理单个节点的资源，包括 CPU、内存等。启动和监控容器（Container），向 ResourceManager 汇报节点资源使用情况和容器状态。ApplicationMaster（AM）：每个应用程序有一个 ApplicationMaster，负责与 ResourceManager 协商资源，并与 NodeManager 协同工作来执行和监控任务。它负责应用程序的调度，如任务分配、监控任务进度等。二、Yarn 中的容器（Container）是什么？容器是 Yarn 中资源分配的基本单位。它封装了一定量的内存、CPU 等资源。NodeManager 负责启动和管理容器，ApplicationMaster 可以向 ResourceManager 请求特定资源规格的容器来运行任务。三、简述 Yarn 的工作流程。客户端向 ResourceManager 提交应用程序。ResourceManager 为应用程序启动一个 ApplicationMaster。ApplicationMaster 向 ResourceManager 申请资源（容器）。ResourceManager 分配资源给 ApplicationMaster。ApplicationMaster 与 NodeManager 通信，启动容器并执行任务。任务执行过程中，ApplicationMaster 监控任务进度和状态，向 ResourceManager 汇报。任务完成后，ApplicationMaster 向 ResourceManager 注销并释放资源。四、Yarn 如何进行资源分配？ResourceManager 根据节点的资源可用性和应用程序的资源需求进行资源分配。它维护着一个资源队列，不同的应用程序可以被分配到不同的队列中，每个队列有一定的资源配额。ApplicationMaster 向 ResourceManager 发送资源请求，ResourceManager 根据资源情况进行分配，并将分配的容器信息返回给 ApplicationMaster。五、Yarn 与 MapReduce 的关系。在 Hadoop 2.0 及以后版本，MapReduce 运行在 Yarn 之上。Yarn 为 MapReduce 作业提供资源管理和调度服务，MapReduce 的 ApplicationMaster 负责 MapReduce 任务的具体调度和执行。MapReduce 作业通过 Yarn 来获取资源并执行任务，提高了集群资源的利用率和可扩展性。六、Yarn 与 Hive 的关系。Hive 可以在 Yarn 上运行查询任务。Hive 客户端将查询提交给 Hive 驱动程序，驱动程序将查询转换为一系列的 MapReduce 任务（或其他执行引擎任务），然后这些任务在 Yarn 上申请资源并执行。Yarn 为 Hive 任务提供资源分配和管理，确保任务能够在集群中高效执行。七、Yarn 常见的配置参数有哪些？yarn.nodemanager.resource.memory-mb：设置每个节点可用的物理内存总量。yarn.scheduler.minimum-allocation-mb：每个容器请求的最小内存分配量。yarn.scheduler.maximum-allocation-mb：每个容器请求的最大内存分配量。yarn.nodemanager.vmem-pmem-ratio：虚拟内存与物理内存的比例。yarn.scheduler.capacity.root.queues：定义资源队列及其配置。八、如何优化 Yarn 性能？合理配置资源参数：根据集群硬件资源和应用程序需求，调整内存、CPU 等资源参数。调整资源队列配置：根据不同应用程序的优先级和资源需求，合理划分资源队列和设置资源配额。监控和分析性能指标：通过监控 Yarn 的资源使用情况、任务执行时间等指标，找出性能瓶颈并进行优化。应用程序优化：优化应用程序的代码和算法，减少资源消耗和提高执行效率。九、Yarn 有哪些容错机制？ResourceManager 容错：ResourceManager 可以通过配置实现高可用（HA），通常使用多个 ResourceManager 实例，通过 ZooKeeper 进行选举和协调。NodeManager 容错：NodeManager 定期向 ResourceManager 汇报心跳和资源使用情况。如果 NodeManager 长时间未汇报心跳，ResourceManager 会认为该节点失效，并将该节点上的容器重新分配到其他节点。ApplicationMaster 容错：ApplicationMaster 可以在失败后重新启动。ResourceManager 会在一定时间内保留应用程序的状态，当 ApplicationMaster 重新启动时，它可以从上次失败的地方继续执行。十、Yarn 如何处理节点故障？当 NodeManager 出现故障时，ResourceManager 会将该节点上正在运行的容器标记为失败，并重新分配到其他健康节点上运行。如果是 ApplicationMaster 所在节点出现故障，ApplicationMaster 会在其他节点上重新启动，并从 ResourceManager 恢复应用程序的状态信息，继续执行任务。http://www.ppmy.cn/news/1541012.html相关文章Python网络请求库requests的10个基本用法大家好&amp;#xff01;今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口&amp;#xff0c;requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。 
引言 
随着互联网技术的…阅读更多...高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:35 +0000</pubDate>
    </item>
    <item>
      <title>Python网络请求库requests的10个基本用法</title>
      <link>https://www.ppmy.cn/news/1541011.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python网络请求库requests的10个基本用法news/2025/11/1 0:24:33/大家好！今天我们要聊聊Python中非常实用的一个库——requests。这个库让发送HTTP请求变得超级简单。无论你是想抓取网页数据还是测试API接口，requests都能派上大用场。下面我们就一起来看看如何使用requests完成一些常见的任务。引言随着互联网技术的发展，HTTP请求成为开发者们日常工作中不可或缺的一部分。Python语言以其简洁易用的特点，成为众多开发者首选的编程语言之一。而requests库作为Python中最受欢迎的HTTP客户端库之一，更是大大简化了发送HTTP请求的过程。本文将详细介绍如何利用requests库执行各种类型的HTTP请求，从基础的GET请求到复杂的认证、文件上传等高级功能。发送GET请求首先，你需要安装requests库。打开命令行工具，输入以下命令：安装完成后，就可以开始使用了。最简单的GET请求如下：这里的response.text会打印出响应的内容。如果你想获取特定信息，可以解析返回的数据。比如，如果返回的是JSON格式的数据，可以用response.json()方法将其转换为Python字典。获取页面的二进制数据有时候我们需要获取图片或文件等二进制数据，这时可以使用requests.get方法并指定stream=True来实现。这段代码会将图片下载到当前目录下。添加查询参数很多时候，我们需要向URL添加查询参数。这可以通过传递一个字典给params参数来实现：这里httpbin.org是一个测试HTTP请求的好地方。发送POST请求发送POST请求也很简单，只需要调用requests.post方法，并传入要发送的数据即可：处理JSON数据当服务器返回JSON格式的数据时，我们可以直接使用response.json()来解析它：这段代码会打印出GitHub API返回的所有事件类型。设置自定义Header如果你需要设置HTTP头部信息，可以通过headers参数来实现：设置User-Agent可以帮助我们模拟浏览器行为。发送带认证信息的请求有时我们需要访问需要认证的网站或API。requests库提供了多种认证方式，包括基本认证（Basic Auth）和OAuth等。下面我们来看一个基本认证的例子：在这个例子中，我们使用了HTTPBasicAuth类来提供用户名和密码进行认证。发送带有表单数据的请求当我们需要提交表单数据时，可以使用requests.post方法，并通过data参数传递字典形式的数据：这段代码会发送包含名字和邮箱的POST请求。发送带有文件的请求在上传文件时，可以使用requests.post方法，并通过files参数传递文件对象：这段代码会上传名为example.txt的文件到服务器。处理重定向和超时在处理网络请求时，我们可能会遇到重定向和超时问题。requests库提供了相应的参数来处理这些问题。处理重定向：如果不需要自动重定向，可以设置allow_redirects=False。处理超时：这段代码设置了请求的超时时间为5秒，如果超过这个时间没有响应，则会抛出Timeout异常。实战案例：获取天气信息假设我们需要获取某个城市的天气信息，可以使用OpenWeatherMap提供的API来实现。以下是具体的步骤：1.注册一个OpenWeatherMap账户并获取API密钥。2.使用requests库发送GET请求获取天气数据。下面是完整的代码示例：在这段代码中，我们使用了requests.get方法发送GET请求，并通过response.json()方法解析返回的JSON数据。然后，我们提取了温度和天气描述信息并打印出来。总结本文介绍了如何使用requests库执行各种类型的HTTP请求，包括发送GET/POST请求、处理JSON数据、设置自定义Header、发送带认证信息的请求、上传文件、处理重定向和超时等问题。通过实战案例展示了如何利用requests获取天气信息，希望这些知识能够帮助你在实际开发过程中更加高效地处理HTTP请求。好了，今天的分享就到这里了，我们下期见。http://www.ppmy.cn/news/1541011.html相关文章高中数学网盘资料（每题有解析和知识点）一、究极超能学习资源高中版 一数作为播放量过亿的哔站up实力非同一般 链接&amp;#xff1a;https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg  提取码&amp;#xff1a;7MBW  复制这段内容打开「百度网盘APP 即可获取」 二、必刷题高考合订本&amp;#xff08;刷题必备&amp;#xff09; 链接&amp;am…阅读更多...lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:33 +0000</pubDate>
    </item>
    <item>
      <title>高中数学网盘资料（每题有解析和知识点）</title>
      <link>https://www.ppmy.cn/news/1541010.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维高中数学网盘资料（每题有解析和知识点）news/2025/11/1 0:24:32/一、究极超能学习资源高中版一数作为播放量过亿的哔站up实力非同一般链接：https://pan.baidu.com/s/1xrcAlq6wj_LMYHcbxAKAWg提取码：7MBW复制这段内容打开「百度网盘APP 即可获取」二、必刷题高考合订本（刷题必备）链接：https://pan.baidu.com/s/13TQXdOg6I615TauDb4WLhQ提取码：56b9复制这段内容打开「百度网盘APP 即可获取」三、小合集（资料大全）链接：https://pan.baidu.com/s/1m-FjsthGG_hT0s-o4ErmpQ提取码：MY3b复制这段内容打开「百度网盘APP 即可获取」http://www.ppmy.cn/news/1541010.html相关文章lazyLoad//1.通过React的lazy函数配合import()函数动态加载路由组件 &gt; 路由组件代码会被分开打包     const Login  lazy(()&gt;import(/pages/Login))          //2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面     &lt;Suspense fallback{&lt;h1&amp;…阅读更多...支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:32 +0000</pubDate>
    </item>
    <item>
      <title>lazyLoad</title>
      <link>https://www.ppmy.cn/news/1541009.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维lazyLoadnews/2025/11/1 0:24:31///1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包const Login = lazy(()=&gt;import('@/pages/Login'))//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面&lt;Suspense fallback={&lt;h1&gt;loading.....&lt;/h1&gt;}&gt;&lt;Switch&gt;&lt;Route path="/xxx" component={Xxxx}/&gt;&lt;Redirect to="/login"/&gt;&lt;/Switch&gt;&lt;/Suspense&gt;切记loading组件，不能用lazy的形式引入方法1，引入一个加载中的样式组件import React, { Component, lazy, Suspense } from 'react'
import Loading from './loading'const About = lazy(() =&gt; import('./About'))&lt;Suspense fallback={&lt;Loading&gt;&lt;/Loading&gt;}&gt;&lt;About&gt;&lt;/About&gt;
&lt;/Suspense&gt;方法2，引入一个样式import React, { Component, lazy, Suspense } from 'react'const About = lazy(() =&gt; import('./About'))&lt;Suspense fallback={&lt;h1&gt;加载中......&lt;/h1&gt;}&gt;&lt;About&gt;&lt;/About&gt;&lt;/Suspense&gt;http://www.ppmy.cn/news/1541009.html相关文章支持国密算法的数字证书-国密SSL证书详解在互联网中&amp;#xff0c;数字证书作为标志通讯各方身份信息的数字认证而存在&amp;#xff0c;常见的数字证书大都采用国际算法&amp;#xff0c;比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势&amp;#xff0c;也出现了支持国密算法的数字证书-国密SSL证书。那…阅读更多...【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:31 +0000</pubDate>
    </item>
    <item>
      <title>支持国密算法的数字证书-国密SSL证书详解</title>
      <link>https://www.ppmy.cn/news/1541008.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维支持国密算法的数字证书-国密SSL证书详解news/2025/11/1 0:24:30/在互联网中，数字证书作为标志通讯各方身份信息的数字认证而存在，常见的数字证书大都采用国际算法，比如RSA算法、ECC算法、SHA2算法等。随着我国加强网络安全技术自主可控的大趋势，也出现了支持国密算法的数字证书-国密SSL证书。那么什么是国密SSL证书？国密SSL证书支持哪种国密算法呢？带着这些疑问，我们继续看下面的内容。一、支持国密算法的数字证书-国密SSL证书国密SSL证书即遵循国家标准技术规范并参考国际标准，采用我国自主研发的SM2公钥算法体系，支持SM2等国产密码算法及国密SSL安全协议的数字证书。国密SSL证书可以应用于政府机构、事业单位、大型国企、金融银行等重要领域进行国产化改造，以满足国密合规需求。二、国密SSL证书的主要作用1、解决国密应用难题。利用国密算法SSL证书可以帮助我国的重要政企职能部门解决现有从客户端到服务器端应用国产密码算法的障碍。2、保障网络通信安全。国密SSL证书与国际SSL证书一样具有身份认证和数据传输加密的功能，可验证网站真实可信，防止传输数据的泄露或篡改，让用户安心访问。3、消除浏览器“不安全”提示。在国密浏览器上访问部署了国密SSL证书的网站时，不会出现浏览器“不安全”提示。4、满足密评密改要求。根据《网络安全法》《等保2.0》《密码法》等相关法律法规及国家政策监管要求，国密SSL证书助力我国重要领域完成国密升级改造。小知识：SM2算法全称椭圆曲线公钥密码算法，是一种非对称密码算法，它的公钥加密算法和数字签名算法可满足多种密码应用中的通信加解密、身份认证和数据完整性、真实性的安全需求，可用于替代RSA国际算法。三、国密SSL证书类型目前市面上国密SSL证书的主要类型有DV、OV、EV、单域名、多域名、通配符等多种国密SSL证书类型。四、国密SSL证书的申请流程国密SSL证书的申请步骤很简单，只需要在完成以下步骤：选择国密SSL证书类型；填写证书申请表格并提交；CA机构验证域名和身份；颁发国密SSL证书；注意，不同CA机构颁发国密SSL证书需要的资料和申请步骤略有不同，此步骤仅供参考。以上就是关于支持国密算法的数字证书-WoTrus的相关介绍了，随着我国网络安全技术的不断提升，在自主可控、国产化的大趋势下，国密SSL证书将会应用于更多领域，帮助我国政企事业单位营造更加安全、更加可信的网络环境，为助力保障我国网络安全贡献力量。http://www.ppmy.cn/news/1541008.html相关文章【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题目录 确认已安装anacondaAnaconda权限问题修改权限结束 你好&amp;#xff01; 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章&amp;#xff0c;了解一下Markdown的基本语法知识。 
确认已安装anaconda 如图&amp;#xff0c;已…阅读更多...人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:30 +0000</pubDate>
    </item>
    <item>
      <title>【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题</title>
      <link>https://www.ppmy.cn/news/1541007.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【BUG】解决已安装anaconda的pycharm中jupyter服务器中出现的import jieba失败问题news/2025/11/1 0:24:29/目录确认已安装anacondaAnaconda权限问题修改权限结束你好！ 这是你第一次使用Markdown编辑器所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。确认已安装anaconda如图，已选择anaconda解释器，但jupyter服务器中却出现import jieba导包失败的问题，是怎么造成的呢？我们来一起看一下。Anaconda权限问题不知道大家安装的时候是否选的是管理员权限也就是All users，其实这里正确的选择应该是Just me，但我选择Just me也错了，这里存有一个疑问。修改权限如果你选择的是Just me，那么有可能是当前登录的用户是普通用户，登录不到管理员级别所以使用不了安装的权限所造成的，所以这时要修改权限，随便用一个文件来举例，比如Xmind，右键“属性”，点“安全”，选中当前登录的普通用户或用户组，点击“编辑”。点击“允许”，这里我已全部勾选所以就不再演示了，图示如下：结束好啦，那到这里我们就结束了jieba导入问题的全部解决流程，快去试一下pycharm终端或jupyter服务器里能否正常导入jieba吧，这次的教程就结束，拜拜~ 再见~！http://www.ppmy.cn/news/1541007.html相关文章人工智能：塑造未来生活与工作的力量&amp;#x1f493; 博客主页&amp;#xff1a;倔强的石头的CSDN主页  &amp;#x1f4dd;Gitee主页&amp;#xff1a;倔强的石头的gitee主页 ⏩ 文章专栏&amp;#xff1a;《热点时事》 期待您的关注 引言 随着人工智能技术的不断发展&amp;#xff0c;我们已经看到了它在各行业带来的巨大变革。 在医疗行业中…阅读更多...jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:29 +0000</pubDate>
    </item>
    <item>
      <title>人工智能：塑造未来生活与工作的力量</title>
      <link>https://www.ppmy.cn/news/1541006.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维人工智能：塑造未来生活与工作的力量news/2025/11/1 0:24:28/💓 博客主页：倔强的石头的CSDN主页📝Gitee主页：倔强的石头的gitee主页⏩ 文章专栏：《热点时事》期待您的关注引言随着人工智能技术的不断发展，我们已经看到了它在各行业带来的巨大变革。在医疗行业中，人工智能技术正在被应用于病例诊断、药物研发等方面，为医学研究和临床治疗提供了新的思路和方法；在企业中，人工智能技术可以通过数据分析、智能决策等手段，协助企业实现运营的智能化和效率的提升。而在日常生活中，智能语音助手、自动驾驶汽车、智能家居等产品也成为了人们生活中的必备物品。人工智能技术的应用前景如何？它会如何改变我们的生活和工作方式？本文我们一起来探讨人工智能技术的未来发展。目录引言🍃人工智能技术的发展历程和现状，应用领域和前景发展历程与现状：应用领域：前景展望：技术与知识需求：🍃个人对人工智能技术应用前景的看法和观点机遇：挑战与应对：案例佐证：结语🍃人工智能技术的发展历程和现状，应用领域和前景人工智能（AI），这一曾被视为科幻小说中的概念，如今已悄然渗透至我们生活的方方面面，成为推动社会进步的重要力量。从最初的简单规则基系统，到如今的深度学习、自然语言处理、机器视觉等复杂技术，人工智能的发展历程见证了人类对智能模拟与超越的不懈追求。发展历程与现状：人工智能的起源可追溯至上世纪中叶，经历了符号主义、连接主义、深度学习等多个发展阶段。近年来，随着大数据的爆发、计算能力的提升以及算法的优化，人工智能迎来了前所未有的发展机遇，尤其是在机器学习、尤其是深度学习技术的推动下，AI系统的智能水平实现了质的飞跃。应用领域：人工智能的应用范围极为广泛，几乎涵盖了所有行业。在医疗领域，AI不仅能够帮助医生进行病例诊断，提高准确率，还能加速新药研发，缩短临床试验周期。企业界则利用AI进行数据分析，优化供应链管理，实现精准营销，甚至通过预测分析来辅助战略决策，极大地提升了运营效率。日常生活中，智能音箱、自动驾驶汽车、智能家居等产品的普及，让AI成为了连接人与世界的桥梁，极大地便利了人们的生活。前景展望：随着技术的不断成熟与融合，人工智能的潜力将进一步释放。未来，AI将在教育、环保、城市管理等更多领域发挥关键作用，推动社会向更加智能化、高效化、可持续的方向发展。例如，在教育领域，个性化学习平台将依据学生的学习习惯和能力定制教学内容，实现因材施教；在环保方面，AI能监测环境变化，预测自然灾害，助力可持续发展。技术与知识需求：实现这些愿景，需要跨学科的知识融合，包括计算机科学、数学、统计学、心理学、伦理学等。同时，持续的技术创新，如量子计算、边缘计算等，将为AI提供更加强大的计算能力，进一步拓展其应用边界。🍃个人对人工智能技术应用前景的看法和观点作为一名长期关注并从事人工智能领域工作的专业人士，我深刻感受到AI正以前所未有的速度改变着我们的世界。在我看来，人工智能的未来发展不仅充满机遇，也伴随着挑战。机遇：AI技术的广泛应用，将极大地提升社会生产力，促进产业升级，创造新的就业机会。例如，在制造业中，智能机器人和自动化流程能够减少人力成本，提高生产效率；在服务业，AI客服、智能推荐系统等则能提升用户体验，增加企业竞争力。挑战与应对：然而，AI的发展也带来了就业结构变化、隐私保护、伦理道德等问题。为了应对这些挑战，我们需要采取积极措施。首先，加强教育与培训，帮助劳动力适应新技术环境，提升数字技能，减少技术失业。其次，建立健全法律法规体系，保护个人隐私，确保AI技术的健康发展。最后，推动跨学科研究，尤其是AI伦理学的发展，确保技术进步的同时，不损害人类的根本利益。案例佐证：以自动驾驶汽车为例，这一技术虽然有望极大改善交通效率，减少交通事故，但也引发了关于责任归属、道德决策等方面的讨论。因此，谷歌、特斯拉等企业在推进自动驾驶技术的同时，也在积极与学术界合作，探索AI伦理框架，确保技术的安全性与道德性。结语人工智能的未来是光明且充满挑战的。作为社会的一员，我们应当积极拥抱变化，同时理性思考，通过合理的政策引导、技术创新与社会教育，共同塑造一个既高效又和谐的人工智能时代。http://www.ppmy.cn/news/1541006.html相关文章jmeter中用csv data set config做参数化2在jmeter中&amp;#xff0c;使用csv data set config进行参数化是很重要的一个功能&amp;#xff0c;但是这个功能的使用需要十分仔细和小心&amp;#xff0c;因为细节之处往往决定着结果的正确与否。 
举例&amp;#xff1a; 
一个登录接口用加密密码登录&amp;#xff0c;一个登录接口用原始密码登录。…阅读更多...Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:28 +0000</pubDate>
    </item>
    <item>
      <title>jmeter中用csv data set config做参数化2</title>
      <link>https://www.ppmy.cn/news/1541005.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维jmeter中用csv data set config做参数化2news/2025/11/1 0:24:27/在jmeter中，使用csv data set config进行参数化是很重要的一个功能，但是这个功能的使用需要十分仔细和小心，因为细节之处往往决定着结果的正确与否。举例：一个登录接口用加密密码登录，一个登录接口用原始密码登录。分别设置3个不同的异常场景：1.用户名不存在 2.填写用户名，不填密码 3.不填用户名，填写密码2个接口的测试用例放在一个csv文件中。这里有个小tip: 默认csv文件是用,分隔，如果用xls表格来存储数据，对于有中文内容的测试数据，需要先通过txt记事本转换成utf-8bom编码格式【具体做法看另一篇】，然后再保存为csv文件，它会自动用逗号来分隔各个数据列，不需要逐行的添加逗号。这个非常重要。注意这里的测试数据，断言部分中因有逗号，之前是在数据前加单引号，现在不用加，也可以，只要allow quoted data设为True.【这个有点小疑惑吧，有的时候竟然不要加。】接下来，运行脚本，看结果。结果报错了，不仔细看根本看不出问题。其实是等于1后的逗号，测试数据里给错了，给的是中文的逗号，但实际上返回的结果里是英文的逗号，就是这么个细小的地方就导致了断言失败。给他改过来，再重新运行一次。这回脚本全部运行成功。说下，这个脚本里用到参数化的地方，即测试数据里的各个字段，都应用到接口脚本的参数化中了。看图。这里传参需要加密，都可以在测试数据的参数上直接运用函数，非常好用。又思考了下，为了方便统一管理测试数据的参数化，对于需要使用加密函数的接口和不需要加密的接口用一个http请求去做参数化，能不能行？即如果把函数写在测试数据上，能不能生效？事实证明，经过试验，不可行。看请求信息，加密函数在测试数据中，然后再调用过来，没法生效，反而报错。正确的加密函数传参时是这样的：所以，如果http请求中使用的参数化的参数不一致，还是得分不同情况来做参数化。如果每个接口使用的参数化不一样，那么就得用不同的线程组来完成参数化。总结：使用csv data set config做参数化，细节把控非常重要，一个标点符号就能让测试结果发生错误。http://www.ppmy.cn/news/1541005.html相关文章Java--集合（三）之vectorlinkedlisthashset结构文章目录 0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式 3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解 0.架构图 1.vector解析 和之前介…阅读更多...稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:27 +0000</pubDate>
    </item>
    <item>
      <title>Java--集合（三）之vectorlinkedlisthashset结构</title>
      <link>https://www.ppmy.cn/news/1541004.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java--集合（三）之vectorlinkedlisthashset结构news/2025/11/1 0:24:25/文章目录0.架构图1.vector解析2.LinkedList分析2.1源码分析2.2迭代器遍历的三种方式3.set接口的使用方法3.1基本使用说明3.2基本遍历方式3.3HashSet引入3.4数组链表模拟3.5hashset扩容机制3.6hashset源码解读3.7扩容*转成红黑树机制**我的理解0.架构图1.vector解析和之前介绍的这个ArrayList相比，这个vector属于线程安全操作，他的这个基本的使用和我们的这个Arraylist没有太大的区别，但是这个扩容机制和我们的这个Arraylist不太一样；在默认的情况下，我们的这个空间容量的大小就是10，然后会按照2倍扩容，这个就是和Arraylist的一个区别，因此下面的这个add，前面的10个数据是不会进行扩容的，只有后面的add(10)才会进行这个扩容的操作；我们可以自己去进行debug调试，这个方法就是我们的s是一个默认的参数，当我们的数据长度小于这个数据的时候根本就不会进行grow里面去进行扩容，当我们的这个循环结束的时候，已经是插入10个数据，这个时候两个是相等的，才会调用这个grow方法；在我们的这个grow方法里面，这个capacityIncrement小于0，对于这个三木而言，就是后面的这个oldcapacity作为结果操作，所以会进行这个二倍扩容，newcapacity就是10*2==20；2.LinkedList分析linkedlist的本质上就是一个双向的链表；2.1源码分析我们以添加节点和删除节点为例进行源码的分析：首先我们创建这个lineedlist的时候就是进行的初始化的工作，这个时候双向链表里面是没有节点的，因此这个时候的size=0,然后去创建第一个节点;添加第一个节点的时候，可以看到这个首先还是进行的这个装箱的过程，把这个基本的数据类型转换为我们的常用类integer；下面的这个是进行的第一次数据的插入过程：因为这个时候双向链表就是空的，所以这个时候我们的last,first都是指向的这个604地址空间位置；当我们插入第二个数据的时候，这个first指向的还是第一个位置的节点，但是这个last已经指向了新的节点，这个地址也是进行了更新：615；但是我们的这个l还是指向的第一个节点地址位置；接下来再次进行数据的插入，这个时候我们的lat再次进行更新，这个l指向的还是我们的最后一个节点的前面的一个位置的地址；下面的这个是进行的remove方法的调用，这个时候就是删除我们的这个链表里面的第一个节点，使用的是这个unlinkFirst方法实现的；这个方法里面，叫这个f的数值变为null,指向的下一个节点也是空的，这个时候这个节点就会被作为垃圾回收掉，这个时候我们的第二个数据就是头结点，因此这个first指向了原来的609地址位置；2.2迭代器遍历的三种方式下面的这个就是我们的循环双向链表支持的三个遍历的方式，linkedlist.get(i)表示拿出来这个双向链表里面的第i个下标位置的节点数值；3.set接口的使用方法3.1基本使用说明set接口实现类创建的实例化对象，即这个接口对象（实现这个接口的类的对象）：1.添加元素不可以是重复的；2.没有顺序的：添加顺序和取出来的这个顺序不是一样的；3.可以添加空值null；4.取出来这个顺序虽然不是添加时候的这个顺序，但是这个取出来的顺序是固定的，不会每一次都发生变化；set接口是collection的子接口，因此这个迭代器遍历set也是可以使用的：3.2基本遍历方式这个就是我们的迭代器遍历和增强for循环两个方式进行遍历；但是不支持这个普通的索引，因为这个里面是没有get方法的，没有办法根据下标进行数据的查找；3.3HashSet引入我们创建这个的时候实际上这个底层走的还是我们的hashmap这个东东；hashset可以存放null值，但是元素不可以重复;我们下面的算是对于这个hashset入门的一个demo案例，这个案例需要用到下面的这个类：我们在这个类里面实现了这个构造器和toString方法；我们创建一个hashset对象，向这个里面去插入数据，因为这个结构式不允许重复的，所以我们第二次插入的这个lucy是不会插入成功的；但是我们的new Dog两次的这个名字是一样的，可以理解为这个堆上面开辟了不同的空间，但是两个引用指向的是相同的内容，所以两次添加这个new的dog对象是可以成功的；接下来我们new两个同名的string对象，这个时候的第二个是不会插入成功的，为什么？需要后续学习之后方可解答~~3.4数组链表模拟hashset的底层是hashmap,hashmap的底层是数组+链表+红黑树；下面的这个就是数组链表的一个模拟情况，就是这个数组里面的每一个元素都是一个链表的头节点（我在这个上面没有完全显示）；下面的先添加这个john对象，然后添加jack对象，继续添加rose对象，每一个数组元素都是有自己的一个链表的，这个就是我们后面分析源码可能会用到的数组链表结构；首先需要定义一个node的类，这个里面成员就是我们的结点的数值和下一个节点内容；然后就是创建对象的过程，我们把这个john放到这个里面的2下标的位置，然后剩下的添加的元素都和这个john组成链表，这个只是为了说明问题，实际上添加的时候是进行这个这个hash的索引分配；运行结束之后，我们就可以看到这个2位置对应的已经形成了一个链表，这个链表里面已经有了我们插入的三个元素；3.5hashset扩容机制1.首先hash值，这个就是一个数字；2.通过对于这个哈希值的运算，得到一个下标，这个下标就是我们要添加这个数组元素的链表位置，例如我们运算之后得到的是3，就会在这个数组3下标的链表上进行元素的添加；3.如果这个位置上面没有其他的元素，就会直接放到这个位置上面去，如果有元素，使用这个equals进行判断，这个equals并不是简单的比较两个数据的内容，因为这个方法我们是可以进行重写的；4.比较这个equals之后，如果相等，就不会进行添加，否则就会尾插到这个链表的后面；3.6hashset源码解读table就是一个属性，刚开始这个table就是null,这个时候会进入这个resize方法里面去，这个就是进行的扩容的操作；我们扩容的这个大小就是16，但是这个16是我们的数组的大小，每一个数组元素对应的这个链表多少个节点现在是不确定的（后面会说到，默认是8个大小）；这个时候我们发现这个对象已经插入到了这个13位置，我们上面的是我们自己设置的插入到2下标的位置，这个是自己通过计算匹配之后插入到的这个13位置的；例如我们想要进行这个数据的插入，匹配到了这个2下标的位置，这个时候通过和这个johu,jack,rose一个一个的进行比对，如果出现了这个equals一样的情况，这个就会进行break操作，否则就会把这个数据添加到我们的这个链表的3位置，这个就是添加的过程；3.7扩容*转成红黑树机制**我的理解1.上面介绍到了这个默认开辟的数组大小是16，实际上这个12就是临界（0.75倍的关系，0.75叫做加载因子），就是当我们的这个数组里面的12个位置都被占用的时候，我们就会考虑扩容，因为害怕剩下的4个大小不够使用，这个是第一点；2.接下来就会进行2倍扩容，例如从16扩到32，这个时候的临界还是0.75倍，即32*0.75=24，也就是说这个达到24之后又会考虑进行扩容操作；3.链表达到8个之后，这个就会考虑进行树化操作，即把这个数组链表转换为这个红黑树的结构，但是这个前提条件是我们的这个数组已经大于64，因为可能是因为这个数组不够长，我们首先会对于这个数组进行扩容；4.如果这个数组元素足够多，数组足够长，而且这个链表的节点已经大于8个，这个时候才会进行这个红黑树的转换（通过调用这个红黑树的相关的算法）；5.这个链表也不是达到8一定会树化，这个8不是确定的，可能是大于8才会树化，可能是9，可能是10，这个8是一个默认值，不是确定数值；6.底层源码里面的这个size++并不仅仅是我们的数组元素增加的时候才会size++,我们的这个数组元素对应的这个链表上面的这个node节点增加的时候我，我们也会进行这个size++的操作；7.上面说的这个第六点主要是为了说明什么问题？就是我们的这个这个最开始数组不是16个大小吗，就是达到12的时候就会触发扩容，但是这个12并不是12个数组元素，可能会是说这个数组只有两个元素，但是这个链表上面有10个节点，这个时候就是size=12,我们接下来插入数据（无论是节点还是数组元素），都会触发扩容操作，也就是说，即使我们的数组大量是空的，但是我们的这个链表上面的节点足够多，这个也是会出触发我们的这个数组的扩容；8.首先，我们进行这个数据的添加的时候首先会比较这个hash值，如果哈希值不一样，说明这个下标索引就不一样，这个时候肯定会放进去，这个时候不会进行这个equals操作，当我们的这个hash值一样的时候，说明我们会插入到一个链表上面去，这个时候才会调用这个equals方法；9.new对象的时候，hash值很难是一样的，但是我们可以重写这个hasncode方法，让他们的属性相同的时候，就会拥有一样的hash值；如果哈希值不一样，说明这个下标索引就不一样，这个时候肯定会放进去，这个时候不会进行这个equals操作，当我们的这个hash值一样的时候，说明我们会插入到一个链表上面去，这个时候才会调用这个equals方法；9.new对象的时候，hash值很难是一样的，但是我们可以重写这个hasncode方法，让他们的属性相同的时候，就会拥有一样的hash值；http://www.ppmy.cn/news/1541004.html相关文章稀疏表示的图像修复、图像退化、白噪声图像分解&amp;#xff1a;图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解&amp;#xff0c;再将重建技术用于两部分稀疏表示的恢复。  稀疏编码&amp;#xff1a;图像或其分解的部分通过一个过完备字典进行稀疏编码&amp;#xff0c;这意味着图像可…阅读更多...Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:26 +0000</pubDate>
    </item>
    <item>
      <title>稀疏表示的图像修复、图像退化、白噪声</title>
      <link>https://www.ppmy.cn/news/1541003.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维稀疏表示的图像修复、图像退化、白噪声news/2025/11/1 0:24:25/图像分解：图像被分解为结构和纹理两个部分。这种方法通常使用两种特性不同的过完备字典对图像进行稀疏分解，再将重建技术用于两部分稀疏表示的恢复。稀疏编码：图像或其分解的部分通过一个过完备字典进行稀疏编码，这意味着图像可以表示为字典中少数几个原子的线性组合。这个过程可以通过匹配追踪算法等稀疏编码技术实现。字典学习：在稀疏表示中，字典的学习和选择是关键步骤。字典可以是预先定义的，也可以通过学习从数据中获得。学习型字典可以更好地适应数据特性，提高修复质量。轮廓匹配和修复：对于物体缺失区域较大且具有复杂结构和纹理的情况，现有的方法可能无法有效修复。一种改进的方法是通过轮廓匹配找到相似物体图像作为参考图，然后利用参考物体轮廓的稀疏表示来修复待修复物体的轮廓。纹理修复：在轮廓修复之后，对图像的非轮廓线部分进行纹理修复。这通常涉及到在已知区域和缺失区域之间匹配相似的纹理块，并将它们复制到缺失区域。参考物体变形：为了提高参考物体轮廓与待修复物体轮廓的相似度，可以对参考物体进行局部变形，以提高轮廓匹配的准确性。图像平滑和修复优先级计算：在纹理修复中，使用图像平滑处理来提取图像结构，减少纹理中幅值较大的梯度对计算修复顺序的影响。深度学习的应用：近年来，深度学习方法也被应用于图像修复中。这些方法通过学习整个图像的上下文图像特征，在修复区域周围内容的约束下生成待修复区域的内容。性能评估：使用PSNR（峰值信噪比）和SSIM（结构相似性指数）等指标来衡量恢复图像的质量，并评估模型的优化程度。这些步骤共同构成了稀疏表示的图像修复过程，目的是在保留图像主要特征的同时，修复或填充图像中的缺失或损坏部分。通过这种方式，即使是大规模图像缺失的复杂结构和纹理也能获得较好的修复效果图像退化是指在图像的获取、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的不完善，导致图像质量下降的现象。这通常表现为图像的模糊、失真和噪声等。图像退化的原因可能包括：成像系统的像差、畸变、带宽有限等造成的图像失真。成像器件拍摄姿态和扫描非线性引起的图像几何失真。运动模糊，如成像传感器与被拍摄景物之间的相对运动。灰度失真，如光学系统或成像传感器本身特性不均匀。辐射失真，如大气湍流效应、大气成分变化等。图像在成像、数字化、采集和处理过程中引入的噪声等。图像退化的过程可以被模型化为一个退化函数和一个加性噪声项。如果输入图像为f(x,y)，退化系统为 H(x,y)，噪声为n(x,y)，那么退化后的图像 g(x,y) 可以通过以下关系表达：g(x,y)=H(x,y)⋆f(x,y)+n(x,y)其中 ⋆表示卷积操作。在实际应用中，往往假设噪声是白噪声，即它的频谱密度为常数，并且与图像不相关。如果退化系统是线性和空间不变的，那么在空域中的退化模型可以表示为上述卷积形式，在频域中可以表示为：G(u,v)=H(u,v)F(u,v)+N(u,v)其中，G(u,v)、F(u,v)、N(u,v) 分别是退化图像 g(x,y)、原图像 f(x,y)、噪声信号 n(x,y) 的傅立叶变换；H(u,v)是系统的点冲击响应函数 h(x,y) 的傅立叶变换，称为系统在频率域上的传递函数。退化模型主要有非线性退化、模糊退化、运动退化和随机噪声退化等。图像退化的数学模型通常假设为线性系统和空间不变系统，这样的系统具有线性、相加性、一致性和位置（空间）不变性等性质。图像退化的过程是图像复原的逆过程，图像复原技术的目的是通过指定的图像退化模型来恢复原始的、未经过退化的图像，以提升图像的视觉质量白噪声是一种理想化的随机信号，其频谱密度在整个频率范围内都是恒定的。在图像处理领域，白噪声通常是指一种统计性质的噪声，它具有以下特点：功率谱密度恒定：在所有频率上都具有相同的功率，即其频谱是平坦的。独立性：白噪声的各个分量之间相互独立，即一个像素的噪声值不影响其邻近像素的噪声值。零均值：白噪声的期望值通常为零，这意味着它在图像中添加的噪声不会改变图像的平均亮度。高斯分布：在实际应用中，白噪声常常假设遵循高斯（正态）分布，其概率密度函数呈钟形曲线，均值为零，方差为常数。不相关性：白噪声的值在不同时间或不同位置是不相关的，即前一个信号的值不会影响后一个信号的值。在图像中，白噪声表现为图像上的随机亮点或暗点，这些点随机分布，没有明显的模式或结构。白噪声可以通过多种方式添加到图像中，例如在图像数字化、传输或处理过程中引入。白噪声对图像的影响包括：降低图像质量，增加视觉噪声。掩盖图像细节，降低图像的分辨率。影响图像处理算法的性能，如边缘检测、特征提取等。为了减少白噪声对图像的影响，可以采用多种图像处理技术，如滤波。常见的滤波方法包括：空间滤波：例如均值滤波器、中值滤波器和高斯滤波器等。频域滤波：例如低通滤波器，可以减少高频噪声成分。在实际应用中，由于白噪声的随机性，完全去除白噪声而不损害图像细节是非常困难的。因此，滤波处理通常旨在在保持图像细节的同时减少噪声的影响。http://www.ppmy.cn/news/1541003.html相关文章Python学习---高效字符串处理技巧一、字符串拼接 
1.1 使用  运算符 
str1  "Hello"
str2  "World"
result  str1  " "  str2
print(result)  # 输出&amp;#xff1a;Hello World 
1.2 使用 join() 方法 
join() 方法可以有效地连接多个字符串&amp;#xff0c;尤其是在连接列表或其他可迭…阅读更多...29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:25 +0000</pubDate>
    </item>
    <item>
      <title>Python学习---高效字符串处理技巧</title>
      <link>https://www.ppmy.cn/news/1541002.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python学习---高效字符串处理技巧news/2025/11/1 0:24:23/一、字符串拼接1.1 使用 + 运算符str1 = "Hello"
str2 = "World"
result = str1 + " " + str2
print(result)  # 输出：Hello World1.2 使用 join() 方法join()方法可以有效地连接多个字符串，尤其是在连接列表或其他可迭代对象时，非常高效。words = ["Hello", "World"]
result = " ".join(words)
print(result)  # 输出：Hello World1.3 使用 f-strings (格式化字符串)name = "Alice"
age = 30
result = f"My name is {name} and I am {age} years old."
print(result)  # 输出：My name is Alice and I am 30 years old.二、字符串分割2.1 使用 split() 方法split()方法根据指定的分隔符将字符串分割为列表。sentence = "Python is awesome"
words = sentence.split()
print(words)  # 输出：['Python', 'is', 'awesome']2.2 使用正则表达式进行分割可以使用re模块的split()方法，支持更复杂的分割逻辑。import resentence = "Python,is,awesome"
words = re.split(',| ', sentence)
print(words)  # 输出：['Python', 'is', 'awesome']三、去除空白字符strip()方法可以去除字符串头尾的空白字符；lstrip()方法去除左侧的空白字符；rstrip()方法去除右侧的空白字符。text = "  Hello World  "
clean_text = text.strip()
print(f"'{clean_text}'")  # 输出：'Hello World'left_clean_text = text.lstrip()
right_clean_text = text.rstrip()
print(f"'{left_clean_text}', '{right_clean_text}'") 
# 输出：'Hello World  ', '  Hello World'四、字符串查找、替换4.1 查找使用 in 关键字、find()、rfind()方法in关键字：查看子字符串是否存在于字符串中；find()方法返回子字符串的第一个出现位置，找不到则返回-1；rfind()则是从右侧开始查找。sentence = "Python is awesome"
result = "Python" in sentence
print(result)  # 输出：Truesentence = "Python is awesome. Python is dynamic."
first_occurrence = sentence.find("Python")
last_occurrence = sentence.rfind("Python")
print(first_occurrence, last_occurrence)  # 输出：0 194.2 替换replace() 方法：将字符串中的某部分内容替换为新的内容，也可以删除特定部分；正则表达式进行替换：复杂替换，可以使用re模块的sub()方法# replace
text = "Hello World"
new_text = text.replace("World", "Python")
print(new_text)  # 输出：Hello Python# 正则表达式
import re
text = "Hello 123 World 456"
new_text = re.sub(r'\d+', '', text)
print(new_text)  # 输出：Hello  Worldhttp://www.ppmy.cn/news/1541002.html相关文章29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）免责声明&amp;#xff1a;内容仅供学习参考&amp;#xff0c;请合法利用知识&amp;#xff0c;禁止进行违法犯罪活动&amp;#xff01; 
本次游戏没法给 
内容参考于&amp;#xff1a;微尘网络安全 
本人写的内容纯属胡编乱造&amp;#xff0c;全都是合成造假&amp;#xff0c;仅仅只是为了娱乐&amp;#xff0c;请不要…阅读更多...【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:24 +0000</pubDate>
    </item>
    <item>
      <title>29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）</title>
      <link>https://www.ppmy.cn/news/1541001.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维29.第二阶段x86游戏实战2-遍历周围-花指令与二叉树数据结构（有如何阅读vm代码混淆代码）news/2025/11/1 0:24:22/免责声明：内容仅供学习参考，请合法利用知识，禁止进行违法犯罪活动！本次游戏没法给内容参考于：微尘网络安全本人写的内容纯属胡编乱造，全都是合成造假，仅仅只是为了娱乐，请不要盲目相信。工具下载：链接：https://pan.baidu.com/s/1rEEJnt85npn7N38Ai0_F2Q?pwd=6tw3提取码：6tw3复制这段内容后打开百度网盘手机App，操作更方便哦上一个内容：28.第二阶段x86游戏实战2-遍历周围-通过附近NPC怪物血量的方式（初识vm代码）上一个内容里写了通过打附近怪物找基址，最终到了一个看着像乱码的地方，代码被进行了vm（现在理解为代码混淆，用来让逆向人员无法正常分析），本次就开始写如何看这种被混淆的代码首先来到下图位置，也就是上一个内容中通过打附近怪物追来的地方然后给上图红框位置打断点，然后取消断点按CTRL+F9来到下图位置，也就是被混淆代码的位置，这种代码被称为花指令然后可以看到下图红框，它们的内容是三个问号，这里可以把问号当成开始混淆代码的标记然后关键点来了，混淆代码只是静态看着混淆，通过断点是可以看到正常的代码的，在下图红框位置打断点，也就是问号的前一行断点住之后取消断点，然后按F8通过F8执行了问号之后，会发现代码正常了，如下图红框，正常了之后不能使用鼠标滚轮上下翻不然还会乱，正常了就可以分析代码了现在回顾一下上一个内容里得到的公式，[ecx+0x10]+0x8 是血量，然后现在找ecx的值，通过恢复的混淆代码可以看出ecx的值来自于esi，所以接下来再找esi往上翻了很久发现了esi，如下图通过断点确定了它会执行，现在的公式[[ebx+0x148]+0x10]+0x8，然后再找ebx的值哪来的如下图ebx的值来自于eax，如下图红框，给ebx赋值之前有一个call，所以eax的值来自于这个call的返回值，所以接下来需要进入call dword ptr[eax+0x48]里面在下图红框位置打断点它的参数好像是一个序号，然后取消断点按F7进入函数然后会来到下图位置，通过下图红框可以得出这里是个循环，因为它把代码往上进行了跳转执行，这里应该就是遍历附近怪物的算法了，接下来开始更细致的分析分析的代码通过分析代码发现这里是二叉树的数据结构，所以接下来要介绍一下二叉树数据结构，首先现在有如下图1-30个数据，这30个数据（注意是30个数据不是30个数字，数据可以是内存地址、数字、文字等）使用二叉树常用存放法如下图30个数据使用二叉树数据结构时存放的样子，数字的顺序放在什么位置是基于实现的算法来的，所以有些顺序会跟下图不一样，它也可能是无序的，一般高性能二叉树都会从小到大的顺序来存放数据（这里的高性能是指查询快插入慢）现在假设要找第30个数据使用常规数据，也就是下图样子的方式来存放数据，那就会从1到30挨个对比要找30次才能找到第30个数据（别说从后往前找）如果使用二叉树来找第30个数据，如下图只需要查询7次就可以找到第30个数据，如果要是上千上万的数据二叉树查询快的特性就会体现的很明显，下方的排序方式还只是一个简单是用脑子算出来的，如果真正要用的二叉树排序会比下图中的更合理，可能会达到三四次就能找到，然后现在带入代码带入代码，如下图，这个函数有一个入参（或者说二叉树的序号），这个算法就是根据入参去二叉树里找一个数据，它用来确定找没找的条件是判断eax+0xD位置是不是非0，不是通过入参判断，下图里第一个数据标的有问题，第一个数据应该是下方的mov eax,dword ptr[esi+0x4]这一行才对然后看它的返回值，如下图它有两个retn，所以现在的公式 [[[eax+0x14]+0x148]+0x10]+0x8然后eax的值最终来自于esi+0x4，现在的公式[[[[esi+0x4]+0x14]+0x148]+0x10]+0x8，然后再找esi的值esi的值来自于ecx+0x54，现在的公式[[[[[ecx+0x54]+0x4]+0x14]+0x148]+0x10]+0x8，然后接下来返回到上一层继续找ecx的值来源然后ecx来自于0xCEEFA4，现在的公式[[[[[[0xCEEFA4]+0x54]+0x4]+0x14]+0x148]+0x10]+0x8通过公式测试，3F800000就是1.0使用浮点数的方式显示内存1.000000这意思是附近某npc是满血的然后现在找一下基址，现在模块基址是0x750000代码的位置0x9E0A12，0x9E0A12-0x7500000x290A12然后是附近npc列表的偏移，0x59EFA4http://www.ppmy.cn/news/1541001.html相关文章【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】 
2.3.6 变量分布可视化 
2.3.6.1 单一变量分布可视化 
对于 pandas.core.series.Series 类型的变量&amp;#xff1a; index&amp;#xff1a;含义&amp;#xff1a;它表示 Series 对象的索引&amp;#xff0c;也就是每个数据点对…阅读更多...百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:22 +0000</pubDate>
    </item>
    <item>
      <title>【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】</title>
      <link>https://www.ppmy.cn/news/1541000.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.6】news/2025/11/1 0:24:21/【天池比赛】【零基础入门金融风控 Task2赛题理解】【2.3.1-2.3.5】2.3.6 变量分布可视化2.3.6.1 单一变量分布可视化对于pandas.core.series.Series类型的变量：index：含义：它表示Series对象的索引，也就是每个数据点对应的标签。索引可以是整数、字符串、日期时间等各种类型。.values：含义：它返回一个numpy.ndarray对象，包含了Series中的数据值。palette参数为一个包含颜色代码的列表，为每个柱子分配了不同的颜色。你可以根据自己的喜好调整颜色代码palette = ['#FF69B4', '#87CEFA', '#FFD700', '#98FB98', '#FFA07A', '#DA70D6', '#6A5ACD', '#2E8B57']
plt.figure(figsize=(8, 8))
sns.barplot(y=data_train["employmentLength"].value_counts(dropna=False)[:20].index,x=data_train["employmentLength"].value_counts(dropna=False)[:20].values,palette=palette)
plt.show()运行结果：http://www.ppmy.cn/news/1541000.html相关文章百度智能云千帆 ModelBuilder 大模型服务及开发解读本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。 
更多大会演讲内容&amp;#xff0c;请访问&amp;#xff1a; 
https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html 最近大模型产业应用圈子里有一句非常流行的话&amp;#xff0c;叫做度日如年。不是说这件…阅读更多...08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:21 +0000</pubDate>
    </item>
    <item>
      <title>百度智能云千帆 ModelBuilder 大模型服务及开发解读</title>
      <link>https://www.ppmy.cn/news/1540999.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维百度智能云千帆 ModelBuilder 大模型服务及开发解读news/2025/11/1 0:24:20/本文整理自百度云智峰会 2024 —— 大模型平台技术实践论坛的同名演讲。更多大会演讲内容，请访问：https://cloud.baidu.com/summit/AIcloudsummit_2024/index.html最近大模型产业应用圈子里有一句非常流行的话，叫做度日如年。不是说这件事情非常难做，而是非常有趣，每天有新的应用，新的场景，新的用户加入到这个行业里面来，让我们感到非常兴奋。今天我要介绍的是 ModelBuilder 如何应用在产业和业务实践中。自从去年 3 月 27 号千帆大模型平台上线以来，我们已经服务了 10 万 + 的用户，接触 1 万多个场景，我亲自参与做了一千多个场景，在企业应用中有非常多关键点，包括场景应用的效果。首先，现在大模型的应用不仅仅是看他刷榜刷多少分，而是真正在行业应用里面它的表现怎么样，它的效果怎么样；这里指的就是大模型的可塑性，遇到了 badcase 能不能快速解决；以及能不能根据用户的反馈持续迭代模型。模型迭代到底效果好不好、它听不听话，能不能经过很好的 SFT...这就依赖大模型和传统模型结合的基座模型能力，以及非常好用的精调工具链。第二点推理服务性能。当一个模型真正好用，上线以后，调用量是非常大的，模型越好用，他的业务调用量越大，调用量越大对资源消耗越大。有一个统计说一个真正严肃的应用，在场景里面对资源的消耗达到整个资源消耗的 80% 甚至到 90%，这种模型的性能，它的时延和吞吐非常重要。所以一个模型好不好，不仅仅是说效果怎么样，可塑性怎么样，还有在应用的时候对成本控制，他的性能是不是也能满足应用需求。第三点稳定性和安全性。一个真正严肃的服务，应该在线上能够经得住考验，能够经历停电、地震等不可控的因素，还能够在各种苛刻的条件下稳定地运行。今天会从这三个角度介绍千帆大模型 ModelBuilder 怎么提供相应服务。百度智能云千帆 3.0 正式发布，提供面向生产力场景的企业级服务。升级后的千帆 3.0 为大家提供了一整套的从模型开发到模型服务再到应用开发的全流程工具，其中模型开发和模型服务聚焦到产品上就是百度智能云千帆 ModelBuilder。我们把目光聚焦到 ModelBuilder 产品全景图。对于一个大模型的产业应用来说，如果抛开模型开发，只谈模型服务，将是一个没有灵魂的应用。为什么这么说呢？我们可以举个例子。比如电信反诈场景，这些犯罪分子都是非常狡猾的，我们今天更新策略，犯罪分子明天就能想出其他的策略，所以我们需要不断的根据线上反馈，优化和迭代我们的模型，做到魔高一尺道高一丈。我们再想一想，如果应用是基于非常好的模型去做的，也达到很好的效果，但是你的竞争对手也可以用这样的 API 调用，你的差异化价值是什么？不管是 B 端还是 C 端的应用，差异化的价值是我们对于场景的理解。在这些场景上数据的积累将会变成知识，通过平台的方式内化到模型里面，使得我们场景应用能够非常好的满足用户和企业提效的需求，这是模型开发的重要价值和意义。此外，我们提供了非常多的模型。大家会问为什么我们需要那么多模型，有一个旗舰模型不就解决我所有问题吗？大家想一想，旗舰模型虽然效果好，但是他的性能，他的推理速度可能没有小参数模型快，在有些场景上不一定适用。在真正产业应用的时候，通过大模型和传统模型的结合，能够真正满足产业应用中复杂的场景。除此之外我们提供语音和视觉全系列的模型，还有非常优秀的开源模型，通过这些模型组合，再通过模型开发，使得大模型产业应用真正为我们的客户带来更多价值。下面我们来看一下每一层到底做什么事。模型服务层提供了丰富的大模型，我们可以从左到右来为大家做简要介绍。旗舰大模型是效果最好、性能最优的大模型，适用于通用复杂场景、高级分析与规划。在旗舰大模型上我们提供了重要的升级，包括了ERNIE 4.0 Turbo，相对于原来的 ERNIE 4.0，在大多数的通用场景上效果更好，速度更快，也是我们现在用的最多的旗舰型模型。在主力模型上，我们在原先的 ERNIE Speed 和 ERNIE Lite 上做了升级。经过半年多的时间，根据线上用户的反馈，基于对场景的理解加入了更多的数据，更新算法，我们推出了  ERNIE Speed Pro 和 ERNIE Lite Pro，更常适合于精调，非常适合于行业应用。轻量级模型 ERNIE Tiny，适用于特定场景自然语言到指令调用、边缘设备推理场景。除此之外，我们提供了大量的垂直场景大模型，用于一些非常垂直的，对效果和性能要求非常高的场景，比如说用于角色扮演的 ERNIE Character 模型，用于函数调用 ERNIE Functions 模型，用于小说生成电影场景的 ERNIE Novel 模型。这些模型在特定场景，能够发挥比通用模型更好的效果。同时，我们还提供了语音和视觉系列的模型，通过不同的模型组合，帮助我们更好地在不同领域落地大模型产业应用。在语音和视觉相关的模型上，提供了人脸、OCR、语音、语义、图像等基础的 API，在此基础上还提供了一些适用于特定场景应用平台，比如智能文档分析平台等。人类大多数情况下不是通过文字，而是通过语音进行交流，所以一个好的语音识别接口能够帮助我们通过大模型，使人类和机器、人类和事物之间做更好地交流。语音合成大模型提供三类重要的功能：第一类叫超自然的音色合成。传统的语音合成能够实现播音员的效果。但是，只有播音员效果是无法满足各类场景需要的，不同的场景需要不同的语音的风格去做适配，使得整个过程更自然和更真实。第二类是多角色多情感的合成，特别适合于小说、短剧的语音。第三类是个性化声音复刻，只需要五分钟的时间可以高保真还原每一个人的声音。此外，我们对应用平台系统做了全新升级。以智能文档处理为例，我们提供了基于大模型智能文档处理的助手，可以支持文档解析、文档抽取、文档查询比对等非常多的功能，尤其对于文档抽取和审查做了非常多的优化，比如文档抽取支持 16 种文档格式，达到 90% + 的识别准确率，并且可以对多模态内容，比如图像文本表格等等做理解。在大模型合同审查这一块，我们支持 20 多种合同类型，能够达到 85%+ 的审查意见的采纳率，对于合同审查的人员大大提升工作效率。讲完模型服务层，再来看一下模型开发层。一个真正好用的平台需要经过实践检验。我们的模型开发层从数据管理、训练模式、开发工具、评估&amp;优化再到预测服务部署，以及大模型周边系统，在百度内部所有产品线中，比如百度地图、百度文库、百度 APP 还有文小言等基于生成式 AI 应用，都是通过这个工具链一点点打磨出来。所以我们这个工具链是久经考验。值得一提的是，我们的工具链支持了文心旗舰大模型的精调。大家知道，对于旗舰模型的精调难度非常大，动辄大几百亿、千亿的参数，一旦出任何问题都会使得整个结果变得不好，所以除了工具链以外，还引入各种优化的措施，来确保大家在使用精调工具的时候获得比较好的效果。整个精调过程中有几个步骤由为重要，只有经过实践才能发现问题。比如对于精调数据来说，很多用户不知道精调数据该怎么准备，如何优化，基于未经优化的原始数据调出来的效果不能达到预期。基于这样的情况，我们发布了数据洞察和分析平台，能够对原始数据做分析和洞察，比如数据分布分析和数据的萃取、样本定向的发掘等。结合清洗算子和各种工具能够对数据做进一步处理，从而获得更好数据的效果，使得模型的训练效果能够达到我们的预期。第二是我们提供了非常丰富的精调能力，我们第一个推出 DPO/KTO 强化学习的功能，让模型达到更好效果。大多数的大模型强化学习都是用的传统 RLHF 的方式，使用难度非常大。相比RLHF，DPO/KTO 使用难度缩小很多，虽然效果上限弱一些，但是整个便捷性、效率会比原来的 RLHF 高很多。因此平台引入这两个强化学习功能，使得开发者可以在平台上享受到强化学习带来效果提升。可以看到经过 DPO 以后，不管是在健康助手、小说角色、生成字数都有大幅度提升。对于初次使用精调用户来说，我们还提供高频场景精调样板间，用来降低场景调优的门槛，比如预制了行业数据集，提供了立竿见影的调参方法，场景效果超过旗舰级模型的能力，效果具备可泛化性。这些样板间覆盖了在线教育、电商、交互助手和社交文娱等，使得高频场景用户能够快速上手达到预期效果。我们的精调工具链在多个场景多个行业得到广泛应用：合作伙伴全诊通，使用我们的精调工具链在医患对话上达到非常好的效果，使得医生可以把精力更多聚焦在患者身上，可以很快把病历生成出来，使得看诊效率大幅度提升。百度电商慧播星使用 SFT 对 ERNIE 4.0 进行精调后，大幅度提升问答优质率，使得电商转换得到大幅度提升。有了好的模型以后，还需要非常好的性能，进行模型压缩和推理加速，极致提升服务性能。千帆 ModelBuilder 提供了非常多压缩功能和推理计算加速的工具链，节约 50% 以上成本的同时，模型吞吐可以提升 3-5 倍。除此之外，在安全性和高可用做了非常多的升级，精调模型推理服务上我们通过虚拟 API 方式，使得大模型在多地域提供服务，保障模型的稳定性。结合模型的续推、监控、报警的机制，提升整个运维工作效率。在内容保障方面，在数据训练服务阶段进行了全方位的防控，来提供更可靠安全保障。同时，支持了自定义干预机制，可针对客户进行个性化干预。在企业私有化部署部署方面进行了升级，一个是百度智能云千帆大模型融合底座，这个底座在私有化环境上实现了大模型和传统模型的统一开发运维。另外一个是百度智能云千帆大模型一体机，使得我们的用户能够快速的开箱即用体验到生成式 AI 能力和相应场景。大模型融合底座，除了提供大模型和传统模型的统一开发运维能力之外，还提供了企业级基础管控，企业级 AI 共享管理平台和模型风险的管理，使得企业在应用和开发大模型过程中能够更好地使用大模型。百度智能云千帆大模型一体机支持昇腾、昆仑芯、天数智芯、英伟达等多种芯片，这个基础上结合飞桨框架和大模型平台 Lite 版，可以做到对硬件无缝的迁移和打通。基于这个一体机企业可以快速地进行应用开发和集成。未来已来，千帆 ModelBuilder 愿意和各位企业和开发者一起探索生成式 AI 产业应用，为用户带来更高效率的更创新的场景和应用一起努力。革新启航，千帆齐扬谢谢大家。http://www.ppmy.cn/news/1540999.html相关文章08_实现 reactive目录 编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符 处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况 浅响应与深响应代理数组…阅读更多...Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:20 +0000</pubDate>
    </item>
    <item>
      <title>08_实现 reactive</title>
      <link>https://www.ppmy.cn/news/1540998.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维08_实现 reactivenews/2025/11/1 0:24:18/目录编写 reactive 的函数签名处理对象的其他行为拦截 in 操作符拦截 for...in 循环delete 操作符处理边界新旧值发生变化时才触发依赖的情况处理从原型上继承属性的情况处理一个对象已经是代理对象的情况处理一个原始对象已经被代理过一次之后的情况浅响应与深响应代理数组数组的索引与 length遍历数组数组的查找方法隐式修改数组长度的原型方法结语编写 reactive 的函数签名前面我们已经实现了一个基础的响应式数据，但是这是一种比较简陋的方法，而且使用起来书写相对繁琐，所以我们先构造一个 reactive 的函数签名，如下：functionget(target,key,receiver){track(target,key)returnReflect.get(target,key,receiver)}functionset(target,key,newVal){target[key]=newValtrigger(target,key)returntrue}functionreactive(value){// 简单做一个基础拦截if(typeofvalue!=='object'||value===null){console.warn('value 必须是一个对象')returnvalue}constproxy=newProxy(value,{get,set})returnproxy}conststate=reactive({name:'zs',age:18})effect(()=&gt;{console.log(`${state.name}今年${state.age}岁了`)})state.age++上述这段代码中，我们将 get 和 set 的逻辑抽离了出去，这样代码会更优雅一点，同时简单的封装了一下 reactive，创建一个可响应的数据也方便一点。处理对象的其他行为这个行为具体的可以查阅文档得知：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#object_internal_methods拦截 in 操作符前面我们处理的只有 get 和 set，也简单的把 get 就看做是读，set 看做是写，而在响应式系统中，读是一个宽泛的概念，比如 in 操作符也是一个读的操作，例如：effect(()=&gt;{'foo'inobj})而这种读的操作，在响应式系统中也应该被拦截，而如果想拦截 in 这个读的操作，就需要使用内部方法 [[HasProperty]]，而这个内部方法在 Proxy 中对应的则是 has，这些在 ECMA 或者 MDN 文档中都可以找到，有兴趣的自行翻阅即可。已经知道了对应的拦截器，那实现也就非常简单了，如下：functionhas(target,key){console.log('in 被拦截了')track(target,key)returnReflect.has(target,key)}functionreactive(value){if(typeofvalue!=='object'||value===null){console.warn('value 必须是一个对象')returnvalue}constproxy=newProxy(value,{get,set,has})returnproxy}conststate=reactive({name:'zs',age:18})effect(()=&gt;{'age'instate})我们来查看一下输出的结果，如图：拦截 for…in 循环for…in 循环对应的内部方法为 [[OwnPropertyKeys]]，对应 Proxy 中的 ownKeys，我们先看一下实现代码，如下：constITERATE_KEY=Symbol('iterate')functionownKeys(target){// 手动构造了一个 key，让其与副作用函数关联track(target,ITERATE_KEY)returnReflect.ownKeys(target)}在这段代码中，与之前不一样的则是，手动的创建一个 key，这是为什么呢？我们设计响应式依赖收集数据结构中，需要一个 key，而 ownKeys 方法确并没有提供 key 的参数，只有 target，为什么不提供 key 呢，合理吗？其实是合理的，因为不同于 get/set 的操作，我们总能精准的知道，当前读取的是对象的那个属性，而 ownKeys 则是用来获取一个对象的所有属于自己的键值，这个操作是没有和任何具体的键值进行绑定，所以不提供 key 是合理的。因此我们如果想复合我们设计的数据结构，只有手动的构造一个 key 来实现依赖的关联。那我们来看看，是否现在可以达到我们预期的效果，代码如下：conststate=reactive({name:'zs',age:18})effect(()=&gt;{for(constkeyinstate){console.log(key)}})state.address='shanghai'这段代码，我们的预期是先输出 name、age，然后添加了一个 address 时，肯定会对 for…in 循环产生印象，那么应该在输出一个 address，我们看一下执行的结果，如图：预期中的 address 并没有出现，这是为什么呢？因为这一部分触发的其实 set，我们给 set 方法添加一句打印，如下：functionset(target,key,newVal){console.log('set: ',key)target[key]=newValtrigger(target,key)returntrue}查看一下运行结果，如图：但是在 set 中触发，key 是 address，这和我们设置的 ITERATE_KEY 是一点关系都没有，所以应该如何触发呢？我们可以尝试给 ITERATE_KEY 单开一个 Set 集合在执行即可，如下：functiontrigger(target,key){letdepsMap=targetMap.get(target)if(!depsMap)returnletdeps=depsMap.get(key)// 取得 ITERATE_KEY 的依赖letiterateDeps=depsMap.get(ITERATE_KEY)consteffetsToRun=newSet()deps&amp;&amp;deps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})// 除了加入当前 key 的依赖，还要加入 ITERATE_KEY 的依赖iterateDeps&amp;&amp;iterateDeps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})effetsToRun.forEach(fn=&gt;{if(fn.options&amp;&amp;fn.options.scheduler){fn.options.scheduler(fn)}else{fn()}})}此时我们写一段测试代码，如下：conststate=reactive({name:'zs',age:18})effect(()=&gt;{for(constkeyinstate){console.log(key)}})console.log('*****添加******')state.address='shanghai'结果如图：但是现在还有一个问题，就是无差别触发，比如我重新修改年龄，那么此时并不会对这个迭代行为产生影响，那么就不应该触发，所以我们需要识别 set 触发时，当前的 key 是新增的还是重新赋值，基于这点我们就可以优化一下代码，如下：functiontrigger(target,key,type){letdepsMap=targetMap.get(target)if(!depsMap)returnletdeps=depsMap.get(key)consteffetsToRun=newSet()deps&amp;&amp;deps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})// 只有添加属性才会触发 ITERATE_KEY 的副作用函数if(type==='ADD'){letiterateDeps=depsMap.get(ITERATE_KEY)iterateDeps&amp;&amp;iterateDeps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})}effetsToRun.forEach(fn=&gt;{if(fn.options&amp;&amp;fn.options.scheduler){fn.options.scheduler(fn)}else{fn()}})}/* ... */functionset(target,key,newVal,receiver){// 根据当前对象有没有这个 key 来区分是新增还是修改consttype=Object.prototype.hasOwnProperty.call(target,key)?'SET':'ADD'constresult=Reflect.set(target,key,newVal,receiver)if(!result)returntrigger(target,key,type)returnresult}/* ... */conststate=reactive({name:'zs',age:18})effect(()=&gt;{for(constkeyinstate){console.log(key)}})console.log('*****修改******')state.age++console.log('*****添加******')state.sex='男'查看一下输出的结果，如图：此时就是符合我们预期的，修改不触发，添加才触发。当然，为了更好的维护，我们通常会将这个维护成一个枚举值，如下：delete 操作符delete 在 Proxy 对应的方法则是 deleteProperty，因此我们在其中书写对应的逻辑即可，如下：functiondeleteProperty(target,key){// 检测属性是否存在consthadKey=Object.prototype.hasOwnProperty.call(target,key)constresult=Reflect.deleteProperty(target,key)// 属性存在和删除成功，则触发依赖if(hadKey&amp;&amp;result){trigger(target,key,TriggerType.DELETE)}returnresult}这里其他的没有特殊的地方，唯有在 trigger 的时候，我们传递了一个类型，这是因为当属性删除的时候，也会印象 for…in 的迭代行为，所以需要这个类型，如下：functiontrigger(target,key,type){letdepsMap=targetMap.get(target)if(!depsMap)returnletdeps=depsMap.get(key)consteffetsToRun=newSet()deps&amp;&amp;deps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})// 添加判断条件if(type===TriggerType.ADD||type===TriggerType.DELETE){letiterateDeps=depsMap.get(ITERATE_KEY)iterateDeps&amp;&amp;iterateDeps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})}effetsToRun.forEach(fn=&gt;{if(fn.options&amp;&amp;fn.options.scheduler){fn.options.scheduler(fn)}else{fn()}})}那么基于修改后的代码我们可以来测试一下，测试1，如下：conststate=reactive({name:'zs',age:18,sex:'男'})effect(()=&gt;{console.log('effect',state.sex)})deletestate.sex结果如图：是达到我们的预期了，在来看看第二个情况，如下：conststate=reactive({name:'zs',age:18,sex:'男'})effect(()=&gt;{for(constkeyinstate){console.log('effect: ',key)}})console.log('************')deletestate.sex结果如图：也是符合我们的预期的，成功触发了 for…in 的迭代行为。处理边界新旧值发生变化时才触发依赖的情况现在我们的只要触发了 set 就会进行依赖的派发，而在正确的逻辑中，如果新旧值不一样，则无需触发，我们写一段代码测试一下，如下：conststate=reactive({name:'zs',age:18,sex:'男'})effect(()=&gt;{console.log('effect:',state.age)})state.age=18测试结果如图：所以我们需要对触发的新旧值进行判断，代码如下：functionset(target,key,newVal,receiver){// 获取旧值constoldVal=target[key]consttype=Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)return// 新旧值不相等，则触发依赖if(oldVal!==newVal){trigger(target,key,type)}returnresult}我们在执行一样的测试代码，如图：现在我们使用的判断是 ===，这个方式是会存在一些问题的，我们看一段测试结果，如下：console.log(NaN===NaN)// falseconsole.log(+0===-0)// trueconsole.log(Object.is(NaN,NaN))// trueconsole.log(Object.is(+0,-0))// false一个值从 NaN 变为 NaN 不会对我们的结果产生影响，所以要看做一样的值，而 +0 和 -0 则会影响，比如在某些数学运算和函数中，+0和-0可能会产生不同的结果。例如，在某些情况下，计算1 / +0和1 / -0会得到正无穷大和负无穷大，所以应该是不一样的，因此这里需要将 === 换成 Object.is 判断，如下：functionset(target,key,newVal,receiver){constoldVal=target[key]consttype=Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)returnif(!Object.is(oldVal,newVal)){trigger(target,key,type)}returnresult}处理从原型上继承属性的情况话不多说，我们看一段测试代码，如下：constobj={}constproto={bar:1}constchild=reactive(obj)constparent=reactive(proto)// 将 parent 作为 child 的原型Object.setPrototypeOf(child,parent)effect(()=&gt;{console.log(child.bar)})child.bar=2执行结果如图：从结果不难发现，修改 bar 的值之后，竟然触发了两次副作用函数，这是为什么呢？让我们顺着代码的执行过程来解析一下。首先我们知道，如果一个对象身上没有某个属性的话，会顺着原型链网上查找，这里 child.bar 实际上是 parent.bar 的值，所以输出的值是1，而这个查找的过程，第一次查找 child 时就会触发 child 的 get 拦截，此时 key 为 bar，我们的 child 时一个响应式数据，就会发生一次依赖的收集；而在 child 上没有找打，则去查找 parent，那么 parent.bar 也是一个读取行为，则也会触发 parent 的 get 拦截，且 parent 也是一个响应式数据，那么也会造成一次依赖的收集，此时就会导致收集的依赖关系如下：child|--bar|--effect
parent|--bar|--effect不过这些还不足以解释为什么会触发两次，那么我们再来看 child.bar = 2 这句代码会发生什么事情。首先设置 bar 的值时候，一定会触发一次 child 的 set 拦截，这里就可以知道次数 +1，哪还有一次从何而来呢？关于这一段，在 ECMA 中可以找到调用内部方法 [[Set]] 时的执行过程，如图：这一段解释的意思大概是，如果设置的属性不存在于对象上的话，则会取得其原型，并调用原型的 [[Set]] 方法，也就是 parent 的 [[Set]] 内部方法吗，而由于 parent 也是一个响应式数据，那么也会也会触发一次 set 拦截，而前面我们也分析了依赖收集的关系，parent 也收集了这个 bar 属性，看到这里就很明显了，这就是第二次执行的由来。知道了问题之后，我们就可以思考如何解决。尽然是两次执行，我们只需要屏蔽掉其中一次即可，而具体屏蔽那一次，肯定是除第一次之后的都屏蔽掉，因为原型只要想，这个链条上可以不止两个。那如何让其只执行第一次呢？这个我们就要把视线回到receiver上，我们来看一下不同时候触发的 set 的拦截里面 receiver 都是那个，我们添加一句打印，如下：functionset(target,key,newVal,receiver){console.log('set-target: ',target)console.log('set-receiver: ',receiver)constoldVal=target[key]consttype=Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)returnif(!Object.is(oldVal,newVal)){trigger(target,key,type)}returnresult}// 为了方便查看打印，添加一个 name 属性表示constobj={name:'obj'}constproto={bar:1,name:'proto'}constchild=reactive(obj)constparent=reactive(proto)Object.setPrototypeOf(child,parent)effect(()=&gt;{console.log(child.bar)})child.bar=2打印结果如图：通过这个打印可以看到，target 第一次是 obj 原始对象，第二次为 proto 原始对象，而反之 receiver 两次都是代理对象 child，因此我们只要添加一个判断条件，当 receiver 这个代理的原始对象等于 target 那么才触发更新，如果不是则表示是原型上的，则不派发。有了这个思路之后，我们的问题就是，如何在代理身上得到代理的原始对象，不幸的是，原生的 proxy 并没有提供这样的属性，但是我们可以自己解决，代码如下：// 获取原始对象时的 keyconstRAW_KEY=Symbol('raw')functionget(target,key,receiver){// 只要 key 为 RAW_KEY，就返回原始对象if(key===RAW_KEY){returntarget}track(target,key)returnReflect.get(target,key,receiver)}有了这个 RAW_KEY 之后，就可以在代理身上拿到其所代理的原始对象，代码如下：functionset(target,key,newVal,receiver){constoldVal=target[key]consttype=Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)return// receiver[RAW_KEY] 表示所代理原始对象，若两者相等则表示 receiver 是 target 的代理对象if(receiver[RAW_KEY]===target){if(!Object.is(oldVal,newVal)){trigger(target,key,type)}}returnresult}/* ... */constobj={}constproto={bar:1}constchild=reactive(obj)constparent=reactive(proto)Object.setPrototypeOf(child,parent)effect(()=&gt;{console.log(child.bar)})console.log('*****修改*****')child.bar=2结果如图：现在触发的次数就正常了。处理一个对象已经是代理对象的情况如果当一个对象已经是代理对象了，那么按照逻辑来说，就应该直接返回这个代理对象，而不需要在做一次代理，而实现这一点也很简单，可以参考设置 RAW_KEY 的方式，如下：// 添加是否是代理对象的标识 keyconstIS_REACTIVE=Symbol('isReactive')functionreactive(value){if(typeofvalue!=='object'||value===null){console.warn('value 必须是一个对象')returnvalue}if()constproxy=newProxy(value,{get,set,has,ownKeys,deleteProperty})// 给完成代理的对象添加一个标识，表示是一个代理对象proxy[IS_REACTIVE]=truereturnproxy}// 判断一个值是否是响应式对象functionisReactive(value){returntypeofvalue==='object'&amp;&amp;value!==null&amp;&amp;!!value[IS_REACTIVE]}/* ... */consto1=reactive({name:'zs'})consto2=reactive(o1)consto3=reactive({name:'zs'})console.log(o1===o2)// trueconsole.log(o1===o3)// falseo1 等于 o2 就表示了不会对本身就是一个代理对象的数据进行二次代理。处理一个原始对象已经被代理过一次之后的情况若一个原始对象 obj 已经被代理过一次之后，再次使用代理的时候，也不应该在进行代理，而是返回之前代理完成的对象，代码如下：// 缓存已经代理过的对象constreactiveMap=newWeakMap()functionreactive(value){if(typeofvalue!=='object'||value===null){console.warn('value 必须是一个对象')returnvalue}// 以 value 为 key，从缓存中取出对应的代理对象，如果有责返回缓存的代理对象，不然进行代理if(reactiveMap.has(value)){returnreactiveMap.get(value)}if(isReactive(value))returnvalueconstproxy=newProxy(value,{get,set,has,ownKeys,deleteProperty})proxy[IS_REACTIVE]=true// 将代理好的对象缓存起来reactiveMap.set(value,proxy)returnproxy}constobj={name:'zs'}constp1=reactive(obj)constp2=reactive(obj)console.log(p1===p2)// truep1 与 p2 相等，则表示没有重复对同一个原始对象进行代理。浅响应与深响应我们来看一段示例代码：constobj={foo:{bar:1}}constp1=reactive(obj)effect(()=&gt;{console.log(p1.foo.bar)})console.log('*****修改******')p1.foo.bar=2再来看一下输出的结果，如图：修改 p1.foo.bar 的值并没有导致副作用函数再次执行，那么就表示目前我们的 reactive 还是一个浅响应的，foo 的值还是一个普通对象，而非代理的响应式对象，因此我们需要给它变成响应式对象。这点我们可以在 get 拦截器中完成，当检测到 Reflect.get 返回的值是一个对象时，那么就再次进行代理，完成递归式的处理，不过我们这个行为是懒的，只要当用到了这个属性才会被深度代理，如下：functionget(target,key,receiver){if(key===RAW_KEY){returntarget}track(target,key)// 得到本次获取的原始值constresult=Reflect.get(target,key,receiver)// 若是一个对象则进行代理，否则直接返回此值if(typeofresult==='object'&amp;&amp;result!==null){returnreactive(result)}returnresult}现在我们在运行上面的例子，查看一下结果，如图：但是并不是是什么时候都需要进行深度响应，此时我们就需要一个方法来完成只进行浅响应，基于这个情况，shallowReactive 应运而生，基于此我们可以将 reactive 函数在做一层封装，将其抽离出来，如下：// 因为是抽离出来的 get，所以如果想拿到 isShallow 的值，就需要在封装一层functionbaseGet(isShallow){returnfunctionget(target,key,receiver){if(key===RAW_KEY){returntarget}track(target,key)constresult=Reflect.get(target,key,receiver)// 如果 isShallow 为 true 表示只需要做到浅响应即可，因此直接返回 result 即可if(isShallow)returnresultif(typeofresult==='object'&amp;&amp;result!==null){returnreactive(result)}returnresult}}// 深响应functionreactive(value){returncreateReactiveObject(value)}// 浅响应functionshallowReactive(value){returncreateReactiveObject(value,true)}// 将逻辑再做一次抽离，放入 createReactiveObject 函数中//  - 使用 isShallow 参数来区分是深响应还是浅响应，默认为 false 表示进行深响应处理functioncreateReactiveObject(value,isShallow=false){if(typeofvalue!=='object'||value===null){console.warn('value 必须是一个对象')returnvalue}if(reactiveMap.has(value)){returnreactiveMap.get(value)}if(isReactive(value))returnvalue// 通过 baseGet 返回具体的 get 拦截回调函数constproxy=newProxy(value,{get:baseGet(isShallow),set,has,ownKeys,deleteProperty})proxy[IS_REACTIVE]=truereactiveMap.set(value,proxy)returnproxy}添加一段测试代码看看是否完成了浅响应，如下：constobj={a:{b:100}}constp1=shallowReactive(obj)effect(()=&gt;{console.log(p1.a.b)})console.log('*****修改******')p1.a.b++查看结果，看看是否修改值之后是否会触发更新，如图：我们在测试一下只修改第一层的属性是否会发生更新，代码如下：constobj={a:1}constp1=shallowReactive(obj)effect(()=&gt;{console.log(p1.a)})console.log('*****修改******')p1.a++结果如图：代理数组JavaScript 中万物皆对象，分为常规对象和异质对象，Proxy 就是一个异质对象，而数组也是。所以需要针对数组进行单独的处理，但是因为也是对象，所以之前大部分的实现都是可用的，如下：constarr=[1,2,3]consta1=reactive(arr)effect(()=&gt;{console.log('effect: ',a1[0])})a1[0]=4测试结果如图：数组的索引与 length通过前文我们知道，通过索引访问是可以建立响应式关系的，但是如果设置的索引大于当前数组的 length，则会导致隐式的修改了 length 的值，如下：constarr=[1]consta1=reactive(arr)effect(()=&gt;{console.log('effect: ',a1.length)})// 设置索引为1的值，则长度也变为 2a1[1]=4console.log(a1.length)但是目前这样并不会触发副作用函数的重新执行，所以我们需要自己来进行一些处理，通过这个例子我们可以知道，当设置的索引大于或者等于数组的长度的时候，就是新增的，所以操作类型，我们还需要针对数组做一层判断，如下：// 表示这些key忽略constnoWarnKey=[RAW_KEY,IS_REACTIVE,ITERATE_KEY]functionbaseSet(isReadonly){returnfunctionset(target,key,newVal,receiver){constoldVal=target[key]consttype=Array.isArray.isArray(target)?// 如果代理的目标是数组，则检测 key 是否小于 target.length// 如果小于，则修改的是数组中已经存在的元素，触发 SET 事件，否则触发 ADD 事件key&lt;target.length?TriggerType.SET:TriggerType.ADD:Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)returnif(receiver[RAW_KEY]===target){if(!Object.is(oldVal,newVal)){trigger(target,key,type)}}returnresult}}当然，这里的判断只是一个粗浅的判断，只是为了讲清楚这个原理，实际的实现需要更换一下，如下：functionbaseSet(isReadonly){returnfunctionset(target,key,newVal,receiver){constoldLen=Array.isArray(target)?target.length:undefinedconstoldVal=target[key]lettype=Object.prototype.hasOwnProperty.call(target,key)?TriggerType.SET:TriggerType.ADDconstresult=Reflect.set(target,key,newVal,receiver)if(!result)returnconstnewLen=Array.isArray(target)?target.length:undefinedif(receiver[RAW_KEY]===target){if(!Object.is(oldVal,newVal)){// 设置时如果满足以下条件，则操作类型是 'ADD'// 1、target 是数组// 2、key 不是 length// 3、旧长度小于新长度if(Array.isArray(target)&amp;&amp;key!=='length'&amp;&amp;newLen&gt;oldLen){type=TriggerType.ADD}// 派发更新trigger(target,key,type)}}returnresult}}而有了这个操作的类型之后，我们就可以进一步的修改 trigger 里面的代码，如下：functiontrigger(target,key,type){letdepsMap=targetMap.get(target)if(!depsMap)returnletdeps=depsMap.get(key)consteffetsToRun=newSet()deps&amp;&amp;deps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})// 如果是一个数组，且是新增元素if(Array.isArray(target)&amp;&amp;type===TriggerType.ADD){// 则去除 length 的依赖加入执行集合constlengthEffects=depsMap.get('length')lengthEffects&amp;&amp;lengthEffects.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})}if(type===TriggerType.ADD||type===TriggerType.DELETE){letiterateDeps=depsMap.get(ITERATE_KEY)iterateDeps&amp;&amp;iterateDeps.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})}effetsToRun.forEach(fn=&gt;{if(fn.options&amp;&amp;fn.options.scheduler){fn.options.scheduler(fn)}else{fn()}})}此时在执行原来的测试代码，如图：此时因为设置了索引导出数组长度隐式增加，也可以触发响应式了，解决完成这个，我们在来看看，直接修改 length 属性也会隐式的影响数组元素，例如：constarr=['A']consta1=reactive(arr)effect(()=&gt;{// 访问数组第一个元素console.log('effect: ',a1[0])})// 将数组的长度设置0，则会清空数组a1.length=0console.log(a1.length)测试结果如图：此时并没有触发副作用函数的触发，因此不妨来猜想一些情况，假设将 length 设置为 100，那么会对 a1[0] 造成影响吗，并不会，也就说只有 length 设置的值小于或者等于当前索引，才应该去触发响应，而为了实现这一点，我们还需要给 trigger 传递第四个参数，如下：functiontrigger(target,key,type,newValue){letdepsMap=targetMap.get(target)if(!depsMap)returnletdeps=depsMap.get(key)consteffetsToRun=newSet()addEffects(effetsToRun,deps)// 如果target是数组，并且 key 是 'length'if(Array.isArray(target)&amp;&amp;key==='length'){// 对于索引大于或者等于当前 length 的新值的元素，就将其取出并添加到 effetsToRun 中等待执行//  - 假设值原数组为 [1,2,3,4,5]，设置 length 为 2//  - 那么新数组就会删减为 [1,2]，则对于索引大于等于 2 的元素 [3,4,5] 就都被删除了，不存在了肯定也要触发依赖//  - 而对于索引小于 2 的元素 [1,2] 则是存在的，没有改变，所以不需要触发依赖depsMap.forEach((deps,key)=&gt;{if(key&gt;=newValue){addEffects(effetsToRun,deps)}})}if(Array.isArray(target)&amp;&amp;type===TriggerType.ADD){constlengthEffects=depsMap.get('length')addEffects(effetsToRun,lengthEffects)}if(type===TriggerType.ADD||type===TriggerType.DELETE){letiterateDeps=depsMap.get(ITERATE_KEY)addEffects(effetsToRun,iterateDeps)}effetsToRun.forEach(fn=&gt;{if(fn.options&amp;&amp;fn.options.scheduler){fn.options.scheduler(fn)}else{fn()}})}// 将添加的逻辑抽离出来functionaddEffects(effetsToRun,effects){if(!effects)returneffects.forEach(effectFn=&gt;{if(effectFn!==activeFn){effetsToRun.add(effectFn)}})}functionbaseSet(isReadonly){returnfunctionset(target,key,newVal,receiver){/**/if(receiver[RAW_KEY]===target){if(!Object.is(oldVal,newVal)){if(Array.isArray(target)&amp;&amp;key!=='length'&amp;&amp;newLen&gt;oldLen){type=TriggerType.ADD}// 传递第四个参数-本次修改的新值trigger(target,key,type,newVal)}}returnresult}}此时，我们再次运行测试代码，结果如图：成功的触发了副作用函数，数组清空，值为 undefined 也是符合我们的预期的。遍历数组在日常的代码开发中，我们都会尽量避免使用 for…in 来遍历数组，但是在语法上，是支持这样遍历的，因此我们需要再之前编写的 ownKeys 方法中，在做出一些修改，之前我们为了实现 for…in 遍历一个对象，对象的属性增加或者删除都会重新触发，统一将 key 设置为了ITERATE_KEY(Symbol(‘iterate’))，但是这是为了适应普通对象的，所以如果是数组的话，要针对 key 做出一些处理，如下：functionownKeys(target){// 如果是数组，则使用 length 为 key，否则使用 ITERATE_KEYconstkey=Array.isArray(target)?'length':ITERATE_KEYtrack(target,key)returnReflect.ownKeys(target)}此时我们写一段测试代码测试一下：constarr=reactive(['A','B'])effect(()=&gt;{console.log('effect触发')for(constkeyinarr){console.log(key)}})console.log('*****修改length*****')arr.length=0结果如图：相比 for…in 来说，我们更加常用的是 for…of，而 for…of 采用的是可迭代协议，具体这块的知识在这里不做赘述，但是无需任何改动，for…of 就是可以正常工作的，因为迭代器本身就是基于数组长度和索引来迭代的，而这些在之前，我们就都已经处理好了。不过在 for…of 会读取一次 Symbol.iterator，这个并不需要跟踪收集依赖，还需要多做一次处理，如下：functionbaseGet(isShallow,isReadonly){returnfunctionget(target,key,receiver){if(key===RAW_KEY){returntarget}// 为什么直接把 symbol 去掉了呢，因为 for in 本身也不会迭代 Symbolif(!isReadonly&amp;&amp;typeofkey!=='symbol'){track(target,key)}constresult=Reflect.get(target,key,receiver)if(isShallow)returnresultif(typeofresult==='object'&amp;&amp;result!==null){returnisReadonly?readonly(result):reactive(result)}returnresult}}测试代码如下：constarr=reactive(['A','B'])effect(()=&gt;{console.log('effect触发')for(constitemofarr){console.log(item)}})console.log('*****修改length*****')arr.length=0结果如图：数组的查找方法可以触发的部分这里就不做展示，仅展示无法触发响应的案例，如下：constobj={}constarr=reactive([obj])console.log(arr.includes(obj))// false为什么存在的值，但是却表示无法找到呢？在 ECMA 规范中表明，includes 方法会通过索引获取值，而我们这里使用的是 arr，arr 是一个代理，在代理中，如果得到这个值是一个对象的话，则会对这个对象进行代理，那么这个 obj 就变为了 objProxy = Proxy(obj)，这两者之间肯定是不相等的，所以这里 arr 通过 includes 查找的时候，includes 内部通过遍历取值对比，实际执行判断时 arr[0] === obj，arr[0]是objProxy，那肯定就会返回 false，这里我们尽然说是因为再次代理的原因，是不是使用浅响应就可以找到呢，是可以的，代码如下：constobj={}constarr=shallowReactive([obj])console.log(arr.includes(obj))// true// 我们也可以直接使用 arr[0] 来直接得到这个代理对象，因为之前我们处理过了，不会重复代理一个对象，所以不会得到两个代理对象，如果没有做这个，那么得到的还是 falseconstobj={}constarr=reactive([obj])console.log(arr.includes(arr[0]))// true哪知道问题的原因之后应该如何解决呢？这个解决方案其实也不难，includes 内部的 this 指向的代理后的 arr，如果从这里找不到，我们从代理的原始数组里面在找一次即可，所以一次找不到，那就在找一次，也因此，我们需要重新一下 includes 方法，如下：// 创建对象，以重写数组方法名为 key，并绑定执行函数constarrayInstrumentations={};['includes','indexOf','lastIndexOf'].forEach(key=&gt;{arrayInstrumentations[key]=function(...args){// this ---&gt; proxy// 1、在 proxy 里面找一次constproxyResult=Array.prototype[key].apply(this,args)// 如果在代理中找到的结果为 true 或者不等于 -1，表示找到了，直接返回if((typeofproxyResult==='boolean'&amp;&amp;proxyResult===true)||(typeofproxyResult==='number'&amp;&amp;proxyResult!==-1)){returnproxyResult}// 2、在原始数组中找一次constrawResult=Array.prototype[key].apply(this[RAW_KEY],args)// 直接返回原始数组中的结果returnrawResult}})functionbaseGet(isShallow,isReadonly){returnfunctionget(target,key,receiver){if(key===RAW_KEY){returntarget}// 如果访问的是重新的数组方法，则直接使用重新的方法if(Array.isArray(target)&amp;&amp;arrayInstrumentations.hasOwnProperty(key)){returnReflect.get(arrayInstrumentations,key,receiver)}constnoKeys=[IS_REACTIVE,RAW_KEY,Symbol.iterator]if(!isReadonly&amp;&amp;!noKeys.includes(key)){track(target,key)}constresult=Reflect.get(target,key,receiver)if(isShallow)returnresultif(typeofresult==='object'&amp;&amp;result!==null){returnisReadonly?readonly(result):reactive(result)}returnresult}}执行结果如图：隐式修改数组长度的原型方法这些方法主要是指数组的栈方法，例如：push、pop、shift、unshift。除此之外还有 splice 也会修改数组的长度。此时我们来看一段测试代码，如下：constarr=reactive(['A'])// 第一个 effecteffect(()=&gt;{arr.push('B')})// 第二个 effecteffect(()=&gt;{arr.push('C')})此时运行代码，会得到一个栈溢出的错误，如图：我们来解读一下这个执行过程：这是因为，push 会读取 length 属性，所以当第一个 effect 执行之后，就会将 length 加入到一个依赖关系中，即进行了依赖收集而第二个 effect 执行的时候，也会读取 length 属性，除了读取之外，它还会设置 length 属性当第二个 effect 在设置 length 属性时，就会将 length 关联的副作用函数取出执行，其中就包括第一个 effect，而此时，我们的第二个 effect 还并没有执行完成，就执行起来了第一个 effect第一个 effect 又再次执行，又设置了 length 属性，触发 set，又要取出全部与 length 关联的副作用函数，此时这写函数里面就包括第二个，然后一直重复这个循环，就导致了栈溢出解决方法也简单，问题就是不停的收集依赖导致的，只要在这些方法运行期间，暂停依赖收集，那么就算改变 length 属性也会因为停止了依赖收集而略过，等待这些方法执行完成，就可以恢复依赖收集，代码如下：// 是否应该收集依赖letshouldTrack=true// 暂停收集依赖functionpauseTracking(){shouldTrack=false}// 恢复收集依赖functionresumeTracking(){shouldTrack=true}constarrayInstrumentations={}// 在重写一些方法;['push','pop','shift','unshift','splice'].forEach(key=&gt;{// 这些会改动数组的长度，造成额外的依赖收集，因此在这些方法运行期间，暂停依赖的收集arrayInstrumentations[key]=function(...args){// 暂停依赖收集pauseTracking()constresult=Array.prototype[key].apply(this,args)// 恢复依赖收集resumeTracking()returnresult}})functiontrack(target,key){// 停止收集依赖期间或者 activeFn 为空，则不收集if(!shouldTrack||!activeFn)returnletdepsMap=targetMap.get(target)if(!depsMap){depsMap=newMap()targetMap.set(target,depsMap)}letdeps=depsMap.get(key)if(!deps){deps=newSet()depsMap.set(key,deps)}deps.add(activeFn)activeFn.deps.push(deps)}此时在运行测试案例，就不会出现栈溢出的错误了结语篇幅原因，这里仅展示代理对象和数组两种最为常见的数据结构，实现代理 Set 和 Map 将在后续的作为扩展章节展示http://www.ppmy.cn/news/1540998.html相关文章Java密封类（Sealed Classes）增强详解Java密封类&amp;#xff08;Sealed Classes&amp;#xff09;增强详解 
Java 17引入了一个重要的新特性——密封类&amp;#xff08;Sealed Classes&amp;#xff09;&amp;#xff0c;这一特性旨在增强Java编程语言的能力&amp;#xff0c;提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的…阅读更多...MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:19 +0000</pubDate>
    </item>
    <item>
      <title>Java密封类（Sealed Classes）增强详解</title>
      <link>https://www.ppmy.cn/news/1540997.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java密封类（Sealed Classes）增强详解news/2025/11/1 0:24:17/Java密封类（Sealed Classes）增强详解Java 17引入了一个重要的新特性——密封类（Sealed Classes），这一特性旨在增强Java编程语言的能力，提供了一种机制来限制哪些类可以继承一个给定的类或者实现一个给定的接口。通过sealed和permits关键字，密封类不仅增强了类型安全性，还简化了代码结构，并在编译时进行了更精确的检查。以下是对Java密封类的深入解析。一、密封类的定义与目的密封类是通过sealed修饰符声明的类，它限制了哪些类可以继承它。同时，使用permits关键字来指定哪些子类是被允许的。这一特性的主要目的是防止类的无序扩展，确保类的继承体系在可控范围内，减少潜在的错误和异常逻辑。在Java 17之前，一个类要么是可以被extends的，要么是final的，只有这两种选项。如果需要控制哪些类可以继承，通常只能通过改变类的访问级别，比如去掉类的public，将访问级别设为默认（包私有）。然而，这种方法并不能完全满足对类继承关系的细粒度控制需求。密封类的引入，正是为了解决这一问题。二、密封类的语法与用法密封类的语法如下：publicsealedclass父类名permits子类1,子类2,...{// 类成员}publicfinalclass子类1extends父类名{// 子类1成员}publicsealedclass子类2extends父类名permits子类2_1,...{// 子类2成员}// 或者publicnon-sealedclass子类3extends父类名{// 子类3成员，子类3可以被任意类继承}在上面的语法中，父类被声明为sealed，并通过permits关键字指定了允许继承它的子类。子类可以是final的（禁止继承），也可以是sealed的（限制继承），还可以是non-sealed的（恢复开放继承）。例如，假设我们有一个表示形状的类Shape，我们希望只有Circle、Rectangle和Square这三个类可以继承它，那么我们可以这样定义：publicsealedinterfaceShapepermitsCircle,Rectangle,Square{// Shape接口的成员}publicfinalclassCircleimplementsShape{// Circle类的成员}publicsealedclassRectangleimplementsShapepermitsSquare{// Rectangle类的成员}publicfinalclassSquareextendsRectangle{// Square类的成员}在这个例子中，Shape是一个密封接口，它只允许Circle、Rectangle和Square这三个类实现。同时，Rectangle也被声明为密封类，它只允许Square作为其子类。这样的设计使得类的继承体系更加清晰和可控。三、密封类的优势与特点增强类型安全性密封类通过限制类的继承关系，可以减少类型转换的错误和潜在的运行时异常，提高程序的稳定性。例如，在上面的Shape例子中，由于我们限制了哪些类可以实现Shape接口，因此在编译时就可以检查到任何非法的继承关系，从而避免运行时错误。简化代码结构密封类可以减少需要显式声明的类和接口数量，简化代码结构。例如，在上面的例子中，我们不需要为Shape接口编写额外的防御性代码来防止未知的子类实现它，因为密封机制已经保证了只有指定的子类可以实现它。提高代码的可读性和可维护性在框架和库的设计中，使用密封类可以更好地控制类的继承体系，减少代码耦合性，提高代码的可读性和可维护性。例如，在图形库中，类的作者可能希望只有特定的类可以扩展Shape，因为库的大部分工作涉及以合适的方式处理每种形状。通过使用密封类，作者可以明确地指定哪些类可以扩展Shape，从而简化库的设计和维护。支持模式匹配的未来发展方向密封类还为模式的详尽分析提供了基础，支持模式匹配的未来发展方向。在Java 14中引入的模式匹配（Pattern Matching for instanceof）特性中，密封类可以作为其基础之一，使得编译器能够在编译时检查到更多的类型信息，从而提供更精确的错误检查和代码优化。四、密封类的限制与注意事项不支持匿名类和函数式接口的继承由于密封类需要明确的继承关系，因此不支持匿名类和函数式接口的继承。这意味着，如果一个类被声明为密封类，那么它不能被用作匿名类的父类，也不能被函数式接口所实现。子类必须位于同一模块或同一包中在密封类的声明中，permits指定的子类必须位于同一模块中（如果超类在命名模块中）或在同一包中（如果超类在未命名模块中）。这一限制确保了密封类的继承关系在编译时是可控的，避免了跨模块或跨包的非法继承。子类可以是final、sealed或non-sealed在密封类的继承体系中，子类可以是final的（禁止继承），也可以是sealed的（限制继承），还可以是non-sealed的（恢复开放继承）。然而，需要注意的是，如果一个子类被声明为non-sealed，那么它就可以被任意类继承，这可能会破坏密封类所带来的类型安全性和代码简化性。因此，在使用non-sealed子类时需要谨慎考虑。编译时检查密封类提供了编译时的类型检查，确保不会出现意外的继承关系。然而，这也意味着在编写密封类时需要注意编译器的错误提示，并根据提示进行相应的修改。五、密封类的应用场景与示例密封类在Java中有着广泛的应用场景，特别是在框架和库的设计中。以下是一些常见的应用场景和示例：状态机模式在状态机模式中，系统状态的变化是有限的且有明确的定义。使用密封类可以确保只有预定义的状态类可以被创建，避免了意外的状态添加。例如，一个有限状态机（FSM）可以使用密封类来定义其状态集合，并通过permits关键字来指定哪些状态是合法的转换目标。图形库在图形库中，类的作者可能希望只有特定的类可以扩展某些基类或接口。例如，在上面的Shape例子中，作者可能希望只有Circle、Rectangle和Square这三个类可以扩展Shape接口。通过使用密封类，作者可以明确地指定哪些类可以扩展Shape接口，从而简化库的设计和维护。API设计在API设计中，有时需要限制某些类的继承关系以避免潜在的错误和异常逻辑。例如，一个用于处理网络通信的API可能希望只有特定的类可以扩展其基类或实现其接口。通过使用密封类，API设计者可以明确地指定哪些类可以扩展或实现这些基类或接口，从而确保API的稳定性和安全性。六、总结与展望Java 17中的密封类是一个重要的语言特性，它提供了对类继承关系的更细粒度控制。通过限制哪些类可以继承一个给定的类或者实现一个给定的接口，密封类增强了类型安全性、简化了代码结构，并在编译时进行了更精确的检查。这对于框架和库的设计者来说尤其有用，因为它可以更好地控制类的继承体系、减少代码耦合性、提高代码的可读性和可维护性。未来，随着Java语言的不断发展和完善，密封类可能会得到更多的应用和优化。例如，可能会引入更多的语法和特性来支持密封类的使用；可能会与其他语言特性（如模式匹配）进行更深入的集成；可能会提供更多的工具和库来帮助开发者更好地理解和使用密封类。总之，密封类作为Java 17的一个重要特性，将为Java语言的发展和应用带来更多的可能性和机遇。http://www.ppmy.cn/news/1540997.html相关文章MacOS安装BurpSuite文章目录 一、下载地址二、下载注册机三、安装教程四、启动burpsuit五、免责声明 一、下载地址 
https://portswigger-cdn.net/burp/releases/download?productpro&amp;version2024.7.1&amp;typeMacOsx二、下载注册机 
https://github.com/NepoloHebo/BurpSuite-BurpLoaderKey…阅读更多...Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:18 +0000</pubDate>
    </item>
    <item>
      <title>MacOS安装BurpSuite</title>
      <link>https://www.ppmy.cn/news/1540996.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MacOS安装BurpSuitenews/2025/11/1 0:24:16/文章目录一、下载地址二、下载注册机三、安装教程四、启动`burpsuit`五、免责声明一、下载地址https://portswigger-cdn.net/burp/releases/download?product=pro&amp;version=2024.7.1&amp;type=MacOsx二、下载注册机https://github.com/NepoloHebo/BurpSuite-BurpLoaderKeygen三、安装教程1、安装burp，直接双击安装2、在应用程序中找到burp3、右键点击显示包内容4、依次打开文件夹：./Contents/Resources/app，然后就会看到我们熟悉的jar文件了。把启动器BurpLoaderKeygen.jar移动到当前app目录5、在文件中打开BurpLoaderkeygen.jar6、启动burpsuit7、返回到Contents目录，编辑vmoptions.txt，末尾追加内容--add-opens=java.base/java.lang=ALL-UNNAMED
--add-opens=java.base/java.lang=ALL-UNNAMED
--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED
--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED
--add-opens=java.base/jdk.internal.org.objectweb.asm.Opcodes=ALL-UNNAMED
-javaagent:BurpLoaderKeygen.jar
-noverify四、启动burpsuit五、免责声明本文档供学习，请使用者注意使用环境并遵守国家相关法律法规!由于使用不当造成的后果上传者概不负责！http://www.ppmy.cn/news/1540996.html相关文章Lua脚本的原子性Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释： 
一、Redis的单线程模型 
Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时…阅读更多...TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:17 +0000</pubDate>
    </item>
    <item>
      <title>Lua脚本的原子性</title>
      <link>https://www.ppmy.cn/news/1540994.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Lua脚本的原子性news/2025/11/1 0:24:14/Lua脚本之所以被认为是原子性的，主要源于Redis的内部实现机制和Lua脚本的执行方式。以下是对Lua脚本原子性的详细解释：一、Redis的单线程模型Redis是一个基于内存、可基于Key-Value等多种数据结构的存储系统，它使用单线程模型来处理客户端的请求。这意味着在任何给定的时间点，Redis服务器只会处理一个客户端的请求。因此，当Redis执行一个Lua脚本时，它会阻塞其他客户端的请求，直到该Lua脚本执行完毕。这种单线程的执行方式确保了Lua脚本中的Redis命令不会被其他客户端的请求打断，从而保证了Lua脚本的原子性。二、Redis内置的Lua解释器Redis服务器内置了一个Lua解释器，用于在服务器端直接执行Lua脚本。当客户端发送一个包含Lua脚本的请求时，Redis服务器会接收这个请求，并使用内置的Lua解释器来解析和执行这个脚本。由于Lua脚本是在Redis服务器端执行的，因此它可以直接访问和操作Redis数据库中的数据，而无需在客户端和服务器之间来回传输数据。这种直接在服务器端执行Lua脚本的方式减少了网络延迟和潜在的数据竞争，进一步保证了Lua脚本的原子性。三、Lua脚本的原子性执行Redis服务器在执行Lua脚本时，会将整个脚本作为一个整体进行执行，中间不会被其他请求打断。这意味着在Lua脚本执行期间，Redis会暂停处理其他客户端的请求，直到该脚本执行完毕。这种原子性的执行方式确保了Lua脚本中的多个Redis命令会按照脚本中指定的顺序连续执行，不会被其他客户端的请求插入或打断。因此，在Lua脚本执行过程中，无需担心会出现竞态条件或数据不一致的问题。四http://www.ppmy.cn/news/1540994.html相关文章TypeScript基础(一): 初识TypeScriptTS是什么&amp;#xff1f; 
TypeScript是微软公司开发的一种基于JavaScript语言的编程语言, 
可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。 
TypeScript对JavaScript添加的最…阅读更多...git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:14 +0000</pubDate>
    </item>
    <item>
      <title>TypeScript基础(一): 初识TypeScript</title>
      <link>https://www.ppmy.cn/news/1540993.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维TypeScript基础(一): 初识TypeScriptnews/2025/11/1 0:24:13/TS是什么？TypeScript是微软公司开发的一种基于JavaScript语言的编程语言,可以看做是JavaScript的超集, 即它继承了后者的全部语法, 所有JavaScript脚本都可以当作TypeScript脚本(但是可能会报错), 此外它增加了一些自己的语法。TypeScript对JavaScript添加的最主要部分，就是一个独立的类型系统。为什么要使用 TS ? TypeScript 相对于 JavaScript 的优势是什么？TypeScript 的主要功能是为 JavaScript 添加类型系统。TypeScript 引入了一个更强大、更严格的类型系统，属于静态类型语言。（1）有利于代码的静态分析。有了静态类型，不必运行代码，就可以确定变量的类型，从而推断代码有没有错误。这就叫做代码的静态分析。这对于大型项目非常重要，单单在开发阶段运行静态检查，就可以发现很多问题，避免交付有问题的代码，大大降低了线上风险。（2）有利于发现错误。由于每个值、每个变量、每个运算符都有严格的类型约束，TypeScript 就能轻松发现拼写错误、语义错误和方法调用错误，节省程序员的时间。（3）更好的 IDE 支持，做到语法提示和自动补全。IDE（集成开发环境，比如 VSCode）一般都会利用类型信息，提供语法提示功能（编辑器自动提示函数用法、参数等）和自动补全功能（只键入一部分的变量名或函数名，编辑器补全后面的部分）。（4）提供了代码文档。类型信息可以部分替代代码文档，解释应该如何使用这些代码，熟练的开发者往往只看类型，就能大致推断代码的作用。借助类型信息，很多工具能够直接生成文档。（5）有助于代码重构。修改他人的 JavaScript 代码，往往非常痛苦，项目越大越痛苦，因为不确定修改后是否会影响到其他部分的代码。类型信息大大减轻了重构的成本。一般来说，只要函数或对象的参数和返回值保持类型不变，就能基本确定，重构后的代码也能正常运行。如果还有配套的单元测试，就完全可以放心重构。越是大型的、多人合作的项目，类型信息能够提供的帮助越大。综上所述，TypeScript 有助于提高代码质量，保证代码安全，更适合用在大型的企业级项目。这就是为什么大量 JavaScript 项目转成 TypeScript 的原因。ts 中有哪些类型？1. **基本类型**：- `string`：表示文本数据。- `number`：表示数值，包括整数和浮点数。- `boolean`：表示逻辑值 `true` 和 `false`。- `array`：表示元素类型相同的数组，可以写作 `T[]` 或 `Array&lt;T&gt;`。- `tuple`：表示已知元素数量和类型的数组，各元素类型不必相同。：2. **联合类型**（Union Types）- 将多个类型合并为一个类型，表示值可以是多种类型之一。例如：`type StringOrNumber = string | number`。3. **交叉类型**（Intersection Types）：- 将多个类型合并为一个类型，表示值必须同时是所有指定的类型。例如：`type ExtendsBoth = StringOrNumber &amp; Callable`。4. **任意类型**（Any）：- `any` 类型表示任意类型，用于绕过类型检查。5. **未知类型**（Unknown）：- `unknown` 类型表示任意类型，但是是一个安全的类型，需要进行类型检查后才能使用。6. `never`：- 表示那些永不存在的值的类型，例如总是抛出异常或根本就不会有返回值的函数表达式或箭头函数的返回值类型。7. `void`：- 表示没有任何类型，通常用作没有返回值的函数的返回类型。8. `null` 和 `undefined`：- `null` 和 `undefined` 是所有类型的子类型，可以赋值给任何类型。9. **类型别名**（Type Aliases）：- 使用 `type` 关键字为类型创建一个别名。例如：`type Name = string`。10. **接口**（Interfaces）：- 使用 `interface` 关键字定义对象的形状。接口可以定义函数形状、对象形状，甚至可以扩展其他接口。11. **类类型**（Class Types）：- 类本身也具有类型，包括其成员方法和属性。12. **枚举类型**（Enum）：- `enum` 用于定义命名的常量集合。13. **类型字面量**（Type Literals）：- 直接使用字面量定义类型，例如：`type EmptyObject = { [K in keyof any]: any }`。14. **映射类型**（Mapped Types）：- 使用 `keyof` T 获取 T 的所有键，然后构造一个新类型，其键与 T 相同，但类型不同。15. **条件类型**（Conditional Types）：- 使用 `extends` 关键字在类型上进行条件判断。16. **类型查询**（Type Queries）：- 使用 `typeof` 获取变量的类型，或者使用 `T[key]` 获取属性的类型。17. **索引访问类型**（Indexed Access Types）：- 使用 `T[K]` 访问类型 T 的 K 索引上的类型。18. **工具类型**（Utility Types）：- TypeScript 提供了一系列内置的工具类型，如 `Partial&lt;T&gt;`、`Readonly&lt;T&gt;`、`Pick&lt;T, K&gt;` 等，用于构造新类型。19. **模板字面量类型**（Template Literal Types）：- 使用反引号（`` ` ``）和 `${expression}` 语法创建字符串字面量类型。20. **类型断言**（Type Assertions）：- 使用 `as` 关键字手动指定一个值的类型。﻿any 和 unknown的区别是？在 TypeScript 中，`any` 和 `unknown` 类型都是用来表示任意类型的值，但它们在使用上有一些重要的区别：﻿1. **类型安全性**：- `any` 类型是一种类型擦除，它允许你对变量执行任何操作，而不需要进行类型检查。这意味着你可以对 `any` 类型的值做任何事情，TypeScript 编译器不会对这些操作进行任何类型检查。- `unknown` 类型则是一种类型保留。它表示任何类型，但是当你对 `unknown` 类型的值执行操作时，必须先进行类型检查，以确保操作的安全性。这有助于 TypeScript 编译器捕获潜在的类型错误。﻿2. **操作限制**：- `any` 类型的值可以直接赋值给其他类型，也可以从其他类型赋值而来，无需任何特殊处理。- `unknown` 类型的值在赋值给其他类型或从其他类型赋值时，需要先进行类型检查或类型断言。﻿3. **类型检查**：- `any` 类型的值不需要任何类型检查就可以执行任何操作。- `unknown` 类型的值在执行操作之前，通常需要使用类型守卫（如 `typeof`、`instanceof` 或自定义类型守卫）来缩小类型的范围，或者使用类型断言来指定一个更具体的类型。﻿4. **最佳实践**：- `any` 类型应该谨慎使用，因为它会跳过 TypeScript 的类型检查，这可能导致运行时错误。- `unknown` 类型是更安全的选择，因为它强制你在使用变量之前进行类型检查，从而提高代码的类型安全性。﻿下面是一个简单的示例，展示 `any` 和 `unknown` 类型的区别：let anyValue: any = "Hello";anyValue = 42; // OKanyValue.toUpperCase(); // OKanyValue.substr(2); // Error: Property 'substr' does not exist on type 'any'.﻿let unknownValue: unknown = "Hello";unknownValue = 42; // OKif (typeof unknownValue === "string") {unknownValue.toUpperCase(); // OK} else {unknownValue.substr(2); // Error: Property 'substr' does not exist on type 'never'.}// 或者使用类型断言(unknownValue as string).toUpperCase(); // OK在这个示例中，`anyValue` 可以直接调用任何方法，而 `unknownValue` 需要先进行类型检查。如果没有进行类型检查，尝试对 `unknownValue` 调用 `toUpperCase` 方法时，TypeScript 编译器会报错，因为它不知道 `unknownValue` 是否一定是字符串类型。总的来说，`unknown` 类型比 `any` 类型更安全，因为它要求在使用变量之前进行类型检查，从而帮助避免潜在的类型错误。在 TypeScript 中，推荐尽可能使用 `unknown` 类型，而不是 `any` 类型。﻿void 和 never 的区别是？`void` 和 `never` 是 TypeScript 中的两种类型，它们都与类型的不存在或缺失有关，但用途和行为有所不同：﻿1. **void**:- `void` 类型通常用作函数没有返回值的返回类型。- 当你有一个函数确实会返回一个值，但有时候你不关心这个返回值时，也可以使用 `void` 来明确表示这一点。- `void` 类型的变量实际上只能被赋值为 `undefined` 或者 `null`（如果你在 TypeScript 配置中启用了 `--strictNullChecks` 或 `--strict`，则只能是 `undefined`）。- `void` 可以被赋值给任何类型，但任何类型都不能被赋值给 `void` 类型，除非是 `undefined` 或 `null`。示例：function warnUser(): void {console.warn("This is a warning message");}2. **never**:- `never` 类型表示那些永不存在的值的类型，例如总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数的返回值类型。- `never` 是 `any`、`unknown`、`never` 之外的所有类型的子类型，这意味着你可以将 `never` 类型的变量赋值给任何类型。- `never` 类型的变量只能被赋值为 `never` 类型的值，例如总是会抛出错误的函数或者根本就不会有返回值的函数。﻿示例：function error(message: string): never {throw new Error(message);}﻿function fail(): never {return error("Something failed");}
﻿总结来说，`void` 用来表示“没有类型”或“没有任何返回值”，而 `never` 用来表示“永不存在的类型”，即那些根本不可能被成功返回的类型。`never` 是 `void` 的子类型，但 `void` 不是 `never` 的子类型。在函数返回类型中，`never` 可以用来表示函数总是会抛出错误或根本就不会有返回值的情况。﻿http://www.ppmy.cn/news/1540993.html相关文章git禁用 SSL 证书验证命令 
git config --global http.sslVerify false注意&amp;#xff1a;禁用 SSL 证书验证是不安全的&amp;#xff0c;可能会使你的 Git 操作面临中间人攻击的风险。因此&amp;#xff0c;只有在你确信网络环境是安全的&amp;#xff0c;且了解禁用 SSL 验证的后果时&amp;#xff0c;才应该使用这个配置…阅读更多...git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:13 +0000</pubDate>
    </item>
    <item>
      <title>git禁用 SSL 证书验证</title>
      <link>https://www.ppmy.cn/news/1540992.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维git禁用 SSL 证书验证news/2025/11/1 0:24:12/命令gitconfig --global http.sslVerifyfalse注意：禁用 SSL 证书验证是不安全的，可能会使你的 Git 操作面临中间人攻击的风险。因此，只有在你确信网络环境是安全的，且了解禁用 SSL 验证的后果时，才应该使用这个配置。http://www.ppmy.cn/news/1540992.html相关文章git入门操作文章目录 git入门操作git创建仓库&amp;#xff1a;git initgit clone工作区域&amp;#xff1a;文件状态git添加和提交git add git statusgit add .git commit -m 版本描述git ls-filesgit log git的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总…阅读更多...Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:12 +0000</pubDate>
    </item>
    <item>
      <title>git入门操作</title>
      <link>https://www.ppmy.cn/news/1540991.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维git入门操作news/2025/11/1 0:24:11/文章目录git入门操作git创建仓库：git initgit clone工作区域：文件状态git添加和提交git addgit statusgit add .git commit -m 版本描述git ls-filesgit loggit的reset回退版本git log 查看版本号git reset --softgit reset --hardgit reset --mixed总结git rm 删除文件git入门操作git创建仓库：新建仓库主要有两种方式，第一种就是再文件夹下，使用 git 命令git init第一步：创建一个文件夹并且 cd 到这个文件夹下面第二步：这里使用 git init 后，在这个文件夹下就创建好了一个git仓库第三步：使用 dir /ah 查看这个文件夹下隐藏的 git 配置文件，这个文件就是我们创建 git 仓库的关键所在我们可以 cd 到这个隐藏的文件夹下面看看这里能看到很多的配置文件，因为这些配置文件对于git很重要，所以都是个隐藏的。git clone下面是第二种方式，git clone，这种方式呢，需要我们在gitee或者github这种远程仓库上有一个代码仓库。点击上面的克隆下载使用下面的命令在我们的终端就可以新建一个这样的仓库了### git工作区域和文件状态，git添加和提交工作区域：git 分为四个工作区域，第一个就是工作区，如图也就是我们的工作区域，当我们新建一个文件或者在工作区修改了一个文件的时候，就需要先把修改或者新建的文件放到暂存区，然后统一更新到本地仓库区域。这里举一个例子来说明：把工作区比喻成生产货物的地方，那么本地仓库就是我们存放货物的地方，暂存区相当于我们的货车，当我们在生产区生产了几个货物后，我们需要把货物运到仓库，这时候我们可以根据需求把想要运送过去的货物放入货车，然后送到仓库，这样流程清晰，可操作性强。文件状态对于文件状态下面会在 git 添加和提交里举例：git添加和提交git add1.在上文创建好的 git 仓库里新建文件 test.txt这时候可以在命令行里查看文件（windows 使用：dir）：dir这个区域就是我们的工作区，这时候查看是创建好了的一个文件在工作区当然，我们需要把这个文件给放到暂存区，这样才能提交到本地仓库，也就是说我们的货物需要先放入货车里。使用 git add 命令git add 文件名这里引入一个查看工作区的文件是否存放在暂存区的命令git statusgit status当这个命令出现的文件是绿色的时候，那么这个文件已经放到暂存区了，如果是红色，那就是没有更新到暂存区的。那么我们新建一个文件，不适用 git add，就会是红色的：这里的第二个文件就是红色的，因为它没有add到暂存区下面我么使用 git add . 这个命令把test2加入到暂存区git add .git add . 是指把当前所有文件加入到暂存区当然我们只有test2没有加入进去，但是使用这个全部加入的命令也是可以的当我们把已经修改好的文件夹或者已经创建好的文件夹都放在暂存区的时候，我么就可以把这些文件都放到本地仓库了git commit -m 版本描述这个时候就是使用这个命令的时候了：git commit-m这样我们就把所有文件都给放到本地仓库了，如何查看本地仓库的文件呢？git ls-files查看本地仓库：这里就能看到刚刚commit的文件了git log对于每一个commit，会对应每一个版本，我可以使用一个命令进行所有版本的查看和切换如果说，这个时候，我修改test2的内容，并且add和commit，那么就能看到两个版本号git的reset回退版本如果我们想回到 version 1的话，这里就要用到一个 git reset 的命令了git log 查看版本号对于每次提交我们都有自己的版本号git reset --soft如果我们使用这个命令，那么我们回退到版本1的时候，工作区和暂存区的内容都会保留这里我们回退到版本1，这里后面的版本号是这里：git reset--soft 版本号这里我们再次使用 git status 查看暂存区域：打开文件夹看：发现我们的工作区文件和暂存区修改都没有变git reset --hard这个命令是回退并且不报错工作区和暂存区的改变这里我们先commit：然后再次回退，使用 hardgit reset--hard 版本号再次查看工作区和暂存区：工作区修改没了，如果实在这次操作创建了test2，那么test2也会消失查看暂存区：显示没有文件git reset --mixed这里先对 test2 加入内容 111 ，然后再次 add commit，变成版本 2.0使用 git reset --mixedgit reset--mixed 版本号这里查看工作区：工作区不变查看暂存区：暂存区没有了总结git reset--soft  工作区和暂存区都保留
git reset--hard	工作区和暂存区都不保留
git reset--mixed	工作区保留，暂存区不保留git rm 删除文件当我删除工作区何本地仓库文件 test2，可以使用git rm 文件名http://www.ppmy.cn/news/1540991.html相关文章Python基于OpenCV的实时疲劳检测2.检测方法 
1&amp;#xff09;方法 与用于计算眨眼的传统图像处理方法不同&amp;#xff0c;该方法通常涉及以下几种组合&amp;#xff1a; 
1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间&amp;#xff08;表示眨眼&amp;#xff09;。 相反&amp;#xff0c;眼睛长…阅读更多...exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:11 +0000</pubDate>
    </item>
    <item>
      <title>Python基于OpenCV的实时疲劳检测</title>
      <link>https://www.ppmy.cn/news/1540990.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python基于OpenCV的实时疲劳检测news/2025/11/1 0:24:10/2.检测方法1）方法 与用于计算眨眼的传统图像处理方法不同，该方法通常涉及以下几种组合：1、眼睛定位。 2、阈值找到眼睛的白色。 3、确定眼睛的“白色”区域是否消失了一段时间（表示眨眼）。 相反，眼睛长宽比是一种更为优雅的解决方案，它涉及基于眼睛面部轮廓之间的距离之比的非常简单的计算。参考该博客，这种眨眼检测方法快速，高效且易于实现。（2）眼睛纵横比 我们可以应用脸部界标检测来定位脸部重要区域，包括眼睛，眉毛，鼻子，耳朵和嘴巴 这也意味着我们可以通过了解特定面部部分的索引来提取特定面部结构： 在眨眼检测方面，我们只对两套面部结构感兴趣：眼睛。 每只眼睛都由6 （x，y）坐标表示，从坐标的左角开始（就像您在看那个人一样），然后沿该区域的其余部分顺时针旋转：基于此图像，我们应该取消关键点： 这些坐标的宽度和高度之间存在关系。 根据Soukupová和Čech在2016年的论文《使用面部地标进行实时眼睛眨眼检测》的工作，我们可以得出一个反映这种关系的方程，称为眼睛纵横比（EAR）：4.参考文献[1] 汪明明,林小竹.基于OpenCV人眼定位的人脸检测方法[D].北京石油化工学院.2022（12）.[2] 傅亚煌,黄鸣宇.基于眼动特性的机动车驾驶疲劳系统[J].电脑与信息技术.2022(2).[3] 王奕直,周凌霄,孔万增.基于Adaboost的疲劳驾驶眨眼检测[D].杭州电子科技大学学报.2022(8).[4] 张旭,李亚利,陈晨,王生进,丁晓青.嵌入式驾驶员状态检测算法的实现与优化[J].自动化学报.2022(12).[5] 赵钟.驾驶员疲劳检测方法研究及嵌入式实现[D]. 大连海事大学.2020(6).[6] 徐淑峰,孙炜,赵峰,张忠.Adaboost人脸检测算法在嵌入式平台上的优化与实现[D].上海交通大学微电子学院.2018(6).[7] 牛慧萍.基于DSP的人眼状态信息检测系统的研究和设计.[D].沈阳理工大学.2010(3).[8] 郑玉铎.田杨萌.靳薇.基于Adaboost 和ASM 算法的人眼定位.[J] .北京信息科技大学学报.2013(6).[9] 郭纯宏.基于嵌入式的人眼信息检测系统研究.[D].沈阳理工大学.2011(3).[10] 王洪涛.驾驶疲劳测评方法研究及其DSP实现.[D].武汉理工大学.2007(5).[11] 向本科.基于人眼检测的驾驶员疲劳检测研究.[D].西南大学.2010(5).[12] 常瑜亮.基于DSP的疲劳驾驶检测系统硬件设计与实现. [D].沈阳理工大学.2010(3).[13] 李文磊.基于DSP的疲劳驾驶实时监测系统研究.[D] .南京理工大学.2007(6).http://www.ppmy.cn/news/1540990.html相关文章exchange_proxy exchange 安全代理1. 软件简介 
exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下： WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）…阅读更多...VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:10 +0000</pubDate>
    </item>
    <item>
      <title>exchange_proxy exchange 安全代理</title>
      <link>https://www.ppmy.cn/news/1540989.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维exchange_proxy exchange 安全代理news/2025/11/1 0:24:09/1. 软件简介exchange_proxy 是由小米公司开发并开源的，以 go 语言开发的 exchange 安全代理，可以将内网的 exchange 服务器的 https 服务安全地发布出去， 支持的功能如下：WEB 端增加 OTP 二次认证手机端增加设备激活绑定的功能屏蔽了 PC 端的 EWS 协议（意思就是不支持）不支持windows系统下的outlook 2013/2016等的登录认证，也就是不支持rpc和mapi协议2. 配置说明在使用该系统前，需要确保有以下基础设施的接口，并完成与代理的对接：OTP 动态口令系统短信发送接口通过员工姓名查询员工手机号的接口以上接口准备并对接完成后，正确配置 conf/app.ini 即可启动代理服务器了。[mail]
hosts = mail.xiaomi.com,mail.sec.lu
backend = https://10.10.10.10
port = 443
ssl = true
cert = certs/ca.crt
key = certhttp://www.ppmy.cn/news/1540989.html相关文章VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析 
随着LED技术在汽车照明和工业照明中的广泛应用&amp;#xff0c;对LED驱动电路的要求也日益提高。为了满足这些需求&amp;#xff0c;VAS1802Q作为一款可编程恒流调节器&amp;#xff0c;凭借其宽输入电压范围、精准电流调节以及多重保…阅读更多...Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:09 +0000</pubDate>
    </item>
    <item>
      <title>VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100</title>
      <link>https://www.ppmy.cn/news/1540988.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维VAS1802奇力线性芯片LED驱动芯片车规认证AEC-Q100news/2025/11/1 0:24:08/VAS1802Q 可编程恒流调节器在汽车照明中的应用与技术分析随着LED技术在汽车照明和工业照明中的广泛应用，对LED驱动电路的要求也日益提高。为了满足这些需求，VAS1802Q作为一款可编程恒流调节器，凭借其宽输入电压范围、精准电流调节以及多重保护功能，成为了市场上非常具有竞争力的LED驱动方案。本文将深入探讨VAS1802Q的技术特点及其在汽车照明中的应用优势。1. 宽输入电压与高效能设计VAS1802Q支持1.35V至40V的宽输入电压范围，这使得它能够在低电压条件下正常工作，最低启动电压为1.35V。这种设计特别适合应用于电源供应不稳定或者低电压的汽车环境中。此外，该芯片可输出5mA至150mA的可编程电流，通过简单的外部电阻设置即可实现不同电流需求，且能通过并联多个芯片实现更高的电流输出，满足不同功率LED灯具的需求。2. 节能与精准电流控制VAS1802Q在设计上极具节能性，其静态电流仅为200µA，关断模式下静态电流降至20µA，这为电池供电系统或节能应用提供了显著优势。其SET引脚通过外部电阻调节LED电流，电流精度达到±5%，确保LED输出电流稳定、精确，适应各种不同照明强度的需求。3. PWM调光与灵活性为满足不同照明环境的需求，VAS1802Q支持PWM调光功能，PWM频率范围为500Hz至10kHz，可以通过调节PWM占空比实现LED的亮度调节。EN引脚既可用于启用/关闭芯片，也可作为PWM调光的输入接口，极大增强了照明系统的灵活性和可控性。4. 过温保护与高可靠性汽车和工业应用往往面临严苛的工作环境，温度变化幅度大。VAS1802Q内置的过温保护功能在芯片温度达到140°C时会自动降低LED电流，当温度超过160°C时，芯片会进入热关断状态，确保不会因过热导致故障。当温度恢复至130°C时，芯片会自动重新启动工作。该芯片的工作温度范围为-40°C至+125°C，进一步增强了其在恶劣环境下的可靠性和稳定性。5. 应用于汽车照明的优势VAS1802Q的各项技术特性使其特别适合用于汽车照明系统，如车头灯、尾灯以及车内照明。其符合AEC-Q100汽车级标准，包括ESD保护、耐高温等要求，保证了产品在汽车应用中的长期稳定性。此外，VAS1802Q的低压启动和宽输入电压范围，确保在各种电源条件下都能保持高效稳定的工作，这对于汽车电池系统尤其重要。6. 总结作为一款高效、灵活且可靠的恒流调节器，VAS1802Q不仅具备宽电压范围、低静态电流、过温保护等关键功能，还支持PWM调光和多芯片并联使用，能够满足汽车照明以及其他高精度、高稳定性的LED应用需求。通过其SOT23-5封装，VAS1802Q还具备了设计灵活性，适用于空间有限的应用场景。因此，VAS1802Q无疑是当前LED驱动领域的优秀选择，尤其在汽车照明系统中展现出色的性能和优势。http://www.ppmy.cn/news/1540988.html相关文章Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)系列文章目录 
运维监控平台组件介绍及RPM包构建 文章目录 系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析 二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例 三、监控指标标签1.指标抓取生命周期2…阅读更多...【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:08 +0000</pubDate>
    </item>
    <item>
      <title>Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)</title>
      <link>https://www.ppmy.cn/news/1540987.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Prometheus运维监控平台之服务发现配置、标签及监控规则编写(二)news/2025/11/1 0:24:06/系列文章目录运维监控平台组件介绍及RPM包构建文章目录系列文章目录前言一、服务发现机制1.服务发现概述2.prometheus常用的服务发现协议3.服务发现原理分析二、服务发现配置示例1.静态服务发现配置示例2.基于consul服务发现配置示例三、监控指标标签1.指标抓取生命周期2.标签的作用3.标签分类3.1.静态服务发现metadata标签示例3.2.基于consul动态服务发现metadata标签3.3.自定义标签3.4.重新标记标签3.4.1.relabel原理3.4.2.relabel_configs语法及示例3.4.3.action常用操作示例3.4.3.1. 标签转换之replace操作3.4.3.2. 标签转换之uppercase操作3.4.3.3. 标签转换之lowercase操作3.4.3.4. 标签转换之hashmod操作3.4.3.5. 标签转换之labelmap操作3.4.3.6. 标签转换之labeldrop操作3.4.3.7. 标签转换之labelkeep操作3.4.3.8. 采集控制之keep操作3.4.3.9. 采集控制之drop操作3.4.3.10. 采集控制之keepequal操作3.4.3.11. 采集控制之dropequal操作4.构造标签四、监控规则1.规则分类2.警报规则3.警报规则示例4.报警状态5.警报规则编写5.1.从指定网址获取规则并进行修改5.2.自定义编写告警规则文件总结前言在第一篇文章中，主要针对运维监控平台组件的介绍及通过fpm工具对二进制安装的组件进行RPM包构建,让大家对整个运维监控平台从概念、安装部署有一个大致的认知。但是在企业环境中仅仅了解概念和安装部署是不够的，随着对技术的深入了解，还得学会prometheus如何监控某一个指标，并且这个指标怎么设置监控规则，只有当监控的指标值超过监控规则设置的阈值后，才会产生一条原始的告警。那么问题就来了，怎么配置监控项以及怎么设置监控规则就是本篇文章的核心思想。接下来，闲话少说开始实战。一、服务发现机制1.服务发现概述prometheus通常是基于pull模式拉取监控数据,首先要能够发现需要监控的目标对象target,但随着容器时代的发展所有的监控对象都在动态变化。
而对于prometheus而言解决方案是引入一个中间代理人(即服务注册中心),这个代理人掌握着当前所有监控目标的访问信息，
而prometheus只需要向这个代理人询问有哪些监控目标即可，这种模式被称为服务发现。prometheus核心功能包括服务发现、数据采集、数据存储。
从上图可以看到服务发现部分负责发现需要监控的目标采集点信息(即prometheus.yml中的target)
数据采集部分从服务发现中订阅发现到的信息,获取到target信息后(信息包含协议、主机、端口、请求路径、请求参数等)，将这些信息构建出一个http request请求。
然后prometheus 定时通过pull http协议不断的去目标采集点(target)拉取监控样本数据，最后将采集到监控数据交由TSDB时序数据库进行数据存储，2.prometheus常用的服务发现协议目前prometheus支持的服务发现协议高达二十多种,下方列出常见的几种Prometheus 支持的多种服务发现机制:#Prometheus数据源的配置主要分为静态配置和动态发现, 常用的为以下几类:1）static_configs:#静态服务发现2）file_sd_configs:#文件服务发现3）dns_sd_configs:DNS#服务发现4）kubernetes_sd_configs:#Kubernetes 服务发现5）consul_sd_configs:Consul#consul服务发现3.服务发现原理分析如上图所示,prometheus服务发现机制大致涉及到三部分:1、配置解析处理:主要将prometheus.yml文件中配置的scrape_configs部分中的job_name生成对应的Discovery服务,不同的服务发现协议都会有自己的服务发现方式。根据自身的发现逻辑去发现target，并将其放入到targer容器中2、discoveryManager组件:这个组件内部有个定时周期触发任务,默认每5秒检查一下target容器,如果有变更则将targets容器中target信息放入到syncCh通道中3、scrape组件:这个组件会监听syncCh通道,这样需要监控的targets信息就会传递给scrape组件,然后将target纳入到监控开始采集监控指标promethues.yml结合上述描述二、服务发现配置示例1.静态服务发现配置示例当监控目标少的时候可以使用静态监控服务发现scrape_configs:-job_name:"prometheus"#监控指标名称scrape_interval:5s#定时采集周期任务间隔时间static_configs:#静态服务发现标志-targets:["localhost:9090"]#监控目标当在prometheus.yml文件中添加了如上配置后,打开prometheus Web--&gt;Status--&gt;Targets如下所示2.基于consul服务发现配置示例当监控指标多的时候，适用于consul服务发现，减少人工手动配置scrape_configs:-job_name:"consul-prometheus"consul_sd_configs:#基于consul服务发现标志-server:'localhost:8500'#consulip和端口token:"a0de7f26-127b-cd67-f01e-477c212d7c48"#consul的ACL认证tokenrelabel_configs:#标签转换-source_labels:['__meta_consul_service']regex:.*monitor.*action:keep-source_labels:['__meta_consul_service_address']target_label:ip-source_labels:['__meta_consul_service_port']target_label:port监控指标注册到consul后的示例.具体的注册方式后续会有文章说明当在prometheus.yml文件中添加了如上配置后,打开prometheus Web--&gt;Status--&gt;Targets如下所示三、监控指标标签1.指标抓取生命周期1、Prometheus 在每个 scrape_interval 期间都会检测执行的 job，这些 job 会根据指定的服务发现配置生成 target 列表2、服务发现会返回一个 target 列表，其中包含一组以 __meta_ 为开头的元数据的标签；3、服务发现还会根据目标配置来设置其他标签，这些标签带有 __ 前缀和后缀，包括 __scheme__ 、__address__ 、和 __metrics_path__ ，分别保存有 target 支持使用的协议、target 的地址及指标的 uri路径（默认为 metric），这些 target 列表和标签会返回给 Prometheus，其中一些标签也可以在配置中被覆盖。配置标签会在抓取的生命周期中被重复利用以生成其他标签，比如指标上的 instance 标签的默认值就来自于 __address__ 标签的值。4、Prometheus 对发现的各个目标提供了重新打标的机会，可以在 job 配置段的 relabel_configs 中进行配置。通常用于实现过滤 target 和将元数据标签中的信息附加到指标的标签上。5、在重新打标之后便会对指标数据进行抓取及指标数据返回的过程。收到的指标数据在保存之前，还允许用户在 metric_relabel_configs 配置段中对指标数据重新打标并对其进行过滤。通常用于删除不需要的指标、在指标中删除敏感或不需要的标签以及添加、编辑或者修改指标的标签值或标签格式。2.标签的作用Prometheus中存储的数据为时间序列，是由Metric的名字和一系列的标签(键值对)唯一标识的,不同的标签代表不同的时间序列，即通过指定标签查询指定数据。
不同的标签代表不同的时间序列，即通过指定标签查询指定数据。
指标+标签实现了查询条件的作用，可以指定不同的标签过滤不同的数据.3.标签分类3.1.静态服务发现metadata标签示例metadata标签也称元数据标签，如下图示例#在promethues.yml中配置一个如下的不包含任何标签的采集任务-job_name:tcp_connectmetrics_path:/probeparams:module:[tcp_connect]static_configs:-targets:-192.168.56.131:9273-192.168.56.132:9273打开prometheus Web查看元数据标签如上元数据标签所示:__address__:"当前Target实例的访问地址&lt;host&gt;:&lt;port&gt;"__scheme__:"采集目标服务访问地址的HTTP Scheme，HTTP或者HTTPS"__metrics_path__:"采集目标服务访问地址的访问路径"__parm_module:"存储来自配置中的参数的值"__scrape_interval__:"采集间隔"__scrape_timeout__:"采集超时时间"job:"采集任务名称"3.2.基于consul动态服务发现metadata标签如果了解go语言，可以参考prometheus源码中的discoveryLabels发现这部分#通过api获取标签[root@python2 prometheus]# curl -s http://localhost:9090/api/v1/targets  -uadmin:QAZXCFRF{"status":"success","data":{"activeTargets":[{"discoveredLabels":{"__address__":"192.168.56.131:9273","__meta_consul_address":"192.168.56.131","__meta_consul_dc":"prod","__meta_consul_health":"passing","__meta_consul_node":"consul-node","__meta_consul_service":"monitor_agent","__meta_consul_service_address":"192.168.56.131","__meta_consul_service_id":"telegraf-192.168.56.131-9273","__meta_consul_service_metadata_monitorType":"monitor_agent","__meta_consul_service_metadata_organization":"运维监控平台","__meta_consul_service_metadata_project":"监控agent组件","__meta_consul_service_metadata_version":"v1.22.4","__meta_consul_service_port":"9273","__meta_consul_tags":",telegraf,","__metrics_path__":"/metrics","__scheme__":"http","__scrape_interval__":"15s","__scrape_timeout__":"10s","job":"consul-prometheus"},"labels":{"instance":"192.168.56.131:9273","ip":"192.168.56.131","job":"consul-prometheus","port":"9273"},"scrapePool":"consul-prometheus","scrapeUrl":"http://192.168.56.131:9273/metrics","globalUrl":"http://192.168.56.131:9273/metrics","lastError":"","lastScrape":"2024-10-16T17:59:53.954209636+08:00","lastScrapeDuration":0.003238111,"health":"up","scrapeInterval":"15s","scrapeTimeout":"10s"}....}"__address__":"192.168.56.131:9273",#当前Target实例的地址&lt;host&gt;:&lt;port&gt;"__meta_consul_address":"192.168.56.131",#consul地址"__meta_consul_dc":"prod",#consul数据中心名称"__meta_consul_health":"passing",#target服务状态"__meta_consul_node":"consul-node",#consul名称"__meta_consul_service":"monitor_agent",#target在consul中注册的服务名称"__meta_consul_service_address":"192.168.56.131",#consul地址"__meta_consul_service_id":"telegraf-192.168.56.131-9273",#target注册到consul中的唯一标识"__meta_consul_service_metadata_monitorType":"monitor_agent",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_organization":"运维监控平台",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_project":"监控agent组件",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_version":"v1.22.4",#在target注册到consul时 自定义的meta"__meta_consul_service_port":"9273",#端口"__meta_consul_tags":",telegraf,",#与服务关联的标签"__metrics_path__":"/metrics",#指定 Prometheus 用于抓取指标的路径"__scheme__":"http",#指定协议，默认为http"__scrape_interval__":"15s",#指定抓取的时间间隔"__scrape_timeout__":"10s",#指定抓取的超时时间"job":"consul-prometheus"#采集任务名称注意事项: 以上这些metadata标签只是普罗米修斯去使用,我们不会用该标签去查监控值，同时该标签也不会存储到时序数据库中的，使用promql+metadata标签也是查不出来值的3.3.自定义标签自定义标签示例-job_name:'service_http_status'metrics_path:/probeparams:module:[http_health]static_configs:-targets:['http://192.168.30.52:11000/actuator/health']labels:organization:'运维监控'project:'服务监控'servicetype:'telegraf'自定义标签作用:自定义标签可以实现多维度的查询,标签越多查询的维度越细。注意事项: 在labels显示中job和instance属于默认内部标签,只有监控到了目标，就会存在这两个标签。3.4.重新标记标签重新标记目的:为了更好的标识监控指标重新标记分类:relabel_configs:在采集之前（比如在采集之前重新定义元标签）metric_relabel_configs:在存储之前准备抓取指标数据时，可以使用relabel_configs添加一些标签、也可以只采集特定目标或过滤目标。 已经抓取到指标数据时，可以使用metric_relabel_configs做最后的重新标记和过滤。重新标记标签作用:1、动态生成新标签  根据已有的标签生成新标签2、过滤采集的Target3、删除不需要或者敏感标签4、添加新标签重新标记标签示例-job_name:"consul-prometheus"consul_sd_configs:-server:'localhost:8500'token:"a0de7f26-127b-cd67-f01e-477c212d7c48"relabel_configs:#重新标记标签-source_labels:['__meta_consul_service']regex:.*monitor.*action:keep-source_labels:['__meta_consul_service_address']target_label:ip-source_labels:['__meta_consul_service_port']target_label:port3.4.1.relabel原理1、服务发现的目标，初始状态都是标签集合(model.LabelSet)，这些标签集合是可以被调整的。
2、通过标签调整操作，产生不同的行为 (Action) 变化，进而控制采集行为
这就是 relabel 的原理，目前的 relabel 根据执行结果，可以分为两大类，分别是标签转换和采集控制。标签转换:将服务发现的内部标签，进行提取、修改和取消的操作，只影响对 Target 采集结果的标签变化。采集控制:根据标签匹配，将采集的 Target 进行保留或丢弃，会影响对 Target 的采集请求。3.4.2.relabel_configs语法及示例relabel_configs:-&lt;Action 1&gt;-&lt;Action 2&gt;-&lt;Action 3&gt;-job_name:"consul-prometheus"consul_sd_configs:-server:'localhost:8500'token:"a0de7f26-127b-cd67-f01e-477c212d7c48"relabel_configs:-source_labels:['__meta_consul_service']regex:.*monitor.*action:keep-source_labels:['__meta_consul_service_address']target_label:ip-source_labels:['__meta_consul_service_port']target_label:portaction常用配置项示例#   replace: 进行标签替换。#   lowercase: 转换成小写。#   uppercase: 转换成大写。#   keep: 如果标签匹配，则保留整个采集目标。#   drop: 如果标签匹配，则丢弃整个采集目标。#   keepequal: 如果内部存在相同标签，则保留整个采集目标。#   dropequal: 如果内部存在相同标签，则丢弃整个采集目标。#   hashmod: 将源标签哈希取模的结果，赋值到目标标签。#   labelmap: 从源标签提取字段到目标标签。#   labeldrop: 从源标签中删除匹配的标签。#   labelkeep: 从源标签中保留匹配的标签。# 默认为 replace，即执行标签替换动作。action:&lt;relabel_action&gt;# 参考的源标签集合，注意这里是列表的标签串联形式，来给 action 执行操作时参考的来源指标集合。# 默认为空。source_labels:-&lt;labelname&gt;-&lt;labelname&gt;# 在 source_labels 中每个串联标签的连接符号，因为 relabel 里的 action 大部分都是针对文本操作的，需要将列表转换为文本组织。# 默认为 ; 符号，即产生的结果为 &lt;labelname&gt;;&lt;labelname&gt;;&lt;labelname&gt; 。separator:';'# 需要处理的目标指标，比如对比、新增、修改、删除等行为，需要使用此字段。# 默认为空。target_label:&lt;labelname&gt;# action 使用的正则匹配语句，可以针对 source_labels 串行后的文本，进行匹对、过滤、分组等正则操作。# 默认为 '(.*)'，即匹配所有。regex:&lt;regex&gt;# 如果 action 为 hashmod，使用这个参数来设置取模的数值。# 默认为空。modulus:0# 如果 action 里涉及标签替换的动作，将会使用此字段来构造目标字符串，这里可以使用 regex 里面的正则分组。# 默认为 $1，如果没分组则是整个匹配字符串，如果分组了，则为第一组。replacement:'$1'3.4.3.action常用操作示例在这里我们以consul服务发现为基础,使用consul的discoverLabels为例，对action的每个操作进行演示Before Relabeling:"__address__":"192.168.56.131:9273",#当前Target实例的地址&lt;host&gt;:&lt;port&gt;"__meta_consul_address":"192.168.56.131",#consul地址"__meta_consul_dc":"prod",#consul数据中心名称"__meta_consul_health":"passing",#target服务状态"__meta_consul_node":"consul-node",#consul名称"__meta_consul_service":"monitor_agent",#target在consul中注册的服务名称"__meta_consul_service_address":"192.168.56.131",#consul地址"__meta_consul_service_id":"telegraf-192.168.56.131-9273",#target注册到consul中的唯一标识"__meta_consul_service_metadata_monitorType":"monitor_agent",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_organization":"运维监控平台",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_project":"监控agent组件",#在target注册到consul时 自定义的meta"__meta_consul_service_metadata_version":"v1.22.4",#在target注册到consul时 自定义的meta"__meta_consul_service_port":"9273",#端口"__meta_consul_tagged_address_lan_ipv4":"192.168.56.131","__meta_consul_tagged_address_wan":"192.168.56.131","__meta_consul_tagged_address_wan_ipv4":"192.168.56.131","__meta_consul_tags":",telegraf,",#与服务关联的标签"__metrics_path__":"/metrics",#指定 Prometheus 用于抓取指标的路径"__scheme__":"http",#指定协议，默认为http"__scrape_interval__":"15s",#指定抓取的时间间隔"__scrape_timeout__":"10s",#指定抓取的超时时间"job":"consul-prometheus"#采集任务名称3.4.3.1. 标签转换之replace操作replace 是默认的动作，使用 regexp 的正则对串行源标签值做匹配，并将正则结果提取到目标标签。replace示例#因为默认操作就是replace,可以不用写relabel_configs:-source_labels:[__address__]regex:(.*):([0-9]+)replacement:'${1}'target_label:ip解释:source_labels 选择了需要的提取内容的源标签，然后会用 separator 将其标签值串行拼接起来，因为没有定义 separator，这里是默认的 ; 符号。因此，上述正则操作的文本内容应该为  192.168.56.131:9273;经过正则匹配后，replacement 规定了 $1的结果，其中 $1 正则匹配结果的第一组，并把这个结果赋值给 ip 这个标签。我们借助正则在线工具，查看整个过程，如下图所示最终，discoveredLabels 经过 relabel 后，产生的新标签 ip 也加入到了采集目标的全局标签内.
通过 targets 接口得到 labels 除了内置的标签外，新增了我们预期的标签，这个就是最基础的 relabel replace操作3.4.3.2. 标签转换之uppercase操作uppercase 的操作更加的简单，不需要正则处理，直接将源标签值转变为大写需求：将 __meta_consul_dc 转变为 env_dc 标签内容，并且要求值必须是大写字母relabel_configs:-action:uppercasesource_labels:[__meta_consul_dc]target_label:env_dc这个 action 不使用正则，因此可以忽略 regex 和 replacement，操作过程也更加简单
就是把 source_labels 指定的标签都转化为大写字母，赋值给 env_dc 标签，结果如下所示3.4.3.3. 标签转换之lowercase操作恰好与uppercase操作相反，同时也不需要正则处理，直接将源标签值转变为小写需求：将 上个操作将 uppercase 产生的大写字母标签 env_dc的值 再转变为小写字母的值relabel_configs:-action:lowercasesource_labels:[__meta_consul_dc]target_label:env_dc这个 action 不使用正则，因此可以忽略 regex 和 replacement，操作过程也更加简单
就是把 source_labels 指定的标签的值都转化为小写字母，赋值给 env_dc 标签，结果如下所示3.4.3.4. 标签转换之hashmod操作hashmod这个操作暂时还无法理解这个操作能带来什么收益，其实，这个主要是对 Prometheus 分片扩展设计的。
比如有 5 个 Prometheus，那么通过计算标签的哈希除以 5 取模
那么每个 Prometheus 都可以错开且均衡地采集指标，从而达到性能的水平扩展需求：对 __meta_consul_service_id 标签哈希取模，总数为 5，并赋值到 job 标签。relabel_configs:-action:hashmodsource_labels:[__meta_consul_service_id]target_label:jobmodules:5这是对一个已经存在的标签进行了重新赋值，而且是 Prometheus 内部标签 job。
job 标签确实非常关键，但是其仅仅在初始化这个 job_name 下的采集资源时使用，并且保留到采集目标的 labels 内，
但是，由 relabel 重定义或者采集目标自身提供了 job 标签的话，依旧可以将原有的 job 给替换掉
job 在初始化资源之后，就意味着并不再是神圣不可侵犯，我们可以按需对其进行调整.
以下是替换后的结果{"labels":{"instance":"192.168.56.131:9273","job":"1"}}注意：此处仅仅是举例说明，在实际使用中，建议还是保留 job 的原值，不要对这个内置标签做 relabel 操作，因为在排查定位时，可以使用 job 标签与 job_name 的名称，快速定位到 Prometheus 的配置块3.4.3.5. 标签转换之labelmap操作它的作用主要是从服务发现到的 discoveredLabels 标签里，根据正则匹配，提取出标签名并将原有的值赋值给对应的标签名。
上面介绍的那些操作，都还是需要指定标签名来处理标签值再将值赋值到 target_label 定义的目标标签里，其实没有对标签名称进行操作
而 labelmap 的亮点，就是能够适应地动态地产生标签名需求: 将 __meta_consul_service_metadata_ 为前缀的标签，去除前缀后，将键值对作为最终标签relabel_configs:-action:labelmapregex:'__meta_consul_service_metadata_(.+)'注意:这里不再依赖 source_labels，因为在 labelmap 里，regex 是对所有以__meta_consul_service_metadata_开头的标签匹配的3.4.3.6. 标签转换之labeldrop操作labeldrop 是考虑如何去除标签，它会将 regex 命中匹配的标签，从标签集合中去除，不再传递到 labels 字典里需求：将 job 标签去除relabel_configs:-action:labeldropregex:'^job$'补充一个知识点，Prometheus 里面，如果一个标签的值是空字符串，那么也意味着这个标签不存在。
既然这样，我们可以通过 replace 操作将标签重写为空字符串，实现跟 labeldrop 一样的效果relabel_configs:-source_labels:[job]target_label:jobreplacement:''3.4.3.7. 标签转换之labelkeep操作labelkeep 是相反的操作，仅保留匹配的标签，其他不匹配的则通通去除需求：只保留 instance 这个标签#错误配置示例relabel_configs:-action:labelkeepregex:'^instance$'#错误解读如果应用了上面的配置，则会得到如下的结果[root@python2 prometheus]# curl http://192.168.56.131:9090/api/v1/targets -uadmin:QAZXCFRF{"status":"success","data":{"activeTargets":[],"droppedTargets":[],"droppedTargetCounts":{"prometheus-core":0}}}此时会发现没有任何采集目标，也没有任何的标签集合。原因:1、 discoveredLabels 里面的标签也是服务发现传递给采集流程的初始化配置
2、采集流程还需要使用里面的 __address__ 来构造采集目标，如果被 relabel 清除了，那么就相当于服务发现没有给采集单元传递可以采集的 Targets，也意味着不会产生任何的 activeTargets#正确配置示例至少要保留采集需要的核心指标 (内部标签)，修改配置如下relabel_configs:-action:labelkeepregex:'^(instance|__.*?__)$'3.4.3.8. 采集控制之keep操作keep 是将标签满足匹配的 Targets，保留下来继续采集，其他的则丢弃 (drop)，不再采集，也不会再传入到下一步的 relabel 中。刚提到的 标签转换labelkeep操作，将标签全部清除后，导致采集丢失的现象，也大概能知道 keep 执行了那些类似的动作。但是 Prometheus 并不会主动把这些标签给清除 (remove)，而是作为被丢弃采集的对象，放到 droppedTargets 里记录。需求: 只保留__meta_consul_service 为 monitor_agent采集目标relabel_configs:-source_labels:['__meta_consul_service']regex:.*monitor_agent.*action:keep3.4.3.9. 采集控制之drop操作drop 是将标签满足匹配的 Targets，进行丢弃 (drop)，其他的继续采集，并会传入到 relabel 的下一步进行处理需求：丢弃 __meta_consul_service_id 为telegraf-192.168.56.131-9273的采集目标relabel_configs:-action:dropsource_labels:[__meta_consul_dc]regex:'^telegraf-192.168.56.131.*$'因为我的consul服务发现目前只注册了telegraf-192.168.56.131-9273这一个采集目标，因此发现的目标都能够正常采集3.4.3.10. 采集控制之keepequal操作keepequal 使用标签相等匹配，来判断 source_labels 里每个标签是否与 target_label 的相等，如果相等，则保留采集目标需求：保留__meta_consul_service和job_name一致的采集目标，不一致的被丢弃relabel_configs:-action:keepequalsource_labels:[__meta_consul_tagged_address_lan]target_label:job3.4.3.11. 采集控制之dropequal操作dropequal使用标签相等匹配，来判断source_labels里每个标签是否与target_label 的相等，如果相等，则丢弃(drop)采集目标需求：只采集与 job_name 同名的服务relabel_configs:-action:dropequalsource_labels:[__meta_consul_service]target_label:job我的注册服务是 monitor_agent，而 Prometheus 配置的 job_name 是 consul-prometheus，
那么会发现采集目标会被添加到 activeTargets 开始采集。
如果两者一致则会被添加到dropTargets中，不进行采集4.构造标签目的:一些指标的标签并不是我们直接需要的，某些时候我们需要提取、组装或清洗部分标签，来达到提升标签查询准确率、提高 PromQL 查询关联性和减少存储空间占用等作用，这些都依赖于 relabel 的链式执行效果，让监控标签可以灵活运用四、监控规则1.规则分类Prometheus支持两种类型的规则:记录规则和警报规则。 
要在Prometheus中包含规则，请创建一个包含必要规则语句的文件，并让Prometheus通过Prometheus配置中的rule_files字段加载规则文件。如下所示2.警报规则警报规则 rules 使用的是 yaml 格式进行定义，Prometheus 会根据设置的警告规则 Ruels 以及配置间隔时间进行周期性计算，当满足触发条件规则会发送警报通知。 
警报规则加载的是在 prometheus.yml 文件中进行配置，默认的警报规则进行周期运行计算的时间是1分钟，可以使用 global 中的 evaluation_interval 来决定时间间隔3.警报规则示例在告警规则模版中，可以将相关的规则设置在一个groups下面，一个groups可以定义多个告警规则。alert：告警规则的名称。groups:-name:operationsrules:-alert:node-downexpr:up{env="operations"}!=1for:5mlabels:status:Highteam:operationsannotations:description:"Environment: {{ $labels.env }} Instance: {{ $labels.instance }} is Down ! ! !"value:'{{ $value }}'summary:"The host node was down 20 minutes ago"参数解读:expr:基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。for:评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。labels:自定义标签，允许用户指定要附加到告警上的一组附加标签。annotations:用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。4.报警状态告警分成 3 个状态，Inactive、Pending、FiringInactive:非活动状态，表示正在监控，但是还未有任何警报触发 ，正是HostDown规则的状态。Pending:表示这个警报必须被触发。由于警报可以被分组、压抑/抑制或静默/静音，所以等待验证，一旦所有的验证都通过，则将转到 Firing,比如MemUtil 规则 设置for 1m，表示触发规则连续一分钟才会告警，我们在prometheus.yml 设置了evaluation_interval的执行频率为15s 得连续4次都触发阈值才告警。Firing:将警报发送到 AlertManager，它将按照配置将警报的发送给所有接收者。一旦警报解除，则将状态转到 Inactive，如此循环。5.警报规则编写5.1.从指定网址获取规则并进行修改https://samber.github.io/awesome-prometheus-alerts/rules虽然上述规则是node_exporter组件对应的规则文件，我们使用的是telegraf，其实相差不大，我们可以参考该配置文件进行修改即可使用5.2.自定义编写告警规则文件该方法会在prometheus+telegraf自定义监控指标文章中进行描述总结标签重写 (relabel) 是 Prometheus 技术栈里非常关键的一环，对整个监控周期里的服务发现、采集请求、数据写入、规则计算、告警通知和分布式监控等阶段都产生巨大的影响，如果能够掌握这门技巧，并且灵活应用到各个方面，相信 Prometheus 架构也能够为自身带来非常多的功能回馈。如果这一篇章的内容你还无法全部吃透，非常建议你收藏此文，在需要的时候翻阅，重新认识一遍这方面的内容，甚至在需要的时候，可以直接将案例中的配置进行修改，就可以应用到你的生产环境。http://www.ppmy.cn/news/1540987.html相关文章【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案echarts动态排序图背景色动画不同步 echarts试一试 
series下面添加了showBackground属性&amp;#xff0c;动画时底色背景不同步跟随柱图 
showBackground: true,
backgroundStyle: {borderRadius: 9,color: RGB(255,199,91, 0.2)
}const data  [];
for (let i  0; i &lt; 5; i) {d…阅读更多...简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:07 +0000</pubDate>
    </item>
    <item>
      <title>【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案</title>
      <link>https://www.ppmy.cn/news/1540986.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【Echarts动态排序图，series使用背景色更新动画，背景底色不同步跟随柱子动画】大家有没有解决方案news/2025/11/1 0:24:05/echarts动态排序图背景色动画不同步echarts试一试series下面添加了showBackground属性，动画时底色背景不同步跟随柱图showBackground:true,backgroundStyle:{borderRadius:9,color:'RGB(255,199,91, 0.2)'}constdata=[];for(leti=0;i&lt;5;++i){data.push(Math.round(Math.random()*200));}option={xAxis:{max:'dataMax'},yAxis:{type:'category',data:['A','B','C','D','E'],inverse:true,animationDuration:300,animationDurationUpdate:300,max:4// only the largest 3 bars will be displayed},series:[{realtimeSort:true,name:'X',type:'bar',data:data,label:{show:true,position:'right',valueAnimation:true},showBackground:true,backgroundStyle:{borderRadius:9,color:'RGB(255,199,91, 0.2)'},animation:true}],legend:{show:true},animationDuration:0,animationDurationUpdate:3000,animationEasing:'linear',animationEasingUpdate:'linear',animation:true};functionrun(){for(vari=0;i&lt;data.length;++i){if(Math.random()&gt;0.9){data[i]+=Math.round(Math.random()*2000);}else{data[i]+=Math.round(Math.random()*200);}}myChart.setOption({series:[{type:'bar',data}]});}setTimeout(function(){run();},0);setInterval(function(){run();},2000);http://www.ppmy.cn/news/1540986.html相关文章简述 C# 二维数据集合 List 的创建、遍历、修改、输出简述 C# 二维数据集合 List 的创建、遍历、修改、输出 1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List&amp;#xff0c;数据类型 int5、 简单访问元素6、遍历二维列表&amp;#xff0c;控制台输出7、遍历二维列表&amp;#xff0c;修改数据&amp;#…阅读更多...Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:05 +0000</pubDate>
    </item>
    <item>
      <title>简述 C# 二维数据集合 List 的创建、遍历、修改、输出</title>
      <link>https://www.ppmy.cn/news/1540985.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维简述 C# 二维数据集合 List 的创建、遍历、修改、输出news/2025/11/1 0:24:03/简述 C# 二维数据集合 List 的创建、遍历、修改、输出1、为什么要使用列表 List2、引入命名空间3、声明一维列表 List4、声明创建一个二维列表 List，数据类型 int5、 简单访问元素6、遍历二维列表，控制台输出7、遍历二维列表，修改数据，控制台输出，采用 Join 输出行数据8、删除列表行，索引默认从零开始9、删除集合中一定范围内的元素，索引默认从零开始10、在列表索引前插入元素11、List的方法和属性、方法或属性作用1、为什么要使用列表 List当我们有很多类型一样的数据时，可以使用数组来进行存储并管理，但是数组的缺点：C# 数组的大小必须提前给定的、是固定的，不像 VB 数组可以自由按量变化。 如果我们有许多数据类型一样，但数量不定的数据，当获取的数据数量超过数组定义，数组将发生数据溢出错误，这时候可以使用集合类来进行管理——例如列表 List。我们可以使用列表 List 很方便的添加数据，删除数据以及其他的一些数据操作，便于方便数据操作，List 操作比数组更加灵活。List 类是 ArrayList 类的泛型等效类，该类使用大小可按需动态增加的数组实现 IList 泛型接口。泛型的好处：它为使用C#语言编写面向对象程序增加了极大的效力和灵活性。不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高。性能注意事项：在决定使用 IList 还是使用 ArrayList 类(两者具有类似的功能)时，记住 IList 类在大多数情况下执行得更好并且是类型安全的。如果对 IList 类的类型 T 使用引用类型，则两个类的行为是完全相同的。但是，如果对类型 T 使用值类型，则需要考虑实现和装箱问题。2、引入命名空间usingSystem;usingSystem.Collections.Generic;3、声明一维列表 ListList&lt;T&gt;mList=newList&lt;T&gt;();T 为列表中元素类型，即数据类型。4、声明创建一个二维列表 List，数据类型 int//声明新的二维列表 List：twoDimensionalListList&lt;List&lt;int&gt;&gt;twoDimensionalList=newList&lt;List&lt;int&gt;&gt;();// 初始化二维列表 List ，添加 3 行 4 列twoDimensionalList.Add(newList&lt;int&gt;{1,2,3,4});//添加一维 List 元素twoDimensionalList.Add(newList&lt;int&gt;{5,6,7,8});twoDimensionalList.Add(newList&lt;int&gt;{9,10,11,12});5、 简单访问元素intelement=twoDimensionalList[0][1];// 获取第一行第二个元素，值为2Console.WriteLine(element);Console.WriteLine();A 输出：26、遍历二维列表，控制台输出// 获取二维列表行数introwCount=twoDimensionalList.Count;// 获取二维列表列数intcolumnCount=twoDimensionalList.Count==0?0:twoDimensionalList[0].Count;//遍历二维列表，控制台输出foreach(List&lt;int&gt;rowintwoDimensionalList){foreach(intiteminrow){Console.Write(item+" ");//控制台调试显示数据}Console.WriteLine();}Console.WriteLine();B 输出：1 2 3 45 6 7 89 10 11 127、遍历二维列表，修改数据，控制台输出，采用 Join 输出行数据for(inti=0;i&lt;rowCount;i++){for(intj=0;j&lt;columnCount;j++){twoDimensionalList[i][j]+=1;//修改数据，二维数据每个数加 1}}//遍历二维列表，控制台输出，采用 Join 输出行数据foreach(varrowintwoDimensionalList){Console.WriteLine(string.Join(" ",row));}C 输出：2 3 4 5 //索引为 06 7 8 9 //索引为 110 11 12 13 //索引为 28、删除列表行，索引默认从零开始数据继 C 输出：twoDimensionalList.RemoveAt(2);//删除索引 2 的行数据输出：2 3 4 56 7 8 99、删除集合中一定范围内的元素，索引默认从零开始数据继 C 输出：twoDimensionalList.RemoveRange(0,2);//从索引 0 开始，删除 2 行数据输出：10 11 12 1310、在列表索引前插入元素数据继 C 输出：twoDimensionalList.Insert(1,newList&lt;int&gt;{15,16,17,18});输出：2 3 4 515 16 17 186 7 8 910 11 12 1311、List的方法和属性、方法或属性作用List 的方法和属性在二维数组中同样可以操作，先从一维 List 数据处理开始学习吧 😁😁😁Capacity 用于获取或设置 List 可容纳元素的数量。当数量超过容量时，这个值会自动增长。可以设置这个值以减少容量，也可以调用trin()方法来减少容量以适合实际的元素数目。Count 属性，用于获取数组中当前元素数量Item( ) 通过指定索引获取或设置元素。对于List类来说，它是一个索引器。Add( ) 在List中添加一个对象的公有方法AddRange( ) 公有方法，在List尾部添加实现了ICollection接口的多个元素BinarySearch( ) 重载的公有方法，用于在排序的List内使用二分查找来定位指定元素.Clear( ) 在List内移除所有元素Contains( ) 测试一个元素是否在List内CopyTo( ) 重载的公有方法，把一个List拷贝到一维数组内Exists( ) 测试一个元素是否在List内Find( ) 查找并返回List内的出现的第一个匹配元素FindAll( ) 查找并返回List内的所有匹配元素GetEnumerator( ) 重载的公有方法，返回一个用于迭代List的枚举器Getrange( ) 拷贝指定范围的元素到新的List内IndexOf( ) 重载的公有方法，查找并返回每一个匹配元素的索引Insert( ) 在List内插入一个元素InsertRange( ) 在List内插入一组元素LastIndexOf( ) 重载的公有方法，，查找并返回最后一个匹配元素的索引Remove( ) 移除与指定元素匹配的第一个元素RemoveAt( ) 移除指定索引的元素RemoveRange( ) 移除指定范围的元素Reverse( ) 反转List内元素的顺序Sort( ) 对List内的元素进行排序ToArray( ) 把List内的元素拷贝到一个新的数组内trimToSize( ) 将容量设置为List中元素的实际数目http://www.ppmy.cn/news/1540985.html相关文章Kubernetes集群搭建容器云需要几台服务器？Kubernetes集群搭建容器云需要几台服务器&amp;#xff1f;至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤&amp;#xff0c;会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述&amp;#xff1a; 一…阅读更多...css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:03 +0000</pubDate>
    </item>
    <item>
      <title>Kubernetes集群搭建容器云需要几台服务器？</title>
      <link>https://www.ppmy.cn/news/1540984.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Kubernetes集群搭建容器云需要几台服务器？news/2025/11/1 0:24:02/Kubernetes集群搭建容器云需要几台服务器？至少需要4台服务器。搭建容器云所需的服务器数量以及具体的搭建步骤，会根据所选用的技术栈、业务规模、架构设计以及安全需求等因素而有所不同。以下是一个基于Kubernetes集群的容器云搭建的概述：一、所需服务器数量Kubernetes集群部署通常分为单控制节点模式和多控制节点模式。单控制节点模式：至少需要四台服务器，其中一台作为控制节点（Master），其余三台作为工作节点（Worker）。然而，单控制节点模式存在单点故障的风险，因此在实际生产环境中较少使用。多控制节点模式：为了提高系统的可靠性和容错性，通常会采用多控制节点模式。例如，三控制节点模式至少需要六台服务器，其中三台作为控制节点，另外三台作为工作节点。此外，还可以根据业务规模和需求增加更多的工作节点。除了上述的Kubernetes集群节点外，还需要单独准备一台安装了Jenkins或其他CI/CD工具的服务器，用于执行部署脚本和自动化部署流程。二、容器云搭建步骤1.准备工作确保所有服务器已安装Linux系统，并进行了基本的网络配置。准备好Kubernetes的安装包和相关依赖。2.安装Kubernetes集群在控制节点上安装Kubernetes的Master组件，包括APIServer、etcd、ControllerManager和Scheduler等。在工作节点上安装Kubernetes的Node组件，包括kubelet、kube-proxy和容器运行时（如Docker或containerd）。配置Kubernetes集群的证书、密钥和配置文件，确保集群的安全性和通信。3.配置网络选择并安装一个Kubernetes网络插件（如Calico、Flannel或Weave等），用于实现集群内Pod之间的网络通信。配置Service网段和Pod网段，确保网络不冲突。4.部署CI/CD工具在单独的服务器上安装Jenkins或其他CI/CD工具。配置Jenkins与Kubernetes集群的集成，包括设置Kubernetes插件、配置Pipeline脚本等。5.部署应用使用kubectl命令行工具或KubernetesDashboard等图形化界面，将应用部署到Kubernetes集群中。配置应用的Pod、Service、Ingress等资源，确保应用能够正常运行和访问。6.监控和日志部署监控工具（如Prometheus和Grafana）和日志收集工具（如ELKStack或Fluentd），用于监控集群状态和收集应用日志。配置告警和通知机制，以便在集群或应用出现故障时及时收到通知。7.安全加固配置Kubernetes集群的RBAC（基于角色的访问控制）策略，限制不同用户对集群资源的访问权限。定期更新和升级Kubernetes集群和应用的依赖库和补丁，以确保系统的安全性。8.备份和恢复配置Kubernetes集群的备份和恢复策略，包括备份etcd数据、持久化存储卷等。定期进行备份和恢复测试，以确保在出现故障时能够迅速恢复集群和应用的正常运行。综上所述，Kubernetes集群搭建容器云需要几台服务器？搭建容器云需要多台服务器，并且需要按照一定的步骤进行配置和部署。在实际操作中，还需要根据具体的业务需求和架构设计进行调整和优化。更多容器云相关内容，请关注Petaexpress！​http://www.ppmy.cn/news/1540984.html相关文章css的思考CSS思考[vue react tailwindcss] 
传统css 
全局作用域: 一旦生效&amp;#xff0c;应用于全局&amp;#xff0c;造成各种各样的冲突&amp;#xff0c;为了避免冲突&amp;#xff0c;会写复杂的id选择器和类选择器依赖问题&amp;#xff1a;引入多个css样式文件&amp;#xff0c;引入的css文件会对后面的css文…阅读更多...hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:02 +0000</pubDate>
    </item>
    <item>
      <title>css的思考</title>
      <link>https://www.ppmy.cn/news/1540983.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维css的思考news/2025/11/1 0:24:01/CSS思考[vue react tailwindcss]传统css全局作用域: 一旦生效，应用于全局，造成各种各样的冲突，为了避免冲突，会写复杂的id选择器和类选择器依赖问题：引入多个css样式文件，引入的css文件会对后面的css文件造成影响打破隔离: 一旦涉及到一组样式，但是又有新的样式产生，可能会对原有的样式产生影响解决方法vue在vue中，使用了scope css的方式来保证样式的唯一性，标签上不重复的生成data属性表示唯一性，编译后的css上也会生成这个选择器reactcss in js不是本身有的，是外部提供的css in js使用JavaScript作为语言以声明和可维护的方式描述样式。 它是一个高性能的JS到CSS编译器，它在运行时和服务器端工作。扩展内联样式限制：支持所有的css原生功能范围界定：唯一的选择器类名自动确定当前的 class 作用域，选择器之间无冲突自动添加前缀：CSS 规则可以控制​自动添加前缀代码共享：轻松地在 JS 和 CSS 之间共享常量和函数，灵活方便操作控制轻量页面样式：只生成页面上当前 DOM 树会用到的样式在css in js中，hash会用于u企鹅人一段style是否插入，计算hash的方法就是将一段完整的css转换为hash。编写代码写的不是i最终的css，每次都需要重新序列化得到css然后再次计算hash，为渲染组件带来了额外的开销。react中编写css的几种方法使用className内联样式 {{color: “red”}}css-loader(css-module)importstylesfrom'./App.css'constApp=props=&gt;{return(&lt;div className={style.app}&gt;123&lt;/div&gt;&lt;div className={style['form-item']}&gt;456&lt;/div&gt;)css-in-jsimport{css,jsx}from'@emotion/core'constcolor='white'constApp=props=&gt;{return(&lt;divclassName={css`padding: 32px;background-color: hotpink;font-size: 24px;border-radius: 4px;`}&gt;This is test.&lt;/div&gt;)}emotionimportReactfrom'react';import{css}from'emotion'constcolor='white'functionApp(){return(&lt;div className={css`padding: 32px;background-color: hotpink;font-size: 24px;border-radius: 4px;&amp;:hover {color:${color};}`}&gt;This is emotion test&lt;/div&gt;);}exportdefaultApp;&lt;html lang="en"&gt;&lt;head&gt;&lt;title&gt;React App&lt;/title&gt;&lt;style data-emotion="css"&gt;.css-czz5zq{padding:32px;background-color:hotpink;font-size:24px;border-radius:4px;}&lt;/style&gt;&lt;style data-emotion="css"&gt;.css-czz5zq:hover{color:white;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="root"&gt;&lt;divclass="css-czz5zq"&gt;This is React.js test&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;将样式写模板字符串根据模板字符串生成class名，然后写道组件的class中将生成的class名称以及class内容放到script组件中，然后放到html的head中postcsspostcss提供了一个解析器，能够将css转换为抽象语法树，能够为css提供额外的功能，利用postcss的功能，开发一些插件，处理css组成： css parser css节点数 source map生成器 生成节点树串css =&gt; parse =&gt; plugin 1 =&gt; plugin 2 =&gt; ... =&gt; stringifier =&gt; new css读取css文件，通过parser将css解析为抽象语法树，将抽象语法树传递给任意数量的插件处理，通过诸多插件进行数据处理，插件见传递的数据就是ast树，将处理完成的ast转换为字符串。tailwindcss存在jit(just in time)，在编译过程中去扫描html文件，然后生成对应的样式。http://www.ppmy.cn/news/1540983.html相关文章hadoop_hdfs详解HDFS秒懂 HDFS定义HDFS优缺点优点缺点 HDFS组成架构NameNodeDataNodeSecondary NameNodeClient NameNode工作机制元数据的存储启动流程工作流程 Secondary NameNode工作机制checkpoint工作流程 DataNode工作机制工作流程数据完整性 文件块大小块太小的缺点块太大的缺点 文件写入…阅读更多...《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:01 +0000</pubDate>
    </item>
    <item>
      <title>hadoop_hdfs详解</title>
      <link>https://www.ppmy.cn/news/1540982.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维hadoop_hdfs详解news/2025/11/1 0:24:00/HDFS秒懂HDFS定义HDFS优缺点优点缺点HDFS组成架构NameNodeDataNodeSecondary NameNodeClientNameNode工作机制元数据的存储启动流程工作流程Secondary NameNode工作机制checkpoint工作流程DataNode工作机制工作流程数据完整性文件块大小块太小的缺点块太大的缺点文件写入流程机架感知作用策略文件读取流程HDFS的shell操作HDFS定义HDFS（Hadoop Distributed File System）是一个分布式的文件系统，用户存储文件，通过目录树来定位文件，适合一次写入，多次读出的场景，不支持文件的修改HDFS优缺点优点高容错性：数据保存在多个副本，某一个副本数据丢失后，可以自动恢复适合处理大数据：数据规模可达到GB、TB级，能够处理百万规模的文件数量可构建在廉价的机器上：通过多副本机制，提高可靠性缺点不适合低延时数据访问：毫秒级的存储是做不到的无法高效的对大量小文件进行存储：小文件的寻址时间会超过读取时间不支持并发写入和文件随机修改：一个文件只能一个写，不允许多个线程同时写；仅支持数据追加，不支持文件修改HDFS组成架构NameNodeNN，Master,它是一个主管、管理者保存HDFS上所有文件的元数据维护副本数管理数据块（block）的映射信息处理客户端请求DataNodeDN，就是Slave,数据节点存储数据块执行对数据块的操作Secondary NameNode2NN，不是NN的热备辅助NameNode分担工作量， 定期进行checkpoint紧急情况下，可辅助恢复NameNodeClient客户端通过命令管理和访问HDFS文件切分与合并NameNode工作机制元数据的存储元数据存储在fsiamge文件和edits文件中了解NameNode的文件1、fsimage：NameNode内存中元数据序列化后形成的文件，元数据的快照文件fsimage文件的产生：1）第一次格式化NN时，此时会创建NN的工作目录，在目录中生成一个fsimage_000...000文件2）当NN在启动时，NN会将所有的edits文件和fsiamge文件加载到内存合并得到最新的元数据，将元数据持久化到磁盘生成新的fsimage文件3）如果启用了2NN,2NN也会辅助NN合并元数据，并将合并后的元数据发送给NN
查看faimage文件:语法：hdfs oiv -p 文件类型 -i 镜像文件 -o 转换后文件输出路径实例：hdfs oiv -p XML -i fsimage_0000000005067017090 -o /opt/fsimage.xml2、fsimage_xxx.md5：是对应文件的md5值文件，用来保证fsimage的一致性3、edits：记录客户端更新元数据信息的每一步操作txid:每次更新元数据的写操作命令会被分解为若干步，每一步都会有一个id，这个id称为txid，也叫事务id
edits文件的产生：NN在启动之后，每次更新元数据的操作，都会将命令记录到edits_inprogress文件中，当达到指定条件之后，会进行滚动生成edits_txid文件，同时生成新的edits_inprogress文件来记录新的操作，等edits_inprogress文件再次满足条件后继续滚动，以此循环
edits_inprogress的滚动条件：1）操作次数：默认txid达到100万次，会自动滚动生成edits文件，参数可配置2）时间：默认每2分钟文件自动滚动生成edits文件，时间可配置3）重启：当NN被重启的时候，也会自动触发edits_inprogress的滚动4）手动执行滚动：通过命令hdfs dfsadmin -rollEdits强制滚动edits_inprogress
查看edits文件:语法：hdfs oev -p 文件类型 -i编辑日志 -o 转换后文件输出路径实例：hdfs oev -p XML -i edits_0000000005067128882-0000000005067142023 -o /opt/edits.xml4、edits_inprogress：正在使用的编辑日志文件5、seen_txid：文件保存的是一个数字，是edits记录里txid的最后一个数字6、VERSION：记录的是NameNode的集群信息namespaceID ： 文件系统的唯一标识符，管理一组blockpoolID
clusterID：    集群ID
cTime：        NameNode存储系统的创建时间
storageType：  说明该存储目录包含的是NameNode的数据结构
blockpoolID：  针对每一个NamespaceID所对应的blockpool的ID
layoutVersion：HDFS永久性数据结构的版本信息每次格式化NN，会产生一个VERSION文件，重新生成clusterID和blockpoolID，blockpoolID会被DN领取，生成一个同名的目录，每次DN启动时，
会将这个同名目录中的块上报给NN，DN在第一次启动时，如果没有VERSION信息，会向配置文件中配置的NN发起请求，生成VERSION，加入到集群启动流程加载fsimagefsimage文件记录了自最后一次检查点之前HDFS文件系统中所有目录和文件的序列化信息加载editsedits文件记录了最后一次检查点之后所有针对HDFS文件系统的操作，加载了这两个文件后确保了数据的完整性和一致性记录checkpoint在NN启动时，edits_inprogress文件会回滚，也会再生成一个新的fsimage文件，这样在本次启动之前的所有数据都被保存，记录本次检查点，以便更新新的操作安全模式在加载完fsimage和edits文件后，NN开始监听DN请求，在这个过程期间，NN一直运行在安全模式，在安全模式下只能进行有限的读操作，不能对hdfs文件系统做任何修改，各个DN会向NN上报最新的块信息，在整个系统中99.9%的块满足至少有一个副本，NN会在30秒后退出安全模式# 基本语法
hdfs dfsadmin -safenode get     （功能描述：查看安全模式状态）
hdfs dfsadmin -safenode enter  	（功能描述：进入安全模式状态）
hdfs dfsadmin -safemode leave	（功能描述：离开安全模式状态）
hdfs dfsadmin -safemode wait	（功能描述：等待安全模式状态，hdfs接收的命令会等待，待离开安全模式后依次执行）工作流程Secondary NameNode工作机制checkpointcheckpoint是一种HDFS元数据的备份机制，元数据信息依据触发条件被定期写入持久化存储checkpoint 默认触发条件每隔1小时触发一次edits产生了100万次的操作记录工作流程DataNode工作机制工作流程DataNode启动后向NameNode注册，通过后，每1小时向NameNode上报所有的块信息每3秒一次心跳，心跳返回结果带有NameNode给该DataNode的命令如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用数据完整性一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳当DataNode读取Block的时候，它会计算CheckSum（校验和）如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏Client会复制其他DataNode上的BlockDataNode在其文件创建后周期验证CheckSum文件块大小HDFS中的文件存储在物理上是分块存储（block），Hadoop1.x默认大小是64M，Hadoop2.x默认大小是128M块的大小设置基于最佳传输损耗理论！在一次传输中，寻址时间占用总传输时间的1%时，本次传输的损耗最小，为最佳性价比传输！目前硬件的发展条件，普通磁盘写的速率大概为100M/S, 寻址时间一般为10ms!一次传输时间就是1s，所以块的最佳大小为100M，块的大小最好为2的n次方，所以最接近的就是128M，如果磁盘的传输速率很快，例如是300M/S，那么块大小就可以调整到 256M，可以通过dfs.blocksize参数进行设置。块太小的缺点同样大小的文件在存储时，块太小会占用更多的NN的元数据空间在进行读写操作时，DFS存储了大量的小文件，会消耗额外的寻址时间块太大的缺点块太大，在读取块内某一部分数据场景时，需要将整个块下载后再读取内容，会带来更多额外的网络消耗，不够灵活在上传文件时，一旦发生故障，需要将整个块文件重新上传，那么之前上传文件的资源开销就会浪费默认块大小为128M，128M指的是每个块最多存储128M的数据，如果当前块存储的数据不满128M，那么存了多少数据，就占用多少的磁盘空间！一个块只属于一个文件！文件写入流程流程详细说明流程5：客户端根据返回的DN节点，请求建立传输通道，客户端向最近的DN节点发起通道建立请求，由这个DN节点依次向通道中的距离当前节点距离最近的下一个节点发送建立通道请求，各个节点发送响应，通道建立成功流程7：客户端每读取64K的数据会封装为一个packet（数据包），每个packet为64K，由若干个chunks组成，每个chunks是512B，还会包含一个checksum（校验和），封装成功的packet会放到一个叫做dataQuene的队列中，按顺序发送到通道里第一个DN节点，节点收到packet之后，再送到通道的下一个节点，发送过之后的packet会被放入到ackQuene队列里，当所有的DN节点返回了成功的ack确认消息，这个packet会在ackquene队列中删除。一旦发生错误，ackQuene队列里的小包会回滚到dataQuene，在原始通道里把坏的节点剔除掉，再重新建立一个新的通道继续传输。ACK (Acknowledge Character）即是确认字符，在数据通信中，接收方发给发送方的一种传输类控制字符。表示发来的数据已确认接收无误。在 pipeline 管道传输数据的过程中，传输的反方向会进行ACK校验，确保数据传输安全流程8：第一个块传输完成后，DN向NN上报块的消息，只要有一个DN节点上报块信息,NN就认为这个块已经传输完成，通道关闭，开始下一个块的传输，重复3-8的流程副本数如果暂时不满足条件，之后NN会自动检查，维护副本数机架感知机架感知是一种能够识别集群中各个节点所属机架，并在任务调度和数据块副本放置时利用这些信息来优化数据传输和任务执行效率作用提高数据传输效率增强容错能力优化任务调度策略第一个副本放在本地机架的一个DN节点第二个副本放在本地机架的另一个DN节点（本地机架的网络拓扑距离最多为2，速度快）第三个副本放在其他机架的一个DN节点（考虑安全性）更多的副本，放置在相对空闲的其他DN节点上文件读取流程流程3：NN将文件所对应block的存储地址放入一个队列，客户端从队列中依次按每一个block对应地址来取出数据，也是按照packet进行读取，读取的时候可以多个DN一起读取流程4：读取完一个block之后，会对这个block进行一次checksum验证，验证这个block的数据总量是否正确。如果不一致，说明这个block已损坏，客户端会通知NN,再从其他节点上读取该block,NN收到消息会重新备份一次,并发指令给这个DN将这个坏的block删掉HDFS的shell操作bin/hadoop fscommandOR
bin/hdfs dfscommand# hadoop fs :  既可以对本地文件系统进行操作还可以操作分布式文件系统# hdfs dfs :   只能操作分布式文件系统常用命令实例# 查看文件目录hadoop fs -ls# 创建目录hadoop fs -mkdir# 删除文件或目录hadoop fs -rm# 移动或更名文件hadoop fs -mvhttp://www.ppmy.cn/news/1540982.html相关文章《汇编语言》笔记一 寄存器通用寄存器 
8086CPU的所有的寄存器都是16位的&amp;#xff0c;可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。 一个16位寄存器可以存储一个16位的数据。 
8086CPU的上一代CPU中的寄存器都是8位&amp;#xff0c;为了保证兼容&amp;#xff0c;使原来基于上代CPU编写的程序稍加修…阅读更多...小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:24:00 +0000</pubDate>
    </item>
    <item>
      <title>《汇编语言》笔记一 寄存器</title>
      <link>https://www.ppmy.cn/news/1540981.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维《汇编语言》笔记一 寄存器news/2025/11/1 0:23:59/通用寄存器8086CPU的所有的寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器为通用寄存器。一个16位寄存器可以存储一个16位的数据。8086CPU的上一代CPU中的寄存器都是8位，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上8086CPU的 AX、BX、CX、DX、这4个寄存器可以分为两个独立使用的8位寄存器来用字在寄存器中的存储8086CPU可以一次性处理以下两种尺寸的数据字节：byte，一个字节由8个bit组成，可以存在8位寄存器中字：word，一个字由两个字节组成，两个字节分别称为这个字的高位字节和低位字节汇编指令汇编指令CPU操作高级语言mov ax,18将18送入寄存器AXAX=18mov ah,78将78送入寄存器AHAH=78add ax,8将寄存器AX中的数值加上8AX=AX+8mov ax,bx将寄存器BX中的数据送入寄存器AXAX=BXadd ax,bx将AX和BX中的数值相加，结果存在AX中AX=AX+BX程序段指令执行情况 （原AX的值：0000H 原BX的值：0000H）程序段中的指令指令执行后AX中的数据指令执行后BX中的数据mov ax,4E20H4E20H0000Hadd ax,1406H6226H0000Hmov bx,2000H6226H2000Hadd ax,bx8226H2000Hmov bx,ax8226H8226Hadd ax,bx044CH8226H程序段中的最后一条指令 add ax,bx，在执行前 ax和 bx 中的数据都为 8226H，相加后所得的值为:1044CH，但是 ax 为 16 位寄存器，只能存放 4位十六进制的数据，所以最高位的 1不能在 ax 中保存，ax中的数据为:044CH。程序段指令执行情况 （原AX的值：0000H 原BX的值：0000H）程序段中的指令指令执行后AX中的数据指令执行后BX中的数据mov ax,001AH001AH0000Hmov bx,0026H001AH0026Hadd al.bl0040H0026Hadd ah,bl2640H0026Hadd bh,al2640H4026Hmov ah,00040H4026Hadd al,85H00C5H4026Hadd al,93H0058H4026H程序段中的最后一条指令 add al,93H，在执行前，al 中的数据为 C5H，相加后所得的值为:158H，但是 a1为8位寄存器，只能存放两位十六进制的数据，所以最高位的1丢失，ax 中的数据为:0058H。段地址x16+偏移地址=物理地址 本质含义“段地址x16+偏移地址=物理地址”的本质含义是:CPU 在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。“基础地址+偏移地址=物理地址”的思想你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址:(1)从学校走 2826m 到图书馆。这 2826m 可以认为是图书馆的物理地址。(2)从学校走 2000m 到体育馆，从体育馆再走 826m 到图书馆。第一个距离 2000m,是相对于起点的基础地址，第二个距离 826m 是相对于基础地址的偏移地址(以基础地址为起点的地址)。第一种方式是直接给出物理地址 2826m，而第二种方式是用基础地址和偏移地址相加来得到物理地址的。第二个比喻进一步说明“段地址x16+偏移地址=物理地址”的思想。比如，只能通过纸条来互相通信，你问我图书馆的地址我只能将它写在纸上告诉你。显然，我必须有一张可以容纳4位数据的纸条，才能写下 2826 这个数据。可不巧的是，我没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。这样我只能以这种方式告诉你 2826 这个数据。在第一张纸上写上 200(段地址)，在第二张纸上写上 826(偏移地址)。假设我们事前对这种情况又有过相关的约定:你得到这两张纸后，做这样的运算:200(段地址)x10+826(偏移地址)=2826(物理地址)。8086CPU 就是这样一个只能提供两张3位数据纸条的CPU。段的概念内存并没有分段，段的划分来自于CPU，由于 8086CPU 用“基础地址(段地址x16)+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。可以认为:地址10000H~100FFH 的内存单元组成一个段，该段的起始地址(基础地址)为10000H，段地址为1000H，大小为100H;我们也可以认为地址 10000H1007FH、10080H100FFH 的内存单元组成两个段，它们的起始地址(基础地址)为:10000H和10080H，段地址为:1000H和1008H，大小都为80H。段寄存器段地址在 8086CPU 的段寄存器中存放。8086CPU有4个段寄存器:CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。CS和IPCS为代码段寄存器 IP为指令指针寄存器在 8086PC 机中，任意时刻，设CS 中的内容为 M，P 中的内容为N，8086CPU 将从内存 Mx16+N 单元开始，读取一条指令并执行。执行指令工作原理修改CS、IP指令jmp指令同时修改CS IP的内容，可以使用 jmp段地址：偏移地址的指令完成jmp 2AE3:3CS=2AE3H,IP=0003HCPU将从2AE33H处读取指令jmp 3:0B16CS=0003H,IP=0B16HCPU将从00B46HH处读取指令只下IP的内容jmp ax执行前ax=1000H,CS=2000H,IP=0003H执行后ax=1000H,CS=2000H,IP=1000Hjmp bx执行前bx=0B16H,CS=2000H,IP=0003H执行后bx=0B16H,CS=2000H,IP=0B16Hhttp://www.ppmy.cn/news/1540981.html相关文章小程序底部导航按钮实现商城小程序需要四个底部导航按钮&amp;#xff0c;遂记录一下实现过程 
最终实现效果如下所示 新建一个小程序项目&amp;#xff0c;我是创建了JS模板&amp;#xff0c;项目创建完成后需要新建五个文件夹&amp;#xff0c;其中四个&amp;#xff08;page子文件夹&amp;#xff09;用于存放pages文件&amp;#xff0…阅读更多...外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:59 +0000</pubDate>
    </item>
    <item>
      <title>小程序底部导航按钮实现</title>
      <link>https://www.ppmy.cn/news/1540980.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维小程序底部导航按钮实现news/2025/11/1 0:23:58/商城小程序需要四个底部导航按钮，遂记录一下实现过程最终实现效果如下所示新建一个小程序项目，我是创建了JS模板，项目创建完成后需要新建五个文件夹，其中四个（page子文件夹）用于存放pages文件，一个sources文件夹（与pages同级）用于存放资源文件，如图标文件图标需要8个，因为选中的图标和未选中的图标需要进行区分图标文件源于阿里巴巴矢量图库需要在app.json中添加以下配置信息，其中tabBar是新增的，其余均为系统默认生成{"pages": ["pages/Homepage/Homepage","pages/index/index","pages/logs/logs","pages/Mine/mine","pages/Recommend/recommend","pages/ShoppingCart/shoppingCart"],"tabBar": {"color": "#A9A9A9","selectedColor": "#000000","backgroundColor": "#FFFFFF","borderStyle": "black","position": "bottom","custom": false,"list": [{"pagePath": "pages/Homepage/Homepage","text": "首页","iconPath": "source/img/main.png","selectedIconPath": "source/img/main_selected.png"},{"pagePath": "pages/Recommend/recommend","text": "推荐","iconPath": "source/img/star.png","selectedIconPath": "source/img/star_selected.png"},{"pagePath": "pages/ShoppingCart/shoppingCart","text": "购物车","iconPath": "source/img/shop.png","selectedIconPath": "source/img/shop_selected.png"},{"pagePath": "pages/Mine/mine","text": "个人中心","iconPath": "source/img/my.png","selectedIconPath": "source/img/my_selected.png"}]},"window": {"navigationBarTextStyle": "black","navigationBarTitleText": "Weixin","navigationBarBackgroundColor": "#ffffff"},"style": "v2","componentFramework": "glass-easel","sitemapLocation": "sitemap.json","lazyCodeLoading": "requiredComponents"
}http://www.ppmy.cn/news/1540980.html相关文章外包干了3周，技术退步太明显了。。。。。先说一下自己的情况&amp;#xff0c;大专生&amp;#xff0c;21年通过校招进入武汉某软件公司&amp;#xff0c;干了差不多3个星期的功能测试&amp;#xff0c;那年国庆&amp;#xff0c;感觉自己不能够在这样下去了&amp;#xff0c;长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功…阅读更多...软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:58 +0000</pubDate>
    </item>
    <item>
      <title>外包干了3周，技术退步太明显了。。。。。</title>
      <link>https://www.ppmy.cn/news/1540979.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维外包干了3周，技术退步太明显了。。。。。news/2025/11/1 0:23:57/先说一下自己的情况，大专生，21年通过校招进入武汉某软件公司，干了差不多3个星期的功能测试，那年国庆，感觉自己不能够在这样下去了，长时间呆在一个舒适的环境会让一个人堕落!而我才在一个外包企业干了3周的功能测试，就已经让我变得不思进取，谈了2年的女朋友也因为我的心态和工资和我分手了。于是，我决定要改变现状，冲击下大厂。刚开始准备时，自己都蒙了，差不多一个月的外包测试让我的技术没有一丝的进步，提升的只有我的懒惰…没办法，我找到了我在腾讯的老哥，作为他的小老表，在他了解了我的情况后(几乎就是软件测试基础开始)，直接甩给我一个网盘，说到：“去吧，这里有你需要的所有东西，不要来找我了，我都嫌丢人!”。盘里头是一整套软件测试面试必备文档PDF，和完整学习路线视频教程，看完之后直接给我老哥给跪了…这下面试稳了。这里我免费分享给大家看看，不论是用于巩固基础，还是用于技术提升都可以收藏一份，看完学透，面试大厂so easy。下面展示部分截图，文末附免费下载方式。不多说，直接上干货通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：全网首发-涵盖16个技术栈第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）第二部分，Linux（ Linux基础+Linux练习题）第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）第四部分，Web测试第五部分，API测试第六部分，App测试第七部分，管理工具第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）第九部分，Selenium相关第十部分，性能测试第十一部分，LordRunner相关第十二部分，计算机网络第十三部分，组成原理第十四部分，数据结构与算法第十五部分，逻辑题第十六部分，人力资源软件测试基础软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点Linuxgrep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口?Python统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例MySQL你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性?WebWeb测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结…接口测试什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化?…性能测试你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?…selenium如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?你如何从Selenium连接到数据库?你如何验证多个页面上存在的一个对象?XPath中使用单斜杠和双斜杠有什么区别?如何编写SeleniumIDE/ RC的用户扩展?如何在页面加载成功后验证元素的存在?你对Selenium Grid有什么了解?它提供了什么功能?如何从你的Java Class启动Selenium服务器?Selenium中有哪些验证点?什么是XPath?什么时候应该在Selenium中使用XPath?…计算机与网络一台计算机的IP是192.168.10.71子网掩码255.255.255.64与192.168.10.201 …请简述DNS、活动目录、域的概念。10M兆宽带是什么意思?理论下载速度是多少?什么是IP地址?OSI七层网络模型的划分?TCP和UDP有什么不同?HTTP属于哪一层的协议?HTTP和HTTPS的区别?cookies和session的区别?HTTP的get请求和post请求的区别?HTTP1.0和HTTP1.1有什么区别TCP的连接建立过程，以及断开过程?客户端使用DHCP获取IP的过程?写出某个网段的网络地址和广播地址?…人力资源你的测试职业发展是什么？你自认为做测试的优势在哪里？你找工作时，最重要的考虑因素为何？为什么我们应该录取你？请谈谈你个人的最大特色。一个测试工程师应具备那些素质和技能？还有问一下你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度地保证软件质量？为什么选择测试这行？如果我雇用你，你能给部门带来什么贡献？文档获取方式：这份文档，对于想从事【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！以上均可以分享，点击下方小卡片免费获取。http://www.ppmy.cn/news/1540979.html相关文章软考（网工）——局域网和城域网文章目录 &amp;#x1f550;局域网基础1️⃣局域网和城域网体系架构 IEEE&amp;#xff08;负责链路层&amp;#xff09;2️⃣局域网拓扑结构 &amp;#x1f551;CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理 &amp;#x1f552;二进制指数退避算法1️⃣ 二进制指数退避算法 &amp;#x1…阅读更多...【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:57 +0000</pubDate>
    </item>
    <item>
      <title>软考（网工）——局域网和城域网</title>
      <link>https://www.ppmy.cn/news/1540978.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维软考（网工）——局域网和城域网news/2025/11/1 0:23:56/文章目录🕐局域网基础1️⃣局域网和城域网体系架构 IEEE（负责链路层）2️⃣局域网拓扑结构🕑CSMA/CD1️⃣CSMA/CD2️⃣CSMA/CD三种监听算法3️⃣冲突检测原理🕒二进制指数退避算法1️⃣ 二进制指数退避算法🕓最小帧长计算1️⃣最小帧长计算🕔以太网帧结构和物理层标准1️⃣以太网帧结构2️⃣以太网报文封装3️⃣802.3 以太网（10M）4️⃣快速以太网 802.3u（100M）5️⃣千兆以太网（1000M）（常考）6️⃣万兆以太网 802.3ae（10G）🕕虚拟局域网 VLAN1️⃣VLAN 基础2️⃣冲突域3️⃣广播域4️⃣交换机 VLAN 划分5️⃣VLAN 划分配置6️⃣VLAN 作用7️⃣802.1Q标签8️⃣交换机端口类型🕖生成树协议 STP1️⃣生成树技术背景2️⃣二层环路问题——广播风暴3️⃣二层环路问题——MAC 表震荡4️⃣复杂冗余性网络环境存在更多的物理二层环路5️⃣STP 概念6️⃣STP 基本概念（当网络出现故障）7️⃣网桥 ID（Birdge ID）8️⃣路径开销（Path Cost）9️⃣STP 选举操作🔟几种生成树协议🕗城域网基础1️⃣城域网🕘章节总结🕐局域网基础1️⃣局域网和城域网体系架构 IEEE（负责链路层）2️⃣局域网拓扑结构局域网的主要特征由网络的拓扑结构、所采用的协议类型，以及介质访问控制方法决定。局域网的拓扑结构是指连接网络设备的传输介质的铺设形式，局域网的拓扑结构主要有星型、总线型、环型和混合型。🕑CSMA/CD1️⃣CSMA/CD对总线型、星型和树型拓扑访问控制协议是CSMA/CD(Carrier Sense Multiple Access/Collision Detection,载波侦听多路访问/冲突检测)。CSMA基本原理：发送数据之前，先监听信道上是否有人在发送。若有，说明信道正忙，否则说明信道是空闲的，然后根据预定的策略决定：(1)若信道空闲，是否立即发送。(2)若信道忙，是否继续监听。如果连续发生16次碰撞后，认为网络繁忙或故障，不再尝试发送。2️⃣CSMA/CD三种监听算法(1)非坚持型监听算法：后退随机时间（常考）由于随机时延后退，从而减少了冲突的概率。问题是因为后退而使信道闲置一段时间，这使信道的利用率降低，而且增加了发送时延。(2)1-坚持型监听算法：继续监听，不等待（常考）有利于抢占信道，减少信道空闲时间。但是，多个站同时都在监听信道时必然会发生冲突。冲突概率和利用率都高（双高）(3)P-坚持型监听算法若信道空闲，以概率P发送，以概率(1-P)延迟一个时间单位，P大小可调整。3️⃣冲突检测原理载波监听只能减小冲突的概率，不能完全避免冲突（选择题常考）。当两个帧发生冲突后，若继续发送，将会浪费网络带宽。为了改进带宽利用率，发送站应采取边发边听的冲突检测方法，即：(1)发送期间同时接收，并把接收的数据与站中存储的数据进行比较。(2)若比较结果一致，说明没有冲突，重复(1)。(3)若比较结果不一致，说明发生了冲突，立即停止发送，并发送一个简短的干扰信号(amming),使所有站都停止发送。(4)发送信号后，等待一段随机长的时间，重新监听，再试着发送。🕒二进制指数退避算法1️⃣ 二进制指数退避算法二进制指数退避算法工作原理如下：(1)检测到冲突后，马上停止发送数据，并等待随机时间再发送数据。(2)等待的随机时间 = t * Random[0,1, ……2k-1] ,其中Random表示随机函数。其中t是基本退避时间，可以看作固定值。k = min[重传次数，10]，如果重传16次后，还不能正常发送数据，认为网络拥塞或信道故障，不再尝试重传。根据公式，如果重传12次后， k = min[12,10] = 10 ,那么可能等待的时间是t * Random[0,1023],一共有1024种可能。每次站点等待的时间都是随机数，故后一次退避时间不一定比前一次长。重传次数越多，退避窗口（即Random取值）越大，从而降低冲突概率。如果连续发生16次碰撞后，认为网络繁忙或故障，不再尝试发送。🕓最小帧长计算1️⃣最小帧长计算最小帧长公式 Lmin=2R * d/vR为网络数据速率，d为最大距离，v为传播速度光纤信道：v = 300000km/s 电缆： v = 200000km/s不冲突条件：发送时间 ≥ 传送时间 + 确认时间L/R ≥ 2 * d/v，则推出最小帧长公式🕔以太网帧结构和物理层标准1️⃣以太网帧结构前面7+1字节用于时钟同步，不算入帧长。数据46-1500字节，不够至少填充到46字节。校验位4字节，CRC循环冗余校验32位。最小帧长64字节：6+6+2+46+4=64。最大帧长1518字节：6+6+2+1500+4=1518。2️⃣以太网报文封装3️⃣802.3 以太网（10M）物理介质命名规范：&lt;font style="color:#DF2A3F;"&gt;&lt;传输速率Mbps&gt;&lt;信号方式&gt;&lt;最大传输距离（百米）或介质类型&gt;&lt;/font&gt;4️⃣快速以太网 802.3u（100M）快速以太网是历年考试重点，需要掌握几种标准的传输介质（使用2对还是4对，采用屏蔽线还是非屏蔽线。UTP为非屏蔽双绞线，STP为屏蔽双绞线)。其中，100Base-TX采用4B/5B编码。5️⃣千兆以太网（1000M）（常考）千兆以太网两个标准 802.3z 和 802.3ab(1000BASE-T) ),千兆需要4对双绞线，达到100米传输。1000BASE-LX标准可以使用单模和多模光纤传输。千兆以太网编码方法：4B/5B或8B/9B。6️⃣万兆以太网 802.3ae（10G）万兆以太网标准：IEEE802.3ae,支持10G速率，可用光纤或者双绞线传输。万兆以太网基本应用于点到点线路，不再共享带宽，没有冲突检测，载波监听和多路访问技术也不再重要。万兆以太网和万兆以太网采用与传统以太网同样的帧结构。🕕虚拟局域网 VLAN1️⃣VLAN 基础虚拟局域网(Virtual Local Area Netwok , VLAN )根据管理功能、组织机构或应用类型对交换局域网进行分段而形成的逻辑网络。不同VLAN通信必须经过三层设备：路由器、三层交换机、防火墙等。虚拟局域网工作站可以不属于同一物理网段，任何交换端口都可以分配给某个VLAN,属于同一VLAN的所有端口构成一个广播域。冲突域和广播域，一个中继器和集线器是一个冲突域，一个VLAN为一个广播域，交换机的一个接口为一个冲突域。2️⃣冲突域冲突域是指连接在同一共享介质上的所有节点的集合，冲突域内所有节点竞争同一带宽，一个节点发出的报文（无论是单播、组播、广播），其余节点都可以收到。在传统的以太网中，同一介质上的多个节点共享链路带宽，争用链路的使用权，这样就会发生冲突。同一介质上的节点越多，冲突发生的概率越大。交换机不同的接口发送和接收数据独立，各接口属于不同的冲突域，因此有效地隔离了网络中物理层冲突域，使得通过它互连的主机(或网络)之间不必再担心流量大小对于数据发送冲突的影响。集线器在一个冲突域，交换机的一个接口是一个冲突域。3️⃣广播域广播报文所能到达的整个访问范围称为二层广播域，简称广播域，同一广播域内的主机都能收到广播报文。在传统的以太网中，同一介质上的多个节点共享链路，一台设备发出的广播报文，所有设备均会收到。交换机对广播报文会向所有的接口都转发，所以交换机的所有接口连接的节点属于一个广播域，路由器每个接口是一个广播域。4️⃣交换机 VLAN 划分静态划分VLAN：基于交换机端口。动态划分VLAN: 基于MAC地址、基于策略、基于网络层协议、基于网络层地址(填空题)。5️⃣VLAN 划分配置(1)静态划分VLAN。手动把交换机的某些接口加入到某个VLAN,配置如下：[Huawei] vlan 10 //创建VLAN 10
[Huawei-vlan10] quit//出	
[Huawei] interface GigabitEthernet0/0/1//进入接口
[Huawei-GigabitEthernet0/0/1] port link-type access //把接口设置成access
[Huawei-GigabitEthernet0/0/1] port default vlan 10 //把接口加入VLAN 10(2)动态划分VLAN。根据MAC地址、网络层地址、网络层协议、IP广播域或管理策略划分。1)基于MAC地址进行VLAN划分配置：[Huawei] vlan 20 //VLAN 20
[Huawei-vlan20] mac-vlan mac-address 5489-98FC-5825 //把MAC地址为5489-98FC-5825的终端加入VLAN 20-2)基于策略进行VLAN划分配置：[Huawei] vlan 20 //创建VLAN 20
[Huawei-vlan20] policy-vlan mac-address 0-1-1 ip 10.1.1.1 priority 7
//基于策略划分VLAN,把MAC地址为0-1-1，IP地址为1.1.1.1的主机划分到VLAN20中，并配置该VLAN的802.1p优先级是76️⃣VLAN 作用(1)控制网络流量。一个VLAN内部的通信（包括广播通信）不会转发到其他VLAN中去，从而有助于控制广播风暴，减小冲突域，提高网络带宽的利用率。(2)提高网络的安全性。可以通过配置VLAN之间的路由来提供广播过滤、安全和流量控制等功能。不同VLAN之间的通信受到限制，提高了企业网络的安全性。(3)灵活的网络管理。VLAN机制使得工作组可以突破地理位置的限制而根据管理功能来划分。如果根据MAC地址划分VLAN,用户可以在任何地方接入交换网络，实现移动办公。7️⃣802.1Q标签802.1Q标签字段，重点掌握PRI和VID。PRI(3位)：Priority表示优先级，提供0~7共8个优先级，当有多个帧等待发送时，按优先级顺序发送数据包。VID(12位)：即VLAN标识符，最多可以表示 212=4096 个VLAN,其中VID0用于识别优先级，VID4095保留未用，所以最多可配置4094个VLAN。默认管理VLAN是1，不能删除。交换机添加和删除VLAN标签的过程由专用硬件自动实现，处理速度很快，不会引入太大的延迟（选择题）从用户角度看，数据源产生标准的以太帧，目标接收的也是标准的以太帧，VLAN标记对用户是透明的。8️⃣交换机端口类型Access接口：只能传送单个VLAN数据，一般用于连接PC/摄像头等终端。Trunk接口：能传送多个VLAN数据，一般用于交换机之间互联。Hybrid接口：混合接口，包含access和trunk属性。QinQ: 双层标签，一般用于运营商城域网。🕖生成树协议 STP1️⃣生成树技术背景交换机单链路上行，存在单点故障，线路和设备都不具备冗余性。任何一条链路或者设备故障，网络将面临断网。冗余拓扑能够解决单点故障问题。但是冗余拓扑带来了二层环路问题。实际网络环境中，经常产生二层环路从而引发网络故障。2️⃣二层环路问题——广播风暴网络中若存在二层环路，一旦出现广播数据帧，这些数据帧将被交换机不断泛洪，造成广播风暴。广播风暴对网络危害非常大，将严重消耗设备CPU资源及网络带宽，需要格外注意。广播风暴现象：网络慢、所有指示灯高速闪烁、CPU使用率高、CLI卡顿。3️⃣二层环路问题——MAC 表震荡PC发送数据帧给ServerSW3没有目的MAC表项，于是将数据帧进行泛洪SW1和SW2都收到这个帧并学习源MAC,同时将数据帧进一步泛洪SW3将从GE0/0/1和GE0/0/2都收到这个帧并学习源MAC,更新MAC地址表4️⃣复杂冗余性网络环境存在更多的物理二层环路5️⃣STP 概念采用生成树 (Spansing-tree) 技术，能够在网络中存在二层环路时，通过逻辑阻塞(Block)特定端口，从而打破环路，并且在网络出现拓扑变更时及时收敛，保障网络冗余性。6️⃣STP 基本概念（当网络出现故障）在网络出现拓扑变更时及时收敛，保障网络冗余性。7️⃣网桥 ID（Birdge ID）桥ID一共8个字节，由2个字节优先级和6个字节的MAC地址构成。桥优先级默认为32768，可以手工修改。（越小越优先）MAC地址为交换机背板MAC。8️⃣路径开销（Path Cost）路径开销是一个端口量，是STP/RSTP协议用于选择链路的参考值。端口路径开销的默认值及取值范围由选定的路径开销算法决定，路径开销与端口带宽成反比。华为设备路径开销标准有：802.1d-1998、802.1t及私有的legacy,默认为802.1t标准。9️⃣STP 选举操作1.确定一个根桥(Root Bridge)【选优先级和MAC地址最小的网桥】2.确定其他网桥的根端口(RootPort)【非根桥的端口到根桥最近的端口】3.每个段选择一个指定端口(DesignatedPort)【先选指定桥，指定桥上为指定端口】4.选出非指定端口（NonDesignated Port ）🔟几种生成树协议生成树协议：802.1dSTP(慢，拓扑收敛需要30-50s)快速生成树协议802.1wRSTP(快，6s内完成收敛)多生成树协议802.1sMSTP(实现多个VLAN负载均衡)🕗城域网基础1️⃣城域网(1)E-LAN技术是802.1Q的VLAN帧标记，双层标记，打了两层VLAN标签，这种技术被定义为IEEE802.1ad,也称为QinQ技术。QinQ实际是把用户VLAN嵌套在运营商城域以太网VLAN中传送。(2)IEEE802.1ah,也称为PBB,也叫MAC-IN-MAC技术。🕘章节总结802标准：802.3以太网，802.11无线局域网WLAN。CSMA/CD: 以太网介质访问控制协议，原理：先听后发，边听边发，若有冲突，立即停止。监听算法：非坚持型， 1- 坚持型（双高），P - 坚持型。二进制指数退避算法。二进制退避算法：等待的随机时间 = t * Random[0, 1, ……2k-1] , k=min[重传次数，10]。最小帧长 : Lmin= 2R * d/V。MAC帧结构、以太网传输介质、VLAN技术和STP计算过程。两种城域网技术：QinQ和MAinMAC。http://www.ppmy.cn/news/1540978.html相关文章【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，20661. 力扣1596&amp;#xff1a;每位顾客最经常订购的商品 
1.1 题目&amp;#xff1a; 
表&amp;#xff1a;Customers 
------------------------
| Column Name   | Type    |
------------------------
| customer_id   | int     |
| name          | varchar |
------------------------
c…阅读更多...【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:56 +0000</pubDate>
    </item>
    <item>
      <title>【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，2066</title>
      <link>https://www.ppmy.cn/news/1540977.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【力扣 | SQL题 | 每日4题】力扣1596，1587，2228，2066news/2025/11/1 0:23:55/1. 力扣1596：每位顾客最经常订购的商品1.1 题目：表：Customers+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| customer_id   | int     |
| name          | varchar |
+---------------+---------+
customer_id 是该表具有唯一值的列
该表包含所有顾客的信息表：Orders+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| customer_id   | int     |
| product_id    | int     |
+---------------+---------+
order_id 是该表具有唯一值的列
该表包含顾客 customer_id 的订单信息
没有顾客会在一天内订购相同的商品多于一个表：Products+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| product_id    | int     |
| product_name  | varchar |
| price         | int     |
+---------------+---------+
product_id 是该表具有唯一值的列
该表包含了所有商品的信息写一个解决方案，找到每一个顾客最经常订购的商品。结果表单应该有每一位至少下过一次单的顾客customer_id, 他最经常订购的商品的product_id和product_name。返回结果没有顺序要求。查询结果格式如下例所示。示例 1：输入：Customers表：+-------------+-------+
| customer_id | name  |
+-------------+-------+
| 1           | Alice |
| 2           | Bob   |
| 3           | Tom   |
| 4           | Jerry |
| 5           | John  |
+-------------+-------+Orders表：+----------+------------+-------------+------------+
| order_id | order_date | customer_id | product_id |
+----------+------------+-------------+------------+
| 1        | 2020-07-31 | 1           | 1          |
| 2        | 2020-07-30 | 2           | 2          |
| 3        | 2020-08-29 | 3           | 3          |
| 4        | 2020-07-29 | 4           | 1          |
| 5        | 2020-06-10 | 1           | 2          |
| 6        | 2020-08-01 | 2           | 1          |
| 7        | 2020-08-01 | 3           | 3          |
| 8        | 2020-08-03 | 1           | 2          |
| 9        | 2020-08-07 | 2           | 3          |
| 10       | 2020-07-15 | 1           | 2          |
+----------+------------+-------------+------------+Products表：+------------+--------------+-------+
| product_id | product_name | price |
+------------+--------------+-------+
| 1          | keyboard     | 120   |
| 2          | mouse        | 80    |
| 3          | screen       | 600   |
| 4          | hard disk    | 450   |
+------------+--------------+-------+输出：+-------------+------------+--------------+
| customer_id | product_id | product_name |
+-------------+------------+--------------+
| 1           | 2          | mouse        |
| 2           | 1          | keyboard     |
| 2           | 2          | mouse        |
| 2           | 3          | screen       |
| 3           | 3          | screen       |
| 4           | 1          | keyboard     |
+-------------+------------+--------------+解释：Alice (customer 1) 三次订购鼠标, 一次订购键盘, 所以鼠标是 Alice 最经常订购的商品.
Bob (customer 2) 一次订购键盘, 一次订购鼠标, 一次订购显示器, 所以这些都是 Bob 最经常订购的商品.
Tom (customer 3) 只两次订购显示器, 所以显示器是 Tom 最经常订购的商品.
Jerry (customer 4) 只一次订购键盘, 所以键盘是 Jerry 最经常订购的商品.
John (customer 5) 没有订购过商品, 所以我们并没有把 John 包含在结果表中.1.2 思路：最经常=&gt;排名第一=&gt;窗口函数1.3 题解：with tep1 as (select customer_id, t1.product_id, product_name from Orders t1 join Products t2 on t1.product_id = t2.product_id
), tep2 as (select customer_id, product_id, product_name, count(*) cntfrom tep1group by customer_id, product_id, product_name
), tep3 as (select customer_id, product_id, product_name,rank() over (partition by customer_id order by cnt desc) ranksfrom tep2
)select customer_id, product_id, product_name
from tep3
where ranks = 12. 力扣1587：银行账户概要22.1 题目：表:Users+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| account      | int     |
| name         | varchar |
+--------------+---------+
account 是该表的主键(具有唯一值的列)。
该表的每一行都包含银行中每个用户的帐号。
表中不会有两个用户具有相同的名称。表:Transactions+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| trans_id      | int     |
| account       | int     |
| amount        | int     |
| transacted_on | date    |
+---------------+---------+
trans_id 是该表主键(具有唯一值的列)。
该表的每一行包含了所有账户的交易改变情况。
如果用户收到了钱, 那么金额是正的; 如果用户转了钱, 那么金额是负的。
所有账户的起始余额为 0。编写解决方案,  报告余额高于 10000 的所有用户的名字和余额. 账户的余额等于包含该账户的所有交易的总和。返回结果表单无顺序要求。查询结果格式如下例所示。示例 1：输入：Userstable:
+------------+--------------+
| account    | name         |
+------------+--------------+
| 900001     | Alice        |
| 900002     | Bob          |
| 900003     | Charlie      |
+------------+--------------+Transactionstable:
+------------+------------+------------+---------------+
| trans_id   | account    | amount     | transacted_on |
+------------+------------+------------+---------------+
| 1          | 900001     | 7000       |  2020-08-01   |
| 2          | 900001     | 7000       |  2020-09-01   |
| 3          | 900001     | -3000      |  2020-09-02   |
| 4          | 900002     | 1000       |  2020-09-12   |
| 5          | 900003     | 6000       |  2020-08-07   |
| 6          | 900003     | 6000       |  2020-09-07   |
| 7          | 900003     | -4000      |  2020-09-11   |
+------------+------------+------------+---------------+输出：+------------+------------+
|name|balance|
+------------+------------+
| Alice      | 11000      |
+------------+------------+解释：Alice 的余额为(7000 + 7000 - 3000) = 11000.
Bob 的余额为1000.
Charlie 的余额为(6000 + 6000 - 4000) = 8000.2.2 思路：简单题。2.3 题解：select name, sum(amount) balance
from Users t1
join Transactions t2
on t1.account = t2.account
group by name
having sum(amount) &gt; 100003. 力扣2228：7天内两次购买的用户3.1 题目：表:Purchases+---------------+------+
| Column Name   | Type |
+---------------+------+
| purchase_id   | int  |
| user_id       | int  |
| purchase_date | date |
+---------------+------+
purchase_id 包含唯一值。
该表包含用户从某个零售商购买的日期的日志。编写解决方案，获取最多间隔7天进行两次购买的用户的 id。返回按user_id排序的结果表。结果格式如下所示。示例 1:输入:Purchases 表:
+-------------+---------+---------------+
| purchase_id | user_id | purchase_date |
+-------------+---------+---------------+
| 4           | 2       | 2022-03-13    |
| 1           | 5       | 2022-02-11    |
| 3           | 7       | 2022-06-19    |
| 6           | 2       | 2022-03-20    |
| 5           | 7       | 2022-06-19    |
| 2           | 2       | 2022-06-08    |
+-------------+---------+---------------+输出:+---------+
| user_id |
+---------+
| 2       |
| 7       |
+---------+解释:用户 2 在 2022-03-13 和 2022-03-20 有两次购买。由于第二次购买是在第一次购买后的 7 天内，我们添加了他们的 ID。
用户 5 只购买了 1 次。
用户 7 在同一天有两次购买，所以我们添加了他们的 ID。3.2 思路：自连接就够了。3.3 题解：-- 一眼自连接：
-- 对于驱动表的一条数据，找出user_id相同，purchase_id不同
-- 且二者相差日期是小于等于7天的记录。
-- 即可满足题意。
select distinct t1.user_id 
from Purchases t1
join Purchases t2
on t1.user_id = t2.user_id and abs(datediff(t1.purchase_date, t2.purchase_date)) &lt;= 7
and t1.purchase_id &lt;&gt; t2.purchase_id
order by user_id4. 力扣2066：账户余额4.1 题目：表名:Transactions+-------------+------+
| Column Name | Type |
+-------------+------+
| account_id  | int  |
| day         | date |
| type        | ENUM |
| amount      | int  |
+-------------+------+
(account_id, day) 是该Transactions表的主键.
表中的每行数据表示一次交易的信息, 包括此次交易的账号(account_id), 交易类型(type), 交易发生时间(day), 交易发生金额(amount).
其中交易类型(type)字段包括了两种行为：存入 ('Deposit'), 取出('Withdraw').请写出能够返回用户每次交易完成后的账户余额. 我们约定所有用户在进行交易前的账户余额都为0， 并且保证所有交易行为后的余额不为负数。返回的结果请依次按照 账户（account_id), 日期(day) 进行升序排序.查询结果的格式请参照以下测试样例.测试样例1:输入:Transactions 表:
+------------+------------+----------+--------+
| account_id | day        | type     | amount |
+------------+------------+----------+--------+
| 1          | 2021-11-07 | Deposit  | 2000   |
| 1          | 2021-11-09 | Withdraw | 1000   |
| 1          | 2021-11-11 | Deposit  | 3000   |
| 2          | 2021-12-07 | Deposit  | 7000   |
| 2          | 2021-12-12 | Withdraw | 7000   |
+------------+------------+----------+--------+输出:+------------+------------+---------+
| account_id | day        | balance |
+------------+------------+---------+
| 1          | 2021-11-07 | 2000    |
| 1          | 2021-11-09 | 1000    |
| 1          | 2021-11-11 | 4000    |
| 2          | 2021-12-07 | 7000    |
| 2          | 2021-12-12 | 0       |
+------------+------------+---------+解释:账户1:
- 初始金额为 0.
- 2021-11-07 --&gt; 存入2000. 余额变为 0 + 2000 = 2000.
- 2021-11-09 --&gt; 取出1000. 余额变为 2000 - 1000 = 1000.
- 2021-11-11 --&gt; 存入3000. 余额变为 1000 + 3000 = 4000.
账户2:
- 初始金额为 0.
- 2021-12-07 --&gt; 存入7000. 余额变为 0 + 7000 = 7000.
- 2021-12-12 --&gt; 取出 7000. 余额变为 7000 - 7000 = 0.4.2 思路：窗口函数sum。4.3 题解：-- 一眼窗口函数，看balance字段的值变化即可=&gt; sum-- 第一步：先同步type，将type字段为Withdraw的amount记录变为负值
with tep as (select account_id , day, case when type='Withdraw' then -amountelse amountend amountfrom Transactions
)
-- 然后使用窗口函数，account_id分组，day排序，然后计算amount总和
select account_id, day, sum(amount) over (partition by account_id order by day) balance
from tephttp://www.ppmy.cn/news/1540977.html相关文章【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比实验目的&amp;#xff1a; 
1.熟悉并掌握Cisco Packet Tracer的安装及使用方法&amp;#xff1b; 
2.验证并掌握集线器和交换机的工作方式及区别。 
实验器材&amp;#xff1a; 
一台Windows操作系统的PC机。 
实验准备&amp;#xff1a; 
1&amp;#xff0e;配置网络拓扑&amp;#xff1a;首先&amp;#xff0c;在…阅读更多...每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:55 +0000</pubDate>
    </item>
    <item>
      <title>【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比</title>
      <link>https://www.ppmy.cn/news/1540976.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【某农业大学计算机网络实验报告】实验一 集线器和交换机的对比news/2025/11/1 0:23:53/实验目的：1.熟悉并掌握Cisco Packet Tracer的安装及使用方法；2.验证并掌握集线器和交换机的工作方式及区别。实验器材：一台Windows操作系统的PC机。实验准备：1．配置网络拓扑：首先，在 Packet Tracer 7.3.1 模拟器中配置好如下的网络拓扑结构。如下图所示，具体包括：两台集线器分别连接4台普通PC与3台普通PC，两台通用交换机分别连接4台普通PC与3台普通PC；另：配置过程中交换机端口指示灯可能呈橙色，单击主窗口右下角 Realtime （实时）Simulation（模拟）模式切换按钮数次，即可加速完成交换机的初始化。2. 配置 IP 地址和子网掩码：根据实验要求，对于每个设备，按照实验指导书中提供的表格配置IP地址，点击 PC，打开参数表如下所示，在每台 PC 的配置窗口中配置合理的 IP 地址和子网掩码：3. 设置 Event List Filters（事件列表过滤器）：在模拟状态中，设置事件列表过滤器只显示ICMP事件，可以在后续实验过程中精简进程的显示与避免额外情况的出现。实验内容：任务一：观察集线器和交换机的运行（1）观察集线器对于单播包的处理添加PC0 到PC2 的简单PDU，观察集线器对PC0发送的数据包的转发可以看出，其具体过程为：PC0 发送单播包到集线器 0，再通过集线器转发给 PC1、PC2、PC3，但只有目的地PC2 成功接收；PC2成功接收后，需要向PC0发送成功接收的数据，同样首先向集线器发送单播包，集线器再发送给PC0、PC1、PC3，同样只有 PC0 可以成功地接收数据包，从此一过程就可以看出，集线器存在的明显的弊端，仅仅是一个简单的单播包，集线器却需要向所有PC“广播”才能确定哪一个PC端接收数据。（2）观察交换机对于单播包的处理添加PC7到PC10的简单PDU，观察交换机对PC7发送的数据包的转发可以看出，其具体过程为：PC07发送单播包到交换机，再通过集线器直接转发给PC10并且成功接收；PC10成功接收后，需要向PC7发送成功接收的数据，同样首先向交换机发送单播包，交换机再直接发送给PC7，从此一过程就可以看出，交换机与集线器不同之处与改进，它不再需要向所有连接的PC端发送数据包。（3）观察集线器对于广播包的处理为发送广播包，我们首先需要删除PDU列表窗口中的场景，并单击 Add Complex PDU（添加复杂 PDU）按钮，单击 PC0，在弹出的对话框中设置参数如下图所示：设置完成后点击创建PDU，添加从PC0 发出的复杂PDU(广播包)，切换到模拟模式进行观察，数据包到达集线器后，由集线器转发给PC1,PC2,PC3，可以看到除PC2外，其余PC显示类似等待的图标，这是因为PC1发出数据包后其余接收PC需要进行回复，但它们并不知道PC1的MAC地址，此时再进行下一步，它们首先需要先向PC7发送一个获取PC7的MAC地址的ARP请求。为解决这个问题，我们可以仿照上述的实验内容分别使PC0向PC1,PC2,PC3发送单播包，再次执行广播包操作，可以看到显示所有PC端均已接收到了广播数据包。而在接收PC端向发送PC端发送已接收数据时，由于它们所共用一个集线器，因此在集线器内会发生碰撞，导致信息无法到达PC0，而该碰撞信息也会被发送给所有主机，因此我们可以直观感受到集线器在广播信息时的弊端。（4）观察交换机对于广播包的处理与上述实验过程相同设置完成后，点击创建PDU，添加从PC7发出的复杂PDU(广播包)，切换到模拟模式进行观察，数据包到达集线器后，由集线器转发给PC8,PC9,PC10，可以看到除PC10外，其余PC显示类似等待的图标，这是因为PC7发出数据包后其余接收PC需要进行回复，但它们并不知道PC7的MAC地址，此时再进行下一步，它们首先需要先向PC7发送一个获取PC7的MAC地址的ARP请求。为解决这个问题，我们可以仿照上述的实验内容分别使PC7向PC8,PC9发送单播包，再次执行广播包操作，可以看到显示所有PC端均已接收到了广播数据包，并且都排队正确发送给了PC7已接受到信息的消息，而集线器在此就会发生碰撞，因此其相对于交换机“看不懂”帧的弊端就在这里体现了出来。任务二：分别观察以集线器和以交换机为中心的以太网中，多个站点同时发送数据的情况，理解冲突域的概念（1）观察以集线器为中心的以太网中多个站点同时发送数据的情况首先我们删除上述实验中PDU列表窗口中的场景，添加 PC0 到 PC2 和 PC1 到 PC3 的简单 PDU：由 PC0 向 PC2发送数据包、PC1 向 PC3 发送数据包，并单击 Auto Capture/Play，切换到模拟模式进行观察；可以看到同时发送数据的两个PC机的数据包在集线器中会发生碰撞产生数据冲突，紧接着集线器只能将数据冲突的信息广播给所有主机，导致主机2与主机3并没有收到主机0与主机1的数据包，因此体现了以集线器为中心的以太网中主机无法同时发送消息的缺陷。（2）观察以交换机为中心的以太网中多个站点同时发送数据的情况首先我们删除 PDU 列表窗口中的场景，添加 PC7 到 PC9 和 PC8 到 PC10 的简单 PDU：由 PC7 向PC9 发送数据包、由 PC8 向 PC10 发送数据包。单击 Auto Capture/Play，切换到模拟模式进行观察；我们可以看到PC7 和 PC8 首先向交换机发送数据包，然后交换机首先将数据包转发给 PC9，之后 PC9通过交换机向PC8返回应答数据包，然后交换机将数据包转发给 PC10，之后 PC10通过交换机向PC8返回应答数据包，至此PC7 到 PC9 和 PC8 到 PC10 的通信成功，交换机的特点是其与集线器不同在接受数据包后不会发送数据冲突。任务三：观察集线器和交换机在扩展以太网覆盖范围的同时，对冲突域和广播域范围的影响（1）观察集线器扩展以太网时对冲突域范围的影响进入模拟模式，添加两个简单 PDU，从主机 PC0 向主机 PC3 发送单播包，并同时从主机 PC4 向主机 PC6 发送单播包：可以看到虽然PC3与PC6虽然接收到了PC0与PC4发送的数据包，但是在它们希望返回应答数据包时会与从另一集线器处广播而来的数据包产生数据冲突，而接下来产生冲突的信息又需要被集线器广播，则两个集线器之间又会发生碰撞，该碰撞信息会在两个集线器内被反复传播多次，这是由于集线器广播的特性，使其在扩展以太网中冲突域被扩大了，虽然发送数据包的主机与接收数据包的主机都在同一集线器内的网络下，但依然会有碰撞发生，也从侧面体现了集线器十分不适用于扩展以太网。（2）观察集线器扩展以太网时对广播域范围的影响在 PC0 上添加复杂 PDU，目标 IP 地址设置为 255.255.255.255，依次单击捕获/转发按钮，广播包首先到达第一个集线器；再接着由此集线器广播给其它主机与另一个集线器，此时PC1、PC2与PC3已经接收到了PC0发送的数据包，它们需要向PC0返回应答包；在PC1、PC2与PC3返回应答包的过程中，它们会在第一个集线器中产生冲突，这是我们在上述实验过程中可以预见到的，同时第二个集线器向其它主机广播数据包，同样在第一个集线器处与应答包产生冲突，而PC4、PC5、PC6接收到了数据包，它们需要向PC0返回应答包；第一个集线器将发生碰撞的信息广播给所有主机，正好在第二个集线器处与向PC0返回应答包的数据包相冲突，之后碰撞信息被反复传播多次，直到所有的碰撞信息都被每个主机所接收到，在以集线器为中心的扩展以太网传输广播包时，其广播域虽然扩大了，但随之增大的是碰撞信息会在两个集线器内被不断的传播，大大占用了信道的使用时间。（3）观察交换机扩展以太网时对冲突域及广播域的影响进入模拟模式，添加两个简单 PDU，从主机 PC7 向主机 PC9 发送单播包，并同时从主机 PC11 向主机 PC13 发送单播包，数据包首先到达交换机后，被直接有目的地的交给了对应的主机：在接收的主机成功接收到数据包后，首先向交换机发送应答包，随后由交换机转发给对应的发送主机，在此一同时发送数据包的过程中，没有发生任何的碰撞且发送方正常接收到了应答数据，可见以交换机为中心的扩展以太网冲突域并没有扩大。在 PC7 上添加复杂 PDU，目标 IP 地址设置为 255.255.255.255，依次单击捕获/转发按钮，广播包首先到达第一个交换机；左侧交换机将广播包广播给其网络下的所有主机并且广播给右侧交换机；右侧交换机收到广播包后，将广播包广播给其网络下的所有主机，而左侧交换机网络下的主机需要向PC7返回应答包，因此在左侧交换机中显示排队等待发送应答包；左侧交换机下的主机逐个向PC7返回应答报，而右侧交换机下的主机同样需要向PC7返回应答包，因此在右侧交换机中显示排队等待发送应答包，此后的一系列过程都是两个交换机在排队等待向PC7返回应答包的过程，直到所有应答包都被返回完毕，与上述实验的集线器相比，我们可以感受到以交换机为中心的扩展以太网的广播域被明显扩大了，而且期间没有发生任何碰撞井然有序。思考题：1．集线器在接收到发送给某结点的单播包时是如何转发数据的？交换机又是如何处理单播包的？当集线器接收到单播数据包后，会采取广播给所有主机，只有对应主机接收数据包，其它主机丢弃数据包的方式进行传播，这是因为集线器没有识别帧的功能，接收到单播包后并不知道应该发送给哪一个特定的主机，因此只能广播给所有的主机让主机进行判断。而交换机在接收到单播包后，将会点对点转发给对应主机，这是因为交换机与集线器相比可以识别数据包中的帧信息并存储对应主机的MAC地址，因此交换机可以较为智能的将单播包转发给对应的主机。2.在以集线器/交换机为中心的以太网中，当多个站点同时发送数据时，是否会发生冲突？为什么？当多个站点同时发送数据时，以集线器为中心的以太网会发生冲突，因为集线器不具备识别帧的功能，因此无法将数据包转发给特定主机的端口，只能进行广播发送，因此多个数据包会在集线器处产生数据冲突发生碰撞。而以交换机为中心的以太网不会发生冲突，因为交换机具备识别帧的能力，可以解读数据包中的帧信息是要发送给哪一个主机端口，当多个数据包到达交换机后，会将数据包排队转发给对应的主机端口，因此不会发生冲突。3.使用集线器扩大以太网规模时，有没有可能会使以太网的性能下降？为什么？有可能导致以太网性能下降，因为当以集线器为中心的以太网规模被扩大的同时，广播域被扩大了，集线器的一个弊端也就是冲突域也会随之变大，碰撞概率会大大增加，例如当两个集线器内网络的主机同时发送数据，同时碰撞信息会在两个集线器间不断传播直到所有网络内的主机都收到碰撞信息，因此，集线器扩大以太网规模主要是导致了碰撞次数与冲突信息的增多，影响以太网性能。4.使用交换机扩大以太网规模时，有没有可能会使以太网的性能下降？为什么？有可能导致以太网性能下降，与集线器相比，以交换机为中心的以太网虽然具有识别功能可以隔绝碰撞域不会导致冲突域的扩大，但是交换机并不能隔绝广播域，如果使用交换机扩大以太网，当以太网中广播包的数量增加到一定数量时，无用的广播包将会过长时间的占用信道，因此，交换机扩大以太网规模主要是体现在发送广播包时无用信息的增多与传播，从而影响以太网性能。5.交换机能否隔离碰撞域？首先我们在上述实验内容的基础上为以集线器为中心的扩展以太网，在两个集线器间加入一个交换机，用以验证交换机是否能隔离碰撞域，进入模拟模式，添加两个简单 PDU，从主机 PC0 向主机 PC3 发送单播包，并同时从主机 PC4 向主机 PC6 发送单播包；首先发送信息的主机依然是将数据包先发送给最邻近的集线器；而在集线器将接收到的数据包进行广播时，它会将数据包广播给自己网络所在的所有主机与我们的交换机，我们可以明显看到在交换机处，它判断了我们数据包中的帧的信息，此数据包是不需要发送到另一网络上的，因此阻隔了碰撞的发生，也就是隔离了碰撞域；最后，接收数据的主机返回应答包时也与上述实验步骤中描述的一样，交换机阻隔了碰撞的发生，应答包成功输送到了对应主机上，因此我们可以得出结论，由于交换机可以识别帧的特点，它是可以隔离集线器为中心的扩展以太网的碰撞域的。实验结果、分析与结论：对比集线器交换机基本功能创造网络/数据转发是否能识别帧不能能数据包传输方式广播点对点/广播处理单播包集线器接收到数据包后，广播给所有主机交换机接收到数据包后，点对点转发给对应主机处理广播包集线器接收到数据包后，广播给所有主机，但在主机返回应答包时会在集线器处产生碰撞交换机接收到数据包后，广播发送给所有主机，主机在返回应答包时需要在交换机处排队发送多个站点同时发送数据会产生冲突：由于多个站点共用一个集线器，在发送数据包时会在集线器处产生冲突不会产生冲突：交换机具有识别帧的功能，当多份数据同时到达交换机时，它会根据识别得到的帧的信息将数据包转发给对应主机扩展以太网冲突域扩大，广播域扩大，可能导致以太网性能下降：因为以太网规模扩大的同时也扩大了冲突域，从而导致以太网中碰撞次数与冲突信息的增多，影响以太网性能冲突域不变，广播域扩大，可能导致以太网性能下降：交换机并不能隔绝广播域，使用交换机扩大以太网，这将使以太网中广播包的数量增加，从而影响以太网性能补充可以使用交换机隔离冲突域/实验心得与体会：本次实验课我们第一次从书本上的理论知识走近了实验室中的理论操作，与之前课程我们所接触的实验课程相比，此次的实验内容本身并不复杂操作简单，且老师为我们提供了十分详细的实验指导书，但同时我们也必须认识到，如果只是单纯的跟着老师的实验指导书一板一眼的操作下来，是达不到我们实验的真正目的的，每一个操作，每一个步骤我们都需要用心去理解与深入的思考；正如上述所说，我认为每一个实验与它的实验报告背后都存在它十分明确的一个目的，有一些实验是希望我们通过实验报告记录实验的具体操作，便于我们今后碰到类似这样的操作可以有所参考，而我认为我们此次的实验与实验报告更看重的是，通过观察，进一步加深对相关原理的理解并进行深入的思考，为什么会出现这样或者那样的实验现象？因此在实验过程中，我们需要格外留意与关注我们与他人实验现象的不同，很有可能我们就会在这些地方发现一些值得探讨的细微点；同时，本次实验中我们最核心关注的就是集线器与交换机的对比，其实在我们实际的实验过程中，我虽然可以感受到二者的区别，比如集线器是无明确目标的直接广播，而交换机是有明确目标的点对点转发，我还不太能理解集线器与交换机为什么有这样的区别，而交换机又为什么具有这样的特点，经过后续理论课的学习与课后资料的查阅，我明白了：交换机与集线器最大的差别就在于它能解读“帧”，也就是可以识别已连接设备的物理地址，并将这些Mac地址存储在路由表；另外在此次实验中有一个值得关注的现象，在以太网中除去集线器与交换机等转发数据的单位上会出现类似等待的符号，主机上也同样会出现类似等待的符号同时存在两个信封，在实验课上时我原本对这一原理还不够理解，经过理论课的学习后我明白了，这是因为主机返回应答包时，如果并不知道对应主机的MAC地址，就必须先发送一个获取对应主机MAC地址的ARP（Address Resolution Protocol）请求，即地址解析协议，因此就会出现两个信封；因此我们总的来说，交换机在实际生活中比集线器更具有优势，它大大减少了我们网络上不必要的数据流通，这样的结论并不是我们根据书本上的理论或者自己脑袋中的推演就可以得出的，而是需要实验室中的多个实验内容反复实践相互验证才能严谨得到的，因此对待实验课程，我们即要领悟与理解每一个具体的实验步骤，更要深入挖掘实验背后的原理与意义。http://www.ppmy.cn/news/1540976.html相关文章每月洞察：App Store 和 Google Play 的主要更新Google Play 和 App Store 的算法不断发展&amp;#xff0c;定期更新和变化会显着影响其功能。对于开发人员和营销人员来说&amp;#xff0c;跟上这些变化至关重要&amp;#xff0c;因为它们会直接影响应用发现和排名。 本文将深入探讨 Google Play 和 App Store 的最新更新&amp;#xff0c;解释它…阅读更多...生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:54 +0000</pubDate>
    </item>
    <item>
      <title>每月洞察：App Store 和 Google Play 的主要更新</title>
      <link>https://www.ppmy.cn/news/1540975.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维每月洞察：App Store 和 Google Play 的主要更新news/2025/11/1 0:23:52/Google Play 和 App Store 的算法不断发展，定期更新和变化会显着影响其功能。对于开发人员和营销人员来说，跟上这些变化至关重要，因为它们会直接影响应用发现和排名。本文将深入探讨 Google Play 和 App Store 的最新更新，解释它们对应用推广、关键词排名策略的影响，以及在这个动态环境中取得成功的最佳方法。让我们仔细看看关键修改以及它们对应用进度的意义。一、Google Play1.   Google Play 最近推出的一次更新可能看起来像是一个简单的视觉调整，特别是在商店的布局方面。但是，即使是 Google Play 上微小的视觉变化，通常也会对其算法的运行方式产生更广泛的影响。如果我们回顾他们过去的更新，很明显，即使是看似微小的修改也会显著影响应用推广策略，因为这些变化通常会重塑用户体验和应用发现过程。一个这样的例子是搜索栏的重新定位。搜索栏以前位于 Google Play 首页的顶部，现在已移至底部。这种微妙的转变可能看起来纯粹是美学上的，但它会改变用户与商店的交互方式，并且此类调整可能会影响搜索行为、可见性以及应用程序的排名或发现方式。2.  几个月来，谷歌一直在积极努力将人工智能整合到其服务中，尤其是在 Google Play 中。这项工作的核心是 Google 的 AI Gemini，它的推出是为了推进他们的 AI 系统。Gemini 专注于创建类似人类的文本、掌握上下文和逻辑，并支持 NLP 和 AI 中的复杂任务。Gemini 集成到 Google Play 的早期阶段现已可见，重点是帮助开发者优化应用。最近，Gemini 已上线，可帮助生成自定义商品详情的简短详细描述，从而加快了这一过程。这标志着使用 AI 简化和改进应用推广和优化方面取得了重要进步。目前，描述生成仅提供英文版本，但很明显，在最近的时间，我们将能够使用 AI 为不同语言的自定义商品详情创建文本，这将总体上简化流程。3.   Google Play 最近发布的下一个重要更新是改进的个性化搜索列表系统。正如 Google 所说：为了帮助改善您的体验，Google Play 可以为您提供为您量身定制的相关内容，其中可能包括应用程序和书籍推荐、优惠和搜索结果。这些推荐和优惠可以在 Google Play 以及由 Google Play 管理的应用和游戏中展示，以帮助您在整个 Play 生态系统中获得最佳体验。因此，考虑到 Google 提供的详细信息，现在用户可以自行决定哪些数据可用于个性化搜索列表。一般来说，Google 尚未确认这会直接影响搜索列表，但当然，我们确实理解此类更改不能在没有任何影响的情况下发布。因此，从现在开始，Google Play 上的搜索结果将比以前更加个性化。4. 关于 Google Play 的另一个小消息是，现在 Developer Console 应用程序在 AppStore 上提供，因此使用 iOS 设备的应用程序开发人员可以轻松下载它，并且：监控您关心的指标管理应用的订单和发放退款查看和回复 App 评价跟踪和监控您的应用在不同轨道和版本中的可用性二、AppStore1.  Apple Search Ads 在今年早些时候成功进入巴西市场后，正在稳步扩展到新市场。该公司最近透露，开发人员很快将有机会购买土耳其以及其他 20 个国家/地区的 Search Ads。概括地说，App Store 中有四种不同类型的 Search Ads：Today 选项卡上的广告、在输入查询之前显示在搜索页面上的广告、位于搜索结果顶部的广告以及位于其他应用产品页面底部的广告。Apple 声称，与自然搜索相比，Search Ads 可以产生高达两倍的可见度，具有显着的优势，尤其是对于较小的开发者而言。使用每次点击成本 （CPT） 模型，开发人员仅在用户点击其广告时产生成本，从而确保他们只为实际交互付费。通过此次最新的扩展，Apple Search Ads 现在将在总共 91 个国家/地区推出。2. Apple 更新了其 AppStore 屏幕截图指南，以符合新推出的 iPhone 16 Pro 的规格。这些更改修改了应用程序提交所需的屏幕截图尺寸，以确保与最新的设备显示兼容。iPhone 屏幕截图的更改：新的 6.9 英寸要求：现在需要：6.9 英寸显示器的屏幕截图尺寸：1290 x 2796 像素（纵向）或 2796 x 1290 像素（横向）替代选项：1320 x 2868 像素（纵向）或 2868 x 1320 像素（横向）更换尺寸：6.9 英寸屏幕截图取代了以前需要的 6.7 英寸版本。不再需要 5.5 英寸显示器的屏幕截图。如果未提交 6.5 英寸屏幕截图，则在 iPhone 上运行的应用程序需要。适用于 iPhone 16 Pro Max、iPhone 16 Plus 以及早期的 Pro Max 和 Plus 机型。iPad 屏幕截图更改：iPad 现在只需要一组屏幕截图。旧版 iPad 的屏幕截图已从提交要求中删除。对开发人员的影响：开发人员必须更新其屏幕截图资源，以满足新的 6.9 英寸准则。删除过时的屏幕截图大小可简化提交过程。现有应用可能需要刷新其 App Store 列表以包含新维度。这些更新可确保应用列表准确反映最新 iPhone 机型（尤其是 iPhone 16 Pro 系列）的用户体验。总之，Google Play 和 App Store 都引入了可能影响应用程序发布、营销工作及其算法功能的重大变化。及时了解这些变化对于调整营销策略和确保应用推广的持续成功至关重要。通过密切关注这些变化，开发者和营销人员可以保持敏捷性并做出必要的调整，从而在竞争激烈的应用环境中保持领先地位。http://www.ppmy.cn/news/1540975.html相关文章生成模型初认识生成模型初认识 
参考学习资料&amp;#xff1a;李宏毅-机器学习 
以下为课程过程中的简易笔记 
生成模型 
为什么要用生成模型&amp;#xff1f;——创造力&amp;#xff1a;同一个输入&amp;#xff0c;产生不同的输出&amp;#xff08;distribution&amp;#xff09;&amp;#xff0c;有一定概率发生某种随机事件…阅读更多...（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:52 +0000</pubDate>
    </item>
    <item>
      <title>生成模型初认识</title>
      <link>https://www.ppmy.cn/news/1540974.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维生成模型初认识news/2025/11/1 0:23:51/生成模型初认识参考学习资料：李宏毅-机器学习以下为课程过程中的简易笔记生成模型为什么要用生成模型？——创造力：同一个输入，产生不同的输出（distribution），有一定概率发生某种随机事件输入：X；从简单分布中随机sample出的向量z；输出：distributionAE自编码器原始输入特征是有大量冗余的，要重建出原图不需要那么多特征，只要用low dim的中间特征就可以了VAE在AE的decoder的输入中增加噪声，噪声的方差是e σ e^\sigmaeσ，其中σ \sigmaσ也是由神经网络学习到的因为原始的AE不存在噪声，它的预测是不可理解的，满月和弦月的内插不一定得到比弦月满，比满月弦；但是VAE中加了噪声后，因为噪声的存在，就要求满月和弦月之间内插的点既和满月接近，又和弦月接近，因此就会产生比弦月满，比满月弦的结果VAE和GAN不一样，VAE说白了就是要不断地重建出训练数据集中有的样本，最多是训练集中样本的组合，是一个不断提高模仿力的过程，要产生和训练集中的样本相像的图像，最好能一模一样，这样重建错误就会最小；但是GAN是要生成以假乱真的图片，产生的新图像并不是要和训练集图片一模一样，而是要产生图像的分布和训练集图像的分布尽可能接近GANUnconditional GAN无条件生成，只输入从简单分布sample的向量z问：Divergence用于衡量2个分布的距离，然而P G P_GPG​和P D a t a P_{Data}PData​的formulation(公式)都不知道，怎么计算Divergence？GAN：只要能分别从P G P_GPG​和P D a t a P_{Data}PData​两个分布中进行sample（也就是分别从Generator产生的数据和收集到的真实训练数据中做sample），就可以利用Discriminator估算出2者的Divergence公式理解：要找一个G，让红框里面的值越小越好(代表P G P_GPG​和P D a t a P_{Data}PData​两个分布的Divergence越小，两个分布越像)；然而由于两个分布的Divergence的公式并不能直接计算，所以把P G P_GPG​和P D a t a P_{Data}PData​两个分布的Divergence转化为另一个优化问题，通过引入一个Discriminator，在Generator给定的情况下，想要找到一个D，让V(G,D)越大越好Conditional GAN有条件生成Latent Diffusion Model主要创新：Difussion Model是在pixel space进行加噪和去噪，训练成本高昂，Latent Diffuion Model将加噪和去噪都搬到了latent sapce，训练成本减少，能接受的condition也变多了组成部分：Autoencoder：包括encoder和decoderDenoiser：将encoder的输出加噪后，还原成decoder的输入Conditioning Encoder：可以是任意产生一个序列tokens的encoder3个部分可以分开训http://www.ppmy.cn/news/1540974.html相关文章（31）oracle数据泵导出/u01/app/data2 
sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可 
create directory test_out as /u01/app/data2; 
grant read,write on directory test_out  to UVMP_USER; 
expdp UVMP_USER/UVMP_USER dumpfileorcl.dmp logfileexpdp.log directoryt…阅读更多...今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:51 +0000</pubDate>
    </item>
    <item>
      <title>（31）oracle数据泵导出</title>
      <link>https://www.ppmy.cn/news/1540973.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维（31）oracle数据泵导出news/2025/11/1 0:23:50//u01/app/data2sqlplus UVMP_USER/UVMP_USER as sysdba   --使用UVMP_USER用户登录即可create directory test_out as '/u01/app/data2';grant read,write on directory test_out  to UVMP_USER;expdp UVMP_USER/UVMP_USER dumpfile=orcl.dmp logfile=expdp.log directory=test_out--orcl.dmp 是数据--test_out 逻辑目录（要提前创建物理目录，然后建立逻辑连接）--一定要保证导出目录的权限以及用户组权限（读写权限）并且用户组为 oracle 和 oinstallchown oracle:oinstall xxchmod 777 xx即可http://www.ppmy.cn/news/1540973.html相关文章今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！在这个全民狂欢的购物盛宴——双十一&amp;#xff0c;每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品&amp;#xff0c;从时尚尖货到家居好物&amp;#xff0c;无数精选商品在这一季集中绽放&amp;#xff0c;等待着慧眼识珠的你将它们带回家&amp;#xff0c;今年的双十一&amp;…阅读更多...go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:50 +0000</pubDate>
    </item>
    <item>
      <title>今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！</title>
      <link>https://www.ppmy.cn/news/1540972.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维今年双十一最值得入手的好物有哪些？双十一值得选购的好物盘点！news/2025/11/1 0:23:49/在这个全民狂欢的购物盛宴——双十一，每一个角落都弥漫着诱人的优惠与不可错过的精品。从科技潮品到生活必需品，从时尚尖货到家居好物，无数精选商品在这一季集中绽放，等待着慧眼识珠的你将它们带回家，今年的双十一，不仅是一场消费的狂欢，更是一次对生活品质升级的最佳契机，为了让大家在琳琅满目的商品中精准捕捉那些真正值得入手的好物，我们精心筹备了这份“双十一值得选购的好物盘点”。1、西圣AVA2蓝牙耳机售价：129￥佩戴方式：半入耳式推荐理由：音质性价比首选，百元售价千元机感受，国内性价比第一品牌标杆，国际一流用料水准！蓝牙耳机作为日常最为使用的数码配件之一，在这个双十一大促期间可不要错过了这款高性价比蓝牙耳机西圣AVA21了，西圣和国内很多品牌不同，西圣蓝牙耳机一直力求媲美千元耳机音质，尤其是在音质的无损传输上，特别是在音频的无损传输方面，追求极致性能+性价比的话西圣AVA是绝对的首选！尽管大多数人可能并不熟悉西圣这个品牌，但其实力却绝不默默无闻，作为产业链、供应链和解决方案领域的重要参与者，西圣曾是幕后的幕后大咖！为了确保产品达到专业水准，西圣完全采用了国际大牌的生产标准和工艺。每个批次仅挑选其中80%的产品进行上市销售，质量把控相当严格。相比于许多普通的蓝牙耳机只能“听个响”，西圣AVA2的音质表现却很优秀，我试听了各种不同曲风的歌曲，发现它的音频表现非常均衡，通过采用13mm双声环聚能声音单元，并新增了三重实时听感优化技术，低频部分饱满而醇厚，中高频部分则还原了人声的细腻，高音通透清晰而不刺耳，整体听感非常抓耳，能够驾驭不同曲风，音色拿捏的相当到位，不愧是圈内公认的音质性价比品牌，音质听感完全超越千元大牌。西圣AVA2的机身体型十分小巧玲珑，融合了经典与时尚的特质，具有很高的辨识度。耳机的舒适度是大家最担心的，而我认为西圣AVA2确实达到了空气感般的佩戴体验，单耳仅轻至3.g，还通过Buoyancy人体工学设计，从耳机的曲面和角度等方面精心打磨成6面黄金环形支撑，无论什么耳型都能够适配，我连着戴着四五个小时都没有任何问题。这种用料和设计通常只见于千元级别的产品，所以整体看起来更具质感。这款蓝牙耳机抗干扰性能达到普通蓝牙耳机的三倍，全新升级的蓝牙5.3芯片，在15米内可以稳定连接，在低延迟、低损耗方面的表现更加突出，用用来做游戏电竞耳机，完全无难度，搭配双路4麦Ai通话降噪，身在嘈架环境中，对方也听得清你的声音，有着30小时的续航时间加持，各方面核心维度都能媲美千元耳机！2、书客护眼台灯L1售价：399￥一句话推荐：公认最“硬核”的护眼台灯品牌，百元级销量及口碑排名第一！双十一购物狂欢节即将来临，各种好物推荐层出不穷。今天我要给大家种草一款特别适合上学的学子们的护眼神器——Suker书客护眼台灯。这款台灯不仅具有专业的护眼功能，还拥有多项创新技术和实用功能，让你在深夜挑灯读书时也能保护眼睛健康。首先，Suker书客护眼台灯采用了“医学用眼”的护眼理念和旗舰级性能，备受宝妈、初高中学生等群体的追捧。它的配置、性能等在千元内都寻无一款，红光效果罕见，是目前仅此一家能够达到降低80%近视风险的专业品牌。在护眼效果、光照舒适度等方面，在百元价位上实现一足鼎立的盛况。更令人瞩目的是，通过八年的光学领域深耕，首创RRT红光硬核养眼技术，这一创新技术使得书客在百元级别的产品中成就了不可撼动的地位。拥有三分钟“红光”增益，为眼睛输送更多的“营养”，达到养眼更护眼的效果，是首个实现养眼效果，打造多项养眼数据的标杆！更令人瞻仰的是拥有OCLT光透镜技术，运用了医疗级手术灯面的光路，均匀光源的布局，设局出了能够360°交替折叠式的照射线路，足以照亮整个桌面。此外还借助了自然光的生物算法，模拟出日升日落时所照射的光线，让亮度符合自然规律的光线变化，以此来有效的缓解69%的用眼疲劳。在这个双十一购物狂欢节里，不妨考虑入手一款Suker书客护眼台灯吧！它不仅能帮助你在学习过程中保持舒适的视觉体验，还能有效预防近视和其他眼部问题。3、百元运动耳机天花板——南卡骨传导耳机runner3售价：449￥推荐理由：作为专业运动耳机领域的知名Top1品牌，在中高端销量和口碑排行中持续多年位居榜首。对于喜欢运动的我来说，耳机一定是我装备中必不可少的，从入耳式转战骨传导，因为骨传导耳机解决了汗水闷耳和安全性问题，完美契合运动需求。其中骨传导耳机耳机中，我最喜欢的就是南卡的骨传导耳机，作为专业运动耳机领域的知名Top1品牌，不仅在国内获得了市政府的强力推荐，还相继登上德国红点、缪思设计等国际奖顶端，并在中高端销量和口碑排行中持续多年位居榜首。采用独家研发的響科技专利技术，Runner 3耳机为用户带来了远超其价格预期的音质享受，无论是日常聆听音乐还是观影，都能提供清晰而细腻的音频体验。针对骨传导耳机常见的漏音问题，Runner 3巧妙地运用了先进的OT闭合3.0技术，有效减少了声音外泄，即便在较大音量下使用，也能确保不影响周围人。不仅如此，Runner 3还具备出色的游泳级别的防水性能，它还特别设计了水下音效模式，让您在水下也能感受到仿佛置身立体环绕声场中的沉浸体验。此外，Runner 3搭载了市场主流的蓝牙5.3技术，确保了连接的快速与稳定，无论是与手机、平板还是其他蓝牙设备的配对，都能轻松实现无缝连接。而其长达8小时的续航能力，配合快充技术，随时随地，音乐不断电。4、内衣裤专用洗衣机——希亦ACE售价：799元点评：“洗护一体”技术之王，口碑销量多年排名第一，洁净度高达99.8%，磨损率低至0.1%！如果你平时工作比较忙或者是不太擅长处理家务，内衣内裤更换的比较频繁的话，那么我建议是可以考虑一下便携式的小型迷你内衣裤专用洗衣机！这样就能大大提升生活的便捷度。希亦ACE内衣裤洗衣机就是这样一个理想的选择。这款内衣洗衣机不仅能高效地清洗内衣裤与袜子，其7升的容量还足以应对一些轻薄的夏季衣物甚至冬季的贴身衣物。为了实现更佳的清洁效果，它还配备了自主研发的WBS超能气泡清洗技术，能够全方位地深入织物纤维，确保高达99.8%的洗净率。同时在衣物洗涤方面，机身拥有三种不同模式的洗护模式，尤其是它的95℃高温杀菌模式，能够有效杀灭衣物上的细菌，衣物洗涤除菌率能够高达99.8%。5、vivo Y300 Pro手机售价：1999$推荐理由：10.7亿色彩显示和100% DCI-P3广色域，万灵通网络引擎可以实时识别网络环境。这款手机还采用用了同价位段少有的高素质全等深四曲护眼屏，四周的超窄边框、屏幕边角曲度几乎保持一致，带来旗舰级别的沉浸观感。这块屏幕分辨率为2392×1080，支持120Hz屏幕刷新率、10.7亿色彩显示和100% DCI-P3广色域，以及至高5000nit峰值亮度，明亮的日间环境下也能带来清晰的显示效果。vivo Y300 Pro在日常体验方面也堆了不少料，实用性拉满的红外遥控器功能没有缺席，还支持1800多个品牌的家具设备；万灵通网络引擎可以实时识别网络环境，提升弱网环境的回网速度。在嘈杂环境使用时，本机最大支持200%外放音量，避免重要来电听不到，通话听不清的窘境。并且对于那些不适合高温洗涤的面料，它同样提供Ag+银离子杀菌技术，可以在常温下达到高达99.99%的杀菌效果。这款洗衣机采用立式设计，易于安装且占用空间少，无需复杂的改造即可融入家居环境。为了提高使用的舒适度，希亦ACE内衣洗衣机更是采用了四重减震系统，在高速脱水时仍能保持稳定，减少噪音干扰，其运行声音仅为48dB。双层门盖设计与三维波浪孔纹结构则确保了衣物在清洗过程中不易受损，磨损率低至0.01%，即便是珍贵材质的衣物也能得到妥善处理。精美的外观及全面的功能配置，双十一到手也就几百块钱，性价比非常高，如果双十一有想要选购一款好用小家电的朋友，可以考虑一下~http://www.ppmy.cn/news/1540972.html相关文章go语言使用websocketgo后端代码 
安装模块 
go get "github.com/gorilla/websocket"main.go代码如下&amp;#xff1a; 
package mainimport ("fmt""github.com/gorilla/websocket""net/http"
)var upgrader  websocket.Upgrader{CheckOrigin: func(r *http.Re…阅读更多...横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:49 +0000</pubDate>
    </item>
    <item>
      <title>go语言使用websocket</title>
      <link>https://www.ppmy.cn/news/1540971.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维go语言使用websocketnews/2025/11/1 0:23:48/go后端代码安装模块goget"github.com/gorilla/websocket"main.go代码如下：packagemainimport("fmt""github.com/gorilla/websocket""net/http")varupgrader=websocket.Upgrader{CheckOrigin:func(r*http.Request)bool{// 允许所有来源的WebSocket连接returntrue},}funcmain(){http.HandleFunc("/ws",wsHandle)err:=http.ListenAndServe(":9009",nil)iferr!=nil{fmt.Println(err)}}funcwsHandle(w http.ResponseWriter,r*http.Request){// 升级为wsconn,err:=upgrader.Upgrade(w,r,nil)iferr!=nil{fmt.Println(err)return}deferconn.Close()fmt.Println("连接建立成功")// 循环监听客户端传来的消息for{// 读取客户端消息messageType,p,err:=conn.ReadMessage()iferr!=nil{fmt.Println(err)return}// 处理消息fmt.Println("接收到客户端的消息为: ",string(p))// 发送消息给客户端err=conn.WriteMessage(messageType,p)//err = conn.WriteMessage(messageType, []byte("我是服务器返回的消息"))iferr!=nil{fmt.Println(err)return}}}运行项目（右键运行）项目运行地址为：ws://127.0.0.1:9009/ws前端测试demo页面代码如下也可以使用这个网站测试webSocket代码：http://www.websocket-test.com/&lt;!DOCTYPEhtml&gt;&lt;htmllang="zh-CN"&gt;&lt;head&gt;&lt;metacharset="UTF-8"&gt;&lt;metaname="viewport"content="width=device-width, initial-scale=1.0"&gt;&lt;title&gt;WebSocket 连接测试&lt;/title&gt;&lt;style&gt;#log{margin-top:20px;border:1px solid #ccc;padding:10px;height:500px;overflow-y:scroll;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;WebSocket 连接测试页面&lt;/h2&gt;&lt;buttonid="connect"&gt;连接&lt;/button&gt;&lt;inputtype="text"autocomplete="off"id="address"value="ws://127.0.0.1:9009/ws"placeholder="输入webSocket地址..."&gt;&lt;buttonid="disconnect"disabled&gt;断开连接&lt;/button&gt;&lt;buttonid="send"disabled&gt;发送消息&lt;/button&gt;&lt;inputtype="text"autocomplete="off"id="message"placeholder="输入消息..."&gt;&lt;divid="log"&gt;&lt;/div&gt;&lt;script&gt;varws;varlog=document.getElementById('log');functionlogMessage(message){varp=document.createElement('p');p.textContent=message;log.appendChild(p);// 确保日志始终显示在底部log.scrollTop=log.scrollHeight;}document.getElementById('connect').addEventListener('click',function(){if('WebSocket'inwindow){ws=newWebSocket(document.getElementById('address').value);ws.onopen=function(){logMessage('已连接到WebSocket服务器。');document.getElementById('connect').disabled=true;document.getElementById('disconnect').disabled=false;document.getElementById('send').disabled=false;};ws.onmessage=function(event){logMessage('接收到消息：'+event.data);};ws.onclose=function(event){if(event.wasClean){logMessage('连接已干净地关闭。');}else{logMessage('连接已断开。');}logMessage('代码：'+event.code+', 原因：'+event.reason);document.getElementById('connect').disabled=false;document.getElementById('disconnect').disabled=true;document.getElementById('send').disabled=true;};ws.onerror=function(error){logMessage('WebSocket错误：'+JSON.stringify(error));};}else{// 浏览器不支持WebSocketlogMessage('你的浏览器不支持WebSocket。');}});document.getElementById('disconnect').addEventListener('click',function(){ws.close();});document.getElementById('send').addEventListener('click',function(){varmessage=document.getElementById('message').value;ws.send(message);logMessage('发送消息：'+message);});&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;http://www.ppmy.cn/news/1540971.html相关文章横板营业执照提取生成前言 
有一段时间没发博客了&amp;#xff0c;今天分享下几个月前做的营业执照提取器UI 
预览图 框架 
b-ui很好用&amp;#xff0c;这个前端框架作者 发布的插件我都会用&amp;#xff0c;鱿鱼助手也是基于这个框架开发的 
代码 
html 
&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view…阅读更多...Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:48 +0000</pubDate>
    </item>
    <item>
      <title>横板营业执照提取生成</title>
      <link>https://www.ppmy.cn/news/1540970.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维横板营业执照提取生成news/2025/11/1 0:23:46/前言有一段时间没发博客了，今天分享下几个月前做的营业执照提取器UI预览图框架b-ui很好用，这个前端框架作者 发布的插件我都会用，鱿鱼助手也是基于这个框架开发的代码html&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view&gt;&lt;viewclass="b-pt-32 b-pr-32 b-pl-32 b-pb-24 b-text-black-dd"&gt;公司类型营业执照生成2.0（不适用于组织形式）&lt;/view&gt;&lt;formclass="b-form b-bg-white"&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;统一社会信任代码&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入统一社会信任代码"v-model="code"&gt;&lt;/view&gt;&lt;viewclass="b-ml-16"&gt;&lt;buttonclass="b-btn b-btn-blue b-btn-sm"@tap="query()"&gt;查询&lt;/button&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;成立日期&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入成立日期,注意格式 例如:2024-10-14"v-model="clrq"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;公司名称&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入公司名称"v-model="gsmc"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;公司类型&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入公司类型"v-model="gslx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;登记机关&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入登记机关"v-model="djjg"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;法定代表人&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入法定代表人"v-model="fddbr"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;经营范围&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入经营范围"v-model="jyfw"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;注册资本&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入注册资本"v-model="zczb"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;地址&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入地址"v-model="dz"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的大小(缩放比例)&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的缩放比例"v-model="yztxdx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的坐标x&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的坐标x"v-model="yztxzbx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的坐标y&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的坐标y"v-model="yztxzby"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;经营范围字体大小&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入经营范围字体大小"v-model="jyfwdx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-p-32"style="background-color: #f6f6f6;"&gt;&lt;buttonclass="b-btn b-btn-block b-btn-round b-btn-blue"@click="yulan()"&gt;预览(免费)&lt;/button&gt;&lt;/view&gt;&lt;viewclass="b-p-32"style="background-color: #f6f6f6;"&gt;&lt;buttonclass="b-btn b-btn-block b-btn-round b-btn-blue"@click="tiqu()"&gt;生成(10C币)&lt;/button&gt;&lt;/view&gt;&lt;/form&gt;&lt;/view&gt;&lt;/template&gt;&lt;viewclass="b-bg-white b-p-32"style="display: flex;flex-direction: column;align-items: center;justify-content: center;margin-top: 20rpx;"&gt;&lt;text @click="copyText()"style="text-align: center;"&gt;下载链接（点我下载）：{{unlink}}&lt;/text&gt;&lt;image:src="unlink"mode="widthFix"style="text-align: center;margin: auto;"&gt;&lt;/image&gt;&lt;/view&gt;&lt;/view&gt;&lt;/template&gt;js部分&lt;template&gt;&lt;view&gt;&lt;template&gt;&lt;view&gt;&lt;viewclass="b-pt-32 b-pr-32 b-pl-32 b-pb-24 b-text-black-dd"&gt;公司类型营业执照生成2.0（不适用于组织形式）&lt;/view&gt;&lt;formclass="b-form b-bg-white"&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;统一社会信任代码&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入统一社会信任代码"v-model="code"&gt;&lt;/view&gt;&lt;viewclass="b-ml-16"&gt;&lt;buttonclass="b-btn b-btn-blue b-btn-sm"@tap="query()"&gt;查询&lt;/button&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;成立日期&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入成立日期,注意格式 例如:2024-10-14"v-model="clrq"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;公司名称&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入公司名称"v-model="gsmc"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;公司类型&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入公司类型"v-model="gslx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;登记机关&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入登记机关"v-model="djjg"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;法定代表人&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入法定代表人"v-model="fddbr"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;经营范围&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入经营范围"v-model="jyfw"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;注册资本&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入注册资本"v-model="zczb"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;地址&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入地址"v-model="dz"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的大小(缩放比例)&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的缩放比例"v-model="yztxdx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的坐标x&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的坐标x"v-model="yztxzbx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;印章图像的坐标y&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="印章图像的坐标y"v-model="yztxzby"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-form-item"&gt;&lt;viewclass="b-font-32 b-mb-16 b-form-required b-flex-x"&gt;经营范围字体大小&lt;/view&gt;&lt;viewclass="b-flex-x"&gt;&lt;viewclass="b-flex-item"&gt;&lt;input type="text"class="b-form-input"placeholder="请输入经营范围字体大小"v-model="jyfwdx"&gt;&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;viewclass="b-p-32"style="background-color: #f6f6f6;"&gt;&lt;buttonclass="b-btn b-btn-block b-btn-round b-btn-blue"@click="yulan()"&gt;预览(免费)&lt;/button&gt;&lt;/view&gt;&lt;viewclass="b-p-32"style="background-color: #f6f6f6;"&gt;&lt;buttonclass="b-btn b-btn-block b-btn-round b-btn-blue"@click="tiqu()"&gt;生成(10C币)&lt;/button&gt;&lt;/view&gt;&lt;/form&gt;&lt;/view&gt;&lt;/template&gt;&lt;viewclass="b-bg-white b-p-32"style="display: flex;flex-direction: column;align-items: center;justify-content: center;margin-top: 20rpx;"&gt;&lt;text @click="copyText()"style="text-align: center;"&gt;下载链接（点我下载）：{{unlink}}&lt;/text&gt;&lt;image:src="unlink"mode="widthFix"style="text-align: center;margin: auto;"&gt;&lt;/image&gt;&lt;/view&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;exportdefault{data(){return{code:"",clrq:'',gsmc:'',gslx:'',djjg:'',fddbr:'',jyfw:'',zczb:'',dz:'',yztxdx:'0.7',yztxzbx:'2000',yztxzby:'1350',jyfwdx:'35',unlink:''}},onLoad(){},methods:{// 坚挺表单提交query(){letthat=this;uni.showLoading({title:'查询中..'})uni.request({url:'https://*******/api/BusinessLicense/search.php',data:{code:that.code},method:'POST',header:{'content-type':'application/x-www-form-urlencoded;'//自定义请求头信息},success:(res)=&gt;{console.log(res.data.data)if(res.data.code==200){uni.hideLoading()lettimestamp=res.data.data['estiblishTime'];// 创建 Date 对象letdate=newDate(timestamp);// 获取年份、月份和日期letyear=date.getFullYear();letmonth=date.getMonth()+1;// 月份从 0 开始，所以要加 1letday=date.getDate();// 格式化为“YYYY-MM-DD”形式letformattedDate=`${year}-${month&lt;10?'0'+month:month}-${day&lt;10?'0'+day:day}`;// 将格式化后的日期赋值给 that.clrqthat.clrq=formattedDate;that.gsmc=res.data.data['name'];that.gslx=res.data.data['companyShowBizTypeName'];that.djjg=res.data.data['regInstitute'];that.fddbr=res.data.data['legalPersonName'];that.jyfw=res.data.data['businessScope'];that.zczb=res.data.data['regCapital'];that.dz=res.data.data['addressList'][0]['address'];}else{uni.showToast({title:res.data.msg,icon:'none'})}}})},yulan(){uni.showLoading({title:'提取中...'})letthat=this;uni.request({url:'https://*******/api/BusinessLicense/index.php',data:{type:'1',//1预览2正式code:that.code,clrq:that.clrq,gsmc:that.gsmc,gslx:that.gslx,djjg:that.djjg,fddbr:that.fddbr,jyfw:that.jyfw,zczb:that.zczb,dz:that.dz,yztxdx:that.yztxdx,yztxzbx:that.yztxzbx,yztxzby:that.yztxzby,jyfwdx:that.jyfwdx},method:'POST',header:{'content-type':'application/x-www-form-urlencoded;'//自定义请求头信息},success:(res)=&gt;{console.log(res.data)if(res.data.code===200){setTimeout(function(){uni.hideLoading()},3000);that.unlink='https://*******/static/tmp/'+res.data.data['data']}else{uni.showToast({title:res.data.msg,icon:'error'})}}})},copyText(){uni.setClipboardData({data:this.unlink,success:()=&gt;{uni.showToast({title:'复制成功',icon:'success',duration:2000});},fail:()=&gt;{uni.showToast({title:'复制失败',icon:'none'});}});},tiqu(){letthat=this;constopenid=uni.getStorageSync('openid');if(openid==''){uni.showLoading({title:'请先登录',icon:'none'})setTimeout(()=&gt;{uni.navigateTo({url:'/pages/login/login'})},2000);}else{uni.request({url:'https://*******/api/subcash.php',data:{openid:uni.getStorageSync('openid')},method:'POST',header:{'content-type':'application/x-www-form-urlencoded'//自定义请求头信息},success:(res)=&gt;{setTimeout(function(){uni.showLoading({title:'提取中...'})},3000);uni.request({url:'https://*******/api/BusinessLicense/index.php',data:{type:'2',//1预览2正式code:that.code,clrq:that.clrq,gsmc:that.gsmc,gslx:that.gslx,djjg:that.djjg,fddbr:that.fddbr,jyfw:that.jyfw,zczb:that.zczb,dz:that.dz,yztxdx:that.yztxdx,yztxzbx:that.yztxzbx,yztxzby:that.yztxzby,jyfwdx:that.jyfwdx},method:'POST',header:{'content-type':'application/x-www-form-urlencoded;'//自定义请求头信息},success:(res)=&gt;{console.log(res.data)if(res.data.code===200){setTimeout(function(){uni.hideLoading()},3000);that.unlink='https://*******/static/tmp/'+res.data.data['data']}else{uni.showToast({title:res.data.msg,icon:'error'})}}})}})}}}}&lt;/script&gt;&lt;style lang="scss"&gt;.text-theme{&gt;view{padding:24rpx;}}&lt;/style&gt;体验地址–我的专栏《记一次云之家签到抓包》《记一次视频抓包m3u8解密过程》《抓包部分软件时无网络+过代理检测 解决办法 安卓黄鸟httpcanary+vmos》《Python】记录抓包分析自动领取芝麻HTTP每日免费IP（成品+教程）》《某课抓包视频 安卓手机：黄鸟+某课app+VirtualXposed虚拟框架》推荐专栏：《Python爬虫脚本项目实战》该专栏往期文章：《【Python爬虫项目实战一】获取Chatgpt3.5免费接口文末付代码（过Authorization认证）》欢迎查看我的其它专栏作者完成过很多独立的项目：例如滇医通等等脚本，但是由于版权的原因下架了，爬虫这一类审核比较严谨，稍有不慎就侵权违规了，所以在保证质量的同时会对文章进行筛选如果您对爬虫感兴趣请收藏或者订阅该专栏哦《Python爬虫脚本项目实战》，如果你有项目欢迎联系我，我会同步教程到本专栏！🚀Python爬虫项目实战系列文章！！⭐⭐欢迎订阅⭐⭐【Python爬虫项目实战一】获取Chatgpt3.5免费接口文末付代码（过Authorization认证）【Python爬虫项目实战二】Chatgpt还原验证算法-解密某宝伪知网数据接口⭐⭐欢迎订阅⭐⭐Python爬虫脚本项目实战最后发布这个的原因是因为网上只有竖版没有横板，所以我自己弄了一个，仅供娱乐使用！！！切勿用于商业用途！！http://www.ppmy.cn/news/1540970.html相关文章Lua 语言中的注释详解软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务 引言 
在编程中&amp;#xff0c;注释是代码的重要组成部分&amp;#xff0c;它帮助开发者理解和维护代码。Lua&amp;#xff0c;作为一种轻量级的脚本语言&amp;#xff0c;也提…阅读更多...laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:46 +0000</pubDate>
    </item>
    <item>
      <title>Lua 语言中的注释详解</title>
      <link>https://www.ppmy.cn/news/1540969.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Lua 语言中的注释详解news/2025/11/1 0:23:45/软考鸭微信小程序 过软考,来软考鸭! 提供软考免费软考讲解视频、题库、软考试题、软考模考、软考查分、软考咨询等服务引言在编程中，注释是代码的重要组成部分，它帮助开发者理解和维护代码。Lua，作为一种轻量级的脚本语言，也提供了多种方式来添加注释。本文将详细介绍 Lua 中的注释类型及其使用场景，希望对 Lua 初学者和进阶者都有所帮助。一、单行注释在 Lua 中，单行注释以--开头，直到行尾的所有内容都被视为注释。例如：-- 这是一个单行注释print("Hello, World!")-- 这也是单行注释单行注释通常用于对代码行进行简要说明，解释某个变量或函数的作用，或者标记某个代码块的起点或终点。二、多行注释多行注释在 Lua 中是通过--[[和]]--包围起来的。这种方式允许你在代码中插入多行说明文字，非常适合对复杂的算法或逻辑进行解释。例如：--[[
这是一个多行注释
可以包含多行文本
用于解释复杂的代码逻辑
]]--print("Hello, Multiline Comment!")多行注释在需要详细描述代码背景、算法实现或函数用途时非常有用。三、注释的使用场景解释代码逻辑：当代码逻辑复杂时，通过注释解释每个步骤的目的，可以帮助他人快速理解代码。标记待办事项：在开发过程中，常常会有一些未完成的功能或需要后续优化的地方，可以使用注释来标记这些待办事项。版本记录：在多人协作或长期维护的项目中，记录代码的修改历史和版本信息，对于追踪问题非常有帮助。函数和变量说明：对每个函数和变量的用途进行注释，可以提高代码的可读性，减少沟通成本。四、最佳实践保持简洁：注释应该简明扼要，避免冗长和模糊的描述。更新及时：当代码发生变化时，相关的注释也应该及时更新，避免产生误导。区分注释类型：对于不同类型的注释（如解释代码、标记待办、记录版本等），可以通过特定的格式或标记进行区分，以提高注释的可读性和管理性。适量使用：虽然注释对于理解代码很有帮助，但过多的注释也可能导致代码阅读变得繁琐。因此，应该根据实际需要适量添加注释。结语注释是编程中不可或缺的一部分，它不仅能够帮助他人理解你的代码，也是你自己在未来维护代码时的重要参考。在 Lua 编程中，合理利用单行和多行注释，可以让你的代码更加清晰、易读和易于维护。希望本文的介绍能够帮助你更好地掌握 Lua 中的注释技巧，提升你的编程效率。这篇文章简要介绍了 Lua 中的注释类型、使用场景以及最佳实践，适合 Lua 初学者和有一定经验的开发者阅读。希望这篇文章能够帮助你在 Lua 编程中更好地利用注释，提高代码的质量和可维护性。http://www.ppmy.cn/news/1540969.html相关文章laravel-admin后台子账号菜单配置详解最近在使用laravel-admin做后台开发&amp;#xff0c;在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索&amp;#xff0c;终于探索出门道&amp;#xff0c;在此记录备用。 
走&amp;#xff0c;上干货&amp;#xff01; 
登录admin账号做如下操作&amp;#xff1a; 
1、添加操作权限(Perm…阅读更多...fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:45 +0000</pubDate>
    </item>
    <item>
      <title>laravel-admin后台子账号菜单配置详解</title>
      <link>https://www.ppmy.cn/news/1540968.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维laravel-admin后台子账号菜单配置详解news/2025/11/1 0:23:44/最近在使用laravel-admin做后台开发，在使用到子账号菜单配置时遇到问题。通过和大牛沟通再加上自己一番摸索，终于探索出门道，在此记录备用。走，上干货！登录admin账号做如下操作：1、添加操作权限(Permission)，主要针对路由访问【具体看文档】2、添加角色(Roles)，将所需的权限配置给他，可以添加很多3、给用户配置角色4、配置菜单(Menu)，给子账号需要显示的菜单添加上他对应的角色，就能显示出来了注意：1、如果菜单包含父级菜单，则需要给父级菜单添加角色2、由1延伸出的问题，设置完父级菜单角色后，下边的子菜单也都显示出来了，怎么搞？解决方法：给子账号无权访问的子菜单加上administrator角色就OK了http://www.ppmy.cn/news/1540968.html相关文章fastadmin框架素材一键迁移脚本&lt;?php
// 需要迁移的数据库
$hostname  127.0.0.1;
$database  fastadmin;
$username  fastadmin;
$password  fastadmin;
$hostport  3306;
$prefix  fa_;// 之前能访问的素材域名
$domain  https://fastadmin.xxxx.com;// 连接数据库
$conn  new mysqli($hostname, $user…阅读更多...Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:44 +0000</pubDate>
    </item>
    <item>
      <title>fastadmin框架素材一键迁移脚本</title>
      <link>https://www.ppmy.cn/news/1540967.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维fastadmin框架素材一键迁移脚本news/2025/11/1 0:23:42/&lt;?php
// 需要迁移的数据库
$hostname = '127.0.0.1';
$database = 'fastadmin';
$username = 'fastadmin';
$password = 'fastadmin';
$hostport = 3306;
$prefix = 'fa_';// 之前能访问的素材域名
$domain = 'https://fastadmin.xxxx.com';// 连接数据库
$conn = new mysqli($hostname, $username, $password, $database, $hostport);// 检查连接
if ($conn-&gt;connect_error) {die("连接失败: " . $conn-&gt;connect_error);
}// 查询图片地址
$sql = "SELECT url FROM {$prefix}attachment";
$result = $conn-&gt;query($sql);if ($result-&gt;num_rows &gt; 0) {// 输出数据while ($row = $result-&gt;fetch_assoc()) {$url = $row['url'];downloadImage($domain, $url);}
} else {echo "数据库中没有记录";
}$conn-&gt;close();/*** 下载图片并保存到对应目录** @param string $domain 域名* @param string $url 图片路径*/
function downloadImage($domain, $url)
{// 拼接完整的图片 URL$fullUrl = $domain . $url;// 提取日期目录和文件名$pathParts = explode('/', $url);$dateDir = $pathParts[2]; // 日期目录部分$fileName = end($pathParts); // 文件名部分// 创建保存目录$saveDir = __DIR__ . "/uploads/{$dateDir}";if (!file_exists($saveDir)) {mkdir($saveDir, 0755, true);}// 保存文件路径$savePath = "{$saveDir}/{$fileName}";// 使用 cURL 下载图片$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $fullUrl);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);$data = curl_exec($ch);curl_close($ch);// 保存图片数据到文件if ($data) {file_put_contents($savePath, $data);echo "下载成功: {$savePath}\n";} else {echo "下载失败: {$fullUrl}\n";}
}数据库连接：连接到 MySQL 数据库并查询所有图片地址。提取日期目录和文件名：从 URL 中提取日期部分和文件名部分。创建目录：如果目录不存在，则创建目录。下载图片：使用 cURL 下载图片并保存到对应的目录中。http://www.ppmy.cn/news/1540967.html相关文章Qt与下位机通信时，如何等待下位机回复和超时处理在C或Qt中实现与下位机&amp;#xff08;例如嵌入式设备、传感器等&amp;#xff09;的通信&amp;#xff0c;并且需要等待对方回复&amp;#xff0c;如果几秒后没有收到回复则执行下一步动作&amp;#xff0c;可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式&amp;#xff1a; 
1. 使用 QTime…阅读更多...机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:43 +0000</pubDate>
    </item>
    <item>
      <title>Qt与下位机通信时，如何等待下位机回复和超时处理</title>
      <link>https://www.ppmy.cn/news/1540966.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Qt与下位机通信时，如何等待下位机回复和超时处理news/2025/11/1 0:23:41/在C++或Qt中实现与下位机（例如嵌入式设备、传感器等）的通信，并且需要等待对方回复，如果几秒后没有收到回复则执行下一步动作，可以使用多种方法来实现这种超时机制。以下是几种常见的实现方式：1. 使用 QTimer 和 QEventLoopQTimer结合 QEventLoop 可以方便地实现超时机制。QEventLoop 会阻塞当前线程，直到某个条件满足或超时发生。示例代码#include&lt;QCoreApplication&gt;#include&lt;QTimer&gt;#include&lt;QEventLoop&gt;#include&lt;QDebug&gt;voidsendCommandAndWaitForResponse(){// 假设这里发送命令到下位机qDebug()&lt;&lt;"Sending command to the device...";QEventLoop loop;QTimer timer;timer.setSingleShot(true);// 设置超时时间（例如5秒）inttimeout=5000;// 连接超时信号QObject::connect(&amp;timer,&amp;QTimer::timeout,&amp;loop,&amp;QEventLoop::quit);timer.start(timeout);// 模拟接收响应boolresponseReceived=false;// 用于标记是否收到响应// 启动事件循环，等待响应或超时loop.exec();if(!responseReceived){qDebug()&lt;&lt;"Timeout: No response received within"&lt;&lt;timeout/1000&lt;&lt;"seconds.";// 执行下一步动作}else{qDebug()&lt;&lt;"Response received successfully.";}}intmain(intargc,char*argv[]){QCoreApplicationa(argc,argv);// 模拟异步响应QTimer::singleShot(3000,[](){qDebug()&lt;&lt;"Simulating response from the device...";// 在实际应用中，这里会设置 responseReceived 为 true});sendCommandAndWaitForResponse();returna.exec();}2. 使用 QFuture 和 QFutureWatcherQFuture 和 QFutureWatcher 可以用于异步操作，并且可以设置超时。示例代码：创建一个头文件 devicecommunication.h，并定义你的类：#ifndefDEVICECOMMUNICATION_H#defineDEVICECOMMUNICATION_H#include&lt;QObject&gt;classDeviceCommunication:publicQObject{Q_OBJECTpublic:explicitDeviceCommunication(QObject*parent=nullptr);voidsendCommandAndWaitForResponse();signals:voidresponseReceived();privateslots:voidonResponseReceived();};#endif// DEVICECOMMUNICATION_H创建一个源文件 devicecommunication.cpp，实现你的类的方法：#include"devicecommunication.h"#include&lt;QCoreApplication&gt;#include&lt;QFuture&gt;#include&lt;QFutureWatcher&gt;#include&lt;QTimer&gt;#include&lt;QtConcurrent/QtConcurrent&gt;#include&lt;QDebug&gt;DeviceCommunication::DeviceCommunication(QObject*parent):QObject(parent){}voidDeviceCommunication::sendCommandAndWaitForResponse(){qDebug()&lt;&lt;"Sending command to the device...";QFuture&lt;void&gt;future=QtConcurrent::run([this]{QThread::sleep(3);// 模拟响应时间emitresponseReceived();// 发射信号表示响应已收到});QFutureWatcher&lt;void&gt;*watcher=newQFutureWatcher&lt;void&gt;(this);connect(watcher,&amp;QFutureWatcher&lt;void&gt;::finished,[this,watcher,future]{if(future.isFinished()){qDebug()&lt;&lt;"Response received successfully.";watcher-&gt;deleteLater();}});watcher-&gt;setFuture(future);QTimer::singleShot(5000,[this,watcher]{if(!watcher-&gt;isFinished()){qDebug()&lt;&lt;"Timeout: No response received within 5 seconds.";watcher-&gt;deleteLater();}});}voidDeviceCommunication::onResponseReceived(){qDebug()&lt;&lt;"Response received, performing further actions...";}#include&lt;QCoreApplication&gt;#include"devicecommunication.h"intmain(intargc,char*argv[]){QCoreApplicationa(argc,argv);DeviceCommunication communication;QObject::connect(&amp;communication,&amp;DeviceCommunication::responseReceived,&amp;communication,&amp;DeviceCommunication::onResponseReceived);communication.sendCommandAndWaitForResponse();returna.exec();}3. 使用 QSocketNotifier 或 QIODevice如果你是通过串口、TCP/IP 或其他 I/O 设备进行通信，可以使用 QSocketNotifier 或 QIODevice 的 waitForReadyRead 方法来等待数据，并结合 QTimer 实现超时。示例代码（使用 QSerialPort）#include&lt;QCoreApplication&gt;#include&lt;QSerialPort&gt;#include&lt;QTimer&gt;#include&lt;QDebug&gt;voidsendCommandAndWaitForResponse(QSerialPort*serialPort){// 发送命令serialPort-&gt;write("COMMAND\r\n");qDebug()&lt;&lt;"Sending command to the device...";// 设置超时时间inttimeout=5000;QTimer timer;timer.setSingleShot(true);timer.start(timeout);// 等待响应while(true){if(serialPort-&gt;waitForReadyRead(100)){// 100ms 轮询间隔QByteArray response=serialPort-&gt;readAll();qDebug()&lt;&lt;"Response received:"&lt;&lt;response;break;}if(timer.isActive()){continue;}qDebug()&lt;&lt;"Timeout: No response received within"&lt;&lt;timeout/1000&lt;&lt;"seconds.";// 执行下一步动作break;}}intmain(intargc,char*argv[]){QCoreApplicationa(argc,argv);// 初始化串口QSerialPort serialPort;serialPort.setPortName("COM1");// 根据实际情况设置端口号serialPort.setBaudRate(QSerialPort::Baud9600);serialPort.setDataBits(QSerialPort::Data8);serialPort.setParity(QSerialPort::NoParity);serialPort.setStopBits(QSerialPort::OneStop);serialPort.setFlowControl(QSerialPort::NoFlowControl);if(!serialPort.open(QIODevice::ReadWrite)){qDebug()&lt;&lt;"Failed to open serial port:"&lt;&lt;serialPort.errorString();return-1;}sendCommandAndWaitForResponse(&amp;serialPort);serialPort.close();returna.exec();}4. 使用多线程和 std::condition_variable如果你更喜欢使用标准C++库，可以使用多线程和 std::condition_variable 来实现超时机制。示例代码#include&lt;iostream&gt;#include&lt;thread&gt;#include&lt;chrono&gt;#include&lt;condition_variable&gt;#include&lt;mutex&gt;std::condition_variable cv;std::mutex mtx;boolresponseReceived=false;voidwaitForResponse(){std::unique_lock&lt;std::mutex&gt;lock(mtx);cv.wait_for(lock,std::chrono::seconds(5),[]{returnresponseReceived;});if(!responseReceived){std::cout&lt;&lt;"Timeout: No response received within 5 seconds."&lt;&lt;std::endl;// 执行下一步动作}else{std::cout&lt;&lt;"Response received successfully."&lt;&lt;std::endl;}}voidsimulateDeviceResponse(){std::this_thread::sleep_for(std::chrono::seconds(3));// 模拟响应时间{std::lock_guard&lt;std::mutex&gt;lock(mtx);responseReceived=true;}cv.notify_one();}intmain(){std::cout&lt;&lt;"Sending command to the device..."&lt;&lt;std::endl;std::threadt1(waitForResponse);std::threadt2(simulateDeviceResponse);t1.join();t2.join();return0;}当然Qt库里面提供了对应的QWaitCondition总结•QTimer 和 QEventLoop：适用于简单的超时机制。•QFuture 和 QFutureWatcher：适用于复杂的异步操作。•QSocketNotifier 或 QIODevice：适用于基于I/O的通信。•多线程和 std::condition_variable：适用于标准C++库的超时机制http://www.ppmy.cn/news/1540966.html相关文章机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工在汽车制造的精密领域&amp;#xff0c;每一个细节都关乎着整车的性能与品质&amp;#xff0c;而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S&amp;#xff0c;为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。 SycoTec 4060 ER-S转…阅读更多...HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:42 +0000</pubDate>
    </item>
    <item>
      <title>机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工</title>
      <link>https://www.ppmy.cn/news/1540965.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维机器人大功率主轴SycoTec 4060 ER-S汽车电机机芯焊缝铣削打磨加工news/2025/11/1 0:23:40/在汽车制造的精密领域，每一个细节都关乎着整车的性能与品质，而汽车电机机芯的焊缝加工更是其中至关重要的一环。在机器人末端加装德国进口电主轴 SycoTec 4060 ER-S，为汽车电机机芯焊缝铣削打磨加工带来全新的解决方案。SycoTec 4060 ER-S转速高达 5 万转，能够在极短的时间内对焊缝进行精细的铣削打磨，确保每一处焊缝都光滑平整，极大地提高了生产效率和质量。同时，它的功率高达2000W，强大的功率输出确保了加工的精准度和稳定性。最大扭矩达到 215 Ncm，为高强度的铣削打磨提供了充足的力量。锥面跳动≤1μm，意味着它能够以极高的精度进行加工，确保焊缝的尺寸精度和表面质量达到极致。标准防护等级为 IP57，高防护等级可达到 IP67，甚至能在水下正常工作，因此在恶劣的工作环境下，都能稳定发挥其强大的加工能力。将 SycoTec 4060 ER-S 加装在机器人末端，实现了自动化与高精度的完美结合。机器人的精准运动加上电主轴的卓越性能，使得汽车电机机芯焊缝的加工变得更加高效、精准、可靠。速科德电机科技Kasite丨德国SycoTec亚太服务中心——为工业机器人（金属及复合材料加工），PCB分板（铝基板、铜基板切割），数控机床改造（提升加工效率），义齿加工（氧化锆、钛合金，CAD CAM），广告行业（非金属材料、柔性材料加工），陶瓷插芯（内外圆研磨），微孔加工提供高速主轴&amp;机器人成套解决方案。http://www.ppmy.cn/news/1540965.html相关文章HarmonyOS中ArkUi框架中常用的装饰器目录 1.装饰器 1&amp;#xff09;Component 1--装饰内容 2&amp;#xff09;Entry 1--装饰内容 2--使用说明 3&amp;#xff09;Preview  1--装饰内容 2--使用说明 4&amp;#xff09;CustomDialog 1--装饰内容 2--使用说明 5&amp;#xff09;Observed 1--装饰内容 2--使用说明 6&amp;#xff09;ObjectLin…阅读更多...写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:40 +0000</pubDate>
    </item>
    <item>
      <title>HarmonyOS中ArkUi框架中常用的装饰器</title>
      <link>https://www.ppmy.cn/news/1540964.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维HarmonyOS中ArkUi框架中常用的装饰器news/2025/11/1 0:23:39/目录1.装饰器1）@Component1--装饰内容2）@Entry1--装饰内容2--使用说明3）@Preview1--装饰内容2--使用说明4）@CustomDialog1--装饰内容2--使用说明5）@Observed1--装饰内容2--使用说明6）@ObjectLink1--装饰内容2--使用说明7）@Builder1--装饰内容2--使用说明8）@Extend1--装饰内容2--使用说明9）@Style1--装饰内容2--使用说明10）@Prop1--装饰内容2--使用说明11）@State1--装饰内容2--使用说明12）@Link1--装饰内容2--使用说明13）@Provide1--装饰内容2--使用说明14）@Consume1--装饰内容2--使用说明15）@Watch1--装饰内容2--使用说明2:案例:自定义组件3.案例:自定义组件的使用4.组件预览5.案例:样式复用1.装饰器1）@Component1--装饰内容struct2--使用说明@Component用于定义一个UI组件类。这个装饰器可以指定组件的一些属性，如模板文件、样式文件2）@Entry1--装饰内容struct2--使用说明被装饰的组件会被作为页面的入口组件，页面加载时渲染显示3）@Preview1--装饰内容struct2--使用说明自定义组件被@Preview 修饰后可以在DevEco的预览器里面看到自定义组件的样子4）@CustomDialog1--装饰内容struct2--使用说明用于装饰自定义弹窗.通过这个装饰器，开发者可以定义一个具有特定UI和行为的对话框。5）@Observed1--装饰内容class2--使用说明@Observed标记的属性会触发观察者模式，当该属性发生变化时，系统会自动更新相关的UI元素。6）@ObjectLink1--装饰内容class2--使用说明被装饰的对象，父组件改变对象的属性或者子组件改变对象数据时，与该对象关联的组件都会被更新。7）@Builder1--装饰内容方法2--使用说明允许将重复使用的UI 代码抽象成方法，并可以在build方法中调用。被 @Builder 装饰的方法只能在build方法内部或其他 @Builder 方法中调用8）@Extend1--装饰内容方法2--使用说明允许一个组件继承另一个组件的样式，从而可以复用已有的样式定义。9）@Style1--装饰内容方法2--使用说明提供了一种方式来集中管理样式规则，减少样式的重复定义，提高代码的可维护性。类less和sass中的"混入"（Mixin）10）@Prop1--装饰内容基本数据类型2--使用说明用于定义从父组件传递到子组件的属性。这些属性可以用来配置子组件的行为或外观。11）@State1--装饰内容基本数据类型,类，数组2--使用说明用于声明组件的状态变量。状态变量的变化会触发 UI 的重新渲染。12）@Link1--装饰内容基本数据类型，类，数组2--使用说明用于创建两个状态之间的链接。当一个状态发生变化时，另一个状态也会相应地更新。类似vue中的v-model指令，两个不同的组件绑定同一个变量，一个组件使这个变量改变，另外一个也会跟着改变。13）@Provide1--装饰内容基本数据类型，类，数组2--使用说明装饰的数据作为数据的提供方，可以更新其子孙节点的数据，会刷新绑定该数据的组件。类似安卓中内容提供者，不同的应用的程序调用向外暴漏的数据。14）@Consume1--装饰内容基本数据类型，类，数组2--使用说明装饰的数据感知到@provide装饰的变量更新后，会重新渲染该组件。这个类似安卓中的内容观察者，检测到数据变化后会做出相应的操作.15）@Watch1--装饰内容状态变量(被@State,@Prop,@Link,@ObjectLink,@Provide,@Cunsume,@StorageProp,@StorageLink修饰的变量)2--使用说明监听状态的变化量2:案例:自定义组件@Componentstruct 组件名字{build(){//这里写的是组件内容}}//自定义组件@ComponentstructmyTextShow{build() {Text("你们好啊")  //字体组件.id('HelloWorld').fontSize(50).fontWeight(FontWeight.Bold)  //加粗.fontColor($r('app.color.start_window_background'))//文字颜色.width('50%')  //宽度.height('65%').backgroundImage($rawfile('boy.png')) //背景图片.alignRules({center: { anchor: '__container__', align: VerticalAlign.Center },middle: { anchor: '__container__', align: HorizontalAlign.Center }})}
}3.案例:自定义组件的使用import myTextShow from './MyDiv';  //导入组件@Entry@Component
struct Index {@State message: string = 'Hello World';build() {RelativeContainer() {//这是我们自定义的那个组件myTextShow()}}}4.组件预览//自定义组件
@Component@Preview     //组件预览export defaultstruct myTextShow{build() {Text("这是预览组件")  //字体组件.id('HelloWorld').fontSize(50).fontWeight(FontWeight.Bold)  //加粗.fontColor($r('app.color.start_window_background'))//文字颜色.width('50%')  //宽度.height('65%').backgroundImage($rawfile('boy.png')) //背景图片.alignRules({center: { anchor: '__container__', align: VerticalAlign.Center },middle: { anchor: '__container__', align: HorizontalAlign.Center }})}
}//export default 把该组件导出去，供别人使用5.案例:样式复用@Entry
@Component
struct Index {@State message: string = 'Hello World';//导入组件build() {RelativeContainer() {Column(){Button("黄色按钮").width(200).height(100).fontColor($r("app.color.my_red")).myStyle()Button("默认按钮").myStyle2().width(200).height(100)Button("按钮4").myStyle3().width(200).height(100)Button("按钮5").myStyle4().width(200).height(100)}.padding(20)}}}
@Styles
function myStyle() {.backgroundColor($r("app.color.my_yellow"))
}@Styles
function myStyle2() {.backgroundColor($r("app.color.my_red"))
}
@Styles
function myStyle3() {.backgroundColor($r("app.color.my_green"))
}
@Styles
function myStyle4() {.backgroundColor($r("app.color.start_window_background"))
}http://www.ppmy.cn/news/1540964.html相关文章写了十几年程序，今天才第一天知道什么是屎山代码可以说&amp;#xff0c;我确实没在工作中用过Javascript&amp;#xff0c;因为我从未见过如此“厚颜无耻”的代码 我曾经也是学过2~3年&amp;#xff0c;还是JQuery的年代&amp;#xff0c;但应该确实没在实战中用过&amp;#xff0c;否则我怎么会不记得写过这些屎山代码的&amp;#xff1f;&amp;#xff1f;&amp;…阅读更多...【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:39 +0000</pubDate>
    </item>
    <item>
      <title>写了十几年程序，今天才第一天知道什么是屎山代码</title>
      <link>https://www.ppmy.cn/news/1540963.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维写了十几年程序，今天才第一天知道什么是屎山代码news/2025/11/1 0:23:37/可以说，我确实没在工作中用过Javascript，因为我从未见过如此“厚颜无耻”的代码我曾经也是学过2~3年，还是JQuery的年代，但应该确实没在实战中用过，否则我怎么会不记得写过这些屎山代码的？？？（当年，第一个吃到螃蟹的，赚到第一桶金的是DICUZ，PHP的；真还不是写JAVASCRIPT的）一个看上去平平无奇，像模像样的类Js代码代码1recipeSection.Add(recipeRow);//在上面套用 preset??：自己写的方法：VisualElementPresets.CreateStandardCategoryEditor(),作用是再套了个 MemberGroupControl（）//就是用category 绘制ve.Add(new Label("Categories(强行套用Category 的[Inspector])").CenterContents());ve.Add(groupControl);//group == category ，就是用 categoriesCtl 做绘制。。。。。ve.Add(recipeSection);   return ve;结果某一天。。。。。要是，你只是想在Unity VisualElement UI 添加一个按钮 Button代码1-1recipeSection.Add(recipeRow);//在上面套用 preset??：自己写的方法：VisualElementPresets.CreateStandardCategoryEditor(),作用是再套了个 MemberGroupControl（）//就是用category 绘制ve.Add(new Label("Categories(强行套用Category 的[Inspector])").CenterContents());ve.Add(groupControl);//group == category ，就是用 categoriesCtl 做绘制。。。。。ve.Add(recipeSection);//在这"再添加一个操作按钮吧，测试GridView"));var testButton = new Button(() =&gt; {//这是一个构造函数??(不是，TMD这是一个clickEvent,不是构造函数。。。。)// 下面的{text = "xxxxx"},这个描述语言，TMD才是构造函数，就问你惊喜不惊喜,意外不意外？？？// 下面这么写C# 构造函数，也是有不少的。。。。。////////可以插入一万行代码，事实上 Init的代码就不会少。。。。}){ text = "测试GridView(ItemObjectEditor)" };//这里加的 text 描述。。。。ve.Add(testButton);return ve;如果我什么都不说，一般人会不会看到这样的代码就给我扣帽子：“这样的代码，大牛写的真好啊，就是不同于常人，非常飘逸，肯定另有深意，简直的”写JavaScript的都是什么人？面对这样的屎山代码，这些年，你们都是怎么过 的？？我好像曾经在2~3个团队，明令禁止这么写代码而必须规范地写成如下：但其实再多地外部规范，远不及代码本身底层规则 ，很快这些规范就不会被执行，也多此一举立规范，和立FLAG是差不多的逻辑，根本不要立FLAG"//--------------------"当然，我的文章都写很多废话的看，这又是一句废话就问你，烦不烦"//----------------------/""//----------------------// 又是一行废话，备注 //"代码2recipeSection.Add(recipeRow);//在上面套用 preset??：自己写的方法：VisualElementPresets.CreateStandardCategoryEditor(),作用是再套了个 MemberGroupControl（）//就是用category 绘制ve.Add(new Label("Categories(强行套用Category 的[Inspector])").CenterContents());ve.Add(groupControl);//group == category ，就是用 categoriesCtl 做绘制。。。。。ve.Add(recipeSection);//在这"再添加一个操作按钮吧，测试GridView"));var testButton = new Button(){ text = "测试GridView(ItemObjectEditor)" };//这里加的 text 描述。。。。testButton.addClick(OnClick);////写成EventWarpper(testButton).click += XXXX 都好//写多少行都行，都比较好//就是一行就是一个功能//是一行就行，重点不在于行数太多，而是每一行需要意义明确//千万不要学Json 无意义的括号这种 {  | =》 | });         ve.Add(testButton);return ve;//无论是调试，还是规范，还是可阅读性，还是编辑器friendly
//都比Javascript 要好
//而 Javascript 为什么越看越像屎山代码？？？？
//这个世界上，其实没那么屎山代码
// 30%的JavaScript 容易产生屎山代码，而30%在比例用Js，这个比例就很恐怖了
//当然我不靠Js赚钱，所以怎么吐槽都行。。。。。
function OnClick(eve)
{}//------------------ /最终改成这样，是不是舒服很多？？？代码2-final//。。。。。。。。。。recipeSection.Add(recipeRow);//在这"再添加一个操作按钮吧，测试GridView"));var testButton = new Button(testButtonClick);testButton.text = "测试GridView(ItemObjectEditor)";//这里加的 text 描述。。。。//在上面套用 preset??：自己写的方法：VisualElementPresets.CreateStandardCategoryEditor(),作用是再套了个 MemberGroupControl（）//就是用category 绘制ve.Add(new Label("Categories(强行套用Category 的[Inspector])").CenterContents());ve.Add(groupControl);//group == category ，就是用 categoriesCtl 做绘制。。。。。ve.Add(recipeSection);//在这"再添加一个操作按钮 baabababa”ve.Add(testButton);return ve;}void testButtonClick(){ }一个乱套，而崩坏的世界：代码3using System;
using System.Diagnostics;
using UnityEngine;
using UnityEngine.UIElements;
using Object = UnityEngine.Object;namespace Polyperfect.Crafting.Edit
{public class OpenForEditManipulator : Clickable{/// &lt;summary&gt;/// ObjectEditWindow.cs 点击item事件；会创建一个 window/// &lt;/summary&gt;/// &lt;param name="getObject"&gt;&lt;/param&gt;/// &lt;param name="clickCount"&gt;&lt;/param&gt;/// &lt;param name="ve"&gt;这个 ve 会乱动，所以需要 refreshAction()兜底刷新&lt;/param&gt;/// &lt;param name="refreshAction"&gt;&lt;/param&gt;public OpenForEditManipulator(System.Func&lt;Object&gt; getObject, int clickCount,VisualElement ve, Action&lt;VisualElement,Object&gt; refreshAction = null): base(() =&gt;ObjectEditWindow.CreateForObject(getObject(), ve,refreshAction))//又是一个强行闭包{
//            UnityEngine.Debug.LogError("fffff click??");//一个点击，触发了15次。。。一个compile刷新 ，又执行了45次。。。。。//一共触发了60次。。。。//一共触发了60次。。。。//一共触发了60次。。。。//一共触发了60次。。。。.......//一共触发了60次。。。。.......//一共触发了60次。。。。..............//而且是多次触发。。。。//而且是多次触发。。。。//而且是多次触发。。。。//这是 一个构造函数，你敢想像//这是 一个构造函数，你敢想像//这是 一个构造函数，你敢想像activators.Clear();activators.Add(new ManipulatorActivationFilter {button = MouseButton.LeftMouse, clickCount = clickCount});}}
}http://www.ppmy.cn/news/1540963.html相关文章【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值你有一个初始为空的浮点数数组 averages。另给你一个包含 n 个整数的数组 nums&amp;#xff0c;其中 n 为偶数。 
你需要重复以下步骤 n / 2 次&amp;#xff1a; 
从 nums 中移除 最小 的元素 minElement 和 最大 的元素 maxElement。将 (minElement  maxElement) / 2 加入到 averages …阅读更多...nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:38 +0000</pubDate>
    </item>
    <item>
      <title>【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值</title>
      <link>https://www.ppmy.cn/news/1540962.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【从零开始的LeetCode-算法】3194. 最小元素和最大元素的最小平均值news/2025/11/1 0:23:36/你有一个初始为空的浮点数数组averages。另给你一个包含n个整数的数组nums，其中n为偶数。你需要重复以下步骤n / 2次：从nums中移除最小的元素minElement和最大的元素maxElement。将(minElement + maxElement) / 2加入到averages中。返回averages中的最小元素。示例 1：输入：nums = [7,8,3,4,15,13,4,1]输出：5.5解释：步骤numsaverages0[7,8,3,4,15,13,4,1][]1[7,8,3,4,13,4][8]2[7,8,4,4][8,8]3[7,4][8,8,6]4[][8,8,6,5.5]返回 averages 中最小的元素，即 5.5。示例 2：输入：nums = [1,9,8,3,10,5]输出：5.5解释：步骤numsaverages0[1,9,8,3,10,5][]1[9,8,3,5][5.5]2[8,5][5.5,6]3[][5.5,6,6.5]示例 3：输入：nums = [1,2,3,7,8,9]输出：5.0解释：步骤numsaverages0[1,2,3,7,8,9][]1[2,3,7,8][5]2[3,7][5,5]3[][5,5,5]提示：2 &lt;= n == nums.length &lt;= 50n为偶数。1 &lt;= nums[i] &lt;= 50我的解答：class Solution {public double minimumAverage(int[] nums) {Arrays.sort(nums);int size = nums.length;double res = (double)nums[size - 1];for(int i = 0; i &lt; size / 2; i++){double d = (nums[i] + nums[size - 1 - i]) / 2.0;res = res &gt; d ? d : res; }return res;}
}http://www.ppmy.cn/news/1540962.html相关文章nginx中的HTTP 负载均衡HTTP 负载均衡&amp;#xff1a;如何实现多台服务器的高效分发 
为了让流量均匀分配到两台或多台 HTTP 服务器上&amp;#xff0c;我们可以通过 NGINX 的 upstream 代码块实现负载均衡。 方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡&amp;#xff1a; 
upstr…阅读更多...C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:37 +0000</pubDate>
    </item>
    <item>
      <title>nginx中的HTTP 负载均衡</title>
      <link>https://www.ppmy.cn/news/1540961.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维nginx中的HTTP 负载均衡news/2025/11/1 0:23:35/HTTP 负载均衡：如何实现多台服务器的高效分发为了让流量均匀分配到两台或多台 HTTP 服务器上，我们可以通过 NGINX 的 upstream 代码块实现负载均衡。方法 在 NGINX 的 HTTP 模块内使用 upstream 代码块对 HTTP 服务器实施负载均衡：upstream backend { server 10.10.12.45:80 weight=1; server app.example.com:80 weight=2; server spare.example.com:80 backup; } server { location / { proxy_pass http://backend; } }该配置对端口 80 的两台 HTTP 服务器实施负载均衡，然后再将另一台服务器定义为 backup，以便在两台主服务器不可用时发挥作用。可选的 weight 参数指示 NGINX 向 第二台服务器传输两倍的请求。未使用时，它的默认值为 1。HTTP 的 upstream 模块控制着 HTTP 请求负载均衡。该模块定义了一个目标池 —— 它可以是 Unix 套接字、IP 地址和服务器主机名的任意组合，也可以是它们的混合使用 配置。upstream 模块还定义了如何将任一个请求分发给任何上游（upstream）服务器。每个上游目标都通过 server 指令在上游池中进行定义。除了上游服务器地址以外， server 指令还接收可选参数。可选参数能够增强对请求路由的控制。这包括均衡算法 中服务器的 weight 参数（无论服务器处于待机模式、可用还是不可用），以及确定服 务器是否不可用的参数。NGINX Plus 还提供了许多其他好用的参数，例如对服务器的 连接限制、高级 DNS 解析控制以及在服务器启动后缓慢增加与服务器的连接等等。现在有一款很火的WAF，也是以反向代理方式接入，雷池社区版，保护你的网站，操作简单，可以试试http://www.ppmy.cn/news/1540961.html相关文章C语言头文件#ifndef条件编译用法C语言中的头文件定义头 C语言里面经常看别人写的头文件&amp;#xff1a; 
#ifndef C_CLIENT_H_
#define C_CLIENT_H_XXXX
#endifXXX为真实的头内容&amp;#xff0c;一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容&amp;#xff0c;其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识…阅读更多...025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:35 +0000</pubDate>
    </item>
    <item>
      <title>C语言头文件#ifndef条件编译用法</title>
      <link>https://www.ppmy.cn/news/1540960.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C语言头文件#ifndef条件编译用法news/2025/11/1 0:23:34/C语言中的头文件定义头C语言里面经常看别人写的头文件：#ifndef C_CLIENT_H_#define C_CLIENT_H_XXXX#endifXXX为真实的头内容，一直不大懂为何要加#ifndef C_CLIENT_H_这样的内容，其中C_CLIENT_H_大概是和自己的.h文件同名的一个大写标识。于是搜了一下，此种做法是为了解决，在同一个.C文件中包含多个头文件时，这多个头文件存在重复定义，从而导致编译时出现重复定义问题。比如我们有2个头文件,第一个是test.h：第二个是test1.h，将test.h头文件包含进去了，这种在大型工程中极有可能发生。在一个main.c文件中,没注意将test.h和test1.h全部包含进去了，此时进行编译，预编译时，头文件会在.c文件中进行展开，于是i这个变量在main.c文件中被定义了2次，则会报错：即重定义问题，报错中提示用#ifdef 或者#pragma规避此问题。如果在.h文件之前加上条件编译的宏语句，那么则不会出现此问题。所以，养成良好的习惯非常重要，在定义头文件的时候，都需要加上类似的结构：不过此种做法实则只能解决单个C文件的重复定义问题，在实际工程开发中，往往是多个C文件的，在不同的C文件是分别进行编译的，所以一个C语言里的#ifndef对另一个C文件不起作用的，比如同时在test.c和main.c文件中包含了test.h文件，此时工程编译时，单个文件往往都能通过，但是到了链接的时候，又会报错，重复定义问题。综合以上，感觉最根本的方法还是养成良好的习惯：1）在头文件里只声明不定义2）把定义定义在C文件里才能规避此类问题。http://www.ppmy.cn/news/1540960.html相关文章025 elasticsearch索引管理-Java原生客户端文章目录 pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mapping elasticsearch版本7.10.2&amp;#xff0c;要求java客户端与之相匹配&amp;#xff0c;推荐Springboot版本是2.3以上版本 依赖配置使用的是JUnit 5&amp;am…阅读更多...如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:34 +0000</pubDate>
    </item>
    <item>
      <title>025 elasticsearch索引管理-Java原生客户端</title>
      <link>https://www.ppmy.cn/news/1540959.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维025 elasticsearch索引管理-Java原生客户端news/2025/11/1 0:23:33/文章目录pom.xml1创建索引2.创建索引并设置settings信息3.创建索引并设置mapping信息4.删除索引库5.给未设置mapping的索引设置mappingelasticsearch版本7.10.2，要求java客户端与之相匹配，推荐Springboot版本是2.3以上版本依赖配置使用的是JUnit 5（由&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;提供支持），而@Before注解是JUnit 4中的注解。在JUnit 5中，应该使用@BeforeEach来代替@Before。替换注解：将所有的@Before注解替换为@BeforeEach。确保你的测试类使用了JUnit 5的相关注解，如@Test（JUnit 5中的@Test注解位于org.junit.jupiter.api.Test）。确保测试类正确配置：确保你的测试类上没有使用JUnit 4的@RunWith注解。如果使用了Spring的测试支持，确保类上有@SpringBootTest或其他相关的Spring测试注解。更新测试方法：确认所有的测试方法都使用了JUnit 5的@Test注解。pom.xml&lt;projectxmlns="http://maven.apache.org/POM/4.0.0"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.3.2.RELEASE&lt;/version&gt;&lt;relativePath/&gt;&lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;artifactId&gt;chubemall-search&lt;/artifactId&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;chubemall-search&lt;/name&gt;&lt;url&gt;http://maven.apache.org&lt;/url&gt;&lt;properties&gt;&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt;&lt;elasticsearch.version&gt;7.10.2&lt;/elasticsearch.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--        &lt;dependency&gt;--&gt;&lt;!--            &lt;groupId&gt;junit&lt;/groupId&gt;--&gt;&lt;!--            &lt;artifactId&gt;junit&lt;/artifactId&gt;--&gt;&lt;!--            &lt;version&gt;3.8.1&lt;/version&gt;--&gt;&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;!--        &lt;/dependency&gt;--&gt;&lt;!--引入common公共模块--&gt;&lt;dependency&gt;&lt;groupId&gt;com.xd.cubemall&lt;/groupId&gt;&lt;artifactId&gt;cubemall-common&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--        &lt;dependency&gt;--&gt;&lt;!--            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;&lt;!--            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;--&gt;&lt;!--        &lt;/dependency&gt;--&gt;&lt;dependency&gt;&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;version&gt;7.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt;&lt;dependencies&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&lt;version&gt;${spring-cloud.version}&lt;/version&gt;&lt;type&gt;pom&lt;/type&gt;&lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;&lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;/project&gt;1创建索引步骤：1.创建一个RestHightLevelClient对象，相当于和服务端建立连接2.使用client的索引管理的对象，indices()返回索引管理对象packagecom.xd.cubemall.es;importorg.apache.http.HttpHost;importorg.elasticsearch.client.IndicesClient;importorg.elasticsearch.client.RequestOptions;importorg.elasticsearch.client.RestClient;importorg.elasticsearch.client.RestHighLevelClient;importorg.elasticsearch.client.indices.CreateIndexRequest;importorg.elasticsearch.client.indices.CreateIndexResponse;importorg.junit.jupiter.api.Test;/*** 索引管理*/publicclassIndexManager{@TestpublicvoidcreateIndex()throwsException{//创建一个client对象RestHighLevelClientclient=newRestHighLevelClient(RestClient.builder(newHttpHost("1.1.1.1",9200),newHttpHost("2.2.2.2",9200),newHttpHost("3.3.3.3",9200)));//获得索引管理对象IndicesClientindicesClient=client.indices();//两个参数//1.创建索引请求对象CreateIndexRequestrequest=newCreateIndexRequest("hello");//2.请求选项，使用默认值。配置请求头，主要用于认证。CreateIndexResponseresponse=indicesClient.create(request,RequestOptions.DEFAULT);System.out.println(response);}}2.创建索引并设置settings信息CreateIndexRequest对象中设置settings即可packagecom.xd.cubemall.es;importorg.apache.http.HttpHost;importorg.elasticsearch.client.IndicesClient;importorg.elasticsearch.client.RequestOptions;importorg.elasticsearch.client.RestClient;importorg.elasticsearch.client.RestHighLevelClient;importorg.elasticsearch.client.indices.CreateIndexRequest;importorg.elasticsearch.client.indices.CreateIndexResponse;importorg.elasticsearch.common.settings.Settings;importorg.junit.jupiter.api.BeforeEach;importorg.junit.jupiter.api.Test;/*** 索引管理*/publicclassIndexManager{privateRestHighLevelClientclient;@BeforeEachpublicvoidinit(){//创建一个client对象client=newRestHighLevelClient(RestClient.builder(newHttpHost("1.1.1.1",9200),newHttpHost("2.2.2.2",9200),newHttpHost("3.3.3.3",9200)));}@TestpublicvoidcreateIndex()throwsException{//获得索引管理对象IndicesClientindicesClient=client.indices();//两个参数//1.创建索引请求对象CreateIndexRequestrequest=newCreateIndexRequest("hello");//2.请求选项，使用默认值。配置请求头，主要用于认证。CreateIndexResponseresponse=indicesClient.create(request,RequestOptions.DEFAULT);//显示结果System.out.println(response);}@TestpublicvoidcreateIndex2()throwsException{CreateIndexRequestrequest=newCreateIndexRequest("hello1").settings(Settings.builder().put("number_of_shards",5).put("number_of_replicas",1).build());System.out.println("Client is null: "+(client==null));System.out.println("Request is null: "+(request==null));client.indices().create(request,RequestOptions.DEFAULT);}}3.创建索引并设置mapping信息{"properties":{"id":{"type":"long"},"title":{"type":"text","analyzer":"ik_smart","store":true},"content":{"type":"text","analyzer":"ik_smart","store":true}}}@TestpublicvoidcreateIndex3()throwsException{XContentBuildermappings=XContentFactory.jsonBuilder().startObject().startObject("properties").startObject("id").field("type","long").endObject().startObject("title").field("type","text").field("analyzer","ik_smart").field("store",true).endObject().startObject("content").field("type","text").field("analyzer","ik_smart").field("store",true).endObject().endObject().endObject();CreateIndexRequestrequest=newCreateIndexRequest("hello2").settings(Settings.builder().put("number_of_shards",5).put("number_of_replicas",1).build()).mapping(mappings);client.indices().create(request,RequestOptions.DEFAULT);}4.删除索引库DeleteIndexRequest对象，其中包含索引库的名称即可indices().delete(request)@TestpublicvoiddeleteIndex()throwsException{client.indices().delete(newDeleteIndexRequest("hello"),RequestOptions.DEFAULT);}5.给未设置mapping的索引设置mapping@TestpublicvoidputMappings()throwsException{Stringmappings="{\n"+"\t\"properties\":{\n"+"\t\t\"id\":{\n"+"\t\t\t\"type\":\"long\"\n"+"\t\t},\n"+"\t\t\"title\":{\n"+"\t\t\t\"type\":\"text\",\n"+"\t\t\t\"analyzer\":\"ik_smart\",\n"+"\t\t\t\"store\":true\n"+"\t\t},\n"+"\t\t\"content\":{\n"+"\t\t\t\"type\":\"text\",\n"+"\t\t\t\"analyzer\":\"ik_smart\",\n"+"\t\t\t\"store\":true\n"+"\t\t}\t\t\n"+"\t}\n"+"}";PutMappingRequestrequest=newPutMappingRequest("hello1").source(mappings,XContentType.JSON);client.indices().putMapping(request,RequestOptions.DEFAULT);}http://www.ppmy.cn/news/1540959.html相关文章如何使用Rancher管理K8S集群目录 1 Rancher介绍 
1.1  Rancher简介 
1.2 Rancher和k8s的区别 
1.3 Rancher使用案例 
2安装rancher 
2.1  初始化实验环境 
2.2  安装Rancher 
2.3  登录Rancher平台 
3  通过Rancher管理已存在的k8s集群 
4 通过Rancher仪表盘管理k8s集群&amp;#xff1a;部署tomcat服务 文档中…阅读更多...C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:33 +0000</pubDate>
    </item>
    <item>
      <title>如何使用Rancher管理K8S集群</title>
      <link>https://www.ppmy.cn/news/1540958.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维如何使用Rancher管理K8S集群news/2025/11/1 0:23:32/目录1 Rancher介绍1.1  Rancher简介1.2 Rancher和k8s的区别1.3 Rancher使用案例2安装rancher2.1  初始化实验环境2.2  安装Rancher2.3  登录Rancher平台3  通过Rancher管理已存在的k8s集群4 通过Rancher仪表盘管理k8s集群：部署tomcat服务文档中的YAML文件配置直接复制粘贴可能存在格式错误，故实验中所需要的YAML文件以及本地包均打包至网盘链接：https://pan.baidu.com/s/1Fwv3UUbKrqFqgh5LSqpKdA提取码：58zd1Rancher介绍1.1  Rancher简介Rancher是一个开源的企业级多集群Kubernetes管理平台，实现了Kubernetes集群在混合云+本地数据中心的集中部署与管理，以确保集群的安全性，加速企业数字化转型。超过40,000家企业每天使用Rancher快速创新Rancher官方文档：https://docs.rancher.cn/1.2 Rancher和k8s的区别Rancher和k8s都是用来作为容器的调度与编排系统。但是rancher不仅能够管理应用容器，更重要的一点是能够管理k8s集群。Rancher2.x底层基于k8s调度引擎，通过Rancher的封装，用户可以在不熟悉k8s概念的情况下轻松的通过Rancher来部署容器到k8s集群当中。1.3 Rancher使用案例1、中保银行在使用Rancher平台之前，中银保险也尝试过使用原生的一些Kubernetes平台，但是这些平台学习使用成本高昂、运行维护特别复杂。尤其是当我公司使用多种混合云环境的时候，一个个Kubernetes集群就变成了一个个技术孤岛，反而加重了公司信息化转型的压力。Rancher平台的采用有效地解决了之前平台使用中所存在的问题，提升我公司测试业务平台的运行维护效率。—— 付春涛 中银保险有限公司 信息科技部 技术负责人2、蔚来汽车数字运营中国Rancher友好的图形化管理界面和资源创建的易用性、多集群管理能力、AD认证和权限管理集成、应用商店功能等各种能力，帮助我们简化了容器化应用的部署，得以方便地进行多云Kubernetes管理和权限控制，提高了应用交付的效率。感谢Rancher团队，期待Rancher中国团队进一步优化功能，推进Rancher在国内的大量落地。—— 赵鹏飞 蔚来汽车数字运营中国 运维开发工程师3、上汽集团Rancher 2.x是数据中心级别的管理平台，拥有多云管理的能力，符合未来企业上云的架构规划演进；Rancher的开源产品模式降低了技术人员的使用成本，在兼顾原生Kubernetes的同时，为开发人员提供了丰富的API与系统功能，提高了开发生产效率。同时，Rancher专业的容器产品团队，架起了开源产品与生产业务的桥梁，在微服务、应用容器化、DevOps、业务上云等技术领域为上汽集团提供了可靠的支持。—— 龚瀚申 上汽集团 PaaS平台总监2安装rancher2.1  初始化实验环境安装rancher需要的实验环境如下：环境说明（centos7.6）：IP                 主机名                 内存    cpu192.168.40.138   xianchaorancher       6G    6vCPU已经存在的K8s实验环境：角色            ip                     主机名控制节点       192.168.40.180         xianchaomaster1工作节点       192.168.40.181         xianchaonode1配置主机名：在192.168.40.138上执行如下：hostnamectl set-hostname xianchaorancher配置hosts文件：#在xianchaomaster1、xianchaonode1、xianchaorancher上操作：192.168.40.180   xianchaomaster1192.168.40.181   xianchaonode1192.168.40.138   xianchaorancher配置rancher到k8s主机互信生成ssh 密钥对[root@xianchaorancher ~]# ssh-keygen  #一路回车，不输入密码把本地的ssh公钥文件安装到远程主机对应的账户[root@xianchaorancher ~]# ssh-copy-id xianchaomaster1[root@xianchaorancher ~]# ssh-copy-id xianchaorancher[root@xianchaorancher ~]# ssh-copy-id xianchaonode1关闭防火墙[root@xianchaorancher ~]# systemctl stop firewalld ; systemctl disable firewalld关闭selinux[root@xianchaorancher ~]# setenforce 0[root@xianchaorancher ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config注意：修改selinux配置文件之后，重启机器，selinux才能永久生效关闭swap分区。[root@xianchaorancher ~]# swapoff -a[root@xianchaorancher ~]# free -m  #可以看到swap分区的大小，已经变为0total        used        free      shared  buff/cache   availableMem:           4876         501         516          20        3858        4068Swap:             0           0           0‘永久关闭：注释swap挂载注：如果是克隆主机请删除网卡中的UUID并重启网络服务。内核参数修改：br_netfilter模块用于将桥接流量转发至iptables链，br_netfilter内核参数需要开启转发。[root@xianchaorancher ~]# modprobe br_netfilter[root@xianchaorancher ~]# echo "modprobe br_netfilter" &gt;&gt; /etc/profile[root@xianchaorancher ~]# cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOF[root@xianchaorancher ~]# sysctl -p /etc/sysctl.d/k8s.conf在xianchaorancher上配置阿里云镜像源：[root@xianchaorancher ~]# mv /etc/yum.repos.d/CentOS-Base.repo  /etc/yum.repos.d/CentOS-Base.repo.backup[root@xianchaorancher ~]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#配置国内阿里云docker的repo源[root@xianchaorancher ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo在xianchaorancher上安装docker-ce。我们已经配置了docker本地源，直接安装docker-ce服务。[root@xianchaorancher ~]# yum install -y yum-utils device-mapper-persistent-data lvm2 wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel  python-devel epel-release openssh-server socat  ipvsadm conntrack ntpdate安装docker-ce[root@xianchaorancher ~]# yum install docker-ce docker-ce-cli containerd.io -y[root@xianchaomaster1 ~]# systemctl start docker &amp;&amp; systemctl enable docker.service修改docker配置文件，配置镜像加速器[root@xianchaorancher ~]# tee /etc/docker/daemon.json &lt;&lt; 'EOF'{"registry-mirrors":["https://rsbud4vc.mirror.aliyuncs.com","https://registry.docker-cn.com","https://docker.mirrors.ustc.edu.cn","https://dockerhub.azk8s.cn","http://hub-mirror.c.163.com","http://qtid6917.mirror.aliyuncs.com", "https://rncxm540.mirror.aliyuncs.com"],"exec-opts": ["native.cgroupdriver=systemd"]}EOF[root@xianchaorancher ~]# systemctl daemon-reload[root@xianchaorancher ~]# systemctl restart docker[root@xianchaorancher ~]# systemctl status docker显示如下，说明docker安装成功了● docker.service - Docker Application Container EngineLoaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)Active: active (running) since Wed 2021-03-17 12:39:06 CST2.2  安装RancherRancher2.6.4支持导入已经存在的k8s1.23+集群，所以我们安装rancher2.6.4版本注：rancher_2.6.4.tar.gz和rancher-agent_2.6.4.tar.gz压缩包在课件在xianchaorancher上操作如下命令：[root@xianchaonode1 ~]#docker load -i rancher-agent_2.6.4.tar.gz[root@xianchaomaster1 ~]#docker load -i rancher-agent_2.6.4.tar.gz[root@xianchaorancher ~]#docker load -i rancher_2.6.4.tar.gz[root@xianchaorancher ~]# docker run -d --restart=unless-stopped -p 80:80 -p 443:443 --privilegedrancher/rancher:v2.6.4注：unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器验证rancher是否启动：[root@xianchaorancher ~]# docker ps | grep rancher显示如下，说明启动成功：70b5916dd1bc   rancher/rancher:v2.6.4   "entrypoint.sh"   45 seconds ago   Up 36 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp   recursing_hofstadter2.3  登录Rancher平台在浏览器访问xianchaorancher的ip地址：选择高级接受风险并继续（1）获取密码：在xianchaorancher上，docker ps查看正在运行的容器，显示如下：CONTAINER ID   IMAGE                    COMMAND           CREATED         STATUS         PORTS                                                                      NAMES70b5916dd1bc   rancher/rancher:v2.6.4   "entrypoint.sh"   3 minutes ago   Up 3 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp   recursing_hofstadter通过上面可以看到容器的id是70b5916dd1bc[root@xianchaorancher~]# docker logs70b5916dd1bc2&gt;&amp;1 | grep "Bootstrap Password:"2022/04/16 02:29:29 [INFO] Bootstrap Password: sq5hsgp7n8585m4l85s6khdnz2q4f79fwtgh5w2l7k669hvknn26jw通过上面可以看到获取到的密码是：sq5hsgp7n8585m4l85s6khdnz2q4f79fwtgh5w2l7k669hvknn26jw把获取到的密码sq5hsgp7n8585m4l85s6khdnz2q4f79fwtgh5w2l7k669hvknn26jw复制到password位置：使用本地用户登录，显示如下：设置新的密码：点击继续之后，显示如下：3通过Rancher管理已存在的k8s集群#把已经存在的k8s集群导入到rancher了选择导入已有的集群，出现下面界面选择通用，出现如下界面：集群名称：xianchao，点击创建出现如下界面：在k8s控制节点复制上图红色箭头标注的一串命令：[root@xianchaomaster1 ~]# curl --insecure -sfL https://192.168.40.138/v3/import/stqwgdprrz7brdvzr7wgrqt6m6wgmq8w6kcj6sg8rwxl6rqr4bqdqb_c-m-5cnf2c8v.yaml | kubectl apply -f –验证rancher-agent是否部署成功：[root@xianchaomaster1 ~]# kubectl get pods -n cattle-system -o wideNAME                                    READY   STATUS    RESTARTS   AGE   IP              NODE              NOMINATED NODE   READINESS GATEScattle-cluster-agent-57c864c7f5-f7n28   1/1     Running   0          44s   10.244.121.7    xianchaonode1     &lt;none&gt;           &lt;none&gt;cattle-cluster-agent-57c864c7f5-rw9w2   1/1     Running   0          52s   10.244.123.66   xianchaomaster1   &lt;none&gt;           &lt;none&gt;看到cattle-cluster-agent这个pod时running，说明rancher-agent部署成功了，在rancher ui界面可以看到如下内容：https://192.168.40.138/dashboard/home4通过Rancher仪表盘管理k8s集群：部署tomcat服务点击xianchao集群：出现如下界面：（1）创建名称空间：名称空间的名字：xianchaotest点击创建（2）创建deployment点击创建名称空间：xianchaotest名称： tomcattest添加标签容器配置指定镜像：tomcat:8.5.34-jre8-alpine[root@xianchaonode1 ~]# docker load -i tomcat_8.5.tar.gz给pod打标签配置完成最基本的deployment资源，点击创建查看资源是否创建成功：（3）创建service资源，把k8s集群的tomcat这个pod映射出来选择左侧看到的服务，点击创建选择节点端口名称：tomcat-svc定义选择器定义服务端口上面定义完成点击创建即可通过上面图片可以看到tomcat-svc已经创建好了访问k8s任何一个节点+端口 30080，可以访问内部的tomcat了：访问192.168.40.180:30080(4)创建Ingress资源注意：没有安装Ingress-controller的，需要安装Ingress-controller七层代理[root@xianchaonode1~]# docker load -i kube-webhook-certgen_1.1.1.tar.gz[root@xianchaonode1~]# docker load -i nginx-ingress-controller_v1.1.1.tar.gz[root@xianchaomaster1~]# mkdir ingress[root@xianchaomaster1~]# cd ingress/[root@xianchaomaster1ingress]# kubectl apply -f deploy.yaml[root@xianchaomaster1ingress]# kubectl create clusterrolebinding clusterrolebinding-user-3  --clusterrole=cluster-admin --user=system:serviceaccount:ingress-nginx:ingress-nginx[root@xianchaomaster1 ingress]# kubectl get pods -n ingress-nginxNAME                                        READY   STATUS      RESTARTS   AGEingress-nginx-admission-create-st6gt        0/1     Completed   0          30singress-nginx-admission-patch-2gv57         0/1     Completed   1          30singress-nginx-controller-56dc9c69b9-kdt67   1/1     Running     0          30s创建ingress规则点击Create添加注解：kubernetes.io/ingress.class： nginx点击Create添加本地hosts解析。C:\Windows\System32\drivers\etc添加行：192.168.40.181xianchao.lucky.com浏览器访问：http://xianchao.lucky.comhttp://www.ppmy.cn/news/1540958.html相关文章C++面试速通宝典——29543. 简述#ifdef、#else、#endif和#ifndef的作用 
利用#ifdef、#endif将程序功能模块包括进去&amp;#xff0c;以向特定用户提供该功能。 
在不需要时用户可轻易将其屏蔽。 
#ifdef MATH 
#include "math.c" 
#endif 
在子程序前加上标记&amp;#xff0c;以便于追踪和调试。 …阅读更多...Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:32 +0000</pubDate>
    </item>
    <item>
      <title>C++面试速通宝典——29</title>
      <link>https://www.ppmy.cn/news/1540957.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C++面试速通宝典——29news/2025/11/1 0:23:30/543. 简述#ifdef、#else、#endif和#ifndef的作用利用#ifdef、#endif将程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。#ifdefMATH#include"math.c"#endif在子程序前加上标记，以便于追踪和调试。#ifdefDEBUGprintf("Indebugging......!");#endif‌‌‌‌　　应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。‌‌‌‌　　注意：虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。解释：在C/C++编程中，#ifdef、#else、#endif和#ifndef是常见的预处理指令（preprocessor directives），用于条件编译。它们的作用如下：#ifdef（If Defined）：作用：检查某个宏（即预处理器定义的符号）是否已经被定义。用法：#ifdef MACRO_NAME如果MACRO_NAME已经被定义（通常使用#define定义），那么从#ifdef到下一个#else或#endif之间的代码会被编译。#defineDEBUG#ifdefDEBUGprintf("Debugging is enabled.\n");#endif如果DEBUG被定义了，printf语句就会被编译。#else：作用：作为#ifdef或#ifndef的条件分支，用于在前面的条件不满足时执行另一部分代码。用法：#else如果前面的#ifdef或#ifndef判断条件不成立，那么从#else到#endif之间的代码会被编译。#ifdefDEBUGprintf("Debugging is enabled.\n");#elseprintf("Debugging is disabled.\n");#endif如果DEBUG没有被定义，那么printf("Debugging is disabled.\n");就会被编译。#endif：作用：结束一个条件编译块。用法：#endif它与#ifdef、#ifndef、#else等指令配对使用，标志着条件编译的结束。#ifdefDEBUGprintf("Debugging is enabled.\n");#endif#endif结束了从#ifdef DEBUG开始的条件编译块。#ifndef（If Not Defined）：作用：检查某个宏是否未被定义。用法：#ifndef MACRO_NAME如果MACRO_NAME没有被定义，那么从#ifndef到#else或#endif之间的代码会被编译。#ifndefRELEASEprintf("This is a debug build.\n");#endif如果RELEASE没有被定义，printf语句就会被编译。544. 结构体可以直接赋值么？‌‌‌‌　　声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针“成员”时，一定要小心。‌‌‌‌　　注意：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作。因此在释放之前一定要确保其他指针不再使用这段内存空间。545. 一个参数可以既是const又是volatile么可以。用const和volatile同时修饰变量，表示这个变量在程序内部是可读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心的去内存读取这个变量的值，而不是去寄存器读取他的备份。注意：再次一定要注意const的意思，const不允许程序中的代码改变程序中的某一变量，其在编译期间发挥作用，并没有实际地禁止某段内存的读写特性。546. 结构体内存对齐问题#include&lt;stdio.h&gt;structS1{inti:8;charj:4;inta:4;doubleb;};structS2{inti:8;charj:4;doubleb;inta:4;};structS3{inti;charj;doubleb;inta;};intmain(){printf("%d\n",sizeof(S1));// 输出8printf("%d\n",sizeof(S1);// 输出12printf("%d\n",sizeof(Test3));// 输出8return0;}sizeof(S1)=16sizeof(S2)=24sizeof(S3)=32解释：位域（Bit-fields位域允许在结构体中定义占用特定位数的成员，这在节省内存或实现硬件寄存器映射时非常有用。位域的存储和对齐规则有以下几点：存储单元：位域通常会被存储在其声明类型的存储单元中。例如，int i:8;会被存储在一个int类型的存储单元中（通常4字节）。位域的对齐：位域成员遵循其声明类型的对齐要求。例如，int类型的位域成员需要4字节对齐。位域的打包：多个位域成员如果在同一个存储单元内，可以紧密打包。例如，int i:8; char j:4; int a:4;可以在同一个4字节的int存储单元内打包存储。547. 请解析((void()())0)()的含义void(* 0)()：是一个返回值为void，参数为空得函数指针0.(void(* )())0：把0转换成一个返回值为void，参数为空的函数指针。(void()())0：在上句的基础上加* 表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。((void()())0)()：这就是上句的函数名对应的函数的调用。函数指针基础：void (*)()是一个函数指针的声明，表示它指向一个返回值为void且不接受任何参数的函数。(void()())0*：0这里被强制转换为一个函数指针，类型为void(*)()。也就是说，0被认为是一个指向返回值为void且不接受参数的函数的指针。(void()())0：这个表达式其实和上面的一样，*在这里是可选的（因为我们是在做类型转换），所以void(*)()和void()()是等价的。本质上，这一步是将0转换为一个函数指针类型。((void()())0)()：((void()())0)是一个函数指针，它指向内存地址0。在后面加上()意味着我们尝试去调用这个位于地址0的函数。简化理解：((void()())0)()这段代码尝试调用一个位于内存地址0的函数。在大多数系统中，地址0是无效的，不会指向任何有效的代码。因此，这样的调用通常会导致程序崩溃或产生未定义行为。这个表达式展示了一种高级且危险的类型转换和函数指针的使用，但在实际应用中，这种操作通常是不安全的，并且会导致严重的错误。548. C语言的结构体和C++的类有什么区别C语言的结构体是不能有函数成员的，而C++的类可以有。C语言中的结构体中的数据成员是没有private、public、protected访问限定的。而C++的类的成员有这些访问限定。C语言的结构体是没有继承关系的，而C++的类却有丰富的继承关系。注意：虽然C的结构体和C++的类有很大的相似度，但是类是实现面向对象的基础。而结构体只可以简单地理解为类的前身。549. 句柄和指针的区别和联系是什么？‌‌‌‌　　句柄和指针其实是两个截然不同的概念。‌‌‌‌Windows系统用句柄标记系统资源，隐藏系统的信息。‌‌‌‌　　你只要知道有这个东西，然后去调用就行了，他是个32bit的uint。指针则标记某个物理内存地址，两者是不同的概念。解释：‌‌‌‌　　句柄（Handle）和指针（Pointer）在计算机编程中是两个不同的概念，但它们在某些情况下可以有相似的作用。下面是它们的区别和联系：指针（Pointer）定义: 指针是一个变量，它存储的是另一个变量的内存地址。通过指针，你可以直接访问或操作该地址上的数据。作用: 指针用于直接操作内存中的数据，可以用来动态分配内存、遍历数组、实现函数指针等。类型安全: 指针是类型安全的，它知道自己指向的是什么类型的数据（例如int*指针只能指向整数类型）。直接内存访问: 使用指针可以直接访问和修改内存中的数据，这在某些情况下非常高效。句柄（Handle）定义: 句柄是一种抽象化的概念，通常是一个整数或指针，用于引用系统资源（如文件、窗口、线程等），而无需了解这些资源的具体内存地址或内部结构。作用: 句柄用于操作复杂系统资源，提供一种间接的访问方式。操作系统或程序通过句柄来管理和操作这些资源，而不暴露具体的内存地址。抽象层次: 句柄比指针更加抽象。它是系统或库提供给用户的一种资源标识符，而用户无法直接操作句柄指向的具体内存或数据结构。类型安全: 句柄通常没有类型安全的保障，尤其在操作系统或库中，一个句柄可能代表不同类型的资源（例如文件句柄和窗口句柄），但它们通常是不同类型的标识符，使用不当会导致错误。联系间接访问: 在某些情况下，句柄可以被看作是指针的一个高级封装或抽象。它们都用于间接地访问或操作数据或资源。资源管理: 指针和句柄都可以用于管理资源。在某些语言或系统中，句柄实际上可能是一个指向特定结构体的指针，只是对用户隐藏了直接内存操作的细节。性能与安全: 指针通常提供更高的性能，因为它允许直接操作内存，但也带来了更大的安全风险。句柄则更安全，因其隐藏了内存细节，但可能在某些情况下牺牲了一些性能。总结‌‌‌‌　　指针和句柄的主要区别在于抽象层次：指针直接指向内存地址并操作数据，而句柄则是对资源的一个间接引用，更加抽象和安全。指针用于需要直接内存操作的场合，而句柄用于需要管理复杂资源而不希望暴露底层实现的场合。550. C++类内可以定义引用数据成员么？‌‌‌‌　　可以，必须通过成员函数初始化列表初始化。解释：‌‌‌‌　　在C++中，类内不能直接定义引用（reference）类型的数据成员，但你可以定义引用类型的成员变量，并在构造函数的初始化列表中对其进行初始化。引用必须在定义时被初始化，因此它们不能在类内直接定义时初始化，而必须在构造函数中完成。#include&lt;iostream&gt;class MyClass{public:int&amp;ref;// 声明一个引用类型的数据成员// 构造函数，通过初始化列表对引用类型的数据成员进行初始化MyClass(int&amp;r):ref(r){}voidprint()const{std::cout&lt;&lt;"ref: "&lt;&lt;ref&lt;&lt;std::endl;}};intmain(){inta=10;MyClassobj(a);// 创建对象时传递引用obj.print();// 输出：ref: 10a=20;obj.print();// 输出：ref: 20，引用仍然指向原始变量return0;}定义引用类型数据成员: 在MyClass类中，int&amp; ref是一个引用类型的数据成员。构造函数中的初始化列表: 由于引用必须在定义时初始化，MyClass的构造函数通过初始化列表的方式将ref初始化为外部传递的引用r。引用的作用: 当ref被初始化后，它始终引用传递给它的那个变量（在这个例子中是a），因此无论a如何改变，ref都会反映出a的最新值。注意事项引用必须在定义时初始化，因此你不能像其他类型的数据成员那样在类的构造函数中赋值，只能在初始化列表中完成。引用一旦被初始化，就不能再指向其他对象。551. C++中类成员的访问权限C++通过public、protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为public、protected、还是private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问protected和private属性的成员。552. C++中的四种转换C++中的四种类型转换是：static_cast、dynamic_cast、const_cast、reinterpret_cast。1.static_cast用途:static_cast是一种最常用的显式类型转换方式，用于在相关类型之间转换。它可以用于将基类指针或引用转换为派生类指针或引用，前提是这种转换在编译时是安全的。它也可以用于基本数据类型之间的转换，例如int转float，以及指针类型之间的转换。限制:static_cast在编译时进行检查，但它不进行运行时检查，因此在不安全的转换情况下，使用static_cast可能会导致未定义行为。class Base{};class Derived:public Base{};Base*base=new Derived;Derived*derived=static_cast&lt;Derived*&gt;(base);// 合理的 static_cast2.dynamic_cast用途:dynamic_cast通常用于在继承层次中进行安全的向下转换，即将基类指针或引用转换为派生类指针或引用。dynamic_cast在运行时进行类型检查，如果转换不安全（例如转换的对象不是目标派生类类型），它会返回nullptr（对于指针）或抛出std::bad_cast异常（对于引用）。要求:dynamic_cast只适用于多态类（即具有虚函数的类），因为它依赖于运行时的类型信息（RTTI）。class Base{virtualvoidfoo(){}// 多态基类};class Derived:public Base{};Base*base=new Base;Derived*derived=dynamic_cast&lt;Derived*&gt;(base);// 返回 nullptr，转换失败3.const_cast用途:const_cast用于修改类型的const或volatile属性。它可以将const对象转换为非const，从而允许对其进行修改。这种转换通常用于需要对const数据进行修改的场景，但这种操作需要谨慎，因为修改常量数据可能会导致未定义行为。限制:const_cast不能用于移除const之外的类型转换，只能用于修改对象的常量性。constinta=10;int*p=const_cast&lt;int*&gt;(&amp;a);*p=20;// 未定义行为，因为 a 本来是 const 的4.reinterpret_cast用途:reinterpret_cast用于进行低级别的重新解释类型转换，主要用于不同类型的指针之间的转换，或将指针转换为整数类型（以及反过来）。这种转换通常不考虑类型的实际内容，只是简单地重新解释比特模式。它适用于需要对内存或底层表示进行直接操作的场景。限制:reinterpret_cast可能非常危险，因为它完全绕过了类型系统的安全性检查。错误使用可能导致严重的错误或未定义行为。inta=65;char*p=reinterpret_cast&lt;char*&gt;(&amp;a);std::cout&lt;&lt;*p&lt;&lt;std::endl;// 输出 'A'，将整数的内存重新解释为字符总结static_cast: 编译时转换，用于相关类型之间的转换。dynamic_cast: 运行时转换，用于安全的向下转换，多用于继承层次中的多态类。const_cast: 移除或添加const属性，用于修改常量性。reinterpret_cast: 低级别的类型重新解释，用于不同类型之间的位模式转换。这些类型转换运算符各有其特定的应用场景，在实际编程中应谨慎使用，尤其是reinterpret_cast和const_cast，以避免引发难以发现的错误。553. 说一下静态成员变量‌‌‌‌　　静态成员变量是类的一个成员，他被所有对象共享，不属于任何单独实例。静态成员变量有以下特点：在类的所有对象之间共享。即使没有创建类的对象，静态成员变量也存在。必须在类的外部进行初始化（通常在类的实现文件中）。可以通过类名加作用域解析运算符（：：）来访问，无需对象实例。554. 静态成员变量在什么时候初始化‌‌‌‌静态成员变量在程序开始时，即在main()函数执行之前就由运行时系统初始化。他们通常在类的实现文件中进行初始化，只初始化一次。555. 说一下堆排序堆排序是一种基于比较的排序算法，使用二叉堆数据结构来实现。它包括两个主要步骤：构建堆：将无序数组构建成一个最大堆（或最小堆），确保所有非叶子节点都遵循堆的性质。排序：依次删除堆顶元素（最大元素或最小元素），并将其移动到数组末尾，然后调整剩余元素以保持堆的性质，直到堆为空。堆排序的时间复杂度为O（n log n），不是稳定排序。不稳定：堆快希直选稳定 ：基冒直折归556. 还有哪些排序算法冒泡排序：通过重复交换相邻逆序元素，使得较小(或较大)元素逐步浮到顶端。选择排序：逐个找出未排序部分的最大（最小）元素，放到已排序序列的末尾。插入排序：取未排序区间中的元素，在已排序序列中从前向后扫描找到相应位置并插入。快速排序：选取基准值，将数组分为大于和小于基准值两部分，递归地对这两部分进行快速排序。（把小于基准的放到基准前面）归并排序：将数组分成两半，对每一半递归地进行归并排序，然后将两个有序地部分合并成一个。希尔排序：是插入排序的一种更高效的改进版本，通过比较距离较远的元素来减少元素的移动次数。计数排序：利用数组下标统计元素的出现次数，适用于一定范围内的整数排序。基数排序：根据数字的有效位或基数将整数分布到桶中，集合各个桶的内容得到有序序列，适用于非负整数。桶排序：将数组分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归的方式继续使用桶排序进行排序）。http://www.ppmy.cn/news/1540957.html相关文章Java JDK的面试题关于Java JDK的面试题&amp;#xff0c;这里有一些常见的问题和答案&amp;#xff0c;可以帮助你准备面试&amp;#xff1a; JDK、JRE和JVM的区别&amp;#xff1a; JDK&amp;#xff08;Java Development Kit&amp;#xff09;是Java开发工具包&amp;#xff0c;包含了JRE和开发工具&amp;#xff08;如javac编译器和ja…阅读更多...在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:30 +0000</pubDate>
    </item>
    <item>
      <title>Java JDK的面试题</title>
      <link>https://www.ppmy.cn/news/1540956.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Java JDK的面试题news/2025/11/1 0:23:29/关于Java JDK的面试题，这里有一些常见的问题和答案，可以帮助你准备面试：JDK、JRE和JVM的区别：JDK（Java Development Kit）是Java开发工具包，包含了JRE和开发工具（如javac编译器和java程序运行工具等），主要用于Java程序的开发。JRE（Java Runtime Environment）是Java运行环境，只包含了运行Java程序所必须的环境，主要用于Java程序的运行。JVM（Java Virtual Machine）是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。Java语言有哪些特点：简单易学、面向对象、平台无关性、支持网络编程、支持多线程、健壮性、安全性好。什么是字节码？采用字节码的最大好处是什么？字节码是Java源代码经过虚拟机编译器编译后产生的文件，它不面向任何特定的处理器，只面向虚拟机。采用字节码的好处是Java程序运行时比较高效，而且由于字节码并不专对一种特定的机器，因此Java程序无须重新编译便可在多种不同的计算机上运行。Oracle JDK和OpenJDK的对比：Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；OpenJDK是完全开源的，而Oracle JDK不是完全开源的；Oracle JDK比OpenJDK更稳定。Java和C++的区别：Java和C++都是面向对象的编程语言，但Java有自动垃圾回收机制，不需要程序员手动管理内存。Java不直接支持指针，而是使用引用来访问对象，这提高了程序的安全性。Java不允许类的多重继承，但可以通过实现多个接口来实现类似的功能。Java程序由于有JVM的存在，可以实现跨平台运行，无需修改即可在不同的操作系统上运行。什么是Java程序的主类？应用程序和小程序的主类有何不同？：在Java程序中，主类是指包含main方法的类，因为main方法是Java程序的入口点。应用程序的主类不需要一定是public的，但小程序（Applet）的主类通常是一个继承自JApplet或Applet的子类，且这个主类必须是public的。什么是跨平台性？原理是什么：跨平台性是指计算机程序能够在不同操作系统或环境中运行的能力，而无需对源代码进行修改。Java语言的跨平台性主要得益于它的两个核心概念：Java虚拟机（JVM）和字节码。Java程序的编写和编译是在开发者的本地环境中进行的，编译后生成的是平台无关的字节码（.class文件）。这些字节码被设计为能够运行在任何安装了相应JVM的设备上。当Java程序在不同的平台上运行时，JVM会将字节码解释为该平台的本地机器码，从而实现了“一次编写，到处运行”的跨平台特性。这些问题覆盖了Java JDK的基本概念、Java语言的特点、字节码、Oracle JDK与OpenJDK的对比、Java与C++的区别、Java程序的主类以及跨平台性的实现原理。准备这些面试题可以帮助你更好地理解Java JDK的相关知识。http://www.ppmy.cn/news/1540956.html相关文章在win系统上做生信数据分析如何快速检查和填写正确的文件路径在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避免分析报错 
文件路径没有填写正确导致分析报错或闪退的问题 
视频教程 
https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径&amp;#xff0c;避…阅读更多...JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:29 +0000</pubDate>
    </item>
    <item>
      <title>在win系统上做生信数据分析如何快速检查和填写正确的文件路径</title>
      <link>https://www.ppmy.cn/news/1540955.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维在win系统上做生信数据分析如何快速检查和填写正确的文件路径news/2025/11/1 0:23:27/在win系统上做生信数据分析如何快速检查和填写正确的文件路径，避免分析报错文件路径没有填写正确导致分析报错或闪退的问题视频教程https://www.bilibili.com/video/BV1mUmHYiESC/ (在win系统上做生信数据分析如何快速检查和填写正确的文件路径，避免分析报错)报错示例截图报错原因讲解我的软件界面run_file_path文件路径参数填写的文件路径是D:/omics_tools/demo_data/iris2.csv, 但是我的D盘的D:/omics_tools/demo_data是没有这个文件的，只有一个D:/omics_tools/demo_data/iris.csv这个文件，所以我的文件路径填错了，给了一个无效的文件路径，软件分析模块界面的run_file_path等一些文件路径尤其是run_file_path的文件路径填错了，导致分析模块无法读取到这个文件，就会出现闪退的情况，我们要保证给的路径一定是完整的绝对路径，并且这个路径是文件的所在路径，就是可以正常对该数据文件进行识别读取和分析处理的。快速检测给的文件路径是否正确有效的方法检测给的文件路径是否正确，一个很简单的方法就是把文件路径直接粘贴到文件管理器的地址栏中，如果能把这个文件找到或打开，这个路径就是正确的，否则，文件路径没有填写正确。把文件路径直接粘贴到文件管理器的地址栏：按enter回车键后，自动在wps或记事本中打开了iris.csv这个文件如果该文件是一个txt,csv,xlsx等表格文件，把路径粘贴到地址栏，按enter回车键后，能在记事本或wps,excel等软件中自动把这个表格文件打开，说明我们的文件路径填写的是正确的，否则，就是没有填写正确，需要坚持一些路径哪些填错了。快速正确填写文件路径的方法让文件管理器显示出文件扩展名如果我们没有设置让文件管理器显示出文件扩展名， 我们看到的文件名字是不完整的，像这样：比如，iris.csv这个文件，只显示了iris这个名字，我们直接复制iris这个名字作为文件路径就是不完整和错误的。这个时候，我们需要先让文件管理器能正常显示出文件的扩展名，设置方法如下：在文件管理器中点击查看---点击显示---点击显示文件扩展名，让文件扩展名前面是有√的。设置好显示文件扩展名后，文件管理器显示文件就是正常的文件名了，像这样：现在我们看到iris.csv的文件名就是显示的是iris.csv,而不是之前的iris了，这样我们去复制iris.csv这个文件名，才是正常的名字。在记事本中通过复制粘贴快速得到该文件的完整正确的文件名绝对路径用于软件的分析模块的正确路径我们在电脑先打开一个空白的记事本窗口：2.1 在文件管理器中把光标放到我们要分析的文件上面，鼠标右键点击该文件，在弹出的菜单栏中选择复制文件地址，并按Ctrl+v粘贴到记事本中我们把完整的文件路径复制到记事本之后，需要把文件路径两边的双引号给删除掉，因为OmicsTools分析模块填写的文件路径都是不能加双引号的至此，现在就可以把这个完整的文件路径粘贴到OmicsTools分析软件对应的文件路径参数中了。2.2 可以在文件管理器中把光标放到我们要分析的文件上面，直接按Ctrl+shift+C快捷键来复制文件的完整路径地址，并按Ctrl+v粘贴到记事本中，然后把文件路径两边的双引号给删除掉，就可以把这个完整的文件路径粘贴到OmicsTools分析软件对应的文件路径参数中了。http://www.ppmy.cn/news/1540955.html相关文章JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误JDK17从17.0.5开始&amp;#xff0c;默认不再允许使用SHA1算法&amp;#xff0c;如果引用的jar包或代码里使用了SHA1算法&amp;#xff0c;会报以下错误。 
Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.…阅读更多...Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:28 +0000</pubDate>
    </item>
    <item>
      <title>JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误</title>
      <link>https://www.ppmy.cn/news/1540954.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维JDK17下，使用SHA1算法报Certificates do not conform to algorithm constraints错误news/2025/11/1 0:23:26/JDK17从17.0.5开始，默认不再允许使用SHA1算法，如果引用的jar包或代码里使用了SHA1算法，会报以下错误。Caused by: javax.net.ssl.SSLHandshakeException: Certificates do not conform to algorithm constraintsat java.base/sun.security.ssl.Alert.createSSLException(Alert.java:131)at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:378)at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:321)at java.base/sun.security.ssl.TransportContext.fatal(TransportContext.java:316)at java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:654)at java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.onCertificate(CertificateMessage.java:473)at java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.consume(CertificateMessage.java:369)at java.base/sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:396)at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:480)at java.base/sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:458)at java.base/sun.security.ssl.TransportContext.dispatch(TransportContext.java:201)at java.base/sun.security.ssl.SSLTransport.decode(SSLTransport.java:172)at java.base/sun.security.ssl.SSLSocketImpl.decode(SSLSocketImpl.java:1510)at java.base/sun.security.ssl.SSLSocketImpl.readHandshakeRecord(SSLSocketImpl.java:1425)at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:455)at java.base/sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:426)at java.base/sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:589)at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:187)at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1450)at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1421)at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:220)at com.pingan.openbank.api.sdk.common.helper.WebUtils.doRequest(WebUtils.java:167)at com.pingan.openbank.api.sdk.common.helper.WebUtils.doPost(WebUtils.java:110)... 11 common frames omitted
Caused by: java.security.cert.CertificateException: Certificates do not conform to algorithm constraintsat java.base/sun.security.ssl.AbstractTrustManagerWrapper.checkAlgorithmConstraints(SSLContextImpl.java:1571)at java.base/sun.security.ssl.AbstractTrustManagerWrapper.checkAdditionalTrust(SSLContextImpl.java:1496)at java.base/sun.security.ssl.AbstractTrustManagerWrapper.checkServerTrusted(SSLContextImpl.java:1440)at java.base/sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:638)... 29 common frames omitted
Caused by: java.security.cert.CertPathValidatorException: Algorithm constraints check failed on signature algorithm: SHA1withRSAat java.base/sun.security.provider.certpath.AlgorithmChecker.check(AlgorithmChecker.java:237)at java.base/sun.security.ssl.AbstractTrustManagerWrapper.checkAlgorithmConstraints(SSLContextImpl.java:1567)... 32 common frames omitted如果从JDK8升级到JDK17时，或其他原因，必须要使用SHA1算法，则需要修改JDK的配置找到你的JDK安装目录，找到目录下conf/security/java.security文件，如"/java-17-openjdk/conf/security/java.security"注释掉或者直接删除SHA1 usage SignedJAR &amp; denyAfter 2019-01-01，注意前面的逗号和空格也要删除如果是RedHat系的，如RHEL，AlmaLinux，Rocky Linux，/etc/crypto-policies/back-ends/java.config也需要修改，把里面的SHA1删除之后，重启服务，即可使用SHA1加密算法http://www.ppmy.cn/news/1540954.html相关文章Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法) 
requests-pkcs12  PyPI 
python中如何使用requests模块下载文件并获取进度提示 1、GET方法 
1.1、调用 # 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-mod…阅读更多...前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:27 +0000</pubDate>
    </item>
    <item>
      <title>Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)</title>
      <link>https://www.ppmy.cn/news/1540953.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)news/2025/11/1 0:23:25/Python3 接口自动化测试，HTTPS下载文件(GET方法和POST方法)requests-pkcs12 · PyPIpython中如何使用requests模块下载文件并获取进度提示1、GET方法1.1、调用# 下载客户端(GET)def download_client_get(self, header_all):try:url = self.host + "/xxx/v1/xxx-module/download-client"getfile = Gehttp://www.ppmy.cn/news/1540953.html相关文章前端_005_Nodejs文章目录 npm包管理器cjs和mjsYarn包管理器 1.Node.js 是js的一个运行环境&amp;#xff0c;从nodejs诞生后js代码不局限于只在浏览器中执行&amp;#xff0c;此外还能再nodejs里写服务端&amp;#xff0c;用js可以前后端全栈开发 2.Node.js不跟浏览器一样默认含有document,window对象&amp;#xf…阅读更多...进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:26 +0000</pubDate>
    </item>
    <item>
      <title>前端_005_Nodejs</title>
      <link>https://www.ppmy.cn/news/1540952.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维前端_005_Nodejsnews/2025/11/1 0:23:24/文章目录npm包管理器cjs和mjsYarn包管理器1.Node.js 是js的一个运行环境，从nodejs诞生后js代码不局限于只在浏览器中执行，此外还能再nodejs里写服务端，用js可以前后端全栈开发2.Node.js不跟浏览器一样默认含有document,window对象，使用时需要引入npm包管理器通过package.json文件进行管理前端需要的包，package-lock.json 会固化当前安装的每个软件包版本，运行npm update会更新该文件npm分为本地模式和全局模式，一般带-g 都是全局安装npm常用命令--save 或 -S: 添加到package.json文件的dependencies列表中（默认行为）。--save-dev 或 -D: 添加到package.json文件的devDependencies列表中，表示该包仅用于开发环境。
npm install --save-dev &lt;PACKAGENAME&gt;
--global 或 -g: 全局安装该包，而不是安装在当前项目中。@&lt;版本号&gt;: 安装指定版本的包。
npm install &lt;package-name&gt;@&lt;version&gt;npm init  //初始化
npm install //安装模块
npm run //执行脚本
npm uninsall //卸载模块
npm update //更新模块
npm ls //查看已安装包
npm run &lt;task-name&gt; //执行脚本任务
npm cache clean //清理npm缓存
npm get registry //获得当前使用镜像源
npm config set registry https://registry.npmjs.org/ //修改镜像源
npm root -g //查看全局安装路径package.json常用属性{"name":"test-project","version":"1.0.0","description":"A Vue.js project","main":"src/main.js","private":true,"scripts":{"dev":"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js","start":"npm run dev","unit":"jest --config test/unit/jest.conf.js --coverage","test":"npm run unit","lint":"eslint --ext .js,.vue src test/unit","build":"node build/build.js"},"dependencies":{"vue":"^2.5.2"},"devDependencies":{"autoprefixer":"^7.1.2","babel-core":"^6.22.1","babel-eslint":"^8.2.1","babel-helper-vue-jsx-merge-props":"^2.0.3","babel-jest":"^21.0.2","babel-loader":"^7.1.1","babel-plugin-dynamic-import-node":"^1.2.0","babel-plugin-syntax-jsx":"^6.18.0","babel-plugin-transform-es2015-modules-commonjs":"^6.26.0","babel-plugin-transform-runtime":"^6.22.0","babel-plugin-transform-vue-jsx":"^3.5.0","babel-preset-env":"^1.3.2","babel-preset-stage-2":"^6.22.0","chalk":"^2.0.1","copy-webpack-plugin":"^4.0.1","css-loader":"^0.28.0","eslint":"^4.15.0","eslint-config-airbnb-base":"^11.3.0","eslint-friendly-formatter":"^3.0.0","eslint-import-resolver-webpack":"^0.8.3","eslint-loader":"^1.7.1","eslint-plugin-import":"^2.7.0","eslint-plugin-vue":"^4.0.0","extract-text-webpack-plugin":"^3.0.0","file-loader":"^1.1.4","friendly-errors-webpack-plugin":"^1.6.1","html-webpack-plugin":"^2.30.1","jest":"^22.0.4","jest-serializer-vue":"^0.3.0","node-notifier":"^5.1.2","optimize-css-assets-webpack-plugin":"^3.2.0","ora":"^1.2.0","portfinder":"^1.0.13","postcss-import":"^11.0.0","postcss-loader":"^2.0.8","postcss-url":"^7.2.1","rimraf":"^2.6.0","semver":"^5.3.0","shelljs":"^0.7.6","uglifyjs-webpack-plugin":"^1.1.1","url-loader":"^0.5.8","vue-jest":"^1.0.2","vue-loader":"^13.3.0","vue-style-loader":"^3.0.1","vue-template-compiler":"^2.5.2","webpack":"^3.6.0","webpack-bundle-analyzer":"^2.9.0","webpack-dev-server":"^2.9.1","webpack-merge":"^4.1.0"},"engines":{"node":"&gt;= 6.0.0","npm":"&gt;= 3.0.0"},"browserslist":["&gt; 1%","last 2 versions","not ie &lt;= 8"]}cjs和mjs1.mjs是ECMA module，加载ES相关模块， 使用import和export，这个是ES6标准cjs是node.js独有的模块，commonjs，使用require()加载和module.exports输出require()是同步加载，后面的代码必须等待这个命令执行完，才会执行。import命令则是异步加载2.Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，默认是加载commonjs.mjs文件总是以 ES6 模块加载，.cjs文件总是以 CommonJS 模块加载，.js文件的加载取决于package.json里面type字段的设置。 {type:“module”}3.网页中引入使用module 的js 可以指定script 其type 为modulesPs:Es模块只能通过http 协议工作，不支持file:// 本地打开文件 所以只能通过搭建服务器的方式打开使用Es 模块的网页另外不要尝试用vs code里liveserver 插件尝试使用import 或者require 方式，这个插件起的服务器是找不到这种方式引入的模块其他nodejs提供许多后端语言支持的特性，如文件操作，异步…等等 这个用到时查找官方手册即可node.js手册ackage.json里面type`字段的设置。 {type:“module”}Yarn包管理器yarn.lock 锁定依赖包版本yarninityarninstallyarnadd[package]yarnadd[package]@[version]yarnadd[package]@[tag]yarnadd[package]--dev# dev dependenciesyarnadd[package]--peer# peer dependenciesyarnup[package]yarnup[package]@[version]yarnup[package]@[tag]yarnremove[package]yarnconfigset&lt;name&gt;&lt;value&gt;yarnconfigsetregistry
``http://www.ppmy.cn/news/1540952.html相关文章进程线程知识总结1. 程序什么时候应该使用线程&amp;#xff0c;什么时候单线程效率高 
使用线程&amp;#xff1a;在I/O密集型或高并发的场景&amp;#xff0c;例如网络服务、文件读写等。通过多线程可以同时处理多个任务&amp;#xff0c;提高利用率。单线程效率高&amp;#xff1a;在CPU密集型任务中&amp;#xff0c;当任务…阅读更多...MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:24 +0000</pubDate>
    </item>
    <item>
      <title>进程线程知识总结</title>
      <link>https://www.ppmy.cn/news/1540951.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维进程线程知识总结news/2025/11/1 0:23:23/1. 程序什么时候应该使用线程，什么时候单线程效率高使用线程：在I/O密集型或高并发的场景，例如网络服务、文件读写等。通过多线程可以同时处理多个任务，提高利用率。单线程效率高：在CPU密集型任务中，当任务逻辑复杂、开销大，频繁切换线程反而会增加开销，影响性能。2. 惊群现象惊群现象是指多个线程或进程被唤醒来处理某个事件，而实际上只有一个能完成工作，其余的线程再次被阻塞，造成资源浪费和性能下降。3. C++函数内的静态变量初始化以及线程安全问题静态变量：首次调用时初始化，直到程序结束。线程安全问题：在多线程环境下，静态变量初始化如果发生在多个线程访问时，可能导致数据竞争。C++11后，可以使用局部静态变量（保证线程安全）进行初始化。4. C++线程安全的单例类classSingleton{public:staticSingleton&amp;getInstance(){staticSingleton instance;// C++11确保线程安全returninstance;}private:Singleton()=default;// 私有构造函数};5. 多线程环境带有状态的对象的讨论状态对象需要注意线程安全性。如果对象在多个线程之间共享，需使用适当的锁机制（如互斥锁）来避免数据竞争。6. C++多线程加volatile的错误认识volatile保证变量的可见性，但是不保证多线程间的原子性和条件约束，通常不足以处理线程安全问题。7. 并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决多进程适合CPU密集型任务，因为可以规避GIL（全局解释器锁），在多核CPU上更有效利用资源。适合于需要隔离或阻止共享内存中损坏的情况。8. 如何证明一个数据结构是线程安全的需要确认该数据结构在并发环境下的每个操作都是原子性的，且在多个线程同时访问时不会导致数据不一致。可以通过静态分析、单元测试、压力测试等方法验证。9. lock-free的实现方式Lock-free算法通过原子操作（如CAS）实现，无需使用互斥锁，确保至少一个线程能成功完成操作而不阻塞其他线程。10. 锁的实现方式互斥锁：保护资源，确保同一时间只允许一个线程访问。读写锁：允许多个读操作并发进行，但写操作需要独占。自旋锁：线程在获取锁时会在循环中不断检查，适合保持时间短的临界区。11. 多线程编程的时候，使用无锁结构会不会比有锁结构更加快通常在高竞争场景中，无锁结构避免了上下文切换和锁竞争的开销，能’améliorer 性能。但无锁编程复杂，容易出错。12. linux线程是如何进行切换的Linux使用时间片轮转调度策略，线程切换时保存当前线程的上下文状态，并加载下一个线程的上下文状态。此过程涉及CPU寄存器、堆栈等。13. Linux开发，使用多线程还是用IO复用select/epoll多线程适合处理大量独立、长时间阻塞的任务。IO复用适合高并发情况下，需要快速响应和阻塞较短的任务。14. 异步，多线程和并行的区别异步是指非阻塞的事件处理机制，不一定创建新线程。多线程指在多个线程间并发执行任务。并行是指在多核CPU上同时执行多个任务。15. Linux下多线程和多进程程序的优缺点，各自适合什么样的业务场景多线程：开销小，适合共享内存场景，但易受单个线程崩溃影响。多进程：独立性强，适合需要稳定性和隔离性的场景，但开销大。16. 开发多线程的程序应该注意哪些问题竞争条件、死锁、可见性、线程安全、调试复杂性等。17. 如何测试线程池的性能可以通过模拟不同负载，使用基准测试工具测量处理时间、吞吐量和响应时间等指标，以评估线程池的性能。18. 死锁的原因和避免原因：互斥、请求与保持、不可剥夺、循环等待。避免：资源有序请求、请求前预先申请资源、引入超时机制等。19. 如何理解互斥锁，条件锁，读写锁以及自旋锁互斥锁：用于保护临界区，单个线程访问。条件锁：用于线程间的条件等待与通知。读写锁：多个读同时访问，写时独占。自旋锁：线程忙等待获取锁。20. 互斥锁，同步锁，临界区，互斥量，信号量，自旋锁之间联系是什么它们都涉及同步和资源控制。互斥锁和互斥量用于确保对共享资源的互斥访问；信号量用于控制访问资源的数量。21. pthread_cond_wait 为什么需要传递 mutex 参数pthread_cond_wait需要释放互斥锁，允许其他线程访问共享资源，从而避免与条件变量相关的资源竞争。22. 多线程网络编程中如何合理地选择线程数根据任务的性质、硬件能力及系统负载情况进行调整，一般选择大于或等于CPU核心数的线程数。23. malloc和free是线程安全的吗，在多线程开发时用这两个函数应该注意什么malloc和free在现代的C标准库中通常是线程安全的，但并发调用时可能导致性能下降，最好使用线程安全的内存池。24. 僵尸进程和孤儿进程有什么区别、如何处理僵尸进程：已结束但未被父进程收尸，保留了状态信息。孤儿进程：父进程已结束，但子进程仍在运行。处理：使用wait()清理僵尸进程，孤儿进程通常被init进程收养。25. Linux系统中进程、线程、时间片的关系进程：执行单元，独立地址空间。线程：共享进程资源，处于进程内的并发执行流。时间片：分配给线程或进程的CPU时间，为调度提供粒度。26. 在Linux系统中，对于用户创建的进程(线程)来说，CPU分配时间片的单位是线程还是进程时间片是以线程为单位分配的，线程在同一进程下共享时间片。27. 内核级调度和用户级调度内核级调度：由操作系统调度程序控制，能够管理多个进程/线程。用户级调度：在用户空间管理线程，内核不知线程存在，切换更快。28. Linux中进程具有父子层次结构，Windows中没有进程层次，这两种设计各有什么优劣优点（Linux）：方便资源管理和组织，父子关系便于信号处理。缺点（Linux）：更复杂的dad/child管理。Windows：简单直接，资源管理透明。29. linux用户级进程跟内核线程（进程）有什么差别用户级进程在用户空间进行管理，内核线程由内核管理。用户级的切换速度快，但无法充分利用多核，内核线程可以更好地调度。30. 为什么要区分用户态和内核态区分用户态与内核态提供了内存保护和进程隔离，确保用户程序在不影响操作系统的情况下运行，避免崩溃和安全隐患。31. 从用户空间到内核空间有以下触发手段系统调用、异常处理、信号、中断等。32. 进程的内存空间布局一页内存空间通常分为：代码段、数据段、堆、栈、共享内存等。33. 进程间通信（IPC）方式管道、消息队列、共享内存、套接字、信号等。34. 进程空间和内核空间对内存的管理不同用户空间有其独立的虚拟地址空间；内核空间则是全局共享的，用于存储内核级别的数据结构。35. 虚拟内存的作用提供每个进程独立的地址空间，隔离进程、实现内存保护和更高效的内存使用。36. 虚拟内存的实现通过页表映射虚拟地址到物理地址，使用换页算法和逻辑页存取管理。37. Linux的slab层Slab分配器管理对象的缓存，有效减少内存碎片，提供快速分配与释放。38. fork与vfork区别fork创建新进程并复制父进程的所有内存页面。vfork创建新进程但不复制内存，父进程会被挂起，直到子进程执行完毕。39. exit()与_exit()区别exit()执行清理（会调用atexit函数），而_exit()直接终止进程，不执行任何清理。40. Linux是如何避免内存碎片的使用动态分配算法和分页、合并算法（例如buddy system、slab allocator）减少或压制碎片。41. 共享内存的实现原理通过映射内存区域到多个进程的地址空间，允许进程间快速访问共享数据。42. 银行家算法用于死锁避免的资源分配算法，判断请求是否安全，以确保系统保持在安全状态。43. linux中断响应机制中断请求产生时，CPU暂停当前执行的任务，保存上下文，然后执行中断处理程序。44. 如何实现守护进程创建进程并将其转为会话领导，脱离控制终端、改变工作目录、关闭不必要的文件描述符等。45. 32位系统一个进程最多有多少堆内存在32位系统中，进程最大虚拟内存通常为4GB，但堆的实际大小取决于操作系统及内存分配方式，通常可达到几百MB到2GB不等。46. 线程安全和不安全的讨论线程安全：数据结构能够在多个线程同时操作时保持一致性和正确性。不安全：导致数据竞争、状态不一致性。47. 可重入函数与线程安全的区别与联系可重入函数：在多线程中即使发生中断也能安全调用，不依赖全局状态。线程安全：在多个线程同时调用时保持状态一致。48. 双重检查锁定模式(DCLP)的风险可能导致多个线程同时进入null判断，基本上绕过了多线程安全的保证。需要确保volatile关键字的使用。49. 内存屏障详解内存屏障（Memory Barrier）用于控制CPU内存操作的顺序，确保某些指令在其他指令前被执行。50. 原子操作原理原子操作是不可被中断的操作，保证在多线程环境下其执行是完整的，通常通过硬件支持提供。51. Linux有内核级线程么有，Linux支持内核级线程，它们可以被内核调度，采用内核的资源管理。52. 使用线程是如何防止出现大的波峰使用多线程可以处理多个并发请求，平稳负载，减少资源占用峰值，对短时间的请求高峰作出快速响应。53. 操作系统中进程调度策略有哪几种先来先服务（FCFS）短作业优先（SJF）时间片轮转（RR）优先级调度54. 线程与进程的区别和联系，线程是否具有相同的堆栈，dll是否有独立的堆栈区别：进程是资源分配的最小单位，线程是执行调度的最小单位。线程之间共享进程的堆栈。DLL：每个线程通常有独立的堆栈。55. 读者-写者问题在并发系统中，多个读者可以同时访问，但当写者访问时需要独占，解决方案包括使用读写锁。56. 哲学家进餐问题模型描述了进程间的问题和资源竞争，主要关注如何合理分配资源，避免死锁解决方案。57. 进程状态的切换图进程状态有创建、就绪、运行、阻塞、终止等状态，各状态之间的转移代表了进程生命周期的管控。http://www.ppmy.cn/news/1540951.html相关文章MusePose模型部署指南一、模型介绍 
MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。 
主要贡献可以概括如下&amp;#xff1a; 
发布的模型能够根据给定的姿势序列&amp;#xff0c;生成参考图中人物的舞蹈视频&amp;#xff0c;生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该 pose alig…阅读更多...05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:23 +0000</pubDate>
    </item>
    <item>
      <title>MusePose模型部署指南</title>
      <link>https://www.ppmy.cn/news/1540950.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MusePose模型部署指南news/2025/11/1 0:23:21/一、模型介绍MusePose是一个基于扩散和姿势引导的虚拟人视频生成框架。主要贡献可以概括如下：发布的模型能够根据给定的姿势序列，生成参考图中人物的舞蹈视频，生成的结果质量超越了同一主题中几乎所有当前开源的模型。发布该pose align算法，以便用户可以将任意舞蹈视频与任意参考图像对齐，这显著提高了推理性能并增强了模型的可用性。修复了几个重要的错误，并在 Moore-AnimateAnyone的代码基础上做了一些改进。二、部署流程1. 环境要求Python 3.10 或更高版本推荐：CUDA 11.7 或更高版本2. 克隆并安装依赖项git clone https://github.com/TMElyralab/MusePose.git
pip install -r requirements.txt3. 下载mim软件包pip install --no-cache-dir -U openmim 
mim install mmengine 
mim install "mmcv&gt;=2.0.1" 
mim install "mmdet&gt;=3.1.0" 
mim install "mmpose&gt;=1.1.0"4.下载权重git lfs install
git clone https://www.modelscope.cn/jackle/ComfyUI-MusePose-models.gitpretrained_weights最后，这些权重应按如下方式组织：./pretrained_weights/
|-- MusePose
|   |-- denoising_unet.pth
|   |-- motion_module.pth
|   |-- pose_guider.pth
|   └── reference_unet.pth
|-- dwpose
|   |-- dw-ll_ucoco_384.pth
|   └── yolox_l_8x8_300e_coco.pth
|-- sd-image-variations-diffusers
|   └── unet
|       |-- config.json
|       └── diffusion_pytorch_model.bin
|-- image_encoder
|   |-- config.json
|   └── pytorch_model.bin
└── sd-vae-ft-mse|-- config.json└── diffusion_pytorch_model.bin三、推理1. 准备在文件夹中准备参考图片和舞蹈视频./assets，并按照示例进行组织：./assets/
|-- images
|   └── ref.png
└── videos└── dance.mp42. 姿势对齐获取参考图的对齐 dwpose：python pose_align.py --imgfn_refer ./assets/images/ref.png --vidfn ./assets/videos/dance.mp4此后，您可以在其中看到姿势对齐结果./assets/poses，其中./assets/poses/align/img_ref_video_dance.mp4是对齐的 dwpose，而./assets/poses/align_demo/img_ref_video_dance.mp4用于调试。3. 推断 MusePose将参考图的路径和对齐的 dwpose 添加到测试配置文件中，./configs/test_stage_2.yaml例如：test_cases:"./assets/images/ref.png":- "./assets/poses/align/img_ref_video_dance.mp4"然后，只需运行python test_stage_2.py --config ./configs/test_stage_2.yaml./configs/test_stage_2.yaml是推理配置文件的路径。最后，你可以在./output/文件夹下查看4. 降低 VRAM 成本如果要降低 VRAM 成本，可以设置推理的宽度和高度。例如，python test_stage_2.py --config ./configs/test_stage_2.yaml -W 512 -H 512它将首先生成 512 x 512 的视频，然后将其调整回姿势视频的原始大小。目前在 512 x 512 x 48 上运行需要 16GB VRAM，在 768 x 768 x 48 上运行需要 28GB VRAM。但需要注意的是，推理分辨率会影响最终结果（尤其是人脸区域）。5. 面部美容如果要增强脸部区域以获得更好的脸部一致性，可以使用FaceFusion。您可以使用该face-swap功能将参考图中的脸部交换到生成的视频中。四、界面演示http://www.ppmy.cn/news/1540950.html相关文章05，hive1 &amp;#xff0c;作用 &amp;#xff1a; 
2 &amp;#xff0c;原理 &amp;#xff1a; 
3 &amp;#xff0c;使用场景 &amp;#xff1a;阅读更多...C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:22 +0000</pubDate>
    </item>
    <item>
      <title>05，hive</title>
      <link>https://www.ppmy.cn/news/1540949.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维05，hivenews/2025/11/1 0:23:20/1 ，作用 ：2 ，原理 ：3 ，使用场景 ：http://www.ppmy.cn/news/1540949.html相关文章C++面试速通宝典——26478. 你了解的网络攻击方式有哪些&amp;#xff1f;SYN攻击的防范方法&amp;#xff1f; 
网络攻击方式包括&amp;#xff1a; 
Dos/DDos攻击&amp;#xff1a;通过大量请求耗尽目标资源。Main-in-the-Middle攻击&amp;#xff1a;攻击者拦截和篡改双方通信。Phishing&amp;#xff1a;通过假冒网站或通信骗取…阅读更多...# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:20 +0000</pubDate>
    </item>
    <item>
      <title>C++面试速通宝典——26</title>
      <link>https://www.ppmy.cn/news/1540948.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维C++面试速通宝典——26news/2025/11/1 0:23:19/478. 你了解的网络攻击方式有哪些？SYN攻击的防范方法？网络攻击方式包括：Dos/DDos攻击：通过大量请求耗尽目标资源。Main-in-the-Middle攻击：攻击者拦截和篡改双方通信。Phishing：通过假冒网站或通信骗取用户信息。SQL注入：在数据库查询中注入恶意SQL代码。跨站脚本（XSS）攻击：在网页中注入恶意脚本。Malware：使用恶意软件进行攻击。SYN攻击（一种Dos攻击）防范方法包括：SYN Cookies：仅在确认客户端响应后分配资源。包过滤：过滤掉异常的或非法的SYN包。连接限制：限制打开SYN请求的速率或数量。超时设置：降低半开连接的超时时间。479. epoll、poll、select的区别？epoll为什么高效？select：它使用位掩码来表示监视的描述符集合，但最大能处理的描述符数目有限制（通常是1024）。poll：它通过一个链表来存储网络描述符，解决了最大描述符限制问题，但每次调用poll都需要遍历整个链表，效率较低。epoll：可以理解为变种的poll，它与poll类似，都是使用链表来存储网络描述符，但每当有事件触发时，它只需要获取已经就绪的事件就可以返回了，因此处理的事件少则效率越高。480. epoll为什么高效？回调机制：epoll使用回调的方式，只关注活动的socket，不必每次都轮询所有的被监听的socket。scalability：epoll具有较好的扩展性，可以处理的socket描述符数量比select和poll都要大。减少用户和内核空间之间复制数据的次数。481. MySQL支持的隔离级别是什么？最常用什么？四种事务隔离级别：READ UNCOMMITTED ： （读未提交）。READ COMMITTED ： （读已提交）。REPEATABLE READ : （可重复读）。SERIALIZABLE : （串行化）。最常用的隔离级别为 REPEATABLE READ（可重复读）。因为他平衡了性能与一致性，同时也是MySQL的默认隔离级别。482. MySQL索引是主要通过什么数据结构实现的？为什么用B+树？MySQL索引主要是通过B+树数据结构实现的。原因：高效的读写：对于数据库读写操作频繁的场景，B+树的平衡性能较好，读写性能稳定。范围查询优势：B+树支持范围查询，hash表只支持精确查询，而二叉树效率低下。磁盘读写优化：B+树的节点大小通常和磁盘扇区大小相同，这样可以最大化磁盘I/O效率。减少磁盘I/O次数：B+树的分支因子大，树的层级较低，可以减少在查询过程中磁盘I/O的次数。483. 虚函数实现机制‌‌‌‌　　C++中的虚函数通过虚函数表实现。‌‌‌‌每一个使用虚函数的类都有一个对应的虚函数表，其中存储了指向类的虚函数的指针。每一个对象实例包含一个指向其类的虚函数表的指针（vptr），当调用一个对象的虚函数时，会通过这个指针在虚函数表中查找对应的函数实现进行调用，从而实现多态性。这种机制允许在运行时根据对象的实际类型来动态绑定方法，而不是在编译时。484. const和define的区别const定义的常量有数据类型，而define是预处理指令，替换文本，没有数据类型。const有作用域限制，define一直到文件结束或被#undef 指令取消。const常量通常存储在程序的数据段中，define是简单替换，不分配存储空间。const常量在调试中可见，因为它们是符号化的，而define替换后的代码通常难以调试。const是在编译阶段使用，define发生在预处理阶段，编译器还未参与。485. struct和class的区别struct和class的主要区别在于默认的访问权限和继承类型：默认访问权限：struct中的成员默认是公开类型，而class中的成员默认是私有的。默认继承类型：使用struct继承默认是公开继承，而class继承默认是私有继承。486. 4层负载和7层负载均衡的区别‌‌‌‌4层负载均衡工作在传输层，主要关注IP地址和端口，使用TCP/UDP协议进行流量分发。‌‌‌‌7层负载均衡工作在应用层，可以处理更高级的协议如HTTP/HTTPS，并且可以基于URL、cookies等因素来进行智能分发。总的来说，4层负载均衡更关注网络层面，7层负载均衡则提供更细粒度的流量管理能力。487. 你了解哪些负载均衡方法负载均衡算法主要有以下几种：轮询：请求按照顺序轮流分配到不同的服务器上。加权轮询：类似轮询，但服务器有不同的权重。最少连接：请求被发送到连接数最少的服务器。加权最少连接：考虑服务器权重和连接数，选择最优服务器。源地址哈希：根据请求源地址的哈希结果分配请求。URL哈希：根据请求的URL哈希结果来分配请求。最少响应时间：选择响应时间最短的服务器。最少带宽：选择当前带宽消耗最少的服务器。488. malloc的底层原理了解么？涉及到哪些系统调用？malloc是标准C库中用于动态内存分配的函数。其底层原理涉及到以下几个系统调用：brk：改变数据段的末尾地址，用于增加或减少数据段的大小。sbrk：增加进程的程序断点，实际上是对brk的封装。mmap：创建一个新的映射区域，用于分配大块内存。‌‌‌‌　　malloc通常是通过上述系统调用来向操作系统请求内存，上层的内存分配器使用这些系统调用来管理内存的分配和释放，以及维护内存的数据结构，如空闲列表或者内存池等，来优化内存的使用和减少内存碎片。489. mmap的原理mmap是一种将文件或者设备的内容映射到进程的地址空间的机制。其基本原理如下：地址空间映射：mmap通过创建一个文件或设备内容与进程虚拟地址空间之间的对应关系，允许进程直接访问这片内存空间。这意味着对这部分内存的读写直接反应到了被映射文件或设备上，无需通过read或write系统调用。延迟加载：mmap采用需求分页的方式，实际内存页只有在访问时才被映射到物理内存中，这代表mmap可以有效管理和使用内存，减少不必要的物理内存占用。共享与私有：mmap支持共享内存映射和私有映射。共享映射允许不同进程共享同一片内存区域，对这片区域的修改会反映到所有映射了该区域的进程中。私有映射则为每个进程创建映射的副本，进程间的修改互不影响。页表：操作系统利用页表来管理这种映射关系，确保进程可以通过虚拟地址访问到正确的物理内存或文件内容。490. string的底层实现、vector的底层实现string的底层实现：动态数组：string在底层实际上是一个动态数组，用于存储字符序列。自动扩容：当字符串内容超过当前分配的内存时，string会自动进行扩容（通常是倍增策略）并拷贝原有数据到新的内存区域。短字符串优化（SSO）：对于短字符串，为了减少动态内存分配的开销，string会在对象内预留一小段空间，直接在其中存储字符串数组和结尾的空字符’\0’，避免了堆分配。复制写时优化（COW，现代C++标准中已废除）：在一些旧的实现中，多个string对象可以共享同一个字符数组，只有在修改时才会进行真正的拷贝，以减少内存使用和提升效率。vector的底层实现：动态数组：vector内部同样使用动态数组来存储数据，它支持随机访问。自动扩容：当插入的元素超过vector当前的容量时，它会自动重新分配更大的内存空间，并将原有元素复制或移动到新的地址。空间预留：vector提供reserve方法，允许手动指定容量，减少不必要的重新分配和数据拷贝。491. 结构体内存对齐相关结构体内存对齐是为了提高CPU访问效率而采取的方式。对齐规则：结构体的每个成员在内存中的起始地址应该是其类型大小的整数倍（例如，int通常是4字节，他的地址应该是4的整数倍）。结构体总大小：结构体的总大小为其最大成员类型大小的整数倍。如果不满足，会在结构体末尾进行填充。按序排列：结构体成员变量之间可能存在填充（padding），以保证后续成员的地址对齐。pragma pack（n）：可以通过#pragma pack(n)来指定结构体以n字节对齐。n一般为2的次幂。492. size of 一个 string 变量的结果‌‌‌‌　　sizeof 一个 string 变量通常返回的是string类型固定的大小，而不是字符串内容的长度。这个大小包括string对象中管理字符串所需的所有成员的大小，如指针、长度和容量等，具体的大小取决于实现（例如具体的编译器和其版本）。在某些实现中可能会有短字符优化（SSO），在这种情况下，小的字符串可以直接存储在这个固定大小的内存之中，而无需动态分配。493. std::move应用场景，和std::forward区别std::move应用场景：主要用于将对象标记为可移动，使之可以被移动构造或移动赋值函数使用。**应用于转移资源的所有权，**避免不必要的复制，例如移动大型容器或独占所有权的对象（如std::unique_ptr）。std:move和std::forward的区别：std::move无条件地将一个对象转换为右值引用，从而允许资源的移动操作。std::forward用于完美转发，在函数模板中，他可以保持参数的值属性（即左值保持左值，右值保持右值），通常与右值引用模板参数结合使用。494. 移动构造函数和复制构造函数的区别复制构造函数：创建一个对象的副本完成成员逐个复制（深复制）原始对象和新对象都拥有自己的独立资源移动构造函数：通过接管另一个对象的资源来创建对象（资源转移）执行“浅复制”，只是将资源的所有权从源对象转移。源对象不再拥有这些资源或处于有效但未定义的状态。495. push_back和emplace_back对比push_back：接受一个元素作为参数，并将其复制（或移动）到容器末尾。emplace_back:使用所提供的参数直接在容器末尾构造元素。避免了额外的复制或移动操作。496. push_back可以传入std::move的变量嘛‌‌‌‌　　push_bakc可以接受通过std::move传递的变量，这样可以将变量的资源移动到容器中，而不是复制。497. push_back一个std::move的变量 与 直接emplace_back 性能对比‌‌‌‌　　push_back一个std::move的变量和直接使用emplace_back的性能是相似的，因为他们都是在进行移动操作，而非复制操作。498. shared_ptr以引用形式传入参数会有什么问题将shared_ptr以引用形式传递不会增加对象的引用计数，这可能会导致以下问题：若函数内部存储或复制了这个引用，而在函数外部原shared_ptr已经被销毁，那么这个存储的引用将成为悬空引用，导致未定义的行为。函数调用者可能会期望传递的shared_ptr对象会因函数调用而共享其所有权，但实际上却没有发生。499. C++的四种类型转换C++提供了四种类型转换操作符：static_cast：用于非多态类型的转换，安全性较高的类型转换。dynamic_cast:用于多态类型的转换，主要用于基类和派生类之间的安全转换。const_cost:用于去除或添加const或volatile属性。reinterpret_cast:用于进行低层次的重新解释类型转换，可能是不安全的。500. explicit关键字的作用，使用场景explicit关键字用来阻止C++编译器执行隐式类型转换，要求类型转换必须明确无误。使用explicit的典型场景包括：防止构造函数的隐式调用，确保只能显式地进行对象初始化。防止具有单个参数的构造函数或转换操作符被编译器自动用作隐式类型转换。501. 协程和线程的区别线程由操作系统内核管理，协程一般由用户空间的库管理。线程切换包括内核空间和用户空间的上下文切换，开销较大；协程切换仅包含用户空间的上下文切换，开销较小。线程的调度由操作系统内核控制；协程的调度由程序员或库控制，拥有更细粒度的控制能力。大量线程会增加系统负担，而大量协程对系统负担较小，可以实现更高的并发性能。502. 共享内存如何使用，原理共享内存的使用通常包括以下步骤：创建共享内存段：一个进程创建一个特定大小的共享内存段。将共享内存段附加到进程的地址空间：需要通信的进程将这个共享内存段映射到他们的地址空间。使用共享内存：进程可以通过指针和内存操作读写这个内存段。分离共享内存段：进程用完后，将共享内存从自己的地址空间分离。删除共享内存段：所有进程都不再需要时，最后一个使用的进程应删除共享内存段。‌‌‌‌　　共享内存的原理是提供一块能被多个进程访问的内存区域。操作系统确保这块内存区域在多个进程间是可见的，从而实现非常快速的数据交换。因为它避免了数据的复制操作，直接在物理内存上进行读写。需要注意的是，由于多个进程可以同时访问，通常需要用同步机制（如信号量）来避免竞争条件。503. 虚拟内存和物理内存在什么时候进行转换？‌‌‌‌　　虚拟内存和物理内存进行转换的时候称为“页映射”，这个过程由操作系统的内存管理单元（MMU）控制。当一个程序试图访问虚拟内存系统时，如果这个地址已经映射到物理内存，MMU将直接转换访问；如果没有映射，操作系统将会触发一个缺页中断，然后加载相应的数据到物理内存，并更新页表以反映新的映射关系，之后访问可以继续进行。这个转换过程对程序是透明的。http://www.ppmy.cn/news/1540948.html相关文章# Js 回调函数Js 回调函数 文章目录 Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理 回调函数的优点和缺点优点缺点 回调地狱解决回调地狱的方法使用 Promise使用 async/await 应用函数式编程中的回调函数高阶函数函数柯里化 异步编程中的回调函数回调函数的错误处理传…阅读更多...极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:19 +0000</pubDate>
    </item>
    <item>
      <title># Js 回调函数</title>
      <link>https://www.ppmy.cn/news/1540947.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维# Js 回调函数news/2025/11/1 0:23:17/Js 回调函数文章目录Js 回调函数回调函数的定义和使用回调函数的常见用途异步操作事件处理回调函数的优点和缺点优点缺点回调地狱解决回调地狱的方法使用 Promise使用 async/await应用函数式编程中的回调函数高阶函数函数柯里化异步编程中的回调函数回调函数的错误处理传递错误参数使用 Promise 和`async/await`回调函数是一种作为参数传递给另一个函数的函数，它在特定的事件发生或某个操作完成后被调用。回调函数的定义和使用sayHellow函数接收一个回调函数作为参数。在函数内部执行一些操作后，调用了传递进来的回调函数。&lt;!DOCTYPEhtml&gt;&lt;buttononclick="test1()"&gt;回调函数测试&lt;/button&gt;&lt;html&gt;&lt;body&gt;&lt;scripttype="text/javascript"&gt;functionsayHellow(msg,callback){alert(msg)if(typeofcallback==="function"){callback(msg);}}functionone(msg){alert("回调函数执行结果："+msg)}functiontest1(){sayHellow('你好张三',one);sayHellow('你好李四',function(){alert('匿名函数实现回调')})}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;回调函数的常见用途异步操作在JavaScript中，很多操作是异步的，比如网络请求、文件读取等。回调函数在处理异步操作时非常有用。例如，使用XMLHttpRequest进行网络请求时，可以在请求完成后调用回调函数来处理响应数据。事件处理在处理用户交互事件（如点击按钮、鼠标移动等）时，回调函数可以在事件发生时执行相应的操作。例如，给一个按钮添加点击事件监听器，当按钮被点击时，回调函数会被调用。document.getElementById('myButton').addEventListener('click',function(){console.log('按钮被点击了！');});回调函数的优点和缺点优点灵活性：可以根据不同的需求传递不同的回调函数，实现不同的行为。异步处理：非常适合处理异步操作，确保在操作完成后执行特定的逻辑。缺点回调地狱：当多个异步操作依赖于彼此的结果时，可能会导致回调函数嵌套过多，使代码难以阅读和维护。错误处理困难：在复杂的回调函数链中，错误处理可能变得复杂。回调地狱当多个异步操作依赖于彼此的结果时，可能会导致回调函数嵌套过多，形成所谓的"回调地狱"doSomethingAsync(function(){doAnotherAsyncThing(function(){doYetAnotherAsyncThing(function(){// 更多嵌套...});});});解决回调地狱的方法使用 PromisePromise是一种用于处理异步操作的对象，它可以避免回调地狱，并提供了一种更清晰的方式来处理异步代码。例如，可以使用then方法链式调用多个异步操作，每个操作返回一个Promise。functiondoSomethingAsync(){returnnewPromise(function(resolve,reject){setTimeout(function(){console.log('异步操作 1 完成');resolve();},1000);});}functiondoAnotherAsyncThing(){returnnewPromise(function(resolve,reject){setTimeout(function(){console.log('异步操作 2 完成');resolve();},1000);});}// 使用 then 方法调用链doSomethingAsync().then(doAnotherAsyncThing).then(function(){console.log('所有异步操作完成');});使用 async/awaitasync/await是基于Promise的语法糖，它使异步代码看起来更像同步代码，更加易读和易于维护。例如，可以使用async函数和await关键字来等待异步操作完成。asyncfunctionperformAsyncOperations(){// 等到 doSomethingAsync() 方法执行结束再执行后面的awaitdoSomethingAsync();// 等 doAnotherAsyncThing() 执行完成后再执行后面的awaitdoAnotherAsyncThing();console.log('所有异步操作完成');}performAsyncOperations();应用函数式编程中的回调函数高阶函数数组的map、filter和reduce等方法都是高阶函数，它们接收一个回调函数作为参数，用于对数组中的每个元素进行操作。constnumbers=[1,2,3,4,5];constdoubledNumbers=numbers.map(function(number){returnnumber*2;});console.log(doubledNumbers);// [2, 4, 6, 8, 10]map方法接收一个回调函数作为参数，该回调函数将数组中的每个元素乘以2，并返回一个新的数组。函数柯里化add函数接收一个参数a，并返回一个新的函数，该函数接收参数b并返回a + b的值。回调函数在这里被用于延迟计算，直到所有的参数都被提供。&lt;!DOCTYPEhtml&gt;&lt;/html&gt;&lt;script&gt;functionadd(a){returnfunction(b){returna+b;};}constaddOne=add(5);console.log(addOne(3));// 8&lt;/script&gt;异步编程中的回调函数async和await是ES2017引入的语法糖，用于简化异步操作的处理。回调函数的错误处理传递错误参数回调函数通常接收一个错误参数作为第一个参数，用于在发生错误时通知调用者。如果没有错误发生，这个参数通常为null。例如，下面的代码展示了如何在异步操作中处理错误：functionasyncOperation(callback){setTimeout(function(){consterror=null;constresult='success';// 返回错误callback(error,result);},1000);}asyncOperation(function(err,result){if(err){console.error(err);}else{console.log(result);}});asyncOperation函数模拟了一个异步操作，在操作完成时调用回调函数，并传递一个错误参数和一个结果参数。调用者可以根据错误参数的值来决定如何处理结果。使用 Promise 和async/awaitPromise和async/await提供了一种更简洁的方式来处理错误。在Promise中，可以使用catch方法来处理拒绝的Promise，在async/await中，可以使用try/catch块来捕获异步操作中的错误。// 返回 promisefunctionasyncOperation(){returnnewPromise((resolve,reject)=&gt;{setTimeout(()=&gt;{consterror=null;constresult='success';if(error){reject(error);}else{resolve(result);}},1000);});}asyncfunctionexecuteAsyncOperation(){try{// 等待 asyncOperation 返回结果constresult=awaitasyncOperation();console.log(result);}catch(err){console.error(err);}}// 调用 executeAsyncOperation()executeAsyncOperation();asyncOperation函数返回一个Promise，在异步操作完成时，根据是否有错误来决定是resolve还是reject这个Promise。在executeAsyncOperation函数中，使用async/await来调用asyncOperation函数，并使用try/catch块来捕获可能发生的错误。http://www.ppmy.cn/news/1540947.html相关文章极简版Java敏感词检测SDK敏感词工具 
sensitive-word 基于 DFA 算法实现的高性能敏感词工具&amp;#xff0c;开源在GitHub&amp;#xff1a;https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦&amp;#xff0c;是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。 
使用场景…阅读更多...Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:18 +0000</pubDate>
    </item>
    <item>
      <title>极简版Java敏感词检测SDK</title>
      <link>https://www.ppmy.cn/news/1540946.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维极简版Java敏感词检测SDKnews/2025/11/1 0:23:16/敏感词工具sensitive-word 基于 DFA 算法实现的高性能敏感词工具，开源在GitHub：https://github.com/houbb/sensitive-word。用于敏感词/违禁词/违法词/脏词等的识别和阻拦，是基于 DFA 算法实现的高性能 java 敏感词过滤工具框架。使用场景：但凡是允许用户能将内容发布到网上的，任何地方理论上都应该要有一次内容审核，审核目的只要是否有违规违禁词等。之前开发过一款小程序，小程序的内容也有严格内容审核机制，当时采用的是小程序的API做的内容审核。而这款敏感词检测sdk，更加适合自己做内容平台开发等场景。Maven引入&lt;dependency&gt;&lt;groupId&gt;com.github.houbb&lt;/groupId&gt;&lt;artifactId&gt;sensitive-word&lt;/artifactId&gt;&lt;version&gt;0.21.0&lt;/version&gt;&lt;/dependency&gt;快速使用直接判断是否包含敏感词finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";Assert.assertTrue(SensitiveWordHelper.contains(text));核心方法返回第一个敏感词finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";Stringword=SensitiveWordHelper.findFirst(text);Assert.assertEquals("五星红旗",word);返回所有敏感词finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";List&lt;String&gt;wordList=SensitiveWordHelper.findAll(text);Assert.assertEquals("[五星红旗, 毛主席, 天安门]",wordList.toString());默认的替换策略finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";Stringresult=SensitiveWordHelper.replace(text);Assert.assertEquals("****迎风飘扬，***的画像屹立在***前。",result);指定替换的内容finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";Stringresult=SensitiveWordHelper.replace(text,'0');Assert.assertEquals("0000迎风飘扬，000的画像屹立在000前。",result);高级用法自定义替换策略场景说明：不同的敏感词有不同的替换结果。比如【游戏】替换为【电子竞技】，【失业】替换为【灵活就业】。/*** 自定替换策略* @since 0.2.0*/@TestpublicvoiddefineReplaceTest(){finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";ISensitiveWordReplacereplace=newMySensitiveWordReplace();Stringresult=SensitiveWordHelper.replace(text,replace);Assert.assertEquals("国家旗帜迎风飘扬，教员的画像屹立在***前。",result);}publicclassMyWordReplaceimplementsIWordReplace{@Overridepublicvoidreplace(StringBuilderstringBuilder,finalchar[]rawChars,IWordResultwordResult,IWordContextwordContext){StringsensitiveWord=InnerWordCharUtils.getString(rawChars,wordResult);// 自定义不同的敏感词替换策略，可以从数据库等地方读取if("五星红旗".equals(sensitiveWord)){stringBuilder.append("国家旗帜");}elseif("毛主席".equals(sensitiveWord)){stringBuilder.append("教员");}else{// 其他默认使用 * 代替intwordLength=wordResult.endIndex()-wordResult.startIndex();for(inti=0;i&lt;wordLength;i++){stringBuilder.append('*');}}}}使用实例场景1：基本使用finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";List&lt;String&gt;wordList=SensitiveWordHelper.findAll(text);Assert.assertEquals("[五星红旗, 毛主席, 天安门]",wordList.toString());List&lt;String&gt;wordList2=SensitiveWordHelper.findAll(text,WordResultHandlers.word());Assert.assertEquals("[五星红旗, 毛主席, 天安门]",wordList2.toString());List&lt;IWordResult&gt;wordList3=SensitiveWordHelper.findAll(text,WordResultHandlers.raw());Assert.assertEquals("[WordResult{startIndex=0, endIndex=4}, WordResult{startIndex=9, endIndex=12}, WordResult{startIndex=18, endIndex=21}]",wordList3.toString());场景2： wordTags例子在 dict_tag_test.txt 文件中指定对应词的标签信息。finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";// 默认敏感词标签为空List&lt;WordTagsDto&gt;wordList1=SensitiveWordHelper.findAll(text,WordResultHandlers.wordTags());Assert.assertEquals("[WordTagsDto{word='五星红旗', tags=[]}, WordTagsDto{word='毛主席', tags=[]}, WordTagsDto{word='天安门', tags=[]}]",wordList1.toString());List&lt;WordTagsDto&gt;wordList2=SensitiveWordBs.newInstance().wordTag(WordTags.file("dict_tag_test.txt")).init().findAll(text,WordResultHandlers.wordTags());Assert.assertEquals("[WordTagsDto{word='五星红旗', tags=[政治, 国家]}, WordTagsDto{word='毛主席', tags=[政治, 伟人, 国家]}, WordTagsDto{word='天安门', tags=[政治, 国家, 地址]}]",wordList2.toString());其他特性忽略大小写finalStringtext="fuCK the bad words.";Stringword=SensitiveWordHelper.findFirst(text);Assert.assertEquals("fuCK",word);忽略半角圆角finalStringtext="ｆｕｃｋ the bad words.";Stringword=SensitiveWordHelper.findFirst(text);Assert.assertEquals("ｆｕｃｋ",word);忽略数字的写法这里实现了数字常见形式的转换。finalStringtext="这个是我的微信：9⓿二肆⁹₈③⑸⒋➃㈤㊄";List&lt;String&gt;wordList=SensitiveWordBs.newInstance().enableNumCheck(true).init().findAll(text);Assert.assertEquals("[9⓿二肆⁹₈③⑸⒋➃㈤㊄]",wordList.toString());忽略繁简体finalStringtext="我爱我的祖国和五星紅旗。";List&lt;String&gt;wordList=SensitiveWordHelper.findAll(text);Assert.assertEquals("[五星紅旗]",wordList.toString());忽略英文的书写格式finalStringtext="Ⓕⓤc⒦ the bad words";List&lt;String&gt;wordList=SensitiveWordHelper.findAll(text);Assert.assertEquals("[Ⓕⓤc⒦]",wordList.toString());忽略重复词finalStringtext="ⒻⒻⒻfⓤuⓤ⒰cⓒ⒦ the bad words";List&lt;String&gt;wordList=SensitiveWordBs.newInstance().ignoreRepeat(true).init().findAll(text);Assert.assertEquals("[ⒻⒻⒻfⓤuⓤ⒰cⓒ⒦]",wordList.toString());更多策略检测邮箱检测邮箱等个人信息，默认未启用。finalStringtext="楼主好人，邮箱 sensitiveword@xx.com";List&lt;String&gt;wordList=SensitiveWordBs.newInstance().enableEmailCheck(true).init().findAll(text);Assert.assertEquals("[sensitiveword@xx.com]",wordList.toString());连续数字检测一般用于过滤手机号/QQ等广告信息，默认未启用。V0.2.1 之后，支持通过 numCheckLen(长度) 自定义检测的长度。finalStringtext="你懂得：12345678";// 默认检测 8 位List&lt;String&gt;wordList=SensitiveWordBs.newInstance().enableNumCheck(true).init().findAll(text);Assert.assertEquals("[12345678]",wordList.toString());// 指定数字的长度，避免误杀List&lt;String&gt;wordList2=SensitiveWordBs.newInstance().enableNumCheck(true).numCheckLen(9).init().findAll(text);Assert.assertEquals("[]",wordList2.toString());网址检测用于过滤常见的网址信息，默认未启用。finalStringtext="点击链接 https://www.baidu.com 查看答案";finalSensitiveWordBssensitiveWordBs=SensitiveWordBs.newInstance().enableUrlCheck(true).init();List&lt;String&gt;wordList=sensitiveWordBs.findAll(text);Assert.assertEquals("[https://www.baidu.com]",wordList.toString());Assert.assertEquals("点击链接 ********************* 查看答案",sensitiveWordBs.replace(text));IPV4 检测避免用户通过 ip 绕过网址检测等，默认未启用。finalStringtext="个人网站，如果网址打不开可以访问 127.0.0.1。";finalSensitiveWordBssensitiveWordBs=SensitiveWordBs.newInstance().enableIpv4Check(true).init();List&lt;String&gt;wordList=sensitiveWordBs.findAll(text);Assert.assertEquals("[127.0.0.1]",wordList.toString());引导类特性配置为了让使用更加优雅，统一使用 fluent-api 的方式定义。用户可以使用 SensitiveWordBs 进行如下定义：注意：配置后，要使用我们新定义的 SensitiveWordBs 的对象，而不是以前的工具方法。工具方法配置都是默认的。SensitiveWordBswordBs=SensitiveWordBs.newInstance().ignoreCase(true).ignoreWidth(true).ignoreNumStyle(true).ignoreChineseStyle(true).ignoreEnglishStyle(true).ignoreRepeat(false).enableNumCheck(false).enableEmailCheck(false).enableUrlCheck(false).enableIpv4Check(false).enableWordCheck(true).numCheckLen(8).wordTag(WordTags.none()).charIgnore(SensitiveWordCharIgnores.defaults()).wordResultCondition(WordResultConditions.alwaysTrue()).init();finalStringtext="五星红旗迎风飘扬，毛主席的画像屹立在天安门前。";Assert.assertTrue(wordBs.contains(text));配置说明：总结更多内容，比如如何自定因黑白名单以及敏感词标签设置等，参考官方文档：https://github.com/houbb/sensitive-wordhttp://www.ppmy.cn/news/1540946.html相关文章Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语最近&amp;#xff0c;Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli&amp;#xff0c;他认为 Meta 正在混淆用户的理解&amp;#xff0c;并对 “开源” 这一术语造成了污染。 Maffulli 指出&amp;a…阅读更多...ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:16 +0000</pubDate>
    </item>
    <item>
      <title>Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语</title>
      <link>https://www.ppmy.cn/news/1540945.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维Meta因称其AI模型Llama为“开源” 遭炮轰，被指“污染” 开源术语news/2025/11/1 0:23:15/最近，Meta 公司因将其人工智能模型称为 “开源” 而遭到了猛烈的批评。这一指控来自于开源倡导组织 Open Source Initiative 的负责人 Stefano Maffulli，他认为 Meta 正在混淆用户的理解，并对 “开源” 这一术语造成了污染。Maffulli 指出，Meta 的 Llama 大型语言模型并未达到真正的开源标准，这在当今欧盟等机构正在努力支持真正开源技术的背景显得尤为有害。Meta 的 Llama 模型被下载次数已超过4亿次，成为了当前众多所谓 “开源” AI 模型中最受欢迎的一款。尽管如此，Meta 的模型并没有完全开放，限制了用户进行实验和适应性开发的能力。Maffulli 强调，如果公司像 Meta 这样模糊不清地使用 “开源” 这个词，可能会阻碍由用户驱动的 AI 长期发展。虽然 Meta 坚持表示其对开源 AI 的承诺，并称 Llama 是全球 AI 的基石，但其开放程度仍然有限。Meta 仅允许开发者免费下载 Llama 模型，但实际上只提供了模型的权重信息，而未披露如何开发这些模型的详细技术数据。此外，Llama 的许可证并不符合 OSU 认定开源标准，因为它限制了 Meta 竞争对手的自由使用。一些其他技术公司也开始称这类模型为 “开放权重”（open weight），不是开源。艾伦人工智能研究所的负责人 Ali Farhadi 表示，虽然开放权重模型很有价值，但这仍然不足以支持开发者进行深入开发。开发无法看到这些模型的开发过程，也无法在其基础上创建新产品，这与开源软件的优势形成了鲜明对比。Maff 透露，OSI 计划在下周正式发布对开源 AI 的定义，要求模型开发者提供更多的透明度，除了模型的权重外，还需公开训练算法及其他开发软件的信息，OSI 也呼吁 AI 公司发布训练模型所用的数据，尽管出于隐私和法律原因，有时这并不现实。Maffulli 警告说，如果像 Meta 这样的公司成功地将 “开源” 变成一个 “通用术语”，那么他们就能在欧盟及其他机构推动真正开放的技术标准中，加入那些有利于自身营收的专利，从而影响行业的公平竞争。http://www.ppmy.cn/news/1540945.html相关文章ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境详细介绍如何在 Ubuntu 22.04 桌面系统上搭建 ESP-IDF 的开发环境&amp;#xff0c;并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。 目录 
环境准备 1.1 更新系统1.2 安装必要的工具和依赖项 安装 ESP-IDF 2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本 …阅读更多...安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:15 +0000</pubDate>
    </item>
    <item>
      <title>ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境</title>
      <link>https://www.ppmy.cn/news/1540944.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维ubuntu22.04 桌面系统怎么搭建一个esp-idf的项目，搭建开发环境news/2025/11/1 0:23:14/详细介绍如何在Ubuntu 22.04桌面系统上搭建ESP-IDF的开发环境，并创建一个 ESP-IDF 项目。以下内容将涵盖从环境准备到项目创建和编译的所有步骤。目录环境准备1.1 更新系统1.2 安装必要的工具和依赖项安装 ESP-IDF2.1 克隆 ESP-IDF 仓库2.2 运行安装脚本设置环境变量3.1 临时设置环境变量3.2 永久添加到 .bashrc创建 ESP-IDF 项目4.1 使用示例项目4.2 创建新项目编译、烧录和监视项目5.1 编译项目5.2 烧录固件5.3 监视串口输出使用 VSCode 进行开发（可选）6.1 安装 VSCode6.2 安装 ESP-IDF 扩展常见问题与故障排除总结1. 环境准备在开始之前，确保您的 Ubuntu 系统已更新，并安装了必要的工具。1.1 更新系统打开终端，运行以下命令更新系统软件包：sudoaptupdatesudoaptupgrade -y1.2 安装必要的工具和依赖项ESP-IDF 需要一些依赖库和工具，请按以下步骤安装：sudoaptinstallgitwgetflex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 -ygit：用于克隆 ESP-IDF 仓库。python3：ESP-IDF 使用 Python 3。cmake和ninja-build：用于构建项目。libusb-1.0-0和dfu-util：用于与 ESP32 设备通信。2. 安装 ESP-IDFESP-IDF 是 Espressif 提供的官方开发框架，支持 ESP32 系列芯片。2.1 克隆 ESP-IDF 仓库首先，选择一个目录用于存放 ESP-IDF，例如~/esp：mkdir-p ~/espcd~/esp然后，克隆 ESP-IDF 仓库（以 release/v5.0 分支为例，您也可以选择其他版本）：gitclone -b release/v5.0 --recursive https://github.com/espressif/esp-idf.git注意：--recursive参数用于克隆子模块。2.2 运行安装脚本ESP-IDF 提供了安装脚本，可自动安装所需的工具链和 Python 包。cd~/esp/esp-idf
./install.sh allall参数表示安装所有支持的工具链，包括 ESP32、ESP32-S2、ESP32-S3、ESP32-C3 等。安装过程可能需要一段时间，取决于网络速度。3. 设置环境变量在每次使用 ESP-IDF 前，需要设置环境变量，确保系统能够找到 ESP-IDF 工具。3.1 临时设置环境变量您可以运行以下命令，临时设置环境变量：.$HOME/esp/esp-idf/export.sh或者：source$HOME/esp/esp-idf/export.sh这将在当前终端会话中生效。3.2 永久添加到 .bashrc为了避免每次都手动设置，可以将上述命令添加到~/.bashrc文件中：echo'.$HOME/esp/esp-idf/export.sh'&gt;&gt;~/.bashrc然后，重新加载~/.bashrc：source~/.bashrc这样，每次打开新的终端时，环境变量都会自动设置。4. 创建 ESP-IDF 项目您可以使用 ESP-IDF 提供的示例项目，或者创建一个新的项目。4.1 使用示例项目ESP-IDF 包含丰富的示例，可以直接使用。cd~/espcp-r$IDF_PATH/examples/get-started/hello_world.cdhello_world$IDF_PATH：环境变量，指向 ESP-IDF 的安装目录。4.2 创建新项目您也可以从头创建一个新的项目：cd~/esp
idf.py create-project my_projectcdmy_project这将创建一个名为my_project的新项目，包含基本的项目结构。5. 编译、烧录和监视项目接下来，我们将编译项目、烧录到设备，并监视串口输出。5.1 编译项目确保已经设置了环境变量，进入项目目录，运行：idf.py build这将编译项目，生成固件。可能的错误与解决方法缺少环境变量：如果收到idf.py: command not found，请确保已正确设置环境变量，或者重新运行source ~/esp/esp-idf/export.sh。5.2 烧录固件将 ESP32 开发板通过 USB 连接到电脑，运行以下命令烧录固件：idf.py -p /dev/ttyUSB0 flash-p参数指定串口设备，请将/dev/ttyUSB0替换为实际的设备名称，可以使用ls /dev/ttyUSB*查看。识别串口设备如果不确定设备名称，可以运行：ls/dev/ttyUSB*或者：dmesg|grepttyUSB5.3 监视串口输出您可以使用以下命令监视串口输出，查看设备的日志信息：idf.py -p /dev/ttyUSB0 monitor提示：您也可以将flash和monitor命令合并：idf.py -p /dev/ttyUSB0 flash monitor按Ctrl+]可以退出监视器。6. 使用 VSCode 进行开发（可选）为了提高开发效率，您可以在 Visual Studio Code（VSCode）中进行开发。6.1 安装 VSCode如果尚未安装 VSCode，可以使用以下命令安装：sudosnapinstall--classic code或者从 VSCode 官网下载并安装。6.2 安装 ESP-IDF 扩展打开 VSCode，点击左侧的扩展（Extensions）图标。搜索ESP-IDF，安装由 Espressif Systems 提供的官方扩展。安装完成后，按照扩展的指引，配置 ESP-IDF 的路径和 Python 环境。在 VSCode 中打开您的项目，即可进行开发、编译、烧录和监视。7. 常见问题与故障排除问题 1：无法连接到开发板症状：运行idf.py flash时，出现连接错误。解决方法：检查串口设备名称是否正确。确保开发板已正确连接，并未被其他程序占用。尝试按下开发板的BOOT或EN按钮，再次尝试烧录。问题 2：idf.py命令找不到症状：终端提示idf.py: command not found。解决方法：确保已运行source ~/esp/esp-idf/export.sh。检查~/.bashrc中是否正确添加了环境变量。问题 3：Python 包版本冲突症状：编译时出现 Python 包版本错误。解决方法：使用 ESP-IDF 提供的 Python 虚拟环境，确保依赖包的版本正确。不要在系统的 Python 环境中安装或升级与 ESP-IDF 相关的包。8. 总结通过以上步骤，您已经在 Ubuntu 22.04 桌面系统上成功搭建了 ESP-IDF 的开发环境，并学会了如何创建、编译和烧录 ESP-IDF 项目。关键点：环境准备：安装必要的工具和依赖项。安装 ESP-IDF：克隆仓库并运行安装脚本。设置环境变量：确保 ESP-IDF 工具可用。项目创建与编译：使用idf.py命令进行项目管理。建议：熟悉 ESP-IDF 文档：ESP-IDF 官方文档提供了丰富的资源和示例，可以帮助您深入了解。使用版本控制：建议使用 Git 管理您的项目代码，方便协作和版本管理。定期更新 ESP-IDF：Espressif 会定期发布更新，包含新功能和修复。参考资源：ESP-IDF 编程指南ESP-IDF 示例项目http://www.ppmy.cn/news/1540944.html相关文章安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现在生产作业过程中&amp;#xff0c;员工玩手机是一种极其危险的行为。它会分散员工的注意力&amp;#xff0c;使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素&amp;#xff0c;如机械设备的运转、高空作业、化学品的使用等&amp;#xff0c;一旦员工分心&amp;#xff0c;就很容易忽视这些…阅读更多...《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:14 +0000</pubDate>
    </item>
    <item>
      <title>安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现</title>
      <link>https://www.ppmy.cn/news/1540943.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维安全生产玩手机检测系统 玩手机识别系统 玩手机监测预警系统 使用 Python 和 OpenCV 库实现news/2025/11/1 0:23:12/在生产作业过程中，员工玩手机是一种极其危险的行为。它会分散员工的注意力，使其无法专注于工作任务。生产现场往往存在各种潜在的危险因素，如机械设备的运转、高空作业、化学品的使用等，一旦员工分心，就很容易忽视这些危险，从而导致意外事故的发生。玩手机会降低工作效率，延长生产周期，增加企业的成本。此外，当员工沉迷于手机时，还可能会出现操作失误，对产品质量造成严重影响，甚至损坏生产设备，给企业带来不可估量的损失。玩手机识别系统的技术原理与特点玩手机识别系统基于先进的计算机视觉和人工智能技术。它通过摄像头采集生产现场的图像或视频信息，然后利用深度学习算法对这些数据进行分析和处理。该系统能够准确识别出员工是否在使用手机，其识别的依据包括手机的外形特征、屏幕的发光模式以及员工手持手机的姿势等。与传统的监控系统相比，玩手机识别系统具有更高的准确性和智能化程度。它可以在复杂的环境中快速准确地识别出玩手机的行为，不受光线、角度等因素的影响。同时，该系统还具备自学习能力，能够不断优化识别算法，提高识别精度。此外，它还可以对多个区域进行同时监测，实现全方位的覆盖，大大提高了监控效率。玩手机监测预警系统的功能与作用玩手机监测预警系统是安全生产玩手机检测系统的重要组成部分。当系统检测到员工玩手机的行为时，会立即发出预警信号。预警方式多种多样，如声光报警、短信通知、系统弹窗等，以便相关管理人员能够及时采取措施。该系统的作用不仅在于及时发现问题，还在于预防事故的发生。通过实时监测和预警，它可以对员工起到警示作用，促使员工自觉遵守安全生产规定，减少玩手机的行为。同时，管理人员可以根据预警信息，迅速找到违规员工，进行批评教育或采取相应的处罚措施，从而维护生产现场的秩序和安全。玩手机监测预警系统还可以对监测数据进行存储和分析。通过对历史数据的统计和分析，企业可以了解员工玩手机行为的发生频率、高发区域和时间段等信息，为制定针对性的安全管理措施提供依据。例如，企业可以根据数据分析结果，合理安排工作任务和休息时间，避免员工因疲劳或无聊而玩手机。import cv2
import numpy as npdef detect_phone_use(frame):# 将图像转换为灰度图gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)# 使用高斯模糊减少噪声blurred = cv2.GaussianBlur(gray, (5, 5), 0)# 使用边缘检测算法edges = cv2.Canny(blurred, 50, 150)# 查找轮廓contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)phone_detected = Falsefor contour in contours:# 假设手机的轮廓近似为矩形perimeter = cv2.arcLength(contour, True)approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)if len(approx) == 4:phone_detected = Truebreakreturn phone_detected# 打开摄像头
cap = cv2.VideoCapture(0)while True:ret, frame = cap.read()if not ret:breakphone_use_detected = detect_phone_use(frame)if phone_use_detected:cv2.putText(frame, "Phone Detected", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)else:cv2.putText(frame, "No Phone Detected", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)cv2.imshow('Phone Detection', frame)if cv2.waitKey(1) &amp; 0xFF == ord('q'):breakcap.release()
cv2.destroyAllWindows()安全生产玩手机检测系统的应用场景安全生产玩手机检测系统广泛应用于各种生产场所。在制造业工厂中，它可以监测生产线上的工人是否在操作设备时玩手机，确保生产过程的安全和稳定。在建筑工地，它可以防止工人在高处作业或操作重型机械时因玩手机而发生意外。在化工企业，它可以避免员工在接触危险化学品时因分心而导致事故。该系统还适用于交通运输、能源开采等行业。在交通运输领域，如港口、车站等，它可以监测工作人员是否在工作期间玩手机，保障运输作业的顺利进行。在能源开采行业，如煤矿、油田等，它可以确保工人在井下或井口等危险区域不玩手机，降低安全风险。http://www.ppmy.cn/news/1540943.html相关文章《深度学习》模型的部署、web框架 服务端及客户端案例目录 
一、模型的部署 
1、模型部署的定义与目的 
1&amp;#xff09;定义 
2&amp;#xff09;目的 
2、模型部署的步骤 
1&amp;#xff09;导出模型 
2&amp;#xff09; 部署模型 
3&amp;#xff09;测试模型 
4&amp;#xff09;监控模型 
3、模型部署的方式 
1&amp;#xff09;云端部署 
2&amp;#xff09;嵌入…阅读更多...【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:12 +0000</pubDate>
    </item>
    <item>
      <title>《深度学习》模型的部署、web框架 服务端及客户端案例</title>
      <link>https://www.ppmy.cn/news/1540942.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维《深度学习》模型的部署、web框架 服务端及客户端案例news/2025/11/1 0:23:10/目录一、模型的部署1、模型部署的定义与目的1）定义2）目的2、模型部署的步骤1）导出模型2） 部署模型3）测试模型4）监控模型3、模型部署的方式1）云端部署2）嵌入式设备部署3）边缘计算部署4）移动端部署5）FPGA和GPU部署二、web框架对比1、Django1）优点2）缺点2、Pyramid1）优点2）缺点3、Flask1）优点2）缺点三、案例实现1、创建客户端运行结果：2、创建一个服务端运行状态：3、运行方法一、模型的部署1、模型部署的定义与目的1）定义模型部署是指将训练好的机器学习模型或深度学习模型运行在专属的计算资源上，使模型在独立的运行环境中高效、可靠地运行，并为业务应用提供推理服务。2）目的将模型应用于实际业务中，使最终用户或系统能够利用模型的输出，从而发挥其作用。部署模型的目的是将模型应用到实际问题中，以实现预测、分类、推荐等任务，并为用户或业务提供实时的决策支持。以及将模型尽可能有效地集成到实际系统中，并确保其能够高效地运行，满足实际业务需求。2、模型部署的步骤1）导出模型将训练好的模型导出为可部署的格式2） 部署模型将导出的模型部署到生产环境中，通常是以一个服务或一个库的形式。3）测试模型在生产环境中对模型进行测试，以确保其能够正常工作，并且输出结果符合预期。4）监控模型在生产环境中对模型进行监控，以便及时发现并解决问题。3、模型部署的方式1）云端部署将模型部署到云端服务器上，通过API接口提供服务，实现远程调用。这种方式可以实现大规模的分布式计算和存储，同时提供高可用性和可扩展性。在云端部署中，需要考虑数据的安全性和隐私保护，以及模型的并发处理能力。2）嵌入式设备部署将模型部署到嵌入式设备中，如智能手机、智能音箱、智能家居等。这种方式可以实现本地化的智能化应用，具有实时性、低延迟的优点。在嵌入式设备部署中，需要考虑设备的计算能力、存储空间等限制，以及模型的轻量化设计。3）边缘计算部署将模型部署到边缘设备上，如路由器、摄像头等。这种方式可以实现本地数据的实时处理和智能化分析，减少数据传输的延迟和成本。在边缘计算部署中，需要考虑设备的计算能力和数据处理能力，以及模型的实时性要求。4）移动端部署将模型部署到移动端设备上，如智能手机、平板电脑等。这种方式可以实现移动设备的智能化应用，提高用户体验。在移动端部署中，需要考虑设备的功耗和性能限制，以及模型的轻量化设计。5）FPGA和GPU部署FPGA（Field-Programmable Gate Array）部署是将深度学习模型部署到FPGA芯片上，实现高效的硬件加速，提高模型的运行速度和效率。GPU（Graphics Processing Unit）部署是将深度学习模型部署到GPU上，利用GPU的并行计算能力，提高模型的运行速度和效率。这两种方式适用于对计算性能要求较高的场景，如实时图像处理、视频分析等。二、web框架对比1、Django1）优点功能全面：Django是一个“全包式”的框架，提供了丰富的内置功能，如ORM（对象关系映射）、用户认证、内容管理等，非常适合快速开发。文档完善：Django的官方文档非常详细，易于理解，对于新手来说非常友好。 社区支持强大：Django拥有一个庞大的社区和大量的第三方包可供选择，这使得开发者能够轻松地找到解决方案和支持。安全性高：Django具有集成的安全功能，如防止跨站请求伪造（CSRF）和SQL注入攻击的机制，能够最大程度地保护系统的安全性。2）缺点学习曲线较陡：对于初学者来说，Django提供的功能可能会显得过于复杂，需要一定的时间去学习和掌握。 灵活性较低：由于Django的全包式设计，它在一些情况下可能不如其他框架灵活。性能问题：在处理高负载应用程序时，Django的性能可能不如一些轻量级的框架。2、Pyramid1）优点灵活性和可扩展性：Pyramid的设计哲学是“尽可能少地强制开发人员做出选择”，它提供了一组基本的工具和功能，但允许开发人员根据项目需求选择使用的组件和库。 高性能：Pyramid在设计上注重性能，采用了一些优化技术，如延迟加载和缓存机制，以提供快速响应和高并发处理能力。适用于大型应用程序：由于Pyramid的灵活性和可扩展性，它非常适合构建大型和复杂的Web应用程序。2）缺点社区及资源相对较少：与Django和Flask相比，Pyramid的社区和第三方资源可能较少学习曲线：虽然Pyramid提供了灵活的选择，但对于初学者来说，可能需要更多的时间来理解和选择适合项目的组件和库。3、Flask1）优点轻量级：Flask是一个轻量级的框架，代码量少，灵活性高，适合快速开发小型应用程序。简单易学：Flask的设计理念简洁明了，入门相对容易，对于初学者来说非常友好。可扩展性强：Flask提供了丰富的扩展库，开发者可以根据需求选择合适的扩展来扩展功能。社区支持良好：Flask有一个庞大的社区，提供了丰富的资源和支持。2）缺点功能相对较少：相比于一些大型框架如Django，Flask的功能相对较少，需要依赖扩展库来实现一些功能。安全性考虑：由于Flask的轻量级特性，安全性方面的考虑需要开发者自行关注。不适合大型应用：由于Flask的轻量级特性，它可能不适合开发大型复杂的应用程序。 综上所述，Django、Pyramid和Flask各有其优缺点，选择哪个框架取决于项目的具体需求、开发者的偏好和经验水平。三、案例实现1、创建客户端创建一个py文件flask_predict.py，将代码写入其中import requestsflask_url = 'http://192.168.24.42:5012/predict'   # 设置需要读取的服务器地址def predict_result(image_path):image = open(image_path,'rb').read()payload = {'image':image}r = requests.post(flask_url,files=payload).json()   # 发送post请求，输入当前ip和图片，然后返回的结果转化为json大字符串类型# print(r)if r['success']:for (i,result) in enumerate(r['predictions']):print("{}.预测类别为{}：的概率：{}".format(i+1,result['label'],result['probability']))else:print("request failed")if __name__ == '__main__':# predict_result('./flower_data/val_filelist/image_00028.jpg')predict_result('train/6/image_07168.jpg')运行结果：在服务端代码运行后运行此处代码2、创建一个服务端创建一个py文件flask_server.py，用于将自己电脑当做成一个服务器，别人访问当前服务器ip内的内容，来预测数据import io
import flask
import torch
import torch.nn.functional as F
from PIL import Image
from torch import nn
from torchvision import transforms, models, datasetsapp = flask.Flask(__name__)  # 创建一个新的Flask应用程序实例
# __name__参数通常被传递给Flask应用程序来定位应用程序的根路径，这样FlasK就可以知道在哪里找到模板、静态文件等。
# 总体来说app = flask.Flask(__name_)是Flask应用程序的起点。它初始化了一个新的Flask应用程序实例。为后续添加路由、配置model = None
use_gpu = False# 加载模型进来
def load_model():global modelmodel = models.resnet18()  # 导入残差网络模型18层num_ftrs = model.fc.in_features  # 返回原模型最后一层全连接层的输入特征数量model.fc = nn.Sequential(nn.Linear(num_ftrs,102))  # 替换原模型最后一层，为一个线性层，输出层为102个类别，因为总的类别有102中checkpoints = torch.load('best.pth')   # 加载训练好的模型权重model.load_state_dict(checkpoints['state_dict'])   # 将加载好的权重应用到模型上，model.eval()   # 模型设置为测试模式if use_gpu:  # 如果为Truemodel.cuda()  # 将模型传入GPU# 数据预处理
def prepare_image(image,target_size):  # 输入图像、以及指定尺寸# 针对不同模型，image的格式不同，但需要统一到RGB格式if image.mode != 'RGB':  # 判断图像是不是RGB彩色图image = image.convert('RGB')   # 如果不是，将其转化为RGB格式# 按照所使用的模型将输入图片的尺寸修改，并转为tensorimage = transforms.Resize(target_size)(image)  # 调整图像大小为指定尺寸image = transforms.ToTensor()(image)   # 将图像转化为PyTorch，同时图像像素值变成0-1.0之间# 对图像进行标准化，第一个列表为RGB三通道均值，第二个为标准差image = transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])(image)# 增加一个维度，用于按batch测试image = image[None]if use_gpu:image = image.cuda()return torch.tensor(image)# 是一个装饰器，用于将指定的URL路径(在这个例子中是/predict)与一个函数关联起来，并指定该函数响应的HTTP方法(在这个例子中是POST方注
@app.route('/predict',methods=['POST'])def predict():# 做一个标志，刚开始无图像传入时为false,传入图像时为truedata = {"success":False}if flask.request.method == "POST":if flask.request.files.get('image'):  # 判断是否为图像image = flask.request.files["image"].read()  # 将收到的图像进行读取，内容为二进制image = Image.open(io.BytesIO(image))  # io.BytesIO是Python标准库io模块中的一个类，它提供了一个在内存中读写bytes的缓冲区,既可以作为二进制数据的输入源（类似于文件），也可以作为输出目标。# 当io.BytesIO(image)被调用时，它创建了一个内存中的二进制流，并将原始的image bytes数据写入这个流中。# 然后，Image.open(io.BytesIO(image))打开这个内存中的二进制流，就像打开一个实际的图像文件一样，并返回一个可用于进一步处理的图像对象。# 利用上面的预处理函数将读入的图像进行预处理image = prepare_image(image, target_size=(224,224))preds = F.softmax(model(image),dim = 1)  # 得到各个类别的概率results = torch.topk(preds.cpu().data,k=3,dim=1) # 概率最大的前3个结果# torch.topk用于返回输入张量中每行最大的k个元素及其对应的索引results = (results[0].cpu().numpy(), results[1].cpu().numpy())# 将data字典增加一个key，value,其中value为ist格式data['predictions'] = list()for prob, label in zip(results[0][0], results[1][0]):# Label name =idx2labellstr(label)]r = {"label": str(label), "probability": float(prob)}# 将预测结果添加至data字典data['predictions'].append(r)# Indicate that the reguest was a success.data["success"] = Truereturn flask.jsonify(data)   # 将最后结果以json格式文件传出if __name__ == '__main__':print("Loading PyTorch model and Flask starting server ...")print('Please wait until server has fully started')load_model()  # 先加载模型# 再开启服务app.run(host='192.168.24.42',port=5012)   # 用自己的电脑，端口号为5012  这个程序。服务器，进入了聆听状态，等待客户发送请求运行状态：此时代码不会终止，处于聆听状态，每当别的客户端访问当前服务端内的代码内容，即会显示对方ip。3、运行方法首先运行flask_server.py文件的代码，使当前电脑的一个ip当做服务端，然后和当前电脑在同一局路由的客户端可以直接运行flask_predict.py文件的代码，注意ip要相同才可以使用。http://www.ppmy.cn/news/1540942.html相关文章【SpringCloud】03-Gateway网关1. Gateway 
网关&amp;#xff1a;负责请求的路由、转发、身份校验。  
2. Spring Cloud Gateway 依赖 
&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/de…阅读更多...深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:11 +0000</pubDate>
    </item>
    <item>
      <title>【SpringCloud】03-Gateway网关</title>
      <link>https://www.ppmy.cn/news/1540941.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维【SpringCloud】03-Gateway网关news/2025/11/1 0:23:09/1. Gateway网关：负责请求的路由、转发、身份校验。2. Spring Cloud Gateway依赖&lt;!--网关--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos 服务注册发现--&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--openFeign--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--负载均衡器--&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--OK http 的依赖--&gt;&lt;dependency&gt;&lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;&lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt;yaml配置server:port:8080spring:cloud:nacos:server-addr:***:8848gateway:routes:-id:item-serviceuri:lb://item-servicepredicates:-Path=/items/**,/search/**- id: cart-serviceuri: lb://cart-servicepredicates:- Path=/carts/**- id: user-serviceuri: lb://user-servicepredicates:- Path=/users/**,/addresses/**- id: trade-serviceuri: lb://trade-servicepredicates:- Path=/orders/**application:name: gateway3. 断言4. 过滤器spring:cloud:nacos:server-addr:***:8848gateway:routes:-id:item-serviceuri:lb://item-servicepredicates:-Path=/items/**,/search/**filters:- AddRequestHeader=truth, no one- id: cart-serviceuri: lb://cart-servicepredicates:- Path=/carts/**- id: user-serviceuri: lb://user-servicepredicates:- Path=/users/**,/addresses/**- id: trade-serviceuri: lb://trade-servicepredicates:- Path=/orders/**default-filters:- AddRequestHeader=truth, no onehttp://www.ppmy.cn/news/1540941.html相关文章深入理解 Kafka一、引言 在当今的大数据和分布式系统时代&amp;#xff0c;高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统&amp;#xff0c;在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以…阅读更多...python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:09 +0000</pubDate>
    </item>
    <item>
      <title>深入理解 Kafka</title>
      <link>https://www.ppmy.cn/news/1540940.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维深入理解 Kafkanews/2025/11/1 0:23:08/一、引言在当今的大数据和分布式系统时代，高效的消息传递和处理是构建可靠、可扩展应用的关键。Apache Kafka 作为一种高吞吐量的分布式发布 - 订阅消息系统，在众多领域中发挥着重要作用。本文将深入探讨 Kafka 的核心概念、架构、工作原理、应用场景以及最佳实践，通过详细的示例帮助读者更好地理解和运用 Kafka。二、Kafka 的核心概念（一）主题（Topic）定义与作用主题是 Kafka 中消息的逻辑分类。生产者将消息发送到特定的主题，消费者从感兴趣的主题中订阅消息。主题可以看作是一个消息的容器，用于组织和管理具有相同类型或用途的消息。例如，在一个电商系统中，可以有订单主题、用户行为主题等，分别用于存储订单相关的消息和用户操作相关的消息。主题的创建与管理在 Kafka 中，可以使用命令行工具或编程方式创建主题。主题的管理包括修改主题的配置参数（如分区数量、副本因子等）、删除主题等操作。例如，使用以下命令可以创建一个名为 “my_topic” 的主题：bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic my_topic（二）分区（Partition）定义与作用分区是主题的物理划分。每个主题可以被分为一个或多个分区，每个分区都是一个有序的、不可变的消息序列。分区的主要作用是实现水平扩展，提高 Kafka 的吞吐量和可扩展性。例如，一个主题可以被分为多个分区，每个分区可以存储在不同的服务器上，这样可以并行地处理消息，提高系统的吞吐量。分区的分配与副本Kafka 会自动将分区分配到不同的 broker 上，以实现负载均衡。每个分区可以有多个副本，副本的作用是提高数据的可靠性和可用性。当主分区（leader partition）出现故障时，副本分区（follower partition）可以自动切换为主分区，继续提供服务。例如，一个分区可以有一个主副本和两个从副本，主副本负责处理读写请求，从副本同步主副本的数据。当主副本出现故障时，Kafka 会自动从从副本中选举一个新的主副本。（三）生产者（Producer）定义与作用生产者是向 Kafka 主题发送消息的客户端。生产者可以将消息发送到一个或多个主题，并可以指定消息的键和值。生产者的主要作用是将应用程序产生的消息发送到 Kafka 中，供消费者进行消费。例如，在一个电商系统中，订单服务可以作为生产者，将订单创建的消息发送到订单主题中。生产者的配置与优化生产者可以通过配置参数来调整发送消息的行为，如消息的压缩方式、发送消息的批次大小、发送消息的重试次数等。合理地配置生产者参数可以提高消息的发送效率和可靠性。例如，可以将生产者的消息压缩方式设置为 “gzip”，以减少网络传输的开销；可以将发送消息的批次大小设置为合适的值，以提高消息的发送效率。（四）消费者（Consumer）定义与作用消费者是从 Kafka 主题订阅消息的客户端。消费者可以从一个或多个主题中读取消息，并可以按照自己的需求进行处理。消费者的主要作用是从 Kafka 中读取消息，并将消息传递给应用程序进行处理。例如，在一个电商系统中，数据分析服务可以作为消费者，从用户行为主题中读取消息，进行数据分析和处理。消费者的组（Consumer Group）消费者可以组成消费者组，共同从一个主题中读取消息。每个消费者组可以有一个或多个消费者，每个消费者可以订阅一个或多个主题。消费者组的作用是实现消息的负载均衡和容错处理。例如，一个消费者组可以有多个消费者，每个消费者可以从不同的分区中读取消息，这样可以提高消息的读取效率。当一个消费者出现故障时，其他消费者可以自动接管其分区的读取任务，保证消息的持续处理。（五）偏移量（Offset）定义与作用偏移量是消费者在分区中读取消息的位置。每个分区都有一个独立的偏移量，消费者可以通过偏移量来记录自己已经读取的消息位置，以便下次继续从该位置开始读取消息。例如，消费者在读取一个分区中的消息时，会不断地更新偏移量，以记录自己已经读取的消息位置。当消费者重新启动时，可以从上次保存的偏移量开始继续读取消息。偏移量的管理Kafka 提供了多种方式来管理偏移量，如自动提交偏移量、手动提交偏移量等。自动提交偏移量是指 Kafka 自动定期地将消费者的偏移量提交到 broker 上，以保证消费者在出现故障时能够从上次提交的偏移量开始继续读取消息。手动提交偏移量是指消费者自己控制偏移量的提交时机，可以更加灵活地处理消息的消费和偏移量的管理。例如，可以在消费者的配置中设置自动提交偏移量的时间间隔，也可以在代码中手动调用提交偏移量的方法，以实现更加精细的偏移量管理。三、Kafka 的架构与工作原理（一）Kafka 的架构组成BrokerBroker 是 Kafka 的服务器节点，负责存储和管理消息。每个 Broker 可以存储多个主题的分区，并且可以接收生产者发送的消息和向消费者提供消息。例如，一个 Kafka 集群可以由多个 Broker 组成，每个 Broker 可以存储不同主题的分区，以实现高可用性和可扩展性。ZookeeperZookeeper 是一个分布式协调服务，用于管理 Kafka 集群的元数据。Zookeeper 存储了 Kafka 集群的配置信息、主题的分区信息、消费者组的信息等。Kafka 依赖 Zookeeper 来实现集群的高可用性、自动故障转移等功能。例如，当一个 Broker 出现故障时，Zookeeper 会通知其他 Broker 进行故障转移，以保证 Kafka 集群的正常运行。（二）Kafka 的工作原理消息的生产与发送生产者将消息发送到 Kafka 集群时，首先会根据消息的主题和分区策略确定要发送到哪个分区。然后，生产者将消息序列化后发送到对应的 Broker 上。Broker 接收到消息后，将消息存储到对应的分区中，并返回一个确认消息给生产者，表示消息已经成功接收。例如，生产者可以根据消息的键值对来确定消息要发送到哪个分区，也可以使用轮询等分区策略来平均分配消息到不同的分区中。消息的存储与管理Broker 接收到消息后，将消息存储到磁盘上的日志文件中。每个分区都有一个独立的日志文件，用于存储该分区的消息。Broker 会定期地将日志文件中的消息进行清理和压缩，以减少磁盘空间的占用。例如，Broker 可以根据配置的保留时间和大小限制来清理过期的消息；可以使用压缩算法对日志文件进行压缩，以减少磁盘空间的占用。消息的消费与读取消费者从 Kafka 集群中订阅感兴趣的主题，并从对应的分区中读取消息。消费者可以根据自己的需求选择自动提交偏移量或手动提交偏移量。消费者在读取消息时，可以从上次保存的偏移量开始读取，也可以从指定的偏移量开始读取。例如，消费者可以使用 “earliest”、“latest” 等参数来指定从哪个偏移量开始读取消息；可以在代码中手动调用提交偏移量的方法，以实现更加精细的偏移量管理。四、Kafka 的应用场景（一）日志收集与处理日志收集Kafka 可以作为日志收集系统的核心组件，用于收集和存储各种应用程序的日志数据。应用程序可以将日志数据发送到 Kafka 主题中，然后由专门的日志处理服务从 Kafka 中读取日志数据进行处理和分析。例如，在一个分布式系统中，各个服务可以将自己的日志数据发送到 Kafka 主题中，然后由一个集中的日志处理服务从 Kafka 中读取日志数据，进行实时监控、故障排查等操作。日志处理与分析Kafka 可以与其他大数据处理工具（如 Flink、Spark）结合使用，实现对日志数据的实时处理和分析。通过对日志数据的分析，可以提取有价值的信息，如用户行为分析、系统性能监控等。例如，可以使用 Flink 从 Kafka 中读取日志数据，进行实时的数据分析和处理，然后将结果存储到数据库或其他存储系统中，供后续的查询和分析使用。（二）消息队列与异步通信消息队列Kafka 可以作为传统的消息队列系统，用于实现应用程序之间的异步通信。生产者将消息发送到 Kafka 主题中，消费者从主题中订阅消息并进行处理，从而实现应用程序之间的解耦和异步通信。例如，在一个电商系统中，订单服务可以将订单创建的消息发送到 Kafka 主题中，然后由库存服务、物流服务等消费者从主题中订阅消息并进行相应的处理，实现订单处理的异步化和分布式化。异步通信与事件驱动架构Kafka 可以与事件驱动架构结合使用，实现应用程序的异步通信和事件驱动处理。应用程序可以将事件发送到 Kafka 主题中，其他应用程序可以从主题中订阅事件并进行相应的处理，从而实现应用程序之间的松散耦合和高效协作。例如，在一个微服务架构中，各个微服务可以将自己的事件发送到 Kafka 主题中，其他微服务可以从主题中订阅事件并进行相应的处理，实现微服务之间的异步通信和事件驱动处理。（三）流处理与实时数据分析流处理Kafka 可以作为流处理系统的数据源和数据存储，与流处理框架（如 Flink、Spark Streaming）结合使用，实现对实时数据流的处理和分析。通过对实时数据流的处理，可以实现实时监控、实时预警、实时推荐等功能。例如，可以使用 Flink 从 Kafka 中读取实时数据流，进行实时的数据分析和处理，然后将结果输出到其他系统或存储中，供实时决策和业务应用使用。实时数据分析Kafka 可以与实时数据分析工具（如 Kibana、Grafana）结合使用，实现对实时数据的可视化分析和监控。通过对实时数据的分析和监控，可以及时发现问题、优化业务流程、提高系统性能。例如，可以使用 Kibana 从 Kafka 中读取实时数据，进行实时的可视化分析和监控，然后将结果展示在仪表盘上，供业务人员和运维人员进行实时决策和监控使用。五、Kafka 的配置与优化（一）Broker 配置内存配置Broker 需要足够的内存来存储和处理消息。可以根据实际的业务需求和硬件资源来调整 Broker 的内存配置，以提高 Broker 的性能和稳定性。例如，可以调整 Broker 的堆内存大小、文件缓存大小等参数，以适应不同的负载情况。网络配置Broker 的网络配置也非常重要，需要根据实际的网络环境和业务需求来调整网络参数，以提高 Broker 的网络性能和吞吐量。例如，可以调整 Broker 的网络缓冲区大小、连接超时时间等参数，以适应不同的网络环境和负载情况。存储配置Broker 的存储配置直接影响到消息的存储和读取性能。可以根据实际的存储需求和硬件资源来调整存储参数，以提高 Broker 的存储性能和可靠性。例如，可以调整 Broker 的日志文件大小、保留时间、压缩算法等参数，以适应不同的存储需求和负载情况。（二）生产者配置消息压缩生产者可以对发送的消息进行压缩，以减少网络传输的开销和存储成本。可以根据实际的业务需求和网络环境来选择合适的压缩算法，如 “gzip”、“snappy”、“lz4” 等。例如，可以在生产者的配置中设置消息的压缩算法为 “gzip”，以减少网络传输的开销和存储成本。批次大小与发送频率生产者可以将多个消息打包成一个批次进行发送，以提高消息的发送效率。可以根据实际的业务需求和网络环境来调整批次大小和发送频率，以平衡消息的发送效率和延迟。例如，可以将批次大小设置为合适的值，以提高消息的发送效率；可以调整发送频率，以避免消息的堆积和延迟。重试次数与超时时间生产者在发送消息时可能会遇到网络故障等问题，导致消息发送失败。可以设置重试次数和超时时间，以确保消息能够成功发送。例如，可以设置重试次数为 3，超时时间为 1000 毫秒，以确保消息能够在一定的时间内成功发送。（三）消费者配置自动提交偏移量与手动提交偏移量消费者可以选择自动提交偏移量或手动提交偏移量。自动提交偏移量可以简化消费者的代码，但可能会导致消息的重复消费或丢失。手动提交偏移量可以更加灵活地控制消息的消费和偏移量的管理，但需要开发者自己处理偏移量的提交逻辑。例如，可以根据实际的业务需求和可靠性要求来选择自动提交偏移量或手动提交偏移量。消费速度与拉取间隔消费者的消费速度和拉取间隔也会影响到消息的处理效率和系统的稳定性。可以根据实际的业务需求和硬件资源来调整消费速度和拉取间隔，以平衡消息的处理效率和系统的负载。例如，可以调整消费者的拉取间隔，以避免频繁地拉取消息导致系统资源的浪费；可以调整消费速度，以适应不同的业务处理需求。消费者组的配置与管理消费者可以组成消费者组，共同从一个主题中读取消息。可以根据实际的业务需求和系统负载来调整消费者组的配置参数，如消费者数量、分区分配策略等，以提高消息的处理效率和系统的可扩展性。例如，可以根据主题的分区数量和消费者的处理能力来调整消费者的数量，以实现负载均衡；可以选择合适的分区分配策略，以确保消费者能够均匀地分配到不同的分区上进行消费。六、Kafka 的实战示例（一）使用 Java 编写生产者和消费者生产者示例import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;import java.util.Properties;public class KafkaProducerExample {public static void main(String[] args) {Properties props = new Properties();props.put("bootstrap.servers", "localhost:9092");props.put("acks", "all");props.put("retries", 0);props.put("batch.size", 16384);props.put("linger.ms", 1);props.put("buffer.memory", 33554432);props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);for (int i = 0; i &lt; 100; i++) {producer.send(new ProducerRecord&lt;&gt;("my_topic", Integer.toString(i), "Message " + i));}producer.close();}
}消费者示例import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;
import java.util.Properties;public class KafkaConsumerExample {public static void main(String[] args) {Properties props = new Properties();props.put("bootstrap.servers", "localhost:9092");props.put("group.id", "my_group");props.put("enable.auto.commit", "true");props.put("auto.commit.interval.ms", "1000");props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);consumer.subscribe(Arrays.asList("my_topic"));while (true) {ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);for (ConsumerRecord&lt;String, String&gt; record : records) {System.out.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());}}}
}（二）使用 Kafka 进行日志收集与处理日志生产者示例import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;import java.util.Properties;public class LogProducer {public static void main(String[] args) {Properties props = new Properties();props.put("bootstrap.servers", "localhost:90props.put("bootstrap.servers", "localhost:9092");props.put("acks", "all");props.put("retries", 0);props.put("batch.size", 16384);props.put("linger.ms", 1);props.put("buffer.memory", 33554432);props.put("key.serializer",         "org.apache.kafka.common.serialization.StringSerializer");
props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);
// 模拟生成日志消息
for (int i = 0; i &lt; 100; i++) {
String logMessage = "Log message" + i + "at" + System.currentTimeMillis ();
producer.send (new ProducerRecord&lt;&gt;("log_topic", logMessage));
}
producer.close();
}
}2. 日志消费者示例```java
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;
import java.util.Properties;public class LogConsumer {public static void main(String[] args) {Properties props = new Properties();props.put("bootstrap.servers", "localhost:9092");props.put("group.id", "log_group");props.put("enable.auto.commit", "true");props.put("auto.commit.interval.ms", "1000");props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);consumer.subscribe(Arrays.asList("log_topic"));while (true) {ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);for (ConsumerRecord&lt;String, String&gt; record : records) {System.out.println("Received log message: " + record.value());}}}
}日志处理服务可以使用其他工具或框架来处理从 Kafka 中读取的日志消息，例如使用 Flink 进行实时日志分析，或者将日志存储到数据库中进行后续的查询和分析。七、Kafka 的高级特性（一）事务支持生产者事务Kafka 支持生产者事务，允许生产者在一个事务中发送多个消息，并且保证这些消息要么全部成功提交，要么全部回滚。生产者事务可以用于保证消息的原子性和一致性，例如在金融交易系统中，确保多个相关的消息要么全部成功发送，要么全部不发送。例如，可以使用 Kafka 的事务 API 来实现生产者事务，在发送消息之前开启事务，发送完所有消息后提交事务，如果在发送过程中出现错误，则回滚事务。消费者事务Kafka 也支持消费者事务，允许消费者在一个事务中处理多个消息，并且保证这些消息要么全部成功处理，要么全部回滚。消费者事务可以用于保证消息的处理顺序和一致性，例如在订单处理系统中，确保多个相关的消息按照正确的顺序被处理，并且在处理过程中出现错误时能够回滚。例如，可以使用 Kafka 的事务 API 来实现消费者事务，在处理消息之前开启事务，处理完所有消息后提交事务，如果在处理过程中出现错误，则回滚事务。（二）Exactly Once 语义定义与作用Exactly Once 语义是指消息在生产者和消费者之间传递时，保证每个消息只被处理一次，不会出现重复处理或丢失的情况。Exactly Once 语义对于一些对数据准确性要求非常高的应用场景非常重要，例如金融交易系统、订单处理系统等。例如，在金融交易系统中，确保每个交易消息只被处理一次，不会出现重复交易或丢失交易的情况。实现方式Kafka 可以通过结合事务支持和幂等性生产者来实现 Exactly Once 语义。幂等性生产者是指生产者在发送消息时，如果遇到网络故障等问题导致消息重复发送，Kafka 能够自动识别并丢弃重复的消息，保证每个消息只被处理一次。例如，可以使用 Kafka 的事务 API 和幂等性生产者来实现 Exactly Once 语义，在生产者发送消息之前开启事务，发送完所有消息后提交事务，如果在发送过程中出现错误，则回滚事务。同时，将生产者设置为幂等性生产者，确保消息不会被重复处理。（三）Kafka Streams简介与作用Kafka Streams 是 Kafka 提供的一个轻量级的流处理库，用于对 Kafka 中的消息进行实时处理和分析。Kafka Streams 可以将 Kafka 作为数据源和数据存储，实现对实时数据流的处理和分析，并且可以与其他 Kafka 组件（如生产者、消费者、主题等）无缝集成。例如，可以使用 Kafka Streams 对 Kafka 中的日志数据进行实时分析，提取有价值的信息，如用户行为分析、系统性能监控等。示例用法以下是一个使用 Kafka Streams 进行单词计数的示例：import org.apache.kafka.streams.KafkaStreams;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.StreamsConfig;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.KTable;import java.util.Properties;public class WordCountExample {public static void main(String[] args) {Properties props = new Properties();props.put(StreamsConfig.APPLICATION_ID_CONFIG, "word-count-app");props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, "org.apache.kafka.common.serialization.Serdes.StringSerde");props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, "org.apache.kafka.common.serialization.Serdes.StringSerde");StreamsBuilder builder = new StreamsBuilder();KStream&lt;String, String&gt; textLines = builder.stream("input-topic");KTable&lt;String, Long&gt; wordCounts = textLines.flatMapValues(value -&gt; Arrays.asList(value.toLowerCase().split("\\W+"))).groupBy((key, value) -&gt; value).count();wordCounts.toStream().to("output-topic");KafkaStreams streams = new KafkaStreams(builder.build(), props);streams.start();// Add shutdown hook to gracefully close the Kafka Streams applicationRuntime.getRuntime().addShutdownHook(new Thread(streams::close));}
}八、总结Apache Kafka 是一个强大的分布式消息队列系统，具有高吞吐量、可扩展性、可靠性等优点。通过深入理解 Kafka 的核心概念、架构、工作原理、应用场景以及最佳实践，可以更好地利用 Kafka 来构建高效、可靠的分布式系统。在实际应用中，可以根据具体的业务需求和系统架构来选择合适的 Kafka 配置和优化策略，充分发挥 Kafka 的优势，提高系统的性能和稳定性。同时，Kafka 的高级特性如事务支持、Exactly Once 语义、Kafka Streams 等也为复杂的业务场景提供了更多的解决方案。http://www.ppmy.cn/news/1540940.html相关文章python获取当前鼠标位置的RGB值效果 依赖 
pip install Pillow pyautoguisudo apt install gnome-screenshot代码 
import pyautogui
import timedef get_rgb_at_mouse():try:while True:# 获取当前鼠标的位置x, y  pyautogui.position()# 截取当前屏幕图像screenshot  pyautogui.screenshot()# 获取鼠标位置…阅读更多...MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:08 +0000</pubDate>
    </item>
    <item>
      <title>python获取当前鼠标位置的RGB值</title>
      <link>https://www.ppmy.cn/news/1540939.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维python获取当前鼠标位置的RGB值news/2025/11/1 0:23:06/效果依赖pipinstallPillow pyautoguisudoaptinstallgnome-screenshot代码importpyautoguiimporttimedefget_rgb_at_mouse():try:whileTrue:# 获取当前鼠标的位置x,y=pyautogui.position()# 截取当前屏幕图像screenshot=pyautogui.screenshot()# 获取鼠标位置的 RGB 值rgb=screenshot.getpixel((x,y))# 打印 RGB 值print(f"鼠标位置: ({x},{y}) -&gt; RGB:{rgb}")# 暂停一段时间，避免过于频繁的输出time.sleep(0.5)exceptKeyboardInterrupt:print("\n程序已结束。")if__name__=="__main__":print("请将鼠标移动到想要获取 RGB 值的位置。按 Ctrl+C 结束程序。")get_rgb_at_mouse()http://www.ppmy.cn/news/1540939.html相关文章MySQL索引、事物与存储引擎目录 一、MySQL索引 
1.索引的概念 
2.索引的作用 
3.创建索引的原则依据 
4.索引的分类和创建 
4.1 普通索引 
4.2 唯一索引 
4.3 主键索引 
4.4 组合索引&amp;#xff08;单列索引与多列索引&amp;#xff09; 
4.5 全文索引&amp;#xff08;FULLTEXT&amp;#xff09; 
5. 查看索引 
6.删除索引…阅读更多...5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:07 +0000</pubDate>
    </item>
    <item>
      <title>MySQL索引、事物与存储引擎</title>
      <link>https://www.ppmy.cn/news/1540938.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维MySQL索引、事物与存储引擎news/2025/11/1 0:23:05/目录一、MySQL索引1.索引的概念2.索引的作用3.创建索引的原则依据4.索引的分类和创建4.1 普通索引4.2 唯一索引4.3 主键索引4.4 组合索引（单列索引与多列索引）4.5 全文索引（FULLTEXT）5. 查看索引6.删除索引二、MySQL事务1.事务的概念2.事务的ACID特点3.一致性问题4.事务隔离4.1 概述4.2 操作5.事务控制语句6.使用set设置控制事务三、MySQL存储引擎1.常用的存储引擎2.MyISAM存储格式3.操作四、死锁1.概述2.如何避免死锁一、MySQL索引1.索引的概念索引是一个排序的列表，在这个列表重存储着索引的值和包含这个值的数据所在行的物理地址（类似于C语言的链接表通过指针向数据记录的内存地址）。使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到改行数据对应的物理地址然后访问相应的数据，因此能加快数据库的查询速度。索引就好比是一本书的目录，可以根据目录中的页码快速找到所需的内容。索引是表中一列或者若干列值排序的方法。建立索引的目的是加快对表中举例的查找或排序。2.索引的作用设置了合适的索引之后，数据库利用各种快速定位技术，能够大大加快查询速度，这是创建索引的最主要的原因。当表很大或查询涉及到多个表时，使用索引可以成千上万倍地提高查询速度。可以降低数据库的IO成本，并且索引还可以降低数据的排序成本。通过创建唯一键索引，可以保证数据表中的每一行数据的唯一性。可以加快表与表之间的连接。在使用分组和排序时，可大大减少分组和排序的时间。建立索引在搜索和恢复数据库中的数据时能显著提高性能。索引的副作用：索引需要占用额外的磁盘空间。对于MyISAM引擎而言，索引文件和数据文件是分离的，索引文件用于保存数据记录的地址而InnoDB引擎的表数据文件本身就是索引文件。更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在尝尝被搜索的列（以及表）上面创建索引。3.创建索引的原则依据索引虽然可以提升数据库查询的速度，但并不是任何情况下都适合创建索引。因为索引本身会消耗系统资源呢，在有索引的情况下，数据会先进行索引查询，然后定位到具体的数据行，如果索引使用不当，反而会增加数据库的负担。表的主键、外键必须有索引。因为主键具有唯一性，外键关联的是表的主键，查询时可以快速定位。记录超过300行的表应有索引。如果没有索引，每次查询都需要把表遍历一遍，会严重影响数据库的性能。经常与其他表进行连接的表，在连接字段上应该建立索引。唯一性太差的字段不适合建立索引。更新太频繁的字段不适合创建索引。经常出现在where子句中的字段，特别是大表的字段，应该建立索引。在经常进行GROUP BY、ORDER BY的字段上建立索引。索引应该建立在选择性高的字段上。索引应该建立在小字段上，对于打的文本字段甚至超长字段，不要建立索引。4.索引的分类和创建create table member (id int(10),name varchar(10),cardid int(18),phone int(11),address varchar(50),remark text);4.1 普通索引最基本的索引类型，没有唯一性之类的限制。直接创建索引：CREATE INDEX 索引名 ON 表名 (列名[(length)]);#(列名(length))：length是可选项，下同。如果忽略 length 的值，则使用整个列的值作为索引。如果指定，使用列的前 length 个字符来创建索引，这样有利于减小索引文件的大小。在不损失精确性的情况下，长度越短越好。
#索引名建议以“_index”结尾。create index name_index on member (name);修改表方式创建：ALTER TABLE 表名 ADD INDEX 索引名 (列名);创建表的时候指定索引：CREATE TABLE 表名 ( 字段1 数据类型,字段2 数据类型[,...],INDEX 索引名 (列名));4.2 唯一索引与普通索引类似，但区别是唯一索引列的每个值都唯一。唯一索引允许有空值（注意和主键不同）。如果是用组合索引创建，则列值的组合必须唯一。添加唯一键将自动创建唯一索引。直接创建唯一索引：CREATE UNIQUE INDEX 索引名 ON 表名(列名);create unique index cardid_index on member(cardid);修改表方式创建：ALTER TABLE 表名 ADD UNIQUE 索引名 (列名);创建表的时候指定：CREATE TABLE 表名 (字段1 数据类型,字段2 数据类型[,...],UNIQUE 索引名 (列名));4.3 主键索引是一种特殊的唯一索引，必须指定为“PRIMARY KEY”。一个表只能有一个主键，不允许有空值。添加主键将自动创建主键索引。修改表方式创建：ALTER TABLE 表名 ADD PRIMARY KEY (列名); alter table member add primary key (id);4.4 组合索引（单列索引与多列索引）可以是单列上创建的索引，也可以是在多列上创建的索引。需要满足最左原则，因为select语句的where条件是依次从左往右执行的，所以在select语句查询时where条件使用的字段顺序必须和组合索引中的排序一致，否则索引将不会生效。4.5 全文索引（FULLTEXT）适合在进行模糊查询的时候使用，可用于在一篇文章中检索文本信息。在 MySQL5.6 版本以前FULLTEXT 索引仅可用于 MyISAM 引擎，在 5.6 版本之后 innodb 引擎也支持 FULLTEXT 索引。全文索引可以在 CHAR、VARCHAR 或者 TEXT 类型的列上创建。直接创建索引：CREATE FULLTEXT INDEX 索引名 ON 表名 (列名);修改表方式创建：ALTER TABLE 表名 ADD FULLTEXT 索引名 (列名);
alter table member add fulltext remark_index (remark);创建表的时候指定索引：CREATE TABLE 表名 (字段1 数据类型[,...],FULLTEXT 索引名 (列名));
#数据类型可以为 CHAR、VARCHAR 或者 TEXT使用全文索引查询：SELECT * FROM 表名 WHERE MATCH(列名) AGAINST('查询内容');5. 查看索引show index from 表名;
show keys from 表名;各字段的含义如下：Table：表的名称。Non_unique：如果索引不能包括重复词，则为 0；如果可以，则为 1。Key_name：索引的名称。Seq_in_index：索引中的列序号，从 1 开始。Column_name：列名称。Collation：列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。Cardinality：索引中唯一值数目的估计值。Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为 NULL。Packed：指示关键字如何被压缩。如果没有被压缩，则为 NULL。Null：如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。Index_type：用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。Comment：备注。6.删除索引直接删除索引：DROP INDEX 索引名 ON 表名;修改表方式删除索引：ALTER TABLE 表名 DROP INDEX 索引名;删除主键索引：ALTER TABLE 表名 DROP PRIMARY KEY;二、MySQL事务1.事务的概念事务是一种机制、一个操作序列，包含了一组数据库操作命令，并且把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。事务是一个不可分割的工作逻辑单元，在数据库系统上执行并发操作时，事务是最小的控制单元。事务适用于多用户同时操作的数据库系统的场景，如银行、保险公司及证券交易系统等等。事务通过事务的整体性以保证数据的一致性。事务能够提高在向表中更新和插入信息期间的可靠性。2.事务的ACID特点ACID，是指在可靠数据库管理系统（DBMS）中，事务（transaction）应具有的四个特性原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这是可靠数据库所应具备的几个特性。原子性：指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。事务是一个完整的操作，事务的各元素是不可分的。事务中的所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。一致性：指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。当事务完成时，数据必须处于一致状态。在事务开始前，数据库中存储的数据处于一致状态。在正在进行的事务中，数据可能处于不一致的状态。当事务成功完成时，数据必须再次回到已知的一致状态。隔离性：指在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。对数据进行修改的所有并发事务是彼此隔离的，表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。修改数据的事务可在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。也就是说并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。3.一致性问题当多个客户端并发地访问同一个表时，可能出现下面的一致性问题：脏读：当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）幻读：一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，另一个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，操作前一个事务的用户会发现表中还有一个没有修改的数据行，就好象发生了幻觉一样。丢失更新：两个事务同时读取同一条记录，A先修改记录，B也修改记录（B不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。4.事务隔离4.1 概述MySQL事务支持如下四种隔离，用以控制事务所做的修改，并将修改通告至其它的并发的事务未提交读(Read Uncommitted（RU）)：允许脏读，即允许一个事务可以看到其他事务未提交的修改。提交读(Read Committed（RC）)：允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。防止脏读。可重复读(Repeatable Read（RR）)：mysql的默认隔离级别，确保如果在一个事务中执行两次相同的SELECT语句，都能得到相同的结果，不管其他事务是否提交这些修改。可以防止脏读和不可重复读。串行读(Serializable)：相当于锁表，完全串行化的读，将一个事务与其他事务完全的隔离。每次读都需要获得表级共享锁，读取相互都会阻塞。可以防止脏读、不可重复读取和幻读。mysql默认的事务处理级别是 repeatable read ，而Oracle和SQL Server是 read committed事务隔离的级别的作用范围分为两种:全局级：对所有的会话有效会话级：只对当前的会话有效4.2 操作查询全局事务隔离级别：show global variables like '%isolation%';
SELECT @@global.tx_isolation;查询会话事务隔离级别：show session variables like '%isolation%';
SELECT @@session.tx_isolation; 
SELECT @@tx_isolation;设置全局事务隔离级别：set global transaction isolation level read committed;
set @@global.tx_isolation='read-committed';    #重启服务后失效设置会话事务隔离级别：set session transaction isolation level repeatable read;
set @@session.tx_isolation='repeatable-read';5.事务控制语句BEGIN 或 START TRANSACTION：显式地开启一个事务。COMMIT 或 COMMIT WORK：提交事务，并使已对数据库进行的所有修改变为永久性的。ROLLBACK 或 ROLLBACK WORK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。SAVEPOINT S1：使用 SAVEPOINT 允许在事务中创建一个回滚点，一个事务中可以有多个 SAVEPOINT；“S1”代表回滚点名称。ROLLBACK TO [SAVEPOINT] S1：把事务回滚到标记点。6.使用set设置控制事务SET AUTOCOMMIT=0;						#禁止自动提交
SET AUTOCOMMIT=1;						#开启自动提交，Mysql默认为1
SHOW VARIABLES LIKE 'AUTOCOMMIT';		#查看Mysql中的AUTOCOMMIT值如果没有开启自动提交，当前会话连接的mysql的所有操作都会当成一个事务直到你输入rollback|commit;当前事务才算结束。当前事务结束前新的mysql连接时无法读取到任何当前会话的操作结果。如果开起了自动提交，mysql会把每个sql语句当成一个事务，然后自动的commit。当然无论开启与否，begin; commit|rollback; 都是独立的事务。三、MySQL存储引擎1.常用的存储引擎MyISAM：不支持事务和外键约束，占用资源较小，访问速度快，标记锁定，支持全文索引，适用于不需要事务处理，单独写入或查询的应用场景。InnoDB：支持事务处理、外键约束，缓存能力较好，支持行级锁定，读写并发能力较好，5.5版本后支持全文索引，适用于一致性要求高、数据更新频繁的应用场景。2.MyISAM存储格式MyISAM表支持3种不同的存储格式：1.静态（固定长度表）：静态表是默认的存储格式。静态表中的字段都是非可变字段，这样每个记录都是固定长度的，这种存储方式的优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态多。2.动态表：动态表包含可变字段，记录不是固定长度的，这样存储的优点是占用空间较少，但是频繁的更新、删除记录会产生碎片，需要定期执行 OPTIMIZE TABLE 语句或 myisamchk -r 命令来改善性能，并且出现故障的时候恢复相对比较困难。3.压缩表：压缩表有myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。3.操作#查看系统支持的存储引擎
show engines;#查看表使用的存储引擎
方法一：
show table status from 库名 where name='表名'\G方法二：
use 库名;
show create table 表名;#修改存储引擎
1．通过 alter table 修改
use 库名;
alter table 表名 engine=MyISAM;2．通过修改 /etc/my.cnf 配置文件，指定默认存储引擎并重启服务
vim /etc/my.cnf
......
[mysqld]
......
default-storage-engine=INNODBsystemctl restart mysql.service
#注意：此方法只对修改了配置文件并重启mysql服务后新创建的表有效，已经存在的表不会有变更。3．通过 create table 创建表时指定存储引擎
use 库名;
create table 表名(字段1 数据类型,...) engine=MyISAM;四、死锁1.概述所谓死锁：是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用，事务都将无法继续运行。此时称系统处于死锁状态或系统产生了死锁。例如，如果事务A锁住了记录1并等待记录2，而事务B锁住了记录2并等待记录1，这样两个事务就发生了死锁现象。计算机系统中，如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。死锁导致长时间阻塞的危害：众所周知，数据库的连接资源是很珍贵的，如果一个连接因为事务阻塞长时间不释放，那么后面新的请求要执行的sql也会排队等待，越积越多，最终会拖垮整个应用。一旦你的应用部署在微服务体系中而又没有做熔断处理（当某服务出现不可用或响应超时的情况时，会暂时停止对该服务的调用），由于整个链路被阻断，那么就会引发雪崩效应，导致很严重的生产事故。2.如何避免死锁1.设置锁等待超时时间：即两个事务相互等待时，一旦等待时间超过了这个时间之后，那么超时事务回滚释放资源，另一个事务就能正常执行了。在 InnoDB 存储引擎中，参数 innodb_lock_wait_timeout 是用来设置超时时间的，默认值为 50 秒。 show VARIABLES like 'innodb_lock_wait_timeout';参数 innodb_rollback_on_timeout 表示是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）。2.主动开启死锁检测：当 innodb 检测发现死锁之后，就会进行回滚死锁的事物。show VARIABLES like  'innodb_deadlock_detect'; 		#查看当前死锁检测是否开启
set global innodb_deadlock_detect = ON;				#ON为开启死锁检测，OFF为关闭3.使用更合理的业务逻辑：对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定多个资源。4.保持事务简短：减少对资源的占用时间和占用范围，避免长事务，减少完成事务可能的延迟并释放锁。5.为表添加合理的索引:如果不使用索引将会发生全表扫描，扫描时间长，占用资源多，且耗时，会导致死锁的概率大大增加。6.降低隔离级别:如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为间隙锁造成的死锁。7.读多写少的场景下使用乐观锁机制:读取数据不上锁，在读的情况下可以共享资源，这样可以省去了锁的开销，提高了吞吐量。乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。适用于读多写少的场景。SELECT * from t1 where id = 1 lock in share MODE;悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。一般适用于写多的场景。SELECT * from t1 where id = 1 for update;http://www.ppmy.cn/news/1540938.html相关文章5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战 无论是在单机单卡&amp;#xff08;一台机器上只有一块GPU&amp;#xff09;还是单机多卡&amp;#xff08;一台机器上有多块GPU&amp;#xff09;的硬件配置上启动ChatGLM3-6B模型&amp;#xff0c;其前置环境配置和项目文件是相同的。如果大家对配置过程还…阅读更多...大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:06 +0000</pubDate>
    </item>
    <item>
      <title>5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战</title>
      <link>https://www.ppmy.cn/news/1540937.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维5 -《本地部署开源大模型》在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战news/2025/11/1 0:23:03/在Ubuntu 22.04系统下ChatGLM3-6B高效微调实战无论是在单机单卡（一台机器上只有一块GPU）还是单机多卡（一台机器上有多块GPU）的硬件配置上启动ChatGLM3-6B模型，其前置环境配置和项目文件是相同的。如果大家对配置过程还不熟悉，建议参考我在上一期直播《在Ubuntu 22.04系统下部署运行ChatGLM3-6B模型》中的详细课件。请按照以下步骤进行配置和验证，以确保顺利启动模型：执行Ubuntu初始化配置：更改国内软件源 --&gt; 软件包更新 – &gt; 设置英文目录 – &gt; 安装Chrome浏览器（非必要，但建议） – &gt; 配置VPN；配置大模型运行环境：安装显卡驱动 – &gt; 安装Anaconda环境；完成初始配置后，大家需要根据自己实际使用的硬件环境，选择相应的部署和运行步骤：单机单卡情况参考《在Ubuntu 22.04系统下部署运行ChatGLM3-6B模型》课件，重点关注四、ChatGLM3-6B私有化部署和五、运行ChatGLM3-6B模型的方式章节。单机多卡情况先遵循本课件中为单机多卡情况提供的部署指南，执行多卡环境下ChatGLM3-6B模型的启动步骤。1. 本地化部署ChatGLM3-6B模型如果跟着上一期公开课及课件实践过单机单卡的操作流程，我们建议针对本期内容的单机多卡也设置**创建一个新的虚拟环境。**这样做可以有效避免版本冲突和依赖问题，确保多卡环境具备专门优化的、独立于单卡环境的配置，简化项目的维护和调试过程。在实际的生产开发中，一个独立项目对应一个单独的隔离环境是一个比较标准的做法，也建议大家以后在做项目开发的时候遵循。具体的部署流程如下：Step 1. 更新Conda首先，打开命令行终端，检查 Conda 的版本，输入如下命令：conda --version这条命令都会显示当前安装的 Conda 版本号。如果 Conda 已正确安装并正确设置在环境变量中，会正常输出conda的版本，如果收到类似于“命令未找到”的错误，则说明 Conda 没有被添加到环境变量中，或者根本没有安装 Conda。在这种情况下，请查看《在Ubuntu 22.04系统下部署运行ChatGLM3-6B模型》中2.3 安装Anaconda环境部分的说明。Step 2. 升级Conda到最新版本在更新过程中，系统会询问是否要继续进行，需要输入y来确认。使用 Conda 自身的更新命令执行更新：conda update condaStep 3. 检查Conda更新情况更新完成后，再次检查 Conda 的版本来确认更新是否成功。conda --versionStep 4. 使用Conda更新软件包更新完 Conda 后，需要更新环境中的所有包，以确保所有软件包都是最新的。避免产生未知的依赖问题，使用以下命令来更新所有安装的包：conda update --allStep 5. 使用Conda创建独立的隔离环境创建一个新环境用于多卡部署启动ChatGLM3-6B，避免与现有环境中的包发生冲突。使用以下命令创建一个新环境（我这里设置的环境名为chatglm3_multi，大家根据需要更改虚拟环境的名称）：conda create --name chatglm3_multipython=3.11Step 6. 进入隔离环境创建完成后，使用conda activate进入该虚拟环境。除此之外，大家一定要注意：如果使用远程连接，关闭了当前终端，或者是重启了电脑等情况后，再次启动ChatGLM3-6B模型服务时，需要先进入这个虚拟环境。进入指定的虚拟环境方法如下：使用 `conda activate + 指定虚拟环境名称` 的方式，进入该虚拟环境。如果命令行最前面已显示该虚拟环境，说明进入成功。Step 7. 在虚拟环境中安装Pytorch在上一期视频中说过，安装GPU版本的Pytorch需要根据当前安装的显卡驱动最高可支持的CUDA版本来选择正确的Pytorch版本，所以先通过nvidia-smi命令查看一下：在我的这台机器上，最高可支持的CUDA版本是12.0，需要根据此限制，进入Pytorch官网：https://pytorch.org/get-started/previous-versions/ 选择合适的Pytorch版本。注：这里大家要根据自己的实际情况灵活的选择适合自己的Pytorch版本。直接复制安装命令，进入终端执行。Step 8. 检查Pytorch安装是否成功安装完成后，务必检查是否成功安装了GPU版本的PyTorch。最简单的验证方法如下：importtorchprint(torch.cuda.is_available())如果输出是 True，则表示GPU版本的PyTorch已经安装成功并且可以使用CUDA，如果输出是 False，则表明没有安装GPU版本的PyTorch，或者CUDA环境没有正确配置，如果出现这种情况，请重新检查自己的安装过程，并确保此处可以正常加载GPU版本的Pytorch，否则后面的操作会无法执行。Step 9. 下载ChatGLM3-6B模型的项目文件首先，创建一个文件夹来存储该项目文件。使用git工具在Github拉取ChatGLM3-6B模型的项目文件至本地。如果没有安装git的话，需要先安装git，命令如下：sudoaptinstallgit在ChatGLM3-6B的GitHub官网找到远程仓库的url：https://github.com/THUDM/ChatGLM3使用安装好的git工具，将云端的ChatGLM3-6B模型的项目文件拉取到本地环境，执行如下命令：gitclone https://github.com/THUDM/ChatGLM3.gitStep 10. 验证ChatGLM3-6B模型项目文件的完整性等待下载完成，进入文件夹后验证项目文件的有效性。如执行过程正常的话，在本地会出现ChatGLM3文件夹，进入该文件夹，所有的项目文件如下所示：Step 11. 安装ChatGLM3-6B模型项目运行环境的依赖在项目文件中，有一个requirements.txt文件，其中包含了该项目所有的依赖项。该文件可以使用 Python 的 pip 工具来一键执行安装，因此建议先需要升级pip包的版本，避免因pip版本较低导致产生依赖问题。python -m pipinstall--upgrade pip升级完pip工具后，执行如下命令一次性安装启动ChatGLM3-6B模型的所有依赖包： ```bash pip install -r requirement.txt ```Step 12. 下载ChatGLM3-6B模型的权重文件经过Step 9的操作过程，我们下载到的只是ChatGLM3-6B的一些运行文件和项目代码，并不包含ChatGLM3-6B这个模型的权重，还需要进入到 Hugging Face 官网进行下载。下载路径：https://github.com/THUDM/ChatGLM3注：需要开科学上网才能进入Hugging Face官网执行下载，如果没有，可以选择进入ModelScope魔搭社区，按照教程执行下载。按照如下位置，找到对应的远程仓库的URL。复制此命令，进入到服务器的命令行准备执行。如果没有安装过git-lfs这个工具，需要先进行安装，安装命令如下：sudoapt-getinstallgit-lfs初始化git lfs，这是使用git拉取模型权重必要的操作，初始化命令如下：gitlfsinstall完成git-lfs的初始化后，直接复制 Hugging Face上提供的命令，在终端运行，等待下载完成即可。gitclone https://huggingface.co/THUDM/chatglm3-6b等待下载完成后，在ChatGLM3目录下出现一个新的chatglm3-6b文件夹，里面存放的就是ChatGLM3-6B模型的权重文件。全部文件如下所示：如果直接使用git lfs下载的速度过慢，建议直接下载权重文件至本地。一种最简单的方式就是这类大的文件，直接通过浏览器下载到本地后，然后再移动到chatglm3-6b这个文件夹中。这种方式最简单粗暴，且效率也很高。2. 单机多卡启动ChatGLM3-6B模型单机多卡（多个 GPU）环境相较于单机单卡（一个 GPU），可以提供更高的计算能力，但同时也会存在更复杂的资源管理和更复杂的程序代码。比如我们需要考虑如何使所有的 GPU 的负载均衡，如果某个 GPU 负载过重，而其他 GPU 空闲，这会导致资源浪费和性能瓶颈，除此之外，还要考虑每个 GPU 的内存不会被过度使用及模型训练过程中GPU 之间的同步和通信。尽管如此，单机多卡或者多机多卡往往才是工业界实际使用的方式，单机单卡的瓶颈非常严重，所以这方面的内容还是非常有必要掌握的。而如果初次接触，我们需要做的就是：学会有效的使用简单的GPU监控工具来帮助配置一些重要的超参数，例如批大小（batch size），像出现 GPU 内存溢出（即显存不足）等情况，去考虑减小批大小等等。2.1 如何查看当前机器的GPU数量方式一：lspci 命令。这是最常用的方法之一，这个命令会显示与图形相关的设备信息，列出所有 PCI 设备，包括 GPU，其执行命令如下：lspci | grep VGA方式二：如果系统中安装的是 NVIDIA GPU 和驱动程序，最熟知且最直观的nvidia-smi命令。2.2 如何理解GPU性能参数参数很多，如何理解各个数值的意义及需要关注哪些信息呢？我们首先来看上半部分的输出：持续模式：耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态。性能状态：从P0到P12，P0表示最大性能，P12表示状态最小性能。再来看下半部分的输出：除了直接运行 nvidia-smi 命令之外，还可以加一些参数，来查看一些本机 GPU 使用的实时情况，这种方式也是在执行训练过程中最简单直观且比较常用的一种监测方式，执行命令如下：watch-n1nvidia-smi-n参数可以自己灵活调整，后面添加的数字就是以秒为单位执行一次刷新。2.3 单机多卡启动ChatGLM3-6B模型服务在 Linux 系统中想要在多GPU环境下启动一个应用服务，并且指定使用某些特定的GPU，主要有两种方式：CUDA_VISIBLE_DEVICES环境变量使用CUDA_VISIBLE_DEVICES环境变量是最常用的方法之一。这个环境变量可以控制哪些GPU对CUDA程序可见。例如，如果系统有4个GPU（编号为0, 1, 2, 3），而你只想使用编号为1和2的GPU，那么可以在命令行中这样设置：CUDA_VISIBLE_DEVICES=1,2python your_script.py这会让your_script.py只看到并使用编号为1和2的GPU。修改程序代码这种方式需要直接在代码中设置CUDA设备。例如，在PyTorch中，可以使用torch.cuda.set_device()函数来指定使用哪个GPU，除此之外，某些框架或工具提供也可能提供相关的参数或环境变量来控制GPU的使用，但都需要修改相关的启动代码。选择哪种方法取决于具体需求和使用的框架或工具。通常，CUDA_VISIBLE_DEVICES是最简单和最直接的方式，而且它不需要修改代码，这使得它在不同环境和不同应用程序之间非常灵活。如果有控制多个服务并且每个服务需要使用不同GPU的需求，那么需要根据具体情况结合使用。接下来我们依次尝试上述两种方式来启动ChatGLM3-6B模型服务。根据GPU数量自动进行分布式启动这里我们以命令行的交互方式来进行多卡启动测试。官方提供的脚本名称是：cli_demo.py。在启动前，仅需要进行一处简单的修改，因为我们已经把ChatGLM3-6B这个模型下载到了本地，所以需要修改一下模型的加载路径。如果仅修改模型权重就执行启动，该过程会自动检测可用的 GPU 并将模型的不同部分映射到这些 GPU 上。状态如下：这里输入Stop退出启动程序，GPU资源就会立即被释放。默认启动会自动使用多块GPU的资源的原因，在于cli_demo.py这个.py文件中的这行代码：参数device_map="auto", 这个参数指示 transformers 库自动检测可用的 GPU 并将模型的不同部分映射到这些 GPU 上。如果机器上有多个 GPU，模型会尝试在这些 GPU 上进行分布式处理。其通过分析各个 GPU 的当前负载和能力来完成。负载均衡的目标是最大化所有GPU的利用率，避免任何一个GPU过载。可以通过如下代码，查看当前环境下的GPU情况：importtorch# 检查 CUDA 是否可用cuda_available=torch.cuda.is_available()print(f"CUDA available: {cuda_available}")# 列出所有可用的 GPUifcuda_available:num_gpus=torch.cuda.device_count()print(f"Number of GPUs available: {num_gpus}")foriinrange(num_gpus):print(f"GPU {i}: {torch.cuda.get_device_name(i)}")# 获取当前默认 GPUprint(f"Current CUDA device: {torch.cuda.current_device()}")else:print("No GPUs available.")可以把上述代码写在一个.py文件中，执行该文件后会输出当前机器上的GPU资源情况，方便我们对当前的资源情况有一个比较清晰的认知。如果想要指定使用某一块GPU，那么需要这样修改代码cli_demo.py中的代码：importtorch# 设置 GPU 设备device=torch.device('cuda:0'iftorch.cuda.is_available()else'cpu')#model = AutoModel.from_pretrained(MODEL_PATH, trust_remote_code=True, device_map="auto").eval()model=AutoModel.from_pretrained(MODEL_PATH,trust_remote_code=True).eval()# 将模型移到指定的 GPUmodel=model.to(device)修改后看下启动情况：在代码程序中指定某几块GPU加载服务更多数人的情况是：比如当前机器中有4块GPU，我们只想使用前两块GPU做此次任务的加载，该如何选择呢？这很常见，其问题主要在于：如果某块GPU已经处于满载运行当中，这时我们再使用四块默认同时运行的话大概率会提示out of memory报错，或者提示显卡不平衡imblance的warning警告。如果是想在代码中指定多块卡运行该服务，需要在代码中添加这两行代码：importos
os.environ["CUDA_VISIBLE_DEVICES"]=','.join(map(str,[0,1]))然后保存修改后，执行启动过程就可以了。直接使用CUDA_VISIBLE_DEVICES环境变量启动第二种方法就是设置 CUDA 设备环境变量。这个方法非常简单，且不涉及更改Python代码。只需要在运行 Python 脚本之前，在命令行中设置 CUDA_VISIBLE_DEVICES 环境变量。这个环境变量告诉 PyTorch 使用哪个 GPU。例如，如果想使用第二块 GPU（GPU 编号从 0 开始，因此第二块 GPU 是 1），就可以这样启动程序：如果想使用两块 GPU启动，那么可以使用逗号（，）来进行分割。同时，在执行推理的过程中，其功率也会增长。3.ChatGLM3-6B 高效微调实践在大模型掀起新一轮的AI热潮以来，目前的形式就是大语言模型（LLM）百花齐放，工业界用于生产的算法模型由原来是几万，几十万的参数，到现在上升到上十亿，上百亿的情况。在这种情况下，因为显卡资源的因素，预训练大模型基本是大公司或者高校才可以做的事情，小公司或个人只能对大模型进行微调后使用。以前我们比较熟悉的都是全量微调，这个微调过程是对原始模型的所有参数全部做一个调整。但对于LLM，在消费级显卡上就做根本没有办法实现。所以目前对于大模型来说，主流的微调技术叫做高效微调，这种方式是通过微调大模型少量或者额外的一些参数，固定预训练模型（LLM）参数，以此来降低计算和存储成本，同时，还可以在一定程度上实现与全量参数微调相当的性能。3.1 主流的高效微调方法介绍FreezeFreeze是冻结的意思，Freeze方法指的是参数冻结，对原始模型的大部分参数进行冻结，仅训练少部分的参数，这样就可以大大减少显存的占用，从而完成对大模型的微调。特别是在Bert模型出来的时候，比较会常用到Freeze的这样一个微调方法，比如Bert有12层，我们把前10层冻结了，只训练后两层。这是一种比较简单微调方法，由于冻结的参数是大部分，微调的参数是少部分，因此在代码中只需要设置需要微调的层的参数即可，把不需要参加训练的层数requires_grad设置为False，不让其进行更新，从而达到冻结的这样一个效果。Prefix-Tuning（2021年提出）Prefix-Tuning指的是在微调模型的过程中只优化加入的一小段可学习的向量(virtual tokens)作为Prefix，而不需要优化整个模型的参数（训练的时候只更新Prefix部分的参数，而PLM中的其他部分参数固定）。Prefix-Tuning论文地址：https://arxiv.org/abs/2101.00190Prefix-Tuning代码地址：https://github.com/XiangLi1999/PrefixTuning传统的微调范式Fine-turning会利用预训练模型去对不同的下游任务进行微调，对每个任务都要保存一份微调后的模型权重。比如下图展示的三个不同任务的Transformer模型，分别用来做翻译、摘要和将格式转化（table-to-text）。每个任务都有自己的微调模型，这意味着模型的所有权重都在微调过程中针对特定任务进行了更新。这种方法通常需要大量的数据和计算资源，因为整个模型都在学习任务特定的知识。Prefix-tuning 就提出了一种不同的微调策略，对基于Transformers结构的模型，它会将特定的前缀添加到输入序列的开始部分，相当于任务特定的提示，可以是一组固定的词或是可训练的嵌入向量。但是这个Prefix 并不是一些明确的单词，比如对于文本摘要任务来说，我们添加 this is summarization（明确指出这是一个摘要的任务），相反，这个prefix加的是一些隐式的Token。这里就需要了解两个概念：Hard Prompt：也称离散Prompt，是一个实际的文本字符串（自然语言，人工可读），通常由中文或英文词汇组成；Soft Prompt：也称连续Prompt，通常是在向量空间优化出来的提示，通过梯度搜索之类的方式进行优化；在Soft Promot中，提示语的变化对模型最终的性能特别敏感，加一个词、少一个词或者变动位置都会造成比较大的变化。成本比较高，并且效果不太好。显然：Prefix Tuning属于Soft prompt。也就是我们学习调整的就是这部分的参数，从而达到微调的目的。Encoder端增加前缀是为了引导输入部分的编码，Decoder 端增加前缀是为了引导后续token的生成。Prefix-tuning 的优势在于它不需要调整模型的全部权重，而是通过在输入中添加前缀来调整模型的行为，这样可以节省大量的计算资源，同时使得一个单一的模型能够适应多种不同的任务。Prompt Tuning（2021年提出）Prompt Tuning 方法可以看做是Prefix Tuning的简化版本，它给每个任务都定义了自己的Prompt，将真实的Tokens转化为可微的virtual token，并加入人工设计的锚字符（与任务高度相关的Token），拼接到数据上作为输出，但只在输入层加入Prompt tokens。Prompt Tuning论文地址：https://arxiv.org/pdf/2104.08691.pdf如图所示：如果A、B、C三个任务，模型框架都是一样的，对每一个任务都添加一个自己定义的Prompt，然后把每个任务混合在一起放在一个Batch中来进行训练。下面的训练例子说明了两者的区别：Prompt Tuning示例：输入序列: "Prompt 1, Prompt2 | 这部电影令人振奋。"问题: 评价这部电影的情感倾向。答案: 模型需要预测情感倾向（例如“积极”）提示: 无明确的外部提示，充当引导模型的内部提示，因为这里的问题是隐含的，即判断文本中表达的情感倾向。Prefix Tuning 示例：输入序列: " Prefix1, Prefix 2 | I want to watch a movie."问题: 根据前缀生成后续的自然语言文本。答案: 模型生成的文本，如“that is exciting and fun.”提示: 前缀本身提供上下文信息，没有单独的外部提示所以Prompt Tuning和Prefix Tuning都涉及在输入数据中加入可学习的向量，但两者的策略和目的不一样：Prompt Tuning：可学习向量（通常称为prompt tokens）旨在模仿自然语言提示的形式，它们被设计为引导模型针对特定任务生成特定类型的输出。这些向量通常被看作是任务指导信息的一部分，倾向于用更少量的向量模仿传统的自然语言提示。Prefix Tuning：可学习前缀Prefix更多地用于提供输入数据的直接上下文信息，这些前缀作为模型内部表示的一部分，可以影响整个模型的行为。P-Tuning v1P-Turning V1的核心是使用可微的virtual token替换了原来的discrete tokens，且仅加入到输入层，并使用prompt encoder（BiLSTM+MLP）对virtual token进行编码学习。P-Tuning v1 论文地址: https://arxiv.org/pdf/2103.10385.pdfP-tuning v1 github 代码：https://github.com/THUDM/P-tuningPrompt Tuning会使用静态的、可训练的虚拟标记嵌入。这些嵌入在初始化后保持固定，除非在训练过程中被更新，相对简单，因为它只涉及调整一组固定的嵌入参数。在处理多种任务时表现良好，但在处理特别复杂或需要细粒度控制的任务时受限。所以，P-Turining v1 就在输入的句子中也是加入了隐式的 virtual token，区别就是：前面的方式是直接对它进行一个学习更新，只不过不会更新大模型中的参数，只是更新我们加入的 virtual token这样一个参数，P-Turning v1 是对添加的virtual Token，又使用BiLSTM + MLP 对其进行了一个编码。虽然这个编码对于PLM来说简单多了，参数也都非常小。但是，也能起到一个比较好的效果。相同参数规模，如果进行全参数微调，Bert在NLU任务上的效果，超过GPT很多；但是在P-Tuning下，GPT可以取得超越Bert的效果。那么Prompt Tuning和P-Tuning等方法存在两个主要的问题：缺乏模型参数规模和任务通用性：Prompt Tuning论文中表明当模型规模超过100亿个参数时，提示优化可以与全量微调相媲美。但是对于那些较小的模型（从100M到1B），提示优化和全量微调的表现有很大差异，这大大限制了提示优化的适用性。缺乏任务普遍性：尽管Prompt Tuning和P-tuning在一些 NLU 基准测试中表现出优势，但提示调优对硬序列标记任务（即序列标注）的有效性尚未得到验证。缺少深度提示优化，在Prompt Tuning和P-tuning中，连续提示只被插入transformer第一层的输入embedding序列中，在接下来的transformer层中，插入连续提示的位置的embedding是由之前的transformer层计算出来的，这可能导致两个可能的优化挑战。由于序列长度的限制，可调参数的数量是有限的，输入embedding对模型预测只有相对间接的影响。这些问题在P-tuning v2得到了改进。P-Tuning v2P-Tuning v2主要是基于P-tuning和Prefix-tuning技术，最核心的是引入Deep Prompt Encoding和Multi-task Learning等策略进行优化的。P-Tuning v2论文地址: https://arxiv.org/abs/2110.07602P-Tuning v2 github代码：https://github.com/THUDM/P-tuning-v2Deep Prompt Encoding：P-Tuning v2在每一层都加入了Prompts tokens作为输入，而不是仅仅加在输入层，这带来两个方面的好处：更多可学习的参数（从P-tuning和Prompt Tuning的0.01%增加到0.1%-3%），同时也足够参数高效。加入到更深层结构中的Prompt能给模型预测带来更直接的影响。Multi-task learning：基于多任务数据集的Prompt进行预训练，然后再适配到下游任务。对于pseudo token的continous prompt，随机初始化比较难以优化，因此采用multi-task方法同时训练多个数据集，共享continuous prompts去进行多任务预训练，可以让prompt有比较好的初始化。所以P-Tuning v2是一种在不同规模和任务中都可与微调相媲美的提示方法。P-Tuning v2对从330M到10B的模型显示出一致的改进，并在序列标注等困难的序列任务上以很大的幅度超过了Prompt Tuning和P-Tuning。除此之外，还有比较主流的LoRA，QLoRA，感兴趣的也可以自行了解一下。本篇内容主要涉及ChatGLM3-6B模型的P-Turning V2 高效微调。3.2 ChatGLM3-6B模型的高效微调实践本次实验环境配置1：操作系统：Ubuntu 22.04；GPU：3090双卡，总共48G显存；CPU：AMD 5900X；存储：64G内存+2T SSD数据盘；实验环境配置2：操作系统：CentOs 7.3；GPU：4090双卡，总共48G显存；CPU：24 vCPU Intel® Xeon® Platinum 8352V CPU存储：180GB + 100G数据盘ChatGLM官网出了⼀个基于P-Tuning v2的⽅式微调ChatGLM-6B的项目，项目地址：https://github.com/THUDM/ChatGLM-6B/tree/main/ptuning ，最低只需要 7GB 显存即可运行。在ChatGLM3-6B模型的项目文件中，官方提供了基于ChatGLM3-6B-base模型和ChatGLM3-6B两个基座模型的微调示例，其中ChatGLM3-6B-base模型仅提供了Lora微调，而ChatGLM3-6B包括全量微调和P-Tuning V2。相关存储位置如下：base模型不具备对话能力，仅能够生成单轮回复。如果大家希望使用多轮对话模型，需要对Chat模型进行微调，所以需要用到finetune_chatmodel_demo下的参考代码，进入后，相关的项目代码如下：无论是全量微调还是P-Tuning v2，都需要设计微调数据，ChatGLM3-6B支持多轮对话和输入输出格式微调样例。因此如果想要使用自己的数据集进行模型微调，需要首先统一样例格式。同时，ChatGLM3-6B微调对话和微调工具能力的数据格式也不相同。这里我们启动微调的脚本存放在script文件目录下。单轮对话微调首先来看单轮对话微调，对于输入-输出格式，样例采用如下输入格式：[{"prompt":"&lt;prompt text&gt;","response":"&lt;response text&gt;"}// ...]官网提供了一个微调示例：AdvertiseGen 数据集，可以进入Tsinghua Cloud：https://cloud.tsinghua.edu.cn/f/b3f119a008264b1cabd1/?dl=1 下载并上传到finetune_chatmodel_demo路径下。一种更便捷的方式就是在服务器终端使用wget命令来进行下载。同时下载到的AdvertiseGen数据集是一个.tar.gz的压缩文件，需要解压才可使用：wget- O AdvertiseGen https://cloud.tsinghua.edu.cn/f/b3f119a008264b1cabd1/?dl=1ADGEN 数据集任务为根据输入（content）生成一段广告词（summary），其数据格式如下：{"content":"类型#上衣*版型#宽松*版型#显瘦*衣样式#外套*衣袖型#插肩袖*衣款式#拼接","summary":"宽松的版型，穿搭起来总是不挑身材；所以作为早春穿搭的话，有着插肩袖设计的这款外套，最是能展现出舒适和大方的感觉了。而比较宽松的外套款式，它在衣身上特别做了拼接的设计，你看那颜色独特的拼接，很是容易就能展现出独特和抢眼的效果；再加上直筒的版型设计，穿搭起来真的是一点也不挑身材，还能起到显瘦的效果。"}{"content":"类型#上衣*风格#运动*风格#休闲*衣样式#外套*衣领型#立领*衣袖长#长袖*衣门襟#拉链*衣款式#拉链","summary":"基础的外套廓形，直筒，立领长袖，中间金属拉链穿脱，方便实用，带有浓浓的休闲运动味道。日常休闲上班或是去&lt;UNK&gt;等运动时都可以穿着，时尚前卫。"}{"content":"类型#上衣*风格#街头*图案#创意*衣样式#卫衣","summary":"在这件卫衣上，BRAND-white集合了女性化的柔美还有不变的街头风采，&lt;UNK&gt;&lt;UNK&gt;的向日葵花朵美丽的出现在胸前和背后，犹如暗&lt;UNK&gt;闪光的星星一般耀眼又充满着&lt;UNK&gt;的生命力，而后品牌标志性的logo&lt;UNK&gt;出现，呈现出将花束固定的效果，有趣极了，穿的不仅是服饰。更是新颖创意的载体。"}我们需要修改成单轮对话的数据微调格式。官方也提供了转换脚本，如下：执行后，数据格式如下：{"prompt":"类型#裤*版型#宽松*风格#性感*图案#线条*裤型#阔腿裤","response":"宽松的阔腿裤这两年真的吸粉不少，明星时尚达人的心头爱。毕竟好穿时尚，谁都能穿出腿长2米的效果宽松的裤腿，当然是遮肉小能手啊。上身随性自然不拘束，面料亲肤舒适贴身体验感棒棒哒。系带部分增加设计看点，还让单品的设计感更强。腿部线条若隐若现的，性感撩人。颜色敲温柔的，与裤子本身所呈现的风格有点反差萌。"}{"prompt":"类型#裙*风格#简约*图案#条纹*图案#线条*图案#撞色*裙型#鱼尾裙*裙袖长#无袖","response":"圆形领口修饰脖颈线条，适合各种脸型，耐看有气质。无袖设计，尤显清凉，简约横条纹装饰，使得整身人鱼造型更为生动立体。加之撞色的鱼尾下摆，深邃富有诗意。收腰包臀,修饰女性身体曲线，结合别出心裁的鱼尾裙摆设计，勾勒出自然流畅的身体轮廓，展现了婀娜多姿的迷人姿态。"}单轮微调官方提供的示例脚本是finetune_pt.sh。准备完成后，需要安装一下执行微调过程必要的依赖包。执行如下命令：pipinstall-r../requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple这里我们先使用默认的参数，仅修改必要的参数，把微调启动起来。执行微调过程，并启动GPU显存使用情况的监控。默认是使用单卡启动，会占用20GB的显存资源。如果需要加载多块卡，可以进入finturn_pt.sh中修改一下配置。双卡启动会占用30G的显存，占用更多显存的原因，主要会涉及一些模型复制、数据并行、梯度同步等训练过程中的操作。参数名描述PRE_SEQ_LENPrompts序列的长度。LR学习率。高的学习率模型权重在优化过程中更新得更快。NUM_GPUS训练过程中使用的 GPU 数量。MAX_SOURCE_LEN定义输入序列的最大长度。MAX_TARGET_LEN定义输出序列的最大长度。DEV_BATCH_SIZE每个批次的大小，即每个优化步骤使用的示例数量。GRAD_ACCUMULATION_STEPS在进行一次参数更新之前，梯度积累的步数。模型会在 指定次数前向和后向传播后才更新参数。MAX_STEP训练过程执行的最大步数，SAVE_INTERVAL每隔一定数量的步数保存模型的参数RUN_NAME运行的名称（advertise_gen_pt），用于标识和区分不同的训练运行。BASE_MODEL_PATH预训练模型的路径，保持为DATASET_PATH训练数据集的路径，保持为OUTPUT_DIR保存模型输出以及训练日志的文件夹路径。因为默认参数是1000步，会导致训练过程较慢，这里我出于演示目的，将其调整为50执行微调。微调完成后，如下：同时，会在`output/`路径下会⽣成对应的模型⽂件：checkpoint中存储的是训练过程中保存的模型状态，包括模型参数、优化器状态、当前epoch等信息。不同的训练参数，会产生不同数量的checkpoint，比如在脚本中，SAVE_INTERVAL设置为1000，这说明每1000个训练步骤保存一次模型。如果MAX_STEP设置为3000，就应该有3个checkpoints被保存，这个也很好计算。微调完成后使用微调模型执行推理对于输入输出格式的微调，可以使用inference.py进行基本的推理验证。在fineturn_chatmodel_demo文件目录中输入如下命令：python inference.py --tokenizer'chatglm3-6b模型路径'-- model'微调模型的checkpoint路径'这是因为在 P-tuning v2 训练时模型只保存 PrefixEncoder 部分的参数，所以在推理时需要同时加载原 ChatGLM-6B 模型以及 PrefixEncoder 的权重。多轮对话微调多轮对话微调示例采用 ChatGLM3 对话格式约定，基本上大多数使用的也都是多轮对话的方式。[{"conversations":[{"role":"system","content":"&lt;system prompt text&gt;"},{"role":"user","content":"&lt;user prompt text&gt;"},{"role":"assistant","content":"&lt;assistant response text&gt;"},// ... Muti Turn{"role":"user","content":"&lt;user prompt text&gt;"},{"role":"assistant","content":"&lt;assistant response text&gt;"}]}// ...]同样官方也提供了一个数据集，供用户快速使用，可以直接在github 上进行下载。复制远程仓库的url链接后，直接在服务器上使用git工具拉取到本地。同样，使用官方提供的数据格式转化脚本，转化成适合多轮微调格式的数据集。这次使用fineturn_pt_multiturn.sh微调脚本，进行和单轮对话微调相同的配置修改即可。微调过程中会占用24G显存。其推理验证过程，和上面说明的单轮对话微调模型的一致。训练过程的参数会很大程度影响当前训练的显存占用，比如我们做如下实验：显存直接就会爆掉：对于双卡 4090 共计48显存来说，最大仅支持设置到4,就基本会占满显存。如果按照这种- per_device_train_batch_size=1、- gradient_accumulation_steps=16比较低的参数设置还爆显存的话，只能尝试微调量化模型。INT4 的模型参数被冻结，一次训练迭代会以 1 的批处理大小进行 16 次累加的前后向传播，等效为 16 的总批处理大小，实际显存占用也仅有7.9G。所以，P-Tuning V2 高效微调中，PRE_SEQ_LEN=128, DEV_BATCH_SIZE=1, GRAD_ACCUMULARION_STEPS=16, MAX_SEQ_LEN=2048配置下约需要 21GB 显存。若尝试后发现显存不足，可以考虑:尝试降低 DEV_BATCH_SIZE 并提升 GRAD_ACCUMULARION_STEPS尝试添加 --quantization_bit 8 或 --quantization_bit 4。除此之外，对于模型参数的选择，往往是参数越大效果越好。如果资源充足，当然是推荐 30B 以上的模型。 不管是 6B, 7B 和 13B 同样的训练数据，同样训练参数，模型参数量大效果则优于低参数的模型。 根据模型参数预估训练所需的内存开销，一个简单的方法是： 比如 6B 模型，60亿规模参数，根据以下公式计算：模型参数 + 梯度参数 + 优化器参数=6B * 1bytes + 6GB +2*6GB=24GB注意：参数多量化低的模型要优于参数低量化高的模型，举例 ：33B-fb4 模型要优于 13b-fb16 模型.全量微调对于全量微调，需要使用finetune_ds_multiturn.sh这个脚本，其配置MAX_SEQ_LEN=2048, DEV_BATCH_SIZE=16, GRAD_ACCUMULARION_STEPS=1恰好用满 4 * 80GB 显存。我这里也尝试了一下，可以跑通：但奈何硬件差距太多，直接显存爆掉。# 4. 大模型并行训练框架-DeepSpeed   训练像ChatGLM3-6B这种大的模型往往需要配备高价的多GPU、多节点的集群，但是，即便拥有了这些先进的硬件资源，实际的机器利用率往往只能达到其最大效率的一半左右。这意味着，仅仅拥有更加强大的硬件资源并不能保证更高的模型训练吞吐量。同样，即使系统具有更高的吞吐量，也并不能保证所训练出的模型具有更高的精度或更快的收敛速度。更重要的是，当前的开源软件的易用性也常常被用户诟病。DeepSpeed是一个开源深度学习优化库，专门设计来提高大型模型训练的效率和扩展性。这个库采用了一系列先进技术，如模型并行化、梯度累积、动态精度缩放和混合精度训练等，来实现快速训练。除此之外，DeepSpeed还搭载了一套强大的辅助工具集，涵盖分布式训练管理、内存优化以及模型压缩等功能，帮助开发者更有效地处理和优化大规模的深度学习任务。值得一提的是，DeepSpeed是基于PyTorch构建的，因此对于现有的PyTorch项目，开发者可以轻松地实施迁移。此库已在众多大规模深度学习应用中得到验证，涉及领域包括但不限于语言模型、图像分类和目标检测。其使用非常简单，其较强的易用性源于把该软件的构造难度交给开发者而不是用户，所以我们用起来是非常简单的，就是一个configs文件，然后在训练代码中反向传播后执行参数更新的时候加一两行代码就可以了。对于ChatGLM3-6B模型的微调，默认只是在全量微调的脚本中加入了deepspeed的代码，因硬件配置相差太大，即使是使用deepspeed也无法运行。但我们可以将其应用到高效微调的P-Turning v2中，只需要添加一行代码，其他的全部使用默认的即可。DeepSpeed已经在Github上开源，地址：https://github.com/microsoft/DeepSpeed这里在fineturn_pt.sh中加入这样一行代码：直接启动后，就会降低约4G的显存使用。因我们的配置和数据量过小，其实不太容易看出这种差距。训练级别越高，提升的效果会越明显。deepspeed在训练过程中依赖的相关参数配置，来源于这里：这个参数的调整，直接影响整体的训练效率。但这部分参数需要对Deepspeed有一定的了解才能更好的根据训练任务和硬件配置情况灵活调整。我们这里简单的了解一下。DeepSpeed是最早开始关注大模型训练的一批，其最核心的就是ZeRo，ZerO-Offload是将模型的参数、梯度或者优化器的状态可以从GPU内存中转移到GPU中。其终极形态ZeRo-infinity，不仅可以将这些参数等卸载到CPU上，还可以Offload到nvme的硬盘上，在速度上，基于zero的这种方式，随着GPU的增加，可以达到超线性的效率增长和。第二点是训练速度。不管大模型还是小模型的训练，训练的效率一定是框架需要重点关注的，需要在保证精确性的前提下，保证它快。ZeR0-1只会对优化器状态做切分。ZeR0-2会对优化器状态和梯度做切分。ZeR0-3是对优化器状态、梯度和模型参数做切分。φ：假设有一个模型，这个模型由φ个参数，也就是由φ个浮点数组成的模型，每个参数如果以fp16的形式存放，一个参数是32float，也就是4bit，所以这里就是2φ。梯度，同样是2φ的显存占用。优化器状态就是K倍的φ，优化器的状态根据实现的形式是不一样的，这里选择12进行比较。在Baseline中，这120GB显存是每张卡都要占用的，所以现在最大的H100这种80G的显存都放不下。所以在实际计算过程中，GPU1 ~ GPU3 计算显存空间的使用会根据 GPU0 的可使用显存空间来确定，这就造成了一个问题：在显存使用上，GPU0 = GPU1 = GPU2 = GPU3，对 GPU1~GPU3 来说是一种巨大的浪费。而且，这种浪费随着模型精度、参数的增加愈发明显。并行模型：Data Parallelism（DP）：数据并行，整个模型会复制到所有GPU上，输入数据会被分割成多个batch到不同的GPU上。也因为每个GPU都在处理不同的数据子集，所以在独立执行前向传播后计算的损失（loss）也会有所不同，接着每个GPU根据其计算出的损失执行反向传播，计算梯度。当所以GPU计算完成后，求平均。这个平均梯度代表了整个数据集上的平均梯度。使用这个平均梯度更新模型的参数。从而确保所有GPU上的模型都保持同步。Tensor MP：对模型做横向切分，也就是层内的切分，每一层的计算被分割成几个较小的部分，每部分独立在不同的GPU上进行计算。比如最大层是一个MLP层，有非常大的计算，但一张卡放不下，就需要切分成两个小的分别放在两张卡上计算。Pipeline MP：流水线并行，把模型的不同层分在不同的GPU上，比如12层的模型，前6层分在一个GPU上，后六层分在一个GPU上。像我们常用的Transformer结果，它会分成一个个Block，所以一般不同的Block会分布不同的层中。什么是micro_batch_size？Pipeline会把输入进来的mini_batch 分成设备个 micro_batch。理想的计算加载方式应该是将模型加载在每个GPU上，减少模型对单个GPU的占用依赖，如下图所示：DeepSpeed 就是实现这样的加载，结合Deepspeed框架的优化特性，充分发挥每块GPU的计算和显存潜能，从而提高整体的训练效率和资源利用率。在理解了DeepSpeed原理后，我们尝试进行模型加载并观察其内存消耗情况。对于我们的本地运行环境，如果采用 DeepSpeed 在4块3090上加载ChatGLM2-6B模型，加载情况如下：原始模型大小 chatglm-6B FP16 -&gt; 单卡显存M e m m o d e l = 12 G B Mem_{model}=12GBMemmodel​=12GB在n G P U = 4 n_{GPU} = 4nGPU​=4的情况下采用 zero++ 方式计算过程中，模型会先加载到 内存中，占用内存大小M e n l o a d = n G P U ∗ M e m m o d e l = 4 ∗ 12 = 48 G B Men_{load} = n_{GPU} * Mem_{model} = 4 * 12 ~= 48GBMenload​=nGPU​∗Memmodel​=4∗12=48GB内存加载完毕后再分布到各个显存上，遵循 “对内存中n G P U n_{GPU}nGPU​个模型进行截取，而不是 一个模型进行分割”；计算公式如下：M e n l o a d = M e m m o d e l ∗ n G P U Men_{load}=Mem_{model} * n_{GPU}Menload​=Memmodel​∗nGPU​加载130B FP16n G P U = 4 n_{GPU} = 4nGPU​=4时，M e n l o a d = M e m m o d e l ∗ n G P U = 130 ∗ 2 ∗ 4 = 1040 G B Men_{load}=Mem_{model} * n_GPU=130*2*4=1040GBMenload​=Memmodel​∗nG​PU=130∗2∗4=1040GB可见，DeepSpeed 的 分布截取 会占用大量重复内存，造成资源上的冲击和浪费，一种优化方法是加载到虚拟内存中作为缓存，对一个模型进行分割而不是逐个截取。在微调过程中，参数配置和优化对于模型性能和训练效率至关重要。合理的参数设置不仅可以加速模型的收敛，还可以提高模型的表现。特别是当我们使用高级的训练框架如DeepSpeed时，更需要对每个参数有深入的理解和精细的调整。DeepSpeed训练过程中涉及的主要参数和分类如下：paranGPUtimes/acccostmicro-bsbs1 0000times4-4-164U21554MB450s / step6425639 step/epoch32.5min4-4-124U21554MB340s / step4819252 step/epoch34.6h4-4-84U21554MB225s / step3212878 step/epoch32.5h2-2-164U18254MB825s / step3212878 step/epoch32.5h2-2-324U18254MB1650s / step6425639 step/epoch32.5hm i c r o − b s = T R A I N _ B A T C H _ S I Z E ∗ G R A _ A C C _ S T E P S micro-bs=TRAIN\_BATCH\_SIZE*GRA\_ACC\_STEPSmicro−bs=TRAIN_BATCH_SIZE∗GRA_ACC_STEPSb s = m i c r o − b s ∗ n G P U bs=micro-bs*nGPUbs=micro−bs∗nGPU其中，para列中的4-4-16表示per_device_train_batch_size、per_device_eval_batch_size、gradient_accumulation_steps。注：10000条数据在当前para下完成一个epoch需要步数；10000/48/4=52 step/epoch； 10000/32/4=78 step/epoch5. 中文语言模型的评测基准LLM 实时排行，来自 UC伯克利： https://lmsys.org/blog/2023-06-22-leaderboard/选择中文模型：中文语言理解测评基准(CLUE) ：https://www.cluebenchmarks.com/index.html 和SuperCLUE琅琊榜 ：https://www.superclueai.com/开源领域 ChatGLM, LLAMA, RWKV 主要就是这3种模型， 中文好一点就是 ChatGLM , 潜力最好的就是LLAMA ，RNN架构决定RWKV有很好的推理效率（随输入长度内存占比线性自增，而LLAMA则是指数增加） 和 Length Extrapolation （关于长度外推性，可以参考苏神的文章 ）。 当然 MPT-7B-StoryWriter-65k+ 模型也有较长的外推能力。自ChatGPT为代表的大语言模型（Large Language Model, LLM）出现以后，由于其惊人的类通用人工智能（AGI）的能力，掀起了新一轮自然语言处理领域的研究和应用的浪潮。尤其是以ChatGLM、LLaMA等平民玩家都能跑起来的较小规模的LLM开源之后，业界涌现了非常多基于LLM的二次微调或应用的案例。下面这个项目在收集和梳理中文LLM相关的开源模型、应用、数据集及教程等资料，目前收录的资源已达100+个！Awesome Chinese LLM， 主要是整理开源的中文大语言模型，以规模较小、可私有化部署、训练成本较低的模型为主，包括底座模型，垂直领域微调及应用，数据集与教程等。Awesome Chinese LLM 的GitHub地址：https://github.com/HqWu-HITCS/Awesome-Chinese-LLMC-Eval:构造中文大模型的知识评估基准，其榜单是一个全面的中文基础 模型评估 套件(多层次、多学科的语文评价基础模型套件)。它由13948个选择题组成 问题跨越52个不同的学科和四个难度级别，测试集用于模型评估（简单来说就是针对中文模型的综合测试机），目的是C-Eval能够帮助开发人员跟踪模型开发的进展，以及分析开发中模型的优点和弱点。C-Eval 的GitHub地址：https://github.com/hkust-nlp/ceval ， 论文地址：https://arxiv.org/pdf/2305.08322v1.pdf不同颜色的主体表示四个难度等级：初中、高中、大学和专业。比较有代表性，很多新出的模型或者微调过的模型都会在这样一个基准上进行评估。榜单地址：https://cevalbenchmark.com/static/leaderboard.html其使用的数据集的地址是：https://cevalbenchmark.com/static/leaderboard.html ，都是一些选择题。http://www.ppmy.cn/news/1540937.html相关文章大数据都包括哪些内容目录 **1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结&amp;#xff1a;大数据领域的主要内容** 大数据的内容非常广泛&amp;#xff0c;涵盖了数据存储、数据处理、数据分析、…阅读更多...面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...Docker-nginx数据卷挂载数据卷&amp;#xff08;volume&amp;#xff09;是一个虚拟目录&amp;#xff0c;是容器内目录与宿主机目录之间映射的桥梁。 以Nginx为例&amp;#xff0c;我们知道Nginx中有两个关键的目录&amp;#xff1a; 
html&amp;#xff1a;放置一些静态资源conf&amp;#xff1a;放置配置文件 如果我们要让Nginx代理我们…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:04 +0000</pubDate>
    </item>
    <item>
      <title>大数据都包括哪些内容</title>
      <link>https://www.ppmy.cn/news/1540936.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维大数据都包括哪些内容news/2025/11/1 0:23:02/目录**1. 数据存储****2. 数据处理****3. 数据流处理****4. 数据查询与分析****5. 数据管理与调度****6. 数据可视化与分析****Kafka 与 HBase 的关系和区别****总结：大数据领域的主要内容**大数据的内容非常广泛，涵盖了数据存储、数据处理、数据分析、数据可视化等多个方面，下面是大数据领域的常见技术及其对应的内容。1. 数据存储HDFS（Hadoop Distributed File System）：Hadoop 的分布式文件系统，用于存储海量数据。HDFS 将数据分块存储在不同的节点上，并提供高容错性。HBase：HBase 是基于 HDFS 之上的 NoSQL 数据库，适用于需要随机读写大规模数据的场景。它像传统数据库一样支持表结构，但擅长处理非结构化或半结构化数据。HBase 的特点：面向列的存储，擅长处理频繁的读写操作，支持实时查询和高并发写入。使用场景：适用于需要随机访问和快速查询的大规模数据场景，比如电信日志、传感器数据等。2. 数据处理MapReduce：Hadoop 的核心计算框架，擅长处理批处理任务，通过 Map 和 Reduce 两步操作处理大规模数据。Spark：一个快速的计算引擎，支持批处理和实时处理。与 MapReduce 相比，Spark 的内存计算使得它的处理速度更快，特别适用于迭代计算和流处理任务。Flink：一种高效的数据处理框架，类似于 Spark，但在实时流处理方面具有更强的性能和灵活性。3. 数据流处理Kafka：Kafka 是一个高吞吐量的分布式消息队列系统，用于处理实时数据流。Kafka 的特点：它可以高效地收集、存储和传递实时数据流，支持分布式的发布-订阅模型，常用于日志采集、监控系统、流式数据处理等场景。使用场景：适用于日志管理、实时数据分析、事件驱动系统中作为数据管道。4. 数据查询与分析Hive：基于 Hadoop 的数据仓库，提供类似 SQL 的查询语言 HiveQL，用于查询和分析大规模数据。Pig：一种大数据分析工具，提供一种高层次的数据流编程语言 Pig Latin，擅长处理半结构化和非结构化数据。Presto：一个分布式 SQL 查询引擎，可以查询 HDFS、Hive、Cassandra、S3 等多种数据源，适合进行大规模的交互式查询。5. 数据管理与调度Zookeeper：用于分布式系统的协调和管理，Kafka、Hadoop 等系统通常会依赖 Zookeeper 进行分布式节点的协调和状态管理。Oozie：Hadoop 生态系统中的任务调度框架，可以帮助用户定义和管理复杂的工作流，包括 MapReduce、Hive、Spark 等任务的调度。6. 数据可视化与分析Tableau、Power BI：这些工具可以帮助将数据进行可视化展示，便于商业智能（BI）分析。Zeppelin、Jupyter：用于数据科学家进行数据探索、可视化和分析的工具，特别适用于交互式数据分析。Kafka 与 HBase 的关系和区别Kafka和HBase虽然都属于大数据领域，但它们的功能和应用场景不同：Kafka主要用于实时数据流的传输和处理，适合高并发的消息传递场景。HBase是一个 NoSQL 数据库，适合需要快速随机读写的场景，支持大规模数据的实时查询。两者可以结合使用，比如 Kafka 收集实时数据流，然后将处理后的数据存储到 HBase 中，供后续查询和分析。总结：大数据领域的主要内容存储：HDFS、HBase、Cassandra 等。计算：MapReduce、Spark、Flink 等。流处理：Kafka、Flink、Spark Streaming 等。查询与分析：Hive、Presto、Pig 等。管理与调度：Zookeeper、Oozie 等。可视化：Tableau、Power BI 等。学习这些内容时，可以根据需求逐步深入。Kafka 和 HBase 在大数据生态系统中分别承担了实时数据流处理和高效数据存储的任务，它们常常结合使用，以提高系统的整体性能。http://www.ppmy.cn/news/1540936.html相关文章面试后的想法感受 
实际的感受到了行业的萎缩&amp;#xff0c;之前再怎么说找份工作还是能在1个月内搞定&amp;#xff0c;现在距离我是失业为止已经6个月了 
是否该离开当前城市 
当地的互联网公司几乎跑了个遍&amp;#xff0c;有的因为学历原因直接卡的死死的&amp;#xff0c;要是有出彩的开发经验还好比如…阅读更多...文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...Docker-nginx数据卷挂载数据卷&amp;#xff08;volume&amp;#xff09;是一个虚拟目录&amp;#xff0c;是容器内目录与宿主机目录之间映射的桥梁。 以Nginx为例&amp;#xff0c;我们知道Nginx中有两个关键的目录&amp;#xff1a; 
html&amp;#xff1a;放置一些静态资源conf&amp;#xff1a;放置配置文件 如果我们要让Nginx代理我们…阅读更多...基于Multisim8路彩灯循环控制电路设计与仿真1&amp;#xff0e;彩灯能够自动循环点亮&amp;#xff1b;
2&amp;#xff0e;彩灯循环频率快慢可调&amp;#xff1b;
3&amp;#xff0e;彩灯具有8路输出。
4&amp;#xff0e;自行设计脉冲信号产生电路。 链接&amp;#xff1a;https://pan.baidu.com/s/1PhpVy58Y6-_uXnie8KYyzg  提取码&amp;#xff1a;zjad阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:02 +0000</pubDate>
    </item>
    <item>
      <title>面试后的想法</title>
      <link>https://www.ppmy.cn/news/1540935.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维面试后的想法news/2025/11/1 0:23:00/感受实际的感受到了行业的萎缩，之前再怎么说找份工作还是能在1个月内搞定，现在距离我是失业为止已经6个月了是否该离开当前城市当地的互联网公司几乎跑了个遍，有的因为学历原因直接卡的死死的，要是有出彩的开发经验还好比如github上有自己写的开源项目并能获得众多star。但是我这平平无奇的crud操作员何德何能，当前的市场就一言难尽，我不知道其他语言是不是也这样，要不我换个语言试一下，但是当前是要考虑当地的行业环境了，我本身是不愿意到处跑的，但是树挪死人挪活不是，我再坚持坚持。是否该转行了面试了好多轮，简历投了一大把回复的寥寥无几，更别说邀请面试的，大部分主动打招呼的网约车司机，外卖骑手，货车司机，金融电销，就离谱 转行的话也是想转相关行业的呀，项目实施，产品经理之类的，但是怎么感觉相关的行业都不是很好做。是否创业别闹了 我都被我自己的想法气笑了，也真的是病急乱投医了，看过不少网上的段子，说勤勤恳恳的工作者一无所有，胆大心细的创业者负债累累，妈耶，真的是，不过自媒体可以尝试下，手机一架，摄像头一开，动漫特效一上（对自己的容貌不i够自信），往哪一坐，开播，至于有没有人，有没有量的另说，但是这种方式好像是对于处在焦虑中的我一种敷衍的安慰吧（有可能适得其反，天知道），或者记录吐槽下最近的面试遇得到的一些奇葩事。http://www.ppmy.cn/news/1540935.html相关文章文件操作的艺术：Python中的打开与关闭文件引言 
在编程的世界里&amp;#xff0c;文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录&amp;#xff0c;还是进行数据交换&amp;#xff0c;文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言&amp;#xff0c;在文件操作方面提供了丰富的功能和灵活…阅读更多...进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...Docker-nginx数据卷挂载数据卷&amp;#xff08;volume&amp;#xff09;是一个虚拟目录&amp;#xff0c;是容器内目录与宿主机目录之间映射的桥梁。 以Nginx为例&amp;#xff0c;我们知道Nginx中有两个关键的目录&amp;#xff1a; 
html&amp;#xff1a;放置一些静态资源conf&amp;#xff1a;放置配置文件 如果我们要让Nginx代理我们…阅读更多...基于Multisim8路彩灯循环控制电路设计与仿真1&amp;#xff0e;彩灯能够自动循环点亮&amp;#xff1b;
2&amp;#xff0e;彩灯循环频率快慢可调&amp;#xff1b;
3&amp;#xff0e;彩灯具有8路输出。
4&amp;#xff0e;自行设计脉冲信号产生电路。 链接&amp;#xff1a;https://pan.baidu.com/s/1PhpVy58Y6-_uXnie8KYyzg  提取码&amp;#xff1a;zjad阅读更多...STM32L010F4 最小系统设计画一个 STM32L010F4 的测试板子...... by 矜辰所致前言 
最近需要用到一个新的 MCU&amp;#xff1a; STM32L010F4 &amp;#xff0c;上次测试的 VL53L0X 需要移植到这个芯片上&amp;#xff0c;网上一搜 STM32L010F4&amp;#xff0c;都是介绍资料&amp;#xff0c;没有最小系统&amp;#xff0c;使用说明等。…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:23:01 +0000</pubDate>
    </item>
    <item>
      <title>文件操作的艺术：Python中的打开与关闭文件</title>
      <link>https://www.ppmy.cn/news/1540934.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维文件操作的艺术：Python中的打开与关闭文件news/2025/11/1 0:22:59/引言在编程的世界里，文件操作是一项基本而又至关重要的技能。无论是读取配置文件、处理日志记录，还是进行数据交换，文件的打开与关闭都是不可或缺的操作。Python 作为一门简洁而强大的语言，在文件操作方面提供了丰富的功能和灵活的方法。本文将带你深入了解 Python 中如何优雅地打开与关闭文件，从基础语法到高级技巧，再到实战案例，让你在文件操作的道路上更进一步。基础语法介绍核心概念在 Python 中，文件操作主要涉及两个步骤：打开文件和关闭文件。打开文件是为了获取文件对象，通过这个对象可以对文件进行读写操作；关闭文件则是为了释放系统资源，确保文件内容的安全性和完整性。基本语法规则打开文件使用open()函数可以打开一个文件。该函数的基本语法如下：file_object=open(file_name,mode)file_name：要打开的文件名（可以是相对路径或绝对路径）。mode：文件打开模式，常见的模式有：'r'：只读模式，默认值。'w'：写入模式，如果文件已存在会被覆盖。'a'：追加模式，如果文件已存在，指针会放在文件末尾。'b'：二进制模式，通常与其他模式组合使用，如'rb'、'wb'。'+'：读写模式，通常与其他模式组合使用，如'r+'、'w+'。关闭文件使用close()方法可以关闭文件。关闭文件后，文件对象将不能再进行读写操作。file_object.close()基础实例问题描述假设我们有一个文本文件example.txt，内容如下：Hello, world!
This is a test file.我们需要读取这个文件的内容并打印出来。代码示例# 打开文件file_object=open('example.txt','r')# 读取文件内容content=file_object.read()# 打印文件内容print(content)# 关闭文件file_object.close()运行结果Hello, world!
This is a test file.进阶实例问题描述假设我们有一个包含多行数据的文件data.txt，每行数据由逗号分隔，表示一个人的姓名和年龄。我们需要读取文件内容，并将每个人的信息存储在一个列表中，每个元素是一个包含姓名和年龄的字典。代码示例# 定义一个空列表来存储数据people=[]# 打开文件withopen('data.txt','r')asfile_object:# 逐行读取文件内容forlineinfile_object:# 去除行末的换行符，并按逗号分隔name,age=line.strip().split(',')# 将姓名和年龄存储为字典person={'name':name,'age':int(age)}# 将字典添加到列表中people.append(person)# 打印结果forpersoninpeople:print(person)运行结果{'name': 'Alice', 'age': 30}
{'name': 'Bob', 'age': 25}
{'name': 'Charlie', 'age': 35}实战案例问题描述在实际项目中，我们经常需要处理大量日志文件，这些文件可能分布在不同的目录中。假设我们有一个目录logs，其中包含多个日志文件，每个文件的名称格式为log_YYYYMMDD.txt。我们需要编写一个脚本来合并所有日志文件的内容，并按日期排序后输出到一个新的文件merged_log.txt中。解决方案遍历logs目录，获取所有日志文件的路径。按日期对文件进行排序。依次读取每个文件的内容，并将其写入到merged_log.txt中。代码实现importosimportre# 获取日志文件的路径log_dir='logs'log_files=[os.path.join(log_dir,f)forfinos.listdir(log_dir)iff.startswith('log_')andf.endswith('.txt')]# 按日期对文件进行排序defextract_date(filename):match=re.search(r'log_(\d{8})\.txt',filename)ifmatch:returnmatch.group(1)returnNonelog_files.sort(key=extract_date)# 合并日志文件withopen('merged_log.txt','w')asmerged_file:forlog_fileinlog_files:withopen(log_file,'r')asfile_object:content=file_object.read()merged_file.write(f"==={log_file}===\n")merged_file.write(content)merged_file.write('\n')# 打印完成信息print("日志文件合并完成！")运行结果假设logs目录中有以下文件：log_20230101.txtlog_20230102.txtlog_20230103.txtmerged_log.txt的内容将如下所示：=== logs/log_20230101.txt ===
Log entry 1
Log entry 2=== logs/log_20230102.txt ===
Log entry 3
Log entry 4=== logs/log_20230103.txt ===
Log entry 5
Log entry 6扩展讨论文件操作的最佳实践使用with语句：with语句可以自动管理文件的打开和关闭，即使在发生异常的情况下也能确保文件被正确关闭。withopen('example.txt','r')asfile_object:content=file_object.read()错误处理：在进行文件操作时，应考虑可能出现的异常情况，如文件不存在、权限问题等，并进行适当的错误处理。try:withopen('example.txt','r')asfile_object:content=file_object.read()exceptFileNotFoundError:print("文件未找到！")exceptIOError:print("文件读取错误！")性能优化：对于大文件，一次性读取整个文件可能会消耗大量内存。可以考虑逐行读取或使用缓冲区。withopen('large_file.txt','r')asfile_object:forlineinfile_object:process_line(line)文件编码在处理文本文件时，文件编码是一个不容忽视的问题。Python 默认使用 UTF-8 编码，但有时文件可能使用其他编码格式。可以通过open()函数的encoding参数指定文件编码。withopen('example.txt','r',encoding='utf-8')asfile_object:content=file_object.read()文件锁定在多进程或多线程环境中，文件操作可能会引发竞态条件。可以使用文件锁定机制来确保文件的一致性。importfcntlwithopen('example.txt','r+')asfile_object:fcntl.flock(file_object,fcntl.LOCK_EX)# 获取独占锁content=file_object.read()file_object.seek(0)file_object.write('New content')fcntl.flock(file_object,fcntl.LOCK_UN)# 释放锁http://www.ppmy.cn/news/1540934.html相关文章进程之间的通信2user1.c 
#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key  ftok("…阅读更多...记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...Docker-nginx数据卷挂载数据卷&amp;#xff08;volume&amp;#xff09;是一个虚拟目录&amp;#xff0c;是容器内目录与宿主机目录之间映射的桥梁。 以Nginx为例&amp;#xff0c;我们知道Nginx中有两个关键的目录&amp;#xff1a; 
html&amp;#xff1a;放置一些静态资源conf&amp;#xff1a;放置配置文件 如果我们要让Nginx代理我们…阅读更多...基于Multisim8路彩灯循环控制电路设计与仿真1&amp;#xff0e;彩灯能够自动循环点亮&amp;#xff1b;
2&amp;#xff0e;彩灯循环频率快慢可调&amp;#xff1b;
3&amp;#xff0e;彩灯具有8路输出。
4&amp;#xff0e;自行设计脉冲信号产生电路。 链接&amp;#xff1a;https://pan.baidu.com/s/1PhpVy58Y6-_uXnie8KYyzg  提取码&amp;#xff1a;zjad阅读更多...STM32L010F4 最小系统设计画一个 STM32L010F4 的测试板子...... by 矜辰所致前言 
最近需要用到一个新的 MCU&amp;#xff1a; STM32L010F4 &amp;#xff0c;上次测试的 VL53L0X 需要移植到这个芯片上&amp;#xff0c;网上一搜 STM32L010F4&amp;#xff0c;都是介绍资料&amp;#xff0c;没有最小系统&amp;#xff0c;使用说明等。…阅读更多...使用Vscode配置ftp连接远程服务器（上传本地文件）1.安装插件 扩展商店搜sftp，点击进行安装。 2.配置json文件 crtl+shift+p 输入ftp配置命令 sftp:config {"name": "My Server",  //设置名字"host": "localhost"&lt;/阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:22:59 +0000</pubDate>
    </item>
    <item>
      <title>进程之间的通信2</title>
      <link>https://www.ppmy.cn/news/1540933.html</link>
      <description>首页编程日记开发工具嵌入式服务器运维进程之间的通信2news/2025/11/1 0:22:58/user1.c#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");return NULL;}//写入向队列中数据struct msgbuf buf;while(1){printf("请输入写入数据的类型&gt;&gt;&gt;");scanf("%ld",&amp;buf.mtepe);getchar();//吸收空格printf("请输入传输的数据:");fgets(buf.mdata,MSG,stdin);buf.mdata[strlen(buf.mdata)-1] = 0;//将消息放入队列中msgsnd(msgqid,&amp;buf,MSG,0);printf("发送成功\n");if(strcmp(buf.mdata,"quit") == 0){break;}}
}void *task2(void * arg)
{//创建key的值//打开同一个key值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");return NULL;}//从消息队列中读取数据struct msgbuf buf;while(1){msgrcv(msgqid,&amp;buf,MSG,1,0);printf("接受到的消息为：%s\n",buf.mdata);if(strcmp(buf.mdata,"quit") == 0){break;}}}int main(int argc, const char *argv[])
{//定义2个线程pthread_t pid1 ,pid2;//创建线程if(pthread_create(&amp;pid1,NULL,task1,NULL) != 0){perror("pthread_create error");return -1;}if(pthread_create(&amp;pid2,NULL,task2,NULL) != 0){perror("pthread_create error");return -1;}//主线程程序printf("用户一在线，可以进行通信\n");//回收资源//主线程阻塞等待线程完成通信pthread_join(pid1,NULL);pthread_join(pid2,NULL);//创建key的值//打开同一个key值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");r//删除队列if(msgctl(msgqid,IPC_RMID,NULL) != -1){perror("error");return NULL;}return 0;
}user2.c#include &lt;myhead.h&gt;//创建发送信息的数据结构体
struct msgbuf
{long mtepe;char mdata[1024];
};
//宏定义数据的长度
#define MSG (sizeof(struct msgbuf)-sizeof(long))//线程一进行发送信息
void* task1(void * arg)
{//创建key的值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");return NULL;}//写入向队列中数据struct msgbuf buf;while(1){printf("请输入写入数据的类型&gt;&gt;&gt;");scanf("%ld",&amp;buf.mtepe);getchar();//吸收空格printf("请输入传输的数据:");fgets(buf.mdata,MSG,stdin);buf.mdata[strlen(buf.mdata)-1] = 0;//将消息放入队列中msgsnd(msgqid,&amp;buf,MSG,0);printf("发送成功\n");if(strcmp(buf.mdata,"quit") == 0){break;}}
}void *task2(void * arg)
{//创建key的值//打开同一个key值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");return NULL;}//从消息队列中读取数据struct msgbuf buf;while(1){msgrcv(msgqid,&amp;buf,MSG,2,0);printf("接受到的消息为：%s\n",buf.mdata);if(strcmp(buf.mdata,"quit") == 0){break;}}}int main(int argc, const char *argv[])
{//定义2个线程pthread_t pid1 ,pid2;//创建线程if(pthread_create(&amp;pid1,NULL,task1,NULL) != 0){perror("pthread_create error");return -1;}if(pthread_create(&amp;pid2,NULL,task2,NULL) != 0){perror("pthread_create error");return -1;}//主线程程序printf("用户一在线，可以进行通信\n");//回收资源//主线程阻塞等待线程完成通信pthread_join(pid1,NULL);pthread_join(pid2,NULL);//创建key的值//打开同一个key值key_t key = ftok("/",'a');if(key == -1){perror("key_t error");return NULL;}//创建消息队列int msgqid = msgget(key,IPC_CREAT|0664);if(msgqid == -1){perror("msgget error");r//删除队列if(msgctl(msgqid,IPC_RMID,NULL) != -1){perror("error");return NULL;}return 0;
}http://www.ppmy.cn/news/1540933.html相关文章记录一次hiveserver2卡死(假死)问题问题描述 
给开发人员开通了个账号&amp;#xff0c;连接hive进行查询&amp;#xff0c;后来发现&amp;#xff0c;hive服务有时候会卡死&amp;#xff0c;查询不了&amp;#xff0c;连不上&amp;#xff08;所有账号/客户端都连不上hive&amp;#xff09;&amp;#xff0c;但在chd里面看监控&amp;#xff0c;服务器资源状态…阅读更多...目前最新 dnSpy V6.5.1版本，最好的 .NET 程序调试、编辑、反编译软件目前最新 dnSpy V6.5.1版本&amp;#xff0c;最好的 .NET 程序调试、编辑、反编译软件 一、 简介二、新发布程序更新功能三、官方下载&amp;#xff1a; 一、 简介 
dnSpy 是一个调试器 .NET 程序集的编辑器。即使没有源代码&amp;#xff0c;也可以使用它来编辑和调试程序集。主要特点&amp;#x…阅读更多...Linux内核 -- 高性能运算操作之 this_cpu_* 接口Linux this_cpu_* 接口的作用与用法 
Linux 内核中&amp;#xff0c;this_cpu_* 接口用于访问和操作每个 CPU 独有的 per-CPU 变量&amp;#xff0c;提供了一组高效的方法来处理 per-CPU 数据。在 SMP&amp;#xff08;对称多处理&amp;#xff09;系统中&amp;#xff0c;per-CPU 变量可以有效地减少缓存…阅读更多...Docker-nginx数据卷挂载数据卷&amp;#xff08;volume&amp;#xff09;是一个虚拟目录&amp;#xff0c;是容器内目录与宿主机目录之间映射的桥梁。 以Nginx为例&amp;#xff0c;我们知道Nginx中有两个关键的目录&amp;#xff1a; 
html&amp;#xff1a;放置一些静态资源conf&amp;#xff1a;放置配置文件 如果我们要让Nginx代理我们…阅读更多...基于Multisim8路彩灯循环控制电路设计与仿真1&amp;#xff0e;彩灯能够自动循环点亮&amp;#xff1b;
2&amp;#xff0e;彩灯循环频率快慢可调&amp;#xff1b;
3&amp;#xff0e;彩灯具有8路输出。
4&amp;#xff0e;自行设计脉冲信号产生电路。 链接&amp;#xff1a;https://pan.baidu.com/s/1PhpVy58Y6-_uXnie8KYyzg  提取码&amp;#xff1a;zjad阅读更多...STM32L010F4 最小系统设计画一个 STM32L010F4 的测试板子...... by 矜辰所致前言 
最近需要用到一个新的 MCU&amp;#xff1a; STM32L010F4 &amp;#xff0c;上次测试的 VL53L0X 需要移植到这个芯片上&amp;#xff0c;网上一搜 STM32L010F4&amp;#xff0c;都是介绍资料&amp;#xff0c;没有最小系统&amp;#xff0c;使用说明等。…阅读更多...使用Vscode配置ftp连接远程服务器（上传本地文件）1.安装插件 扩展商店搜sftp，点击进行安装。 2.配置json文件 crtl+shift+p 输入ftp配置命令 sftp:config {"name": "My Server",  //设置名字"host": "localhost"&lt;/阅读更多...uniapp上如何绑定全局事件总线（引入自定义全局组件例如弹窗）1、在main.js中挂载bus 
// main.js
Vue.prototype.$bus  new Vue();
uni.$bus  Vue.prototype.$bus;  // 确保在 uni 上绑定 
2、写一个全局弹窗组件 
&lt;template&gt;&lt;view v-if"visible" class"toast-container"&gt;&lt;view class"icon-conta…阅读更多...最新文章品牌故事不会写？这个AI指令可能帮你解决大问题用户上下文透传机制详解[网络] [TCP] Linux UDP Socket 学习指南[网络] [TCP] Linux TCP Socket 学习指南251025B. 海啸HarfBuzz概览10月31日日记山石防火墙NAT-NAT64餐饮不仅仅卖食物，更卖的是服务。餐饮不仅仅卖食物，更卖的是服务。山石防火墙NAT-NAT6410月31日日记【RabbitMQ】RPC模式（请求/回复）圆锥曲线的离心率1由逃逸分析决定 --是什么意思？Copyright @ 2022~2023</description>
      <pubDate>Fri, 31 Oct 2025 16:22:58 +0000</pubDate>
    </item>
  </channel>
</rss>
